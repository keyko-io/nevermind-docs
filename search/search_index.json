{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Nevermined Documentation \u00b6 Nevermined is a data ecosystem solution that provides the capabilities of building bespoke networks where different entities can share and monetize their data and make an efficient and secure usage of it even with untrusted parties. With the explosion of the data and AI market, entities have the necessity of organizing, understanding, using and sharing their data internally and externally. Nevermined provides Data Sharing & Data in situ Computation solutions allowing to unlock data for AI. Nevermined enables a \u201cData in situ Computation\u201d solution, meaning the data never moves, is the algorithm the one moving where the data is. It allows data owners or providers to define the conditions in which they allow others to make use of their data without giving direct access to it. Nevermined is designed to be integrated in Big Data environments. It enables monetizing the data without migration. It\u2019s also designed for GDPR compliance, it never stores any personal information on-chain (encrypted or in plain text). Nevermined is the product powered by Keyko . Data Ecosystem Principles \u00b6 During the design and construction of Nevermined, we identified 6 key factors for the adoption and usage of a data ecosystem and its continued growth: Culture - Culture & Organization help to establish how each ecosystem actor interact with others. We promote it giving a user centric approach User Experience (UX) - The ecosystems should provide an excellent User eXperience, facilitating the participation of all the partners and users Trust - Data ecosystems must promote trustful environments where untrusted parties can collaborate Integrity - Data integrity and provenance as first class citizens where the ecosystem users can validate that data doesn't change and from where is coming Compliance - Data first approach compliance with all the data regulatory requirements Incentives - We promote the usage and retention of data ecosystems via gamification and providing additional value Use Cases \u00b6 Nevermined is a platform agnostic solution enabling data use cases where different parties don't trust each other. It allows to provide data ecosystems where DATA OWNERS need to share and monetize their data with third-party people, but they want to keep the privacy and the control of their data. Typical use cases for sector are: Banking - Data Sharing with the regulator or internal across different jurisdictions Telco - Anonymized Data Sharing with the regulator and partners. AI within moving the data Health & Pharma - AI over medical results of different hospitals without revealing PI Supply Chain - Provenance, integrity and tracking of goods Automotive - Data Sharing for AI to promote the autonomous cars Others - Real estate, digital assets tokenization, ..","title":"Home"},{"location":"#nevermined-documentation","text":"Nevermined is a data ecosystem solution that provides the capabilities of building bespoke networks where different entities can share and monetize their data and make an efficient and secure usage of it even with untrusted parties. With the explosion of the data and AI market, entities have the necessity of organizing, understanding, using and sharing their data internally and externally. Nevermined provides Data Sharing & Data in situ Computation solutions allowing to unlock data for AI. Nevermined enables a \u201cData in situ Computation\u201d solution, meaning the data never moves, is the algorithm the one moving where the data is. It allows data owners or providers to define the conditions in which they allow others to make use of their data without giving direct access to it. Nevermined is designed to be integrated in Big Data environments. It enables monetizing the data without migration. It\u2019s also designed for GDPR compliance, it never stores any personal information on-chain (encrypted or in plain text). Nevermined is the product powered by Keyko .","title":"Nevermined Documentation"},{"location":"#data-ecosystem-principles","text":"During the design and construction of Nevermined, we identified 6 key factors for the adoption and usage of a data ecosystem and its continued growth: Culture - Culture & Organization help to establish how each ecosystem actor interact with others. We promote it giving a user centric approach User Experience (UX) - The ecosystems should provide an excellent User eXperience, facilitating the participation of all the partners and users Trust - Data ecosystems must promote trustful environments where untrusted parties can collaborate Integrity - Data integrity and provenance as first class citizens where the ecosystem users can validate that data doesn't change and from where is coming Compliance - Data first approach compliance with all the data regulatory requirements Incentives - We promote the usage and retention of data ecosystems via gamification and providing additional value","title":"Data Ecosystem Principles"},{"location":"#use-cases","text":"Nevermined is a platform agnostic solution enabling data use cases where different parties don't trust each other. It allows to provide data ecosystems where DATA OWNERS need to share and monetize their data with third-party people, but they want to keep the privacy and the control of their data. Typical use cases for sector are: Banking - Data Sharing with the regulator or internal across different jurisdictions Telco - Anonymized Data Sharing with the regulator and partners. AI within moving the data Health & Pharma - AI over medical results of different hospitals without revealing PI Supply Chain - Provenance, integrity and tracking of goods Automotive - Data Sharing for AI to promote the autonomous cars Others - Real estate, digital assets tokenization, ..","title":"Use Cases"},{"location":"Blog/","text":"Nevermined Blog Posts \u00b6 We use Medium for publishing about Nevermined product and technology. You can find all this content in our Nevermined Medium space. If you want to know more about any topic, please drop us a line on Discord . We will be happy to chat about it. This is a list of the most relevant blog posts we published: Title Topic Author Introducing Nevermined Nevermined Announcement @clem Nevermined Tech: Nuts & Bolts Technical introduction @aitor_argomaniz Using Nevermined to Commercialize Your Organization\u2019s Data Use Case @don_gossen Provenance\u200a\u2014\u200aEverything has a story behind Technical @aitor_argomaniz What decentralized building blocks exist to build your digital ecosystem? Technical @aitor_argomaniz Nevermined & Credit Card Fraud Detection Use Case @rodmar Why use Nevermined? Use Case @aitor_argomaniz Why do we use blockchain? Technical @aitor_argomaniz Facilitating asset tokenization with NFTs Use Case @aitor_argomaniz","title":"Blog posts"},{"location":"Blog/#nevermined-blog-posts","text":"We use Medium for publishing about Nevermined product and technology. You can find all this content in our Nevermined Medium space. If you want to know more about any topic, please drop us a line on Discord . We will be happy to chat about it. This is a list of the most relevant blog posts we published: Title Topic Author Introducing Nevermined Nevermined Announcement @clem Nevermined Tech: Nuts & Bolts Technical introduction @aitor_argomaniz Using Nevermined to Commercialize Your Organization\u2019s Data Use Case @don_gossen Provenance\u200a\u2014\u200aEverything has a story behind Technical @aitor_argomaniz What decentralized building blocks exist to build your digital ecosystem? Technical @aitor_argomaniz Nevermined & Credit Card Fraud Detection Use Case @rodmar Why use Nevermined? Use Case @aitor_argomaniz Why do we use blockchain? Technical @aitor_argomaniz Facilitating asset tokenization with NFTs Use Case @aitor_argomaniz","title":"Nevermined Blog Posts"},{"location":"BuildingBlocks/","text":"Building Blocks \u00b6 Nevermined is based in three core building blocks: Data Sharing \u00b6 It enables the data sharing capabilities between unstructured parties. The main users involved in this scenario are: Organizations with data that need to share and monetize ( Data Owners ). Organizations or individuals looking for data sets to train their models ( Data Consumers ). Typically Data Owners & Consumers don't know or trust each other. Nevermined provides a generic solution where both can share data in a decentralized and secure way. The main benefits for them are: Data Owners can get some benefit of their existing data Data Consumers can get access to datasets they couldn't get access in other conditions Nevermined Data Sharing flow In this use case the CONSUMERS can get access to the datasets, so it's ideal for problems with low data privacy constraints. The main capabilities are: Allowing data monetization. Data owners can make available their data and get some rewards/benefits when others get access to it. Allows an easy data publishing or data access from the users. Provides a Decentralized Access Control where untrusted members can feel confident that other members of the system will play honestly Supports free or paid access scenarios All the interactions related with the assets or services (when are created in the system, who has access, when the access was granted, etc.) is tracked The decentralized access control can be used in public or private blockchain networks You can find more details about the technical implementation of the Data Sharing use case in the ACCESS SPEC . Data in situ Computation (DISC) \u00b6 It facilitates the use cases where data owners allow third parties to execute some algorithms where the data is. For the use cases with more privacy restrictions in which the Data Owner never wants to lose control of their data, and this source data can't be accessed directly, Nevermined provides a Data in situ Computation (DISC) solution. This scenario is based on the premise that data doesn't want to be moved. Moving data of their existing premises is a liability. The data can be leaked in transit and because the private nature of the data, moving it implies some regulatory issues. In that case, Nevermined provides a solution where the Data Owner allows the execution of an algorithm (tensorflow, spark, etc.) in the infrastructure where the data is. It means the Data Consumer provides the algorithm to execute, and this is moved to the Data Owner infrastructure where the data is being kept. The Data Consumer receives the result of the execution of the algorithm on top of the data. Data in situ Computation You can find more details about the technical implementation of the Data in situ Computation use case in the COMPUTE SPEC . The main capabilities of the Data in situ Computation building block are: Solution designed to support different computation or backend paradigms Implemented 2 different backends, one of them orchestrating Kubernetes containers in the Data Provider environment. Other via the integration of a Federated Learning framework Framework or programming language independent The data never moves, algorithm goes where data is Consumer never get access to the real data The algorithm is moved where the data is. An ephemeral environment is created to support the computation It supports the orchestration of computing pipelines All the access control and execution is controlled via the integration with the service agreements Can be run in cloud providers or on-premise Permits the monitoring of the workflows execution Compute backends \u00b6 Nevermined supports to plug different compute backends that could be more convenient depending on the use cases. The rest of the ecosystem keeps the same (services, api\u2019s, applications on top, etc.), but depending on how the use case is, Nevermined will orchestrate the compute jobs in different ways. At this point in time Nevermined integrates 2 different compute backends: Kubernetes backend \u00b6 This backend is perfect for compute jobs that can be executed in the data provider data center and don\u2019t have high privacy constraints. In this scenario the Client can implement the algorithm using different languages or frameworks, and the Nevermined Compute solution will be in charge of orchestrating the infrastructure for moving the algorithm where the data is. Kubernetes orchestration As you can see in the above diagram, the Compute API will be in charge of triggering the compute workflow interacting with the Kubernetes infrastructure via Argo . This includes: Download the algorithm provided by the Data Scientist/Engineer Starts the right Docker container in the infrastructure Mount as volume with the data Execute the algorithm passing as parameter the path where the data is mounted Stop the Compute pod where the algorithm is running Publishing the result as a new asset Destroy all the ephemeral environment Federated Learning backend \u00b6 This backend fits for the execution of federated learning jobs using the data of providers having federated environments. In this scenario the Client can implement the data training model using a generic federated learning framework, and the Nevermined Compute solution will be in charge of orchestrating the execution across all the participants. In this scenario the Compute backend starts two independent tasks, the coordinator and the aggregator. The coordinator will do all the management of the participants as part of a federated job. The aggregator will do the secure aggregation of the trained models. Both the coordinator and aggregator are ephemeral nodes created by demand, so after the job is executed they will be stopped till a new execution request is triggered. Federated Learning backend Data Marketplace and Cataloging \u00b6 It facilitates the search, discovery and management of the existing assets in the data ecosystem. The main capabilities are: Improved User Experience Integration with the Data Governance and Data Catalog tools Easy search and discovery Native integration with the data sharing and data in situ computation building blocks Internal data catalog and APIs Tokenization and incentives","title":"Building Blocks"},{"location":"BuildingBlocks/#building-blocks","text":"Nevermined is based in three core building blocks:","title":"Building Blocks"},{"location":"BuildingBlocks/#data-sharing","text":"It enables the data sharing capabilities between unstructured parties. The main users involved in this scenario are: Organizations with data that need to share and monetize ( Data Owners ). Organizations or individuals looking for data sets to train their models ( Data Consumers ). Typically Data Owners & Consumers don't know or trust each other. Nevermined provides a generic solution where both can share data in a decentralized and secure way. The main benefits for them are: Data Owners can get some benefit of their existing data Data Consumers can get access to datasets they couldn't get access in other conditions Nevermined Data Sharing flow In this use case the CONSUMERS can get access to the datasets, so it's ideal for problems with low data privacy constraints. The main capabilities are: Allowing data monetization. Data owners can make available their data and get some rewards/benefits when others get access to it. Allows an easy data publishing or data access from the users. Provides a Decentralized Access Control where untrusted members can feel confident that other members of the system will play honestly Supports free or paid access scenarios All the interactions related with the assets or services (when are created in the system, who has access, when the access was granted, etc.) is tracked The decentralized access control can be used in public or private blockchain networks You can find more details about the technical implementation of the Data Sharing use case in the ACCESS SPEC .","title":"Data Sharing"},{"location":"BuildingBlocks/#data-in-situ-computation-disc","text":"It facilitates the use cases where data owners allow third parties to execute some algorithms where the data is. For the use cases with more privacy restrictions in which the Data Owner never wants to lose control of their data, and this source data can't be accessed directly, Nevermined provides a Data in situ Computation (DISC) solution. This scenario is based on the premise that data doesn't want to be moved. Moving data of their existing premises is a liability. The data can be leaked in transit and because the private nature of the data, moving it implies some regulatory issues. In that case, Nevermined provides a solution where the Data Owner allows the execution of an algorithm (tensorflow, spark, etc.) in the infrastructure where the data is. It means the Data Consumer provides the algorithm to execute, and this is moved to the Data Owner infrastructure where the data is being kept. The Data Consumer receives the result of the execution of the algorithm on top of the data. Data in situ Computation You can find more details about the technical implementation of the Data in situ Computation use case in the COMPUTE SPEC . The main capabilities of the Data in situ Computation building block are: Solution designed to support different computation or backend paradigms Implemented 2 different backends, one of them orchestrating Kubernetes containers in the Data Provider environment. Other via the integration of a Federated Learning framework Framework or programming language independent The data never moves, algorithm goes where data is Consumer never get access to the real data The algorithm is moved where the data is. An ephemeral environment is created to support the computation It supports the orchestration of computing pipelines All the access control and execution is controlled via the integration with the service agreements Can be run in cloud providers or on-premise Permits the monitoring of the workflows execution","title":"Data in situ Computation (DISC)"},{"location":"BuildingBlocks/#compute-backends","text":"Nevermined supports to plug different compute backends that could be more convenient depending on the use cases. The rest of the ecosystem keeps the same (services, api\u2019s, applications on top, etc.), but depending on how the use case is, Nevermined will orchestrate the compute jobs in different ways. At this point in time Nevermined integrates 2 different compute backends:","title":"Compute backends"},{"location":"BuildingBlocks/#kubernetes-backend","text":"This backend is perfect for compute jobs that can be executed in the data provider data center and don\u2019t have high privacy constraints. In this scenario the Client can implement the algorithm using different languages or frameworks, and the Nevermined Compute solution will be in charge of orchestrating the infrastructure for moving the algorithm where the data is. Kubernetes orchestration As you can see in the above diagram, the Compute API will be in charge of triggering the compute workflow interacting with the Kubernetes infrastructure via Argo . This includes: Download the algorithm provided by the Data Scientist/Engineer Starts the right Docker container in the infrastructure Mount as volume with the data Execute the algorithm passing as parameter the path where the data is mounted Stop the Compute pod where the algorithm is running Publishing the result as a new asset Destroy all the ephemeral environment","title":"Kubernetes backend"},{"location":"BuildingBlocks/#federated-learning-backend","text":"This backend fits for the execution of federated learning jobs using the data of providers having federated environments. In this scenario the Client can implement the data training model using a generic federated learning framework, and the Nevermined Compute solution will be in charge of orchestrating the execution across all the participants. In this scenario the Compute backend starts two independent tasks, the coordinator and the aggregator. The coordinator will do all the management of the participants as part of a federated job. The aggregator will do the secure aggregation of the trained models. Both the coordinator and aggregator are ephemeral nodes created by demand, so after the job is executed they will be stopped till a new execution request is triggered. Federated Learning backend","title":"Federated Learning backend"},{"location":"BuildingBlocks/#data-marketplace-and-cataloging","text":"It facilitates the search, discovery and management of the existing assets in the data ecosystem. The main capabilities are: Improved User Experience Integration with the Data Governance and Data Catalog tools Easy search and discovery Native integration with the data sharing and data in situ computation building blocks Internal data catalog and APIs Tokenization and incentives","title":"Data Marketplace and Cataloging"},{"location":"Licensing/","text":"Software Licenses \u00b6 Nevermined is a solution that includes Open & Private source components. The core of the functionality is Open Source Software using the very open Apache v2 . In addition to that, we provide some additional management tools that can help to operate and monitor a Nevermined based Digital Ecosystem deployment. Nevermined is offered for free from a Source Code point of view. In addition we provide a subscription model where people can get access to additional documentation, support, binaries, docker images, advanced tools, etc. The artifacts provided in the subscription model package all the components and allow an easy deployment, orchestration, operation and monitoring of a complete data ecosystem platform providing enterprise level quality. Why a subcription model? \u00b6 Nevermined is adapted to enterprise requirements to facilitate the development, integration & deployment of complex data solutions. It automatically orchestrates, operates & monitors complete enterprise data ecosystems. Nevermined components are offered with a dual Open Source/Private License. The source code is provided under an Open Source Apache v2 License providing the foundations of your Data Ecosystem: Smart Contracts Metadata API Data Gateway SDK's and Libraries Documentation & Specifications Additionally, Keyko offers an Enterprise & Digital Ecosystem subscription-based License for users with extended capabilities on top of the Open Source components: Integrated Access Control Operational & Development tools Containerization of the whole platform Service Execution Agreements Ecosystem Monitoring Extended Knowledge base If you want to know more, please send us a message to info@nevermined.io","title":"Software Licenses"},{"location":"Licensing/#software-licenses","text":"Nevermined is a solution that includes Open & Private source components. The core of the functionality is Open Source Software using the very open Apache v2 . In addition to that, we provide some additional management tools that can help to operate and monitor a Nevermined based Digital Ecosystem deployment. Nevermined is offered for free from a Source Code point of view. In addition we provide a subscription model where people can get access to additional documentation, support, binaries, docker images, advanced tools, etc. The artifacts provided in the subscription model package all the components and allow an easy deployment, orchestration, operation and monitoring of a complete data ecosystem platform providing enterprise level quality.","title":"Software Licenses"},{"location":"Licensing/#why-a-subcription-model","text":"Nevermined is adapted to enterprise requirements to facilitate the development, integration & deployment of complex data solutions. It automatically orchestrates, operates & monitors complete enterprise data ecosystems. Nevermined components are offered with a dual Open Source/Private License. The source code is provided under an Open Source Apache v2 License providing the foundations of your Data Ecosystem: Smart Contracts Metadata API Data Gateway SDK's and Libraries Documentation & Specifications Additionally, Keyko offers an Enterprise & Digital Ecosystem subscription-based License for users with extended capabilities on top of the Open Source components: Integrated Access Control Operational & Development tools Containerization of the whole platform Service Execution Agreements Ecosystem Monitoring Extended Knowledge base If you want to know more, please send us a message to info@nevermined.io","title":"Why a subcription model?"},{"location":"Specs/","text":"Nevermined Specifications \u00b6 The core of the platform is documented in detail in Specification documents (aka SPECs ). Here you can find a list of the most relevant SPECs: Short Name Title Version Status Editor DID Decentralized Identifiers 0.3 Valid @aaitor META Metadata 0.2 Valid @aaitor ACCESS Decentralized Access Control 0.1 Valid @aaitor COMPUTE Decentralized Data in situ Computation 0.1 Valid @aaitor FL Federated Learning integration 0.1 Valid @r-marques PROV Decentralized Data Provenance 0.2 Valid @aaitor IDM Identity management with on-chain access control 0.1 Valid @aaitor NFT NFTs Engine 0.2 Valid @aaitor KEYTRANSFER Data Transfer Proofs 0.1 Valid @mrsmkl MKTAPI Marketplace API 0.2 Draft @aaitor Attribution \u00b6 Some of the Specs are an evolution of Ocean Protocol Enhancement Proposals - OEPs .","title":"Overview"},{"location":"Specs/#nevermined-specifications","text":"The core of the platform is documented in detail in Specification documents (aka SPECs ). Here you can find a list of the most relevant SPECs: Short Name Title Version Status Editor DID Decentralized Identifiers 0.3 Valid @aaitor META Metadata 0.2 Valid @aaitor ACCESS Decentralized Access Control 0.1 Valid @aaitor COMPUTE Decentralized Data in situ Computation 0.1 Valid @aaitor FL Federated Learning integration 0.1 Valid @r-marques PROV Decentralized Data Provenance 0.2 Valid @aaitor IDM Identity management with on-chain access control 0.1 Valid @aaitor NFT NFTs Engine 0.2 Valid @aaitor KEYTRANSFER Data Transfer Proofs 0.1 Valid @mrsmkl MKTAPI Marketplace API 0.2 Draft @aaitor","title":"Nevermined Specifications"},{"location":"Specs/#attribution","text":"Some of the Specs are an evolution of Ocean Protocol Enhancement Proposals - OEPs .","title":"Attribution"},{"location":"api/","text":"Nevermined APIs \u00b6 Nevermined offers different capabilities built on top of some technical components . Each of team play a different role and allow their integration in different ways. Software Development Kits (SDK's) \u00b6 The main entry point for using Nevermined are the Software Development Kits (SDKs). SDK's are the software libraries encapsulating the Nevermined business logic. They are used to interact with all the components & APIs of the system. Nevermined provides 3 different Open Source implementation of SDK's allowing the integration and implementation of complex use cases on top of the Nevermined Data Ecosystems. Nevermined SDK JS - JavaScript version of the Nevermined SDK to be integrated with front-end applications. Nevermined SDK PY - Python version of the Nevermined SDK to be integrated with back-end applications. The primary users are data scientists. Nevermined SDK JAVA - Java version of the Nevermined SDK to be integrated with JVM applications. The primary users are data engineers. All the three implementations are very similar from a design and interface point of view. It means that beyond the language differences, the concepts and the way the API is exposed from a user point of view is the same. If you want to know more, you can explore the Nevermined Reference API and it's implementation in the SDKs API documentation . Metadata API \u00b6 The Nevermined Metadata API is an Open Source micro-service that allows to store Assets metadata in an off-chain repository. It provides a plugins system allowing to persist the Metadata in ElasticSearch or MongoDB. The Metadata API exposes the functionality for searching metadata using multiple filters and parameters. The Metadata API is typically the backend used for Data Marketplaces or Data Catalogs for storing all the Metadata of a specific domain related to a Marketplace or Catalog . The Metadata API is wrapped by the SDKs, so you don't need to integrate directly this API. Gateway \u00b6 The Nevermined Gateway is an Open Source micro-service in the Nevermined ecosystem. The Gateway is the technical component executed by Data/Compute Providers allowing them to provide extended data services (e.g. storage and compute). The Nevermined Gateway, as part of the Publisher ecosystem, includes the credentials to interact with the infrastructure (initially cloud, but could be on-premise). The Gateway API is wrapped by the SDKs, so you don't need to integrate directly this API.","title":"Overview"},{"location":"api/#nevermined-apis","text":"Nevermined offers different capabilities built on top of some technical components . Each of team play a different role and allow their integration in different ways.","title":"Nevermined APIs"},{"location":"api/#software-development-kits-sdks","text":"The main entry point for using Nevermined are the Software Development Kits (SDKs). SDK's are the software libraries encapsulating the Nevermined business logic. They are used to interact with all the components & APIs of the system. Nevermined provides 3 different Open Source implementation of SDK's allowing the integration and implementation of complex use cases on top of the Nevermined Data Ecosystems. Nevermined SDK JS - JavaScript version of the Nevermined SDK to be integrated with front-end applications. Nevermined SDK PY - Python version of the Nevermined SDK to be integrated with back-end applications. The primary users are data scientists. Nevermined SDK JAVA - Java version of the Nevermined SDK to be integrated with JVM applications. The primary users are data engineers. All the three implementations are very similar from a design and interface point of view. It means that beyond the language differences, the concepts and the way the API is exposed from a user point of view is the same. If you want to know more, you can explore the Nevermined Reference API and it's implementation in the SDKs API documentation .","title":"Software Development Kits (SDK's)"},{"location":"api/#metadata-api","text":"The Nevermined Metadata API is an Open Source micro-service that allows to store Assets metadata in an off-chain repository. It provides a plugins system allowing to persist the Metadata in ElasticSearch or MongoDB. The Metadata API exposes the functionality for searching metadata using multiple filters and parameters. The Metadata API is typically the backend used for Data Marketplaces or Data Catalogs for storing all the Metadata of a specific domain related to a Marketplace or Catalog . The Metadata API is wrapped by the SDKs, so you don't need to integrate directly this API.","title":"Metadata API"},{"location":"api/#gateway","text":"The Nevermined Gateway is an Open Source micro-service in the Nevermined ecosystem. The Gateway is the technical component executed by Data/Compute Providers allowing them to provide extended data services (e.g. storage and compute). The Nevermined Gateway, as part of the Publisher ecosystem, includes the credentials to interact with the infrastructure (initially cloud, but could be on-premise). The Gateway API is wrapped by the SDKs, so you don't need to integrate directly this API.","title":"Gateway"},{"location":"api/SDK/","text":"Software Development Kits (SDKs) \u00b6 The SDKs, independently of their programming language, allow the interaction with the multiple Nevermined components. The SDKs integrate: The Nevermined Smart Contracts, where is kept all the assets registry, token, service execution agreements, etc. The Metadata API, where is kept the metadata associated to assets (title, description, tags, etc). The Gateway, that is the component that make data and computation available via the integration with data repositories and compute apis The Faucet, an optional component that allow users to request Ether for paying on-chain transactions The Secret Store, an optional component existing in some Nevermined deploments, it allows multi-party encryption and decryption of secrets Language Implementations \u00b6 There are different language implementations of the SDKs: Nevermined SDK JS - JavaScript version of the Nevermined SDK to be integrated with front-end applications. Nevermined SDK PY - Python version of the Nevermined SDK to be integrated with back-end applications. The primary users are data scientists. Nevermined SDK JAVA - Java version of the Nevermined SDK to be integrated with JVM applications. The primary users are data engineers. SDK Documentation \u00b6 Nevermined SDK JS Documentation - Javascript documentation is included as part of the project repository. Nevermined SDK PY Documentation - Python documentation is included as part of the project repository. Nevermined SDK JAVA Documentation - The Java documentation is generated automatically using javadoc . All the documentation can be found in javadoc.io . API Reference \u00b6 All the SDKs implement the same Nevermined reference API. This can be found in the Nevermined Reference API Document . Modules \u00b6 The SDK implement different the following modules: Module Topic Assets Managing of data assets on Nevermined networks Accounts Managing accounts Agreements Interacting with Service Execution Agreements (aka SEAs) Conditions Interacting with agreement conditions Provenance Tracking & retrieving data provenance Tokens Request and transfer Nevermined tokens Providers Manage of asset providers Secret Store Encryption and Decryption secrets","title":"Software Development Kits (SDKs)"},{"location":"api/SDK/#software-development-kits-sdks","text":"The SDKs, independently of their programming language, allow the interaction with the multiple Nevermined components. The SDKs integrate: The Nevermined Smart Contracts, where is kept all the assets registry, token, service execution agreements, etc. The Metadata API, where is kept the metadata associated to assets (title, description, tags, etc). The Gateway, that is the component that make data and computation available via the integration with data repositories and compute apis The Faucet, an optional component that allow users to request Ether for paying on-chain transactions The Secret Store, an optional component existing in some Nevermined deploments, it allows multi-party encryption and decryption of secrets","title":"Software Development Kits (SDKs)"},{"location":"api/SDK/#language-implementations","text":"There are different language implementations of the SDKs: Nevermined SDK JS - JavaScript version of the Nevermined SDK to be integrated with front-end applications. Nevermined SDK PY - Python version of the Nevermined SDK to be integrated with back-end applications. The primary users are data scientists. Nevermined SDK JAVA - Java version of the Nevermined SDK to be integrated with JVM applications. The primary users are data engineers.","title":"Language Implementations"},{"location":"api/SDK/#sdk-documentation","text":"Nevermined SDK JS Documentation - Javascript documentation is included as part of the project repository. Nevermined SDK PY Documentation - Python documentation is included as part of the project repository. Nevermined SDK JAVA Documentation - The Java documentation is generated automatically using javadoc . All the documentation can be found in javadoc.io .","title":"SDK Documentation"},{"location":"api/SDK/#api-reference","text":"All the SDKs implement the same Nevermined reference API. This can be found in the Nevermined Reference API Document .","title":"API Reference"},{"location":"api/SDK/#modules","text":"The SDK implement different the following modules: Module Topic Assets Managing of data assets on Nevermined networks Accounts Managing accounts Agreements Interacting with Service Execution Agreements (aka SEAs) Conditions Interacting with agreement conditions Provenance Tracking & retrieving data provenance Tokens Request and transfer Nevermined tokens Providers Manage of asset providers Secret Store Encryption and Decryption secrets","title":"Modules"},{"location":"api/cli/","text":"Nevermined Command Line Interface (CLI) \u00b6 The Nevermined CLI tool enables to connect to the Nevermined Data Ecosystem and interact with it using the command line interface. It orchestrates all the components allowing to: Publish assets Get access to assets Search and discovery Running remote compute jobs Checking the state of Service Agreements Tracking provenance Manage NFTs and Nevermined tokens You can find all the CLI documentation and the commands available in the CLI docs website : https://nevermined-io.github.io/cli/","title":"Command Line Interface"},{"location":"api/cli/#nevermined-command-line-interface-cli","text":"The Nevermined CLI tool enables to connect to the Nevermined Data Ecosystem and interact with it using the command line interface. It orchestrates all the components allowing to: Publish assets Get access to assets Search and discovery Running remote compute jobs Checking the state of Service Agreements Tracking provenance Manage NFTs and Nevermined tokens You can find all the CLI documentation and the commands available in the CLI docs website : https://nevermined-io.github.io/cli/","title":"Nevermined Command Line Interface (CLI)"},{"location":"api/gateway/","text":"Nevermined Gateway \u00b6 The Nevermined Gateway is an Open Source micro-service in the Nevermined ecosystem. The Gateway is the technical component executed by Data/Compute Providers allowing them to provide extended data services (e.g. storage and compute). The Nevermined Gateway, as part of the Publisher ecosystem, includes the credentials to interact with the infrastructure (initially cloud, but could be on-premise). The Gateway allows also the encryption and decryption of components using the following mechanisms: RSA ECDSA Parity Secret Store Nevermined provides the package and automation of the micro-service allowing an easy integration and deployment in cloud providers and Kubernetes clusters. Gateway API Reference \u00b6 You can find a complete API reference documented in Swagger format in the docs folder of the metadata api repository.","title":"Gateway API"},{"location":"api/gateway/#nevermined-gateway","text":"The Nevermined Gateway is an Open Source micro-service in the Nevermined ecosystem. The Gateway is the technical component executed by Data/Compute Providers allowing them to provide extended data services (e.g. storage and compute). The Nevermined Gateway, as part of the Publisher ecosystem, includes the credentials to interact with the infrastructure (initially cloud, but could be on-premise). The Gateway allows also the encryption and decryption of components using the following mechanisms: RSA ECDSA Parity Secret Store Nevermined provides the package and automation of the micro-service allowing an easy integration and deployment in cloud providers and Kubernetes clusters.","title":"Nevermined Gateway"},{"location":"api/gateway/#gateway-api-reference","text":"You can find a complete API reference documented in Swagger format in the docs folder of the metadata api repository.","title":"Gateway API Reference"},{"location":"api/metadata/","text":"Nevermined Metadata API \u00b6 The Nevermined Metadata API is an Open Source micro-service that allows to store Assets metadata in an off-chain repository. It provides a plugins system allowing to persist the Metadata in ElasticSearch. The Metadata API exposes the functionality for searching metadata using multiple filters and parameters. The Metadata API is typically the backend used for Data Marketplaces or Data Catalogs for storing all the Metadata of a specific domain related to a Marketplace or Catalog . Nevermined provides the package and automation of the micro-service allowing an easy integration and deployment in cloud providers and Kubernetes clusters. Metadata API Reference \u00b6 You can find a complete API reference documented in Swagger format in the docs folder of the metadata api repository. Queries \u00b6 Because the Metadata API is using Elastic Search as repository of data, allows to resolve complex searches a filters on top of the metadata information. Some of these queries are pre-built into the metadata api, but also the micro-service exposes via the /api/v1/metadata/assets/ddo/query endpoint the possibility of sending bespoke Elastic Search queries to adapt to different metadata. To call this endpoint the body should contain a elastic search query in the query field, other fields can be also added to sort the results and use pagination, a body example would be: { \"offset\" : 100 , \"page\" : 1 , \"query\" : { \"bool\" : { \"must\" : [{ \"match\" : { \"service.attributes.additionalInformation.categories\" : \"image\" }}]} }, \"sort\" : { \"value\" : 1 } } To use any other query, the DSL language from elastic search can be used. Some more examples can be found in the documentation of the Metadata API repository.","title":"Metadata API"},{"location":"api/metadata/#nevermined-metadata-api","text":"The Nevermined Metadata API is an Open Source micro-service that allows to store Assets metadata in an off-chain repository. It provides a plugins system allowing to persist the Metadata in ElasticSearch. The Metadata API exposes the functionality for searching metadata using multiple filters and parameters. The Metadata API is typically the backend used for Data Marketplaces or Data Catalogs for storing all the Metadata of a specific domain related to a Marketplace or Catalog . Nevermined provides the package and automation of the micro-service allowing an easy integration and deployment in cloud providers and Kubernetes clusters.","title":"Nevermined Metadata API"},{"location":"api/metadata/#metadata-api-reference","text":"You can find a complete API reference documented in Swagger format in the docs folder of the metadata api repository.","title":"Metadata API Reference"},{"location":"api/metadata/#queries","text":"Because the Metadata API is using Elastic Search as repository of data, allows to resolve complex searches a filters on top of the metadata information. Some of these queries are pre-built into the metadata api, but also the micro-service exposes via the /api/v1/metadata/assets/ddo/query endpoint the possibility of sending bespoke Elastic Search queries to adapt to different metadata. To call this endpoint the body should contain a elastic search query in the query field, other fields can be also added to sort the results and use pagination, a body example would be: { \"offset\" : 100 , \"page\" : 1 , \"query\" : { \"bool\" : { \"must\" : [{ \"match\" : { \"service.attributes.additionalInformation.categories\" : \"image\" }}]} }, \"sort\" : { \"value\" : 1 } } To use any other query, the DSL language from elastic search can be used. Some more examples can be found in the documentation of the Metadata API repository.","title":"Queries"},{"location":"api/reference/Accounts/","text":"Nevermined Accounts API \u00b6 Exposes the Public API related with the management of Accounts Get account balance \u00b6 It returns the tokens balance of an account. Parameters: account Public address of the account Example: balance ( 0xaabb ) Get account balance \u00b6 It returns the accounts registered in a blockchain node. Example: list ()","title":"Accounts"},{"location":"api/reference/Accounts/#nevermined-accounts-api","text":"Exposes the Public API related with the management of Accounts","title":"Nevermined Accounts API"},{"location":"api/reference/Accounts/#get-account-balance","text":"It returns the tokens balance of an account. Parameters: account Public address of the account Example: balance ( 0xaabb )","title":"Get account balance"},{"location":"api/reference/Accounts/#get-account-balance_1","text":"It returns the accounts registered in a blockchain node. Example: list ()","title":"Get account balance"},{"location":"api/reference/Agreements/","text":"Agreements API Reference \u00b6 Nevermined Service Execution Agreements (SEAs) (also called \"Service Agreements\" or \"Agreements\") are contracts between parties interacting in a transaction. They provide the capacity of defining on-chain validation of conditions as a previous step of providing a service. The most classical scenarios in Nevermined are Service Agreements allowing Data Sharing or Remote Computation. The SEAs are used here to facilitate: A publisher defining a service that is offered and what a the conditions to obtaining that service A consumer or user that needs to fulfill the publisher conditions to getting access to that service You can find more information about the implementation of the SEAs in the access Spec and the compute Spec . Every execution by an user of a service agreement can be referenced by the agreementId . That is a unique identifier of the agreement execution and it is used across this api reference document. Create a Service Agreement \u00b6 Creates an on-chain Service Agreement instance. Parameters: did Identifier of the asset associated to the service agreement index The service index of the agreement in the DDO agreementId the unique identifier of the execution of an agreement signature the signature of the agreementId provided by the consumer of the agreement consumerAccount The Public address of the consumer account Example: create ( \"did:nv:1234\" , 0 , \"8181818\" , \"fdfdfdfd\" , 0xaabb ) Get the status of a Service Agreement \u00b6 Get the status of a service agreement instance. Parameters: agreementId the unique identifier of the execution of an agreement Example: status ( \"8181818\" ) Is a Service Agreement granted? \u00b6 Return if a service agreement is granted. Parameters: agreementId the unique identifier of the execution of an agreement did Identifier of the asset associated to the service agreement consumerAccount The Public address of the consumer account Example: isAccessGranted ( \"8181818\" , \"did:nv:1234\" , 0xaabb )","title":"Agreements"},{"location":"api/reference/Agreements/#agreements-api-reference","text":"Nevermined Service Execution Agreements (SEAs) (also called \"Service Agreements\" or \"Agreements\") are contracts between parties interacting in a transaction. They provide the capacity of defining on-chain validation of conditions as a previous step of providing a service. The most classical scenarios in Nevermined are Service Agreements allowing Data Sharing or Remote Computation. The SEAs are used here to facilitate: A publisher defining a service that is offered and what a the conditions to obtaining that service A consumer or user that needs to fulfill the publisher conditions to getting access to that service You can find more information about the implementation of the SEAs in the access Spec and the compute Spec . Every execution by an user of a service agreement can be referenced by the agreementId . That is a unique identifier of the agreement execution and it is used across this api reference document.","title":"Agreements API Reference"},{"location":"api/reference/Agreements/#create-a-service-agreement","text":"Creates an on-chain Service Agreement instance. Parameters: did Identifier of the asset associated to the service agreement index The service index of the agreement in the DDO agreementId the unique identifier of the execution of an agreement signature the signature of the agreementId provided by the consumer of the agreement consumerAccount The Public address of the consumer account Example: create ( \"did:nv:1234\" , 0 , \"8181818\" , \"fdfdfdfd\" , 0xaabb )","title":"Create a Service Agreement"},{"location":"api/reference/Agreements/#get-the-status-of-a-service-agreement","text":"Get the status of a service agreement instance. Parameters: agreementId the unique identifier of the execution of an agreement Example: status ( \"8181818\" )","title":"Get the status of a Service Agreement"},{"location":"api/reference/Agreements/#is-a-service-agreement-granted","text":"Return if a service agreement is granted. Parameters: agreementId the unique identifier of the execution of an agreement did Identifier of the asset associated to the service agreement consumerAccount The Public address of the consumer account Example: isAccessGranted ( \"8181818\" , \"did:nv:1234\" , 0xaabb )","title":"Is a Service Agreement granted?"},{"location":"api/reference/Assets/","text":"Nevermined Assets API \u00b6 Every entity object in Nevermined is encapsulated in an asset . Typically the abstract things like datasets, algorithms, services, workflows, etc. But technically can abstract any entity with services provided by an user to the rest network under some conditions. Any asset has 2 main components: A Decentralized Identifier or DID. A unique id that reference the asset. This is recorded on-chain when the asset is registered in a Nevermined network Metadata. A DID Document describing the asset and the services (access, compute, etc.) associated to that asset. This is recorded off-chain. An on-chain DID can be used to resolve the metadata associated to it. You can find more information about the implementation of the SEAs and the services associated to Nevermined assets in the access Spec and the compute Spec . Assets Management \u00b6 Create an asset \u00b6 It registers a new asset on Nevermined. It Creates a new DID, registering it on-chain through DIDRegistry contract and off-chain in Metadata. Parameters: metadata the metadata describing the asset (full metadata specification ) publisherAccount Public address of the account publishing the asset providers List of public addresses that can act on behalf of the asset publisher, typically for providing some services like access associated to it authorization Type of encryption used to validate authorization ( PSK_RSA , PSK_ECDSA , SecretStore ) activityId Provenance identifier of the activity doing the creation action attributes Optional attributes associated with the provenance creation Example: create ( \"{ddo metadata}\" , 0xaabb , [ 0xccdd ] , \"PSK_RSA\" , \"creation\" , \"+ attributes\" ) Create a compute service \u00b6 It registers a new asset on Nevermined with a compute service associated to it. This function creates a new DID, registering it on-chain through DIDRegistry contract and off-chain in Metadata. Parameters: metadata the metadata describing the asset (full metadata specification ) publisherAccount Public address of the account publishing the asset providers List of public addresses that can act on behalf of the asset publisher, typically for providing some services like access associated to it authorization Type of encryption used to validate authorization ( PSK_RSA , PSK_ECDSA , SecretStore ) activityId Provenance identifier of the activity doing the creation action attributes Optional attributes associated with the provenance creation Example: createCompute ( \"{ddo metadata}\" , 0xaabb , [ 0xccdd ] , \"PSK_RSA\" , \"creation\" , \"+ attributes\" ) Order an asset \u00b6 This function orders an Asset represented by a DID. It implies to initialize a Service Agreement on-chain between publisher and consumer. For lower level details you can take a look at access Specs . As a result of an order the function will return an agreementId . This unique identifier about the Service Agreement just created can be used for further consumption of the access or compute service associated to it. Parameters: did Identifier of the asset to order index The service index of the agreement in the DDO to order consumerAccount The Public address of the consumer account executing the order Example: order ( \"did:nv:1234\" , 0 , 0xaabb ) Download assets \u00b6 This function downloads an Asset previously ordered (using the order function). Parameters: agreementId Identifier of the service agreement between the consumer and the publisher did Identifier of the asset to download index The service index to the access service in the DDO to download path Destination folder where the asset files will be downloaded Example: download ( \"8594385934\" , \"did:nv:1234\" , 0 , 0xaabb , \"/path/to/destination\" ) Execute \u00b6 This function executes a compute service of an Asset previously ordered (using the order function). Parameters: agreementId Identifier of the service agreement between the consumer and the publisher did Identifier of the asset to execute index The service index to the compute service in the DDO to execute workflowDid Identifier of the compute workflow to execute Example: execute ( \"8594385934\" , \"did:nv:1234\" , 0 , 0xaabb , \"did:nv:ccdd\" ) Transfer asset ownership \u00b6 It transfer the on-chain ownership of one asset from the original owner to a different account. Parameters: did Identifier of the asset to execute newAccountOwner The Public address of account belonging to the new owner Example: transferOwnership ( \"did:nv:1234\" , 0xddee ) Fetch assets associated information \u00b6 This functions allow retrieve information related with assets. Assets information can be in two different places: On-chain. As part of the assets registry ( DIDRegistry ). There is stored the did and the url resolving to the did document or ddo . Off-chain. As part of marketplaces, the metadata api services keep all the metadata information (in ddo format) Resolve a DID into a DDO \u00b6 A Nevermined network is composed by only one source of truth, the decentralized logic and storage provided by the blockchain and the Smart Contracts. A part of that, the network can be composed by many different marketplaces or metada repositories. This function resolves a did existing in the unique source of truth (blockchain) into the ddo (metadata) that can be stored in any of the multiple metadata servers existing in a Nevermined network deployment. This function will return the metadata of an asset in DDO format. More information about the contents of this document can be found in the metadata specification page. Parameters: did Identifier of the asset to resolve in a DDO that is off-chain Example: resolve ( \"did:nv:1234\" ) Search for assets \u00b6 This function search in a metadata api instance all the DDO that match the search criteria. This function will return a list of assets metadata matching the criteria. Parameters: text the search query sort Key or list of keys to sort the result offset Number of records per page page Page showed Example: search ( \"weather in Berlin\" , \"price\" , 0 , 1 ) Get assets owned by an account \u00b6 This function retrieves the list of assets owned by an account. Parameters: account The Public address of account owning assets Example: ownerAssets ( 0xaabb ) Get assets purchased by an account \u00b6 This function retrieves the list of assets purchased by an account. Parameters: account The Public address of account that purchased the assets Example: consumerAssets ( 0xaabb ) Get the computation logs of a workflow execution \u00b6 When a user triggers a compute execution via the execute function, this execution is scheduled and de-attached of the api method triggering it. This function returns the logs generated during the execution of the multiple stages of a workflow in the data publisher infrastructure. This function requires the executionId and agreementId for getting the logs. Parameters: agreementId Identifier of the service agreement between the consumer and the publisher executionId Identifier of the execution related with the agreement executed account The Public address of account used to execute the computation Example: computeLogs ( \"8974328\" , \"ababacc\" , 0xaabb ) compute status \u00b6 When a user triggers a compute execution via the execute function, this execution is scheduled and de-attached of the api method triggering it. This function returns status of the jobs executed in the data publisher infrastructure. This function requires the executionId and agreementId for getting the logs. Parameters: agreementId Identifier of the service agreement between the consumer and the publisher executionId Identifier of the execution related with the agreement executed account The Public address of account used to execute the computation Example: computeStatus ( \"8974328\" , \"ababacc\" , 0xaabb ) Non-Fungible Tokens (NFTs) associated to assets \u00b6 A Decentralized Identifier (DID) that digitally represents some physical stuff, aligns quite well with the concept of a Non-Fungible Token (NFT). The implication is that, if you are an asset owner in Nevermined, you can mint NFTs associated with your DID and distribute them amongst your customers or users. Mint a NFT associated to an asset \u00b6 This function allows to a DID owner to mint NFTs associated to the DID. Parameters: did Identifier of the asset where the NFTs will be minted amount the amount of NFTs to mint associated to the DID Example: mint ( \"did:nv:1234\" , 5 ) Burn NFTs associated to an asset \u00b6 This function allows to burn existing NFTs associated to a DID. Parameters: did Identifier of the asset where the NFTs will be burned amount the amount of NFTs to burn associated to the DID Example: burn ( \"did:nv:1234\" , 1 ) Transfer NFTs associated to an asset \u00b6 This function allows to transfer NFTs associated to a DID between accounts. Parameters: did Identifier of the asset where the NFTs will be burned account Public address of the account where the NFTs will be transferred amount the amount of NFTs to burn associated to the DID Example: transfer ( \"did:nv:1234\" , 0xabab , 2 ) Get NFTs balance associated to an asset \u00b6 This function allows to get the NFTs balance of an account for a DID. Parameters: account Public address of the account did Identifier of the asset with NFTs associated Example: balance ( 0xabab , \"did:nv:1234\" )","title":"Assets"},{"location":"api/reference/Assets/#nevermined-assets-api","text":"Every entity object in Nevermined is encapsulated in an asset . Typically the abstract things like datasets, algorithms, services, workflows, etc. But technically can abstract any entity with services provided by an user to the rest network under some conditions. Any asset has 2 main components: A Decentralized Identifier or DID. A unique id that reference the asset. This is recorded on-chain when the asset is registered in a Nevermined network Metadata. A DID Document describing the asset and the services (access, compute, etc.) associated to that asset. This is recorded off-chain. An on-chain DID can be used to resolve the metadata associated to it. You can find more information about the implementation of the SEAs and the services associated to Nevermined assets in the access Spec and the compute Spec .","title":"Nevermined Assets API"},{"location":"api/reference/Assets/#assets-management","text":"","title":"Assets Management"},{"location":"api/reference/Assets/#create-an-asset","text":"It registers a new asset on Nevermined. It Creates a new DID, registering it on-chain through DIDRegistry contract and off-chain in Metadata. Parameters: metadata the metadata describing the asset (full metadata specification ) publisherAccount Public address of the account publishing the asset providers List of public addresses that can act on behalf of the asset publisher, typically for providing some services like access associated to it authorization Type of encryption used to validate authorization ( PSK_RSA , PSK_ECDSA , SecretStore ) activityId Provenance identifier of the activity doing the creation action attributes Optional attributes associated with the provenance creation Example: create ( \"{ddo metadata}\" , 0xaabb , [ 0xccdd ] , \"PSK_RSA\" , \"creation\" , \"+ attributes\" )","title":"Create an asset"},{"location":"api/reference/Assets/#create-a-compute-service","text":"It registers a new asset on Nevermined with a compute service associated to it. This function creates a new DID, registering it on-chain through DIDRegistry contract and off-chain in Metadata. Parameters: metadata the metadata describing the asset (full metadata specification ) publisherAccount Public address of the account publishing the asset providers List of public addresses that can act on behalf of the asset publisher, typically for providing some services like access associated to it authorization Type of encryption used to validate authorization ( PSK_RSA , PSK_ECDSA , SecretStore ) activityId Provenance identifier of the activity doing the creation action attributes Optional attributes associated with the provenance creation Example: createCompute ( \"{ddo metadata}\" , 0xaabb , [ 0xccdd ] , \"PSK_RSA\" , \"creation\" , \"+ attributes\" )","title":"Create a compute service"},{"location":"api/reference/Assets/#order-an-asset","text":"This function orders an Asset represented by a DID. It implies to initialize a Service Agreement on-chain between publisher and consumer. For lower level details you can take a look at access Specs . As a result of an order the function will return an agreementId . This unique identifier about the Service Agreement just created can be used for further consumption of the access or compute service associated to it. Parameters: did Identifier of the asset to order index The service index of the agreement in the DDO to order consumerAccount The Public address of the consumer account executing the order Example: order ( \"did:nv:1234\" , 0 , 0xaabb )","title":"Order an asset"},{"location":"api/reference/Assets/#download-assets","text":"This function downloads an Asset previously ordered (using the order function). Parameters: agreementId Identifier of the service agreement between the consumer and the publisher did Identifier of the asset to download index The service index to the access service in the DDO to download path Destination folder where the asset files will be downloaded Example: download ( \"8594385934\" , \"did:nv:1234\" , 0 , 0xaabb , \"/path/to/destination\" )","title":"Download assets"},{"location":"api/reference/Assets/#execute","text":"This function executes a compute service of an Asset previously ordered (using the order function). Parameters: agreementId Identifier of the service agreement between the consumer and the publisher did Identifier of the asset to execute index The service index to the compute service in the DDO to execute workflowDid Identifier of the compute workflow to execute Example: execute ( \"8594385934\" , \"did:nv:1234\" , 0 , 0xaabb , \"did:nv:ccdd\" )","title":"Execute"},{"location":"api/reference/Assets/#transfer-asset-ownership","text":"It transfer the on-chain ownership of one asset from the original owner to a different account. Parameters: did Identifier of the asset to execute newAccountOwner The Public address of account belonging to the new owner Example: transferOwnership ( \"did:nv:1234\" , 0xddee )","title":"Transfer asset ownership"},{"location":"api/reference/Assets/#fetch-assets-associated-information","text":"This functions allow retrieve information related with assets. Assets information can be in two different places: On-chain. As part of the assets registry ( DIDRegistry ). There is stored the did and the url resolving to the did document or ddo . Off-chain. As part of marketplaces, the metadata api services keep all the metadata information (in ddo format)","title":"Fetch assets associated information"},{"location":"api/reference/Assets/#resolve-a-did-into-a-ddo","text":"A Nevermined network is composed by only one source of truth, the decentralized logic and storage provided by the blockchain and the Smart Contracts. A part of that, the network can be composed by many different marketplaces or metada repositories. This function resolves a did existing in the unique source of truth (blockchain) into the ddo (metadata) that can be stored in any of the multiple metadata servers existing in a Nevermined network deployment. This function will return the metadata of an asset in DDO format. More information about the contents of this document can be found in the metadata specification page. Parameters: did Identifier of the asset to resolve in a DDO that is off-chain Example: resolve ( \"did:nv:1234\" )","title":"Resolve a DID into a DDO"},{"location":"api/reference/Assets/#search-for-assets","text":"This function search in a metadata api instance all the DDO that match the search criteria. This function will return a list of assets metadata matching the criteria. Parameters: text the search query sort Key or list of keys to sort the result offset Number of records per page page Page showed Example: search ( \"weather in Berlin\" , \"price\" , 0 , 1 )","title":"Search for assets"},{"location":"api/reference/Assets/#get-assets-owned-by-an-account","text":"This function retrieves the list of assets owned by an account. Parameters: account The Public address of account owning assets Example: ownerAssets ( 0xaabb )","title":"Get assets owned by an account"},{"location":"api/reference/Assets/#get-assets-purchased-by-an-account","text":"This function retrieves the list of assets purchased by an account. Parameters: account The Public address of account that purchased the assets Example: consumerAssets ( 0xaabb )","title":"Get assets purchased by an account"},{"location":"api/reference/Assets/#get-the-computation-logs-of-a-workflow-execution","text":"When a user triggers a compute execution via the execute function, this execution is scheduled and de-attached of the api method triggering it. This function returns the logs generated during the execution of the multiple stages of a workflow in the data publisher infrastructure. This function requires the executionId and agreementId for getting the logs. Parameters: agreementId Identifier of the service agreement between the consumer and the publisher executionId Identifier of the execution related with the agreement executed account The Public address of account used to execute the computation Example: computeLogs ( \"8974328\" , \"ababacc\" , 0xaabb )","title":"Get the computation logs of a workflow execution"},{"location":"api/reference/Assets/#compute-status","text":"When a user triggers a compute execution via the execute function, this execution is scheduled and de-attached of the api method triggering it. This function returns status of the jobs executed in the data publisher infrastructure. This function requires the executionId and agreementId for getting the logs. Parameters: agreementId Identifier of the service agreement between the consumer and the publisher executionId Identifier of the execution related with the agreement executed account The Public address of account used to execute the computation Example: computeStatus ( \"8974328\" , \"ababacc\" , 0xaabb )","title":"compute status"},{"location":"api/reference/Assets/#non-fungible-tokens-nfts-associated-to-assets","text":"A Decentralized Identifier (DID) that digitally represents some physical stuff, aligns quite well with the concept of a Non-Fungible Token (NFT). The implication is that, if you are an asset owner in Nevermined, you can mint NFTs associated with your DID and distribute them amongst your customers or users.","title":"Non-Fungible Tokens (NFTs) associated to assets"},{"location":"api/reference/Assets/#mint-a-nft-associated-to-an-asset","text":"This function allows to a DID owner to mint NFTs associated to the DID. Parameters: did Identifier of the asset where the NFTs will be minted amount the amount of NFTs to mint associated to the DID Example: mint ( \"did:nv:1234\" , 5 )","title":"Mint a NFT associated to an asset"},{"location":"api/reference/Assets/#burn-nfts-associated-to-an-asset","text":"This function allows to burn existing NFTs associated to a DID. Parameters: did Identifier of the asset where the NFTs will be burned amount the amount of NFTs to burn associated to the DID Example: burn ( \"did:nv:1234\" , 1 )","title":"Burn NFTs associated to an asset"},{"location":"api/reference/Assets/#transfer-nfts-associated-to-an-asset","text":"This function allows to transfer NFTs associated to a DID between accounts. Parameters: did Identifier of the asset where the NFTs will be burned account Public address of the account where the NFTs will be transferred amount the amount of NFTs to burn associated to the DID Example: transfer ( \"did:nv:1234\" , 0xabab , 2 )","title":"Transfer NFTs associated to an asset"},{"location":"api/reference/Assets/#get-nfts-balance-associated-to-an-asset","text":"This function allows to get the NFTs balance of an account for a DID. Parameters: account Public address of the account did Identifier of the asset with NFTs associated Example: balance ( 0xabab , \"did:nv:1234\" )","title":"Get NFTs balance associated to an asset"},{"location":"api/reference/Conditions/","text":"Conditions API Reference \u00b6 As part of the Service Execution Agreements (aka SEAs), Nevermined provide some functions to interact with these conditions. Every execution by an user of a service agreement can be referenced by the agreementId . That is a unique identifier of the agreement execution and it is used across this api reference document. Grant Access \u00b6 Grant access to an address for an specific Search Execution Agreement. Parameters: agreementId the unique identifier of the execution of an agreement did Identifier of the asset associated to the service agreement to grant the access granteeAccount Public address of the account to grant the access Example: grantAccess ( \"8181818\" , \"did:nv:1234\" , 0xaabb ) Grant Service Execution \u00b6 Grant access to an address for an specific Search Execution Agreement. Parameters: agreementId the unique identifier of the execution of an agreement did Identifier of the asset associated to the service agreement to grant the access granteeAccount Public address of the account to grant the computation execution Example: grantServiceExecution ( \"8181818\" , \"did:nv:1234\" , 0xaabb ) Lock Reward \u00b6 Lock the amount of token that are going to be paid for the asset. Parameters: agreementId the unique identifier of the execution of an agreement amount Amount of tokens to lock Example: lockPayment ( \"8181818\" , 10 ) Release Reward \u00b6 Release the payment to the data publisher (access/compute/et) related with a service execution. Parameters: agreementId the unique identifier of the execution of an agreement amount Amount of tokens to release Example: releaseReward ( \"8181818\" , 10 ) Refund Reward \u00b6 Refund the payment to the consumer. Parameters: agreementId the unique identifier of the execution of an agreement amount Amount of tokens to refund Example: refundReward ( \"8181818\" , 10 )","title":"Conditions"},{"location":"api/reference/Conditions/#conditions-api-reference","text":"As part of the Service Execution Agreements (aka SEAs), Nevermined provide some functions to interact with these conditions. Every execution by an user of a service agreement can be referenced by the agreementId . That is a unique identifier of the agreement execution and it is used across this api reference document.","title":"Conditions API Reference"},{"location":"api/reference/Conditions/#grant-access","text":"Grant access to an address for an specific Search Execution Agreement. Parameters: agreementId the unique identifier of the execution of an agreement did Identifier of the asset associated to the service agreement to grant the access granteeAccount Public address of the account to grant the access Example: grantAccess ( \"8181818\" , \"did:nv:1234\" , 0xaabb )","title":"Grant Access"},{"location":"api/reference/Conditions/#grant-service-execution","text":"Grant access to an address for an specific Search Execution Agreement. Parameters: agreementId the unique identifier of the execution of an agreement did Identifier of the asset associated to the service agreement to grant the access granteeAccount Public address of the account to grant the computation execution Example: grantServiceExecution ( \"8181818\" , \"did:nv:1234\" , 0xaabb )","title":"Grant Service Execution"},{"location":"api/reference/Conditions/#lock-reward","text":"Lock the amount of token that are going to be paid for the asset. Parameters: agreementId the unique identifier of the execution of an agreement amount Amount of tokens to lock Example: lockPayment ( \"8181818\" , 10 )","title":"Lock Reward"},{"location":"api/reference/Conditions/#release-reward","text":"Release the payment to the data publisher (access/compute/et) related with a service execution. Parameters: agreementId the unique identifier of the execution of an agreement amount Amount of tokens to release Example: releaseReward ( \"8181818\" , 10 )","title":"Release Reward"},{"location":"api/reference/Conditions/#refund-reward","text":"Refund the payment to the consumer. Parameters: agreementId the unique identifier of the execution of an agreement amount Amount of tokens to refund Example: refundReward ( \"8181818\" , 10 )","title":"Refund Reward"},{"location":"api/reference/Provenance/","text":"Provenance API Reference \u00b6 Nevermined Smart Contracts implement the W3C Provenance specification allowing to register on-chain all the provenance information, digital signatures and fingerprints allowing to make use of an open, transparent and unique source of truth for any data ecosystem where multiple parties need to collaborate in a common goal. The complete Nevermined Provenance architecture can be found in the Provenance Spec . This module allows to register Provenance events associated to assets. Also allows to retrieve all the assets provenance track previously registered. Registering Provenance \u00b6 All the provenance events are registered on-chain via the Provenance contract. All the individual provenance events have to be associated to a Provenance ID . This ID is a unique identifier that can be used later on to retrieve information about a specific event. Registering provenance generation \u00b6 Generation is the completion of production of a new entity by an activity. This entity did not exist before generation and becomes available for usage after this generation. Nevermined encapsulate every entity to be managed using Decentralized Identifiers (DID) that are registered via the DIDRegistry Smart Contract. This contract registers automatically the provenance generation event when an asset is created. So this function is not exposed as part of the API, but is referenced here for clarity. You can find more details of this in the Provenance Specs Registering provenance derivation \u00b6 Derivation is a transformation of an entity into another, an update of an entity resulting in a new one, or the construction of a new entity based on a pre-existing entity. This function allows to register a provenance derivation event when a new asset is created as a result of some other asset. The function parameters are: provenanceId the Provenance ID newEntityDid Identifier of the new asset derived as a result of the activity usedEntityDid Identifier of the asset used for deriving a new asset as a result of the activity agentId Public address of the user/agent associated with the action activityId Identifier of the activity doing the derivation action attributes Optional attributes associated with the action Example: wasDerivedFrom ( \"999\" , \"did:nv:1234\" , \"did:nv:5678\" , 0xa1a1 , \"activity creating asset\" , \"+ information\" ) You can find more details of this function in the Provenance Specs Registering provenance utilization \u00b6 Usage is the beginning of utilizing an entity by an activity. Before usage, the activity had not begun to utilize this entity and could not have been affected by the entity. The function parameters are: provenanceId the Provenance ID did Identifier of the asset associated to the activity agentId Public address of the user/agent associated with the action activityId Identifier of the activity doing the usage action attributes Optional attributes associated with the action Example: used ( \"999\" , \"did:nv:1234\" , 0xa1a1 , \"using activity\" , \"additional information\" ) You can find more details of this function in the Provenance Specs Registering provenance association \u00b6 Association is an assignment of responsibility to an agent for an activity, indicating that the agent had a role in the activity. This function allows to register a provenance association event to an asset. The function parameters are: provenanceId the Provenance ID did Identifier of the asset associated to the activity agentId Public address of the user/agent associated with the action activityId Identifier of the activity doing the association action attributes Optional attributes associated with the action Example: wasAssociatedWith ( \"999\" , \"did:nv:1234\" , \"ac1\" , \"additional information\" ) You can find more details of this function in the Provenance Specs Registering provenance delegation \u00b6 Delegation is the assignment of authority and responsibility to an agent (by itself or by another agent) to carry out a specific activity as a delegate or representative, while the agent it acts on behalf of retains some responsibility for the outcome of the delegated work. The function parameters are: provenanceId the Provenance ID did Identifier of the asset associated to the activity delegateAgentId Public address of the user/agent delegated by the responsibleAgentId responsibleAgentId Public address of the user/agent responsible of the did activityId Identifier of the activity doing the association action signature Signature of the provenanceId provided by the delegatedAgentId . This will work as proof of agreement between the delegate and the responsible about a specific provenance action. attributes Optional attributes associated with the action Example: actedOnBehalf ( \"999\" , \"did:nv:1234\" , 0xa1a1 , 0xb2b2 , \"ac1\" , \"s1gnatureeeee\" , \"additional information\" ) You can find more details of this function in the Provenance Specs Retrieving Provenance information \u00b6 Search Provenance events related to an asset \u00b6 When a new provenance event is recorded on-chain, an event is emitted including some information. This function searches across all the ProvenanceAttributeRegistered events related with a specific DID. Parameters: did Identifier of the asset we are looking to search provenance events Example: getDIDProvenanceEvents ( \"did:nv:1234\" ) Search Provenance events related to an asset \u00b6 When a new provenance event is recorded on-chain, an event is emitted including some information. This function searches for specific provenance events methods ( used , wasGeneratedBy , etc.) given a DID. Parameters: method - Reference to the W3C Provenance method event we are going to search. This parameter is an unsigned int from 0 to 15 . See more here in the Smart Contract implementation . did Identifier of the asset we are looking to search provenance events Example: getProvenanceMethodEvents ( 0 , \"did:nv:1234\" ) Get Provenance Entry \u00b6 Get from the on-chain Provenance registry the information about one provenance event, given a provenance id. Parameters: provenanceId Provenance Identifier Example: getProvenanceEntry ( \"049320943\" ) Get Provenance Owner \u00b6 Get from the on-chain Provenance registry the information about who create the provenance entry given a provenance id. Parameters: provenanceId Provenance Identifier Example: getProvenanceOwner ( \"049320943\" ) Managing Provenance Delegates \u00b6 The provenance delegates are accounts that have the ability to register provenance events associated to an asset/entity (Decentralized Identifier - DID) on behalf of the owner. This is helpful in some situations where a user creates a new asset, and later can delegate to a third party to make some actions on an asset and in extension to register provenance events associated to that. The following functions describe how to manage the delegates regarding to DIDs. Add a provenance delegate to a DID \u00b6 It associates a new user as a delegate to an existing DID. Parameters: did Identifier of the asset where the delegate will be added delegatedAccount Public address of the user associated as delegate to the did Example: addDIDProvenanceDelegate ( \"did:nv:1234\" , 0x1234 ) Remove a provenance delegate from a DID \u00b6 It removes an existing delegate of a DID. Parameters: did Identifier of the asset where the delegate will be removed delegatedAccount Public address of the user to remove as delegate to the did Example: removeDIDProvenanceDelegate ( \"did:nv:1234\" , 0x1234 ) Is an user a provenance delegate? \u00b6 Returns true or false if the user account provided is an existing delegate for an existing DID. Parameters: did Identifier of the asset delegatedAccount Public address of the user Example: isProvenanceDelegate ( \"did:nv:1234\" , 0x1234 )","title":"Provenance"},{"location":"api/reference/Provenance/#provenance-api-reference","text":"Nevermined Smart Contracts implement the W3C Provenance specification allowing to register on-chain all the provenance information, digital signatures and fingerprints allowing to make use of an open, transparent and unique source of truth for any data ecosystem where multiple parties need to collaborate in a common goal. The complete Nevermined Provenance architecture can be found in the Provenance Spec . This module allows to register Provenance events associated to assets. Also allows to retrieve all the assets provenance track previously registered.","title":"Provenance API Reference"},{"location":"api/reference/Provenance/#registering-provenance","text":"All the provenance events are registered on-chain via the Provenance contract. All the individual provenance events have to be associated to a Provenance ID . This ID is a unique identifier that can be used later on to retrieve information about a specific event.","title":"Registering Provenance"},{"location":"api/reference/Provenance/#registering-provenance-generation","text":"Generation is the completion of production of a new entity by an activity. This entity did not exist before generation and becomes available for usage after this generation. Nevermined encapsulate every entity to be managed using Decentralized Identifiers (DID) that are registered via the DIDRegistry Smart Contract. This contract registers automatically the provenance generation event when an asset is created. So this function is not exposed as part of the API, but is referenced here for clarity. You can find more details of this in the Provenance Specs","title":"Registering provenance generation"},{"location":"api/reference/Provenance/#registering-provenance-derivation","text":"Derivation is a transformation of an entity into another, an update of an entity resulting in a new one, or the construction of a new entity based on a pre-existing entity. This function allows to register a provenance derivation event when a new asset is created as a result of some other asset. The function parameters are: provenanceId the Provenance ID newEntityDid Identifier of the new asset derived as a result of the activity usedEntityDid Identifier of the asset used for deriving a new asset as a result of the activity agentId Public address of the user/agent associated with the action activityId Identifier of the activity doing the derivation action attributes Optional attributes associated with the action Example: wasDerivedFrom ( \"999\" , \"did:nv:1234\" , \"did:nv:5678\" , 0xa1a1 , \"activity creating asset\" , \"+ information\" ) You can find more details of this function in the Provenance Specs","title":"Registering provenance derivation"},{"location":"api/reference/Provenance/#registering-provenance-utilization","text":"Usage is the beginning of utilizing an entity by an activity. Before usage, the activity had not begun to utilize this entity and could not have been affected by the entity. The function parameters are: provenanceId the Provenance ID did Identifier of the asset associated to the activity agentId Public address of the user/agent associated with the action activityId Identifier of the activity doing the usage action attributes Optional attributes associated with the action Example: used ( \"999\" , \"did:nv:1234\" , 0xa1a1 , \"using activity\" , \"additional information\" ) You can find more details of this function in the Provenance Specs","title":"Registering provenance utilization"},{"location":"api/reference/Provenance/#registering-provenance-association","text":"Association is an assignment of responsibility to an agent for an activity, indicating that the agent had a role in the activity. This function allows to register a provenance association event to an asset. The function parameters are: provenanceId the Provenance ID did Identifier of the asset associated to the activity agentId Public address of the user/agent associated with the action activityId Identifier of the activity doing the association action attributes Optional attributes associated with the action Example: wasAssociatedWith ( \"999\" , \"did:nv:1234\" , \"ac1\" , \"additional information\" ) You can find more details of this function in the Provenance Specs","title":"Registering provenance association"},{"location":"api/reference/Provenance/#registering-provenance-delegation","text":"Delegation is the assignment of authority and responsibility to an agent (by itself or by another agent) to carry out a specific activity as a delegate or representative, while the agent it acts on behalf of retains some responsibility for the outcome of the delegated work. The function parameters are: provenanceId the Provenance ID did Identifier of the asset associated to the activity delegateAgentId Public address of the user/agent delegated by the responsibleAgentId responsibleAgentId Public address of the user/agent responsible of the did activityId Identifier of the activity doing the association action signature Signature of the provenanceId provided by the delegatedAgentId . This will work as proof of agreement between the delegate and the responsible about a specific provenance action. attributes Optional attributes associated with the action Example: actedOnBehalf ( \"999\" , \"did:nv:1234\" , 0xa1a1 , 0xb2b2 , \"ac1\" , \"s1gnatureeeee\" , \"additional information\" ) You can find more details of this function in the Provenance Specs","title":"Registering provenance delegation"},{"location":"api/reference/Provenance/#retrieving-provenance-information","text":"","title":"Retrieving Provenance information"},{"location":"api/reference/Provenance/#search-provenance-events-related-to-an-asset","text":"When a new provenance event is recorded on-chain, an event is emitted including some information. This function searches across all the ProvenanceAttributeRegistered events related with a specific DID. Parameters: did Identifier of the asset we are looking to search provenance events Example: getDIDProvenanceEvents ( \"did:nv:1234\" )","title":"Search Provenance events related to an asset"},{"location":"api/reference/Provenance/#search-provenance-events-related-to-an-asset_1","text":"When a new provenance event is recorded on-chain, an event is emitted including some information. This function searches for specific provenance events methods ( used , wasGeneratedBy , etc.) given a DID. Parameters: method - Reference to the W3C Provenance method event we are going to search. This parameter is an unsigned int from 0 to 15 . See more here in the Smart Contract implementation . did Identifier of the asset we are looking to search provenance events Example: getProvenanceMethodEvents ( 0 , \"did:nv:1234\" )","title":"Search Provenance events related to an asset"},{"location":"api/reference/Provenance/#get-provenance-entry","text":"Get from the on-chain Provenance registry the information about one provenance event, given a provenance id. Parameters: provenanceId Provenance Identifier Example: getProvenanceEntry ( \"049320943\" )","title":"Get Provenance Entry"},{"location":"api/reference/Provenance/#get-provenance-owner","text":"Get from the on-chain Provenance registry the information about who create the provenance entry given a provenance id. Parameters: provenanceId Provenance Identifier Example: getProvenanceOwner ( \"049320943\" )","title":"Get Provenance Owner"},{"location":"api/reference/Provenance/#managing-provenance-delegates","text":"The provenance delegates are accounts that have the ability to register provenance events associated to an asset/entity (Decentralized Identifier - DID) on behalf of the owner. This is helpful in some situations where a user creates a new asset, and later can delegate to a third party to make some actions on an asset and in extension to register provenance events associated to that. The following functions describe how to manage the delegates regarding to DIDs.","title":"Managing Provenance Delegates"},{"location":"api/reference/Provenance/#add-a-provenance-delegate-to-a-did","text":"It associates a new user as a delegate to an existing DID. Parameters: did Identifier of the asset where the delegate will be added delegatedAccount Public address of the user associated as delegate to the did Example: addDIDProvenanceDelegate ( \"did:nv:1234\" , 0x1234 )","title":"Add a provenance delegate to a DID"},{"location":"api/reference/Provenance/#remove-a-provenance-delegate-from-a-did","text":"It removes an existing delegate of a DID. Parameters: did Identifier of the asset where the delegate will be removed delegatedAccount Public address of the user to remove as delegate to the did Example: removeDIDProvenanceDelegate ( \"did:nv:1234\" , 0x1234 )","title":"Remove a provenance delegate from a DID"},{"location":"api/reference/Provenance/#is-an-user-a-provenance-delegate","text":"Returns true or false if the user account provided is an existing delegate for an existing DID. Parameters: did Identifier of the asset delegatedAccount Public address of the user Example: isProvenanceDelegate ( \"did:nv:1234\" , 0x1234 )","title":"Is an user a provenance delegate?"},{"location":"api/reference/Providers/","text":"Providers API Reference \u00b6 In Nevermined a data publisher can delegate to other users identified with their key material, to interact in their behalf. This is useful for users who don't want to run Nevermined infrastructure and delegate that to other entities. This module allows to manage the providers that can interact with data publisher assets. Add a new provider to an asset \u00b6 Allows to associate a new provider to an existing asset. Parameters: did the id of the document where we are gonna associate the provider providerAddress the public address of the provider account the public address of the account executing this action Example: add ( \"did:nv:1234\" , 0xaabb , 0xccdd ) Remove a provider of an asset \u00b6 Allows to de-associate a provider of an asset. Parameters: did the id of the document where we are gonna de-associate the provider providerAddress the public address of the provider account the public address of the account executing this action Example: remove ( \"did:nv:1234\" , 0xaabb , 0xccdd ) List the providers associated to an asset \u00b6 Returns a list with the public addresses of the providers associated to an asset . Parameters: did the id of the document Example: list ( \"did:nv:1234\" )","title":"Providers"},{"location":"api/reference/Providers/#providers-api-reference","text":"In Nevermined a data publisher can delegate to other users identified with their key material, to interact in their behalf. This is useful for users who don't want to run Nevermined infrastructure and delegate that to other entities. This module allows to manage the providers that can interact with data publisher assets.","title":"Providers API Reference"},{"location":"api/reference/Providers/#add-a-new-provider-to-an-asset","text":"Allows to associate a new provider to an existing asset. Parameters: did the id of the document where we are gonna associate the provider providerAddress the public address of the provider account the public address of the account executing this action Example: add ( \"did:nv:1234\" , 0xaabb , 0xccdd )","title":"Add a new provider to an asset"},{"location":"api/reference/Providers/#remove-a-provider-of-an-asset","text":"Allows to de-associate a provider of an asset. Parameters: did the id of the document where we are gonna de-associate the provider providerAddress the public address of the provider account the public address of the account executing this action Example: remove ( \"did:nv:1234\" , 0xaabb , 0xccdd )","title":"Remove a provider of an asset"},{"location":"api/reference/Providers/#list-the-providers-associated-to-an-asset","text":"Returns a list with the public addresses of the providers associated to an asset . Parameters: did the id of the document Example: list ( \"did:nv:1234\" )","title":"List the providers associated to an asset"},{"location":"api/reference/Secret-Store/","text":"Secret Store API Reference \u00b6 Nevermined integrates the Parity Secret Store to support use cases with high security requirements for the secret management. These secrets are being used for the encryption and distributed decryption of the access information to user assets. This module allows the multiparty encryption and decryption of secrets via Secret Store integration. The main functions are: Encrypt \u00b6 Encrypts a document using Secret Store. Parameters: documentId the id of the document to encrypt, typically a DID content the content to encrypt. It can be any kind of string content threshold the minimum number of Secret Store nodes that should build a quorum for decrypting a secret Example: String encryptedContent = encrypt ( \"did:nv:1234\" , \"my secret\" , 3 ) Decrypt \u00b6 Decrypts a document using Secret Store. Parameters: documentId the id of the document to encrypt, typically a DID encryptedContent the content to decrypt. Example: String decryptedContent = decrypt ( \"did:nv:1234\" , \"0358920a932854984293\" )","title":"Secret Store"},{"location":"api/reference/Secret-Store/#secret-store-api-reference","text":"Nevermined integrates the Parity Secret Store to support use cases with high security requirements for the secret management. These secrets are being used for the encryption and distributed decryption of the access information to user assets. This module allows the multiparty encryption and decryption of secrets via Secret Store integration. The main functions are:","title":"Secret Store API Reference"},{"location":"api/reference/Secret-Store/#encrypt","text":"Encrypts a document using Secret Store. Parameters: documentId the id of the document to encrypt, typically a DID content the content to encrypt. It can be any kind of string content threshold the minimum number of Secret Store nodes that should build a quorum for decrypting a secret Example: String encryptedContent = encrypt ( \"did:nv:1234\" , \"my secret\" , 3 )","title":"Encrypt"},{"location":"api/reference/Secret-Store/#decrypt","text":"Decrypts a document using Secret Store. Parameters: documentId the id of the document to encrypt, typically a DID encryptedContent the content to decrypt. Example: String decryptedContent = decrypt ( \"did:nv:1234\" , \"0358920a932854984293\" )","title":"Decrypt"},{"location":"api/reference/Tokens/","text":"Tokens API Reference \u00b6 Nevermined is a solution that uses a blockchain network to execute part of it's business logic using Smart Contracts. Nevermined uses a Ethereum (EVM) based blockchain network. So for executing transactions in existing networks is necessary to pay of that execution. In each network, you\u2019ll need ETH to pay for gas, and Nevermined token for purchasing Nevermined assets ( access and compute ). Nevermined can be deployed in any EVM based network (permissioned or not). In each of these networks ETH and Nevermined tokens can have a real value. The Tokens API Reference describe the functionalities for Nevermined token requests and token transfers. Request Nevermined Tokens \u00b6 Allows to request Nevermined tokens to the Dispenser. This functionality only will work in test networks where the Nevermined token doesn't have a real value. In other production networks it will be necessary to contact the governance entity running Nevermined. Parameters: account the public address of the account receiving the Nevermined tokens amount the amount of Nevermined tokens to receive Example: request ( 0xaabb , 5 ) Transfer Nevermined Tokens \u00b6 Allows to transfer Nevermined tokens between accounts. Parameters: receiver_account the public address of the account receiving the Nevermined tokens amount the amount of Nevermined tokens to transfer sender_account the public address of the account transferring the Nevermined tokens Example: transfer ( 0xaabb , 3 , 0xccdd )","title":"Tokens"},{"location":"api/reference/Tokens/#tokens-api-reference","text":"Nevermined is a solution that uses a blockchain network to execute part of it's business logic using Smart Contracts. Nevermined uses a Ethereum (EVM) based blockchain network. So for executing transactions in existing networks is necessary to pay of that execution. In each network, you\u2019ll need ETH to pay for gas, and Nevermined token for purchasing Nevermined assets ( access and compute ). Nevermined can be deployed in any EVM based network (permissioned or not). In each of these networks ETH and Nevermined tokens can have a real value. The Tokens API Reference describe the functionalities for Nevermined token requests and token transfers.","title":"Tokens API Reference"},{"location":"api/reference/Tokens/#request-nevermined-tokens","text":"Allows to request Nevermined tokens to the Dispenser. This functionality only will work in test networks where the Nevermined token doesn't have a real value. In other production networks it will be necessary to contact the governance entity running Nevermined. Parameters: account the public address of the account receiving the Nevermined tokens amount the amount of Nevermined tokens to receive Example: request ( 0xaabb , 5 )","title":"Request Nevermined Tokens"},{"location":"api/reference/Tokens/#transfer-nevermined-tokens","text":"Allows to transfer Nevermined tokens between accounts. Parameters: receiver_account the public address of the account receiving the Nevermined tokens amount the amount of Nevermined tokens to transfer sender_account the public address of the account transferring the Nevermined tokens Example: transfer ( 0xaabb , 3 , 0xccdd )","title":"Transfer Nevermined Tokens"},{"location":"api/reference/api-reference-latest/","text":"Nevermined API Reference \u00b6 shortname: nevermined-api-spec version: 1.0 status: Draft date: December 2020 The goal of this doc is to help a developer build a version of the Nevermined API in any programming language. Currently, the Nevermined API is defined for Object-Oriented languages such as JavaScript, Java, and Python (which are the three initial implementation languages). Modules \u00b6 The SDKs are organized using the following modules: Assets - Managing of data assets on Nevermined networks Accounts - Managing accounts Agreements - Interacting with Service Exection Agreements Conditions - Interacting with agreement conditions Provenance - Tracking & retrieving data provenance Tokens - Request and transfer Nevermined tokens Providers - Manage of asset providers Secret Store - Encryption and Decryption secrets","title":"API Overview"},{"location":"api/reference/api-reference-latest/#nevermined-api-reference","text":"shortname: nevermined-api-spec version: 1.0 status: Draft date: December 2020 The goal of this doc is to help a developer build a version of the Nevermined API in any programming language. Currently, the Nevermined API is defined for Object-Oriented languages such as JavaScript, Java, and Python (which are the three initial implementation languages).","title":"Nevermined API Reference"},{"location":"api/reference/api-reference-latest/#modules","text":"The SDKs are organized using the following modules: Assets - Managing of data assets on Nevermined networks Accounts - Managing accounts Agreements - Interacting with Service Exection Agreements Conditions - Interacting with agreement conditions Provenance - Tracking & retrieving data provenance Tokens - Request and transfer Nevermined tokens Providers - Manage of asset providers Secret Store - Encryption and Decryption secrets","title":"Modules"},{"location":"architecture/","text":"Nevermined Architecture \u00b6 Nevermined Architecture Introduction Data Ecosystem Principles Use Cases Capabilities Data Sharing Data In Situ Computation Compute backends Kubernetes backend Federated Learning backend Data Marketplace and Cataloging Architecture Technical components Nevermined Specifications (Specs) Introduction \u00b6 Nevermined is a data ecosystem solution that provides the capabilities of building bespoke networks where different entities can share and monetize their data and make an efficient and secure usage of it even with untrusted parties. With the explosion of the data and AI market, entities have the necessity of organizing, understanding, using and sharing their data internally and externally. Nevermined provides Data Sharing & Data In Situ Computation solutions allowing to unlock data for AI. Nevermined enables a \u201cData In Situ Computation\u201d solution, meaning the data never moves, is the algorithm the one moving where the data is. It allows data owners or providers to define the conditions in which they allow others to make use of their data without giving direct access to it. Nevermined is designed to be integrated in Big Data environments. It enables monetizing the data without migration. It\u2019s also designed for GDPR compliance, it never stores any personal information on-chain (encrypted or in plain text). Nevermined is the product powered by Keyko providing Data Sharing & Data In Situ Computation solutions allowing to unlock data for AI. Data Ecosystem Principles \u00b6 During the design and construction of Nevermined, we identified 6 key factors for the adoption and usage of a data ecosystem and its continued growth: Culture - Culture & Organization help to establish how each ecosystem actor interact with others. We promote it giving a user centric approach User Experience (UX) - The ecosystems should provide an excellent User eXperience, facilitating the participation of all the partners and users Trust - Data ecosystems must promote trustful environments where untrusted parties can collaborate Integrity - Data integrity and provenance as first class citizens where the ecosystem users can validate that data doesn't change and from where is coming Compliance - Data first approach compliance with all the data regulatory requirements Incentives - We promote the usage and retention of data ecosystems via gamification and providing additional value Use Cases \u00b6 Nevermined is a platform agnostic solution enabling data use cases where different parties don't trust each other. It allows to provide data ecosystems where DATA OWNERS need to share and monetize their data with third-party people, but they want to keep the privacy and the control of their data. Typical use cases for sector are: Banking - Data Sharing with the regulator or internal across different jurisdictions Telco - Anonymized Data Sharing with the regulator and partners. AI within moving the data Health & Pharma - AI over medical results of different hospitals without revealing PI Supply Chain - Provenance, integrity and tracking of goods Automotive - Data Sharing for AI to promote the autonomous cars Others - Real estate, digital assets tokenization, .. Capabilities \u00b6 Nevermined is based in three core building blocks: Data Sharing \u00b6 It enables the data sharing capabilities between unstructured parties. The main users involved in this scenario are: Organizations with data that need to share and monetize ( Data Owners ). Organizations or individuals looking for data sets to train their models ( Data Consumers ). Typically Data Owners & Consumers don't know or trust each other. Nevermined provides a generic solution where both can share data in a decentralized and secure way. The main benefits for them are: Data Owners can get some benefit of their existing data Data Consumers can get access to datasets they couldn't get access in other conditions Nevermined Data Sharing flow In this use case the CONSUMERS can get access to the datasets, so it's ideal for problems with low data privacy constraints. The main capabilities are: Allowing data monetization. Data owners can make available their data and get some rewards/benefits when others get access to it. Allows an easy data publishing or data access from the users. Provides a Decentralized Access Control where untrusted members can feel confident that other members of the system will play honestly Supports free or paid access scenarios All the interactions related with the assets or services (when are created in the system, who has access, when the access was granted, etc.) is tracked The decentralized access control can be used in public or private blockchain networks You can find more details about the technical implementation of the Data Sharing use case in the ACCESS SPEC . Data In Situ Computation (DISC) \u00b6 It facilitates the use cases where data owners allow third parties to execute some algorithms where the data is. For the use cases with more privacy restrictions in which the Data Owner never wants to lose control of their data, and this source data can't be accessed directly, Nevermined provides a Data In Situ Computation solution. This scenario is based on the premise that data doesn't want to be moved. Moving data of their existing premises is a liability. The data can be leaked in transit and because the private nature of the data, moving it implies some regulatory issues. In that case, Nevermined provides a solution where the Data Owner allows the execution of an algorithm (tensorflow, spark, etc.) in the infrastructure where the data is. It means the Data Consumer provides the algorithm to execute, and this is moved to the Data Owner infrastructure where the data is being kept. The Data Consumer receives the result of the execution of the algorithm on top of the data. Data In Situ Computation You can find more details about the technical implementation of the Data In Situ Computation use case in the COMPUTE SPEC . The main capabilities of the Data In Situ Computation building block are: Solution designed to support different computation or backend paradigms Implemented 2 different backends, one of them orchestrating Kubernetes containers in the Data Provider environment. Other via the integration of a Federated Learning framework Framework or programming language independent The data never moves, algorithm goes where data is Consumer never get access to the real data The algorithm is moved where the data is. An ephemeral environment is created to support the computation It supports the orchestration of computing pipelines All the access control and execution is controlled via the integration with the service agreements Can be run in cloud providers or on-premise Permits the monitoring of the workflows execution Compute backends \u00b6 Nevermined supports to plug different compute backends that could be more convenient depending on the use cases. The rest of the ecosystem keeps the same (services, api\u2019s, applications on top, etc.), but depending on how the use case is, Nevermined will orchestrate the compute jobs in different ways. At this point in time Nevermined integrates 2 different compute backends: Kubernetes backend \u00b6 This backend is perfect for compute jobs that can be executed in the data provider data center and don\u2019t have high privacy constraints. In this scenario the Client can implement the algorithm using different languages or frameworks, and the Nevermined Compute solution will be in charge of orchestrating the infrastructure for moving the algorithm where the data is. Kubernetes orchestration As you can see in the above diagram, the Compute API will be in charge of triggering the compute workflow interacting with the Kubernetes infrastructure via Argo . This includes: Download the algorithm provided by the Data Scientist/Engineer Starts the right Docker container in the infrastructure Mount as volume with the data Execute the algorithm passing as parameter the path where the data is mounted Stop the Compute pod where the algorithm is running Publishing the result as a new asset Destroy all the ephemeral environment Federated Learning backend \u00b6 This backend fits for the execution of federated learning jobs using the data of providers having federated environments. In this scenario the Client can implement the data training model using a generic federated learning framework, and the Nevermined Compute solution will be in charge of orchestrating the execution across all the participants. In this scenario the Compute backend starts two independent tasks, the coordinator and the aggregator. The coordinator will do all the management of the participants as part of a federated job. The aggregator will do the secure aggregation of the trained models. Both the coordinator and aggregator are ephemeral nodes created by demand, so after the job is executed they will be stopped till a new execution request is triggered. Federated Learning backend Data Marketplace and Cataloging \u00b6 It facilitates the search, discovery and management of the existing assets in the data ecosystem. The main capabilities are: Improved User Experience Integration with the Data Governance and Data Catalog tools Easy search and discovery Native integration with the data sharing and data in situ computation building blocks Internal data catalog and APIs Tokenization and incentives Architecture \u00b6 Technical components \u00b6 The complete description of the architecture components & licenses can be found here . A brief summary of some of them: SMART CONTRACTS - Solidity Smart Contracts providing the Service Agreements business logic. GATEWAY - Microservice to be executed by PUBLISHERS. It exposes an HTTP REST API permitting access to PUBLISHER assets or additional services such as computation. METADATA-API - Microservice to be executed by MARKETPLACES. Facilitates creating, updating, deleting and searching the asset metadata registered by the PUBLISHERS. This metadata is included as part of a DDO (see DID SPEC and METADATA SPEC ) and also includes the services associated with the asset (consumption, computation, etc.). SDK - Software library encapsulating the Nevermined business logic. It's used to interact with all the components & APIs of the system. It's currently implemented in the following packages: nevermined-sdk-js - JavaScript version of the Nevermined SDK to be integrated with front-end applications. nevermined-sdk-py - Python version of the Nevermined SDK to be integrated with back-end applications. The primary users are data scientists. nevermined-sdk-java - Java version of the Nevermined SDK to be integrated with JVM applications. The primary users are data engineers. MARKETPLACE - Exposes a web interface allowing users to publish and purchase assets. It also facilitates the discovery of assets. Nevermined Specifications (Specs) \u00b6 The core of the platform is documented in detail in Specification documents (aka SPECs). Here you can find a list of the most relevant SPECs: Short Name Title Version Status Editor DID Decentralized Identifiers 0.1 Raw @aaitor META Metadata 0.1 Raw @aaitor ACCESS Decentralized Access Control 0.1 Raw @aaitor COMPUTE Data In Situ Computation 0.1 Raw @aaitor KEYTRANSFER Data transfer proofs 0.1 Raw @mrsmkl FL Federated Learning Orchestration 0.1 Raw @rodolphe PROV Decentralized Data Provenance 0.1 Raw @aaitor IDM Identity management with on-chain access control 0.1 Raw @aaitor The DID, META, ACCESS & COMPUTE specs are an evolution of Ocean Protocol Enhancement Proposals - OEPs .","title":"Overview"},{"location":"architecture/#nevermined-architecture","text":"Nevermined Architecture Introduction Data Ecosystem Principles Use Cases Capabilities Data Sharing Data In Situ Computation Compute backends Kubernetes backend Federated Learning backend Data Marketplace and Cataloging Architecture Technical components Nevermined Specifications (Specs)","title":"Nevermined Architecture"},{"location":"architecture/#introduction","text":"Nevermined is a data ecosystem solution that provides the capabilities of building bespoke networks where different entities can share and monetize their data and make an efficient and secure usage of it even with untrusted parties. With the explosion of the data and AI market, entities have the necessity of organizing, understanding, using and sharing their data internally and externally. Nevermined provides Data Sharing & Data In Situ Computation solutions allowing to unlock data for AI. Nevermined enables a \u201cData In Situ Computation\u201d solution, meaning the data never moves, is the algorithm the one moving where the data is. It allows data owners or providers to define the conditions in which they allow others to make use of their data without giving direct access to it. Nevermined is designed to be integrated in Big Data environments. It enables monetizing the data without migration. It\u2019s also designed for GDPR compliance, it never stores any personal information on-chain (encrypted or in plain text). Nevermined is the product powered by Keyko providing Data Sharing & Data In Situ Computation solutions allowing to unlock data for AI.","title":"Introduction"},{"location":"architecture/#data-ecosystem-principles","text":"During the design and construction of Nevermined, we identified 6 key factors for the adoption and usage of a data ecosystem and its continued growth: Culture - Culture & Organization help to establish how each ecosystem actor interact with others. We promote it giving a user centric approach User Experience (UX) - The ecosystems should provide an excellent User eXperience, facilitating the participation of all the partners and users Trust - Data ecosystems must promote trustful environments where untrusted parties can collaborate Integrity - Data integrity and provenance as first class citizens where the ecosystem users can validate that data doesn't change and from where is coming Compliance - Data first approach compliance with all the data regulatory requirements Incentives - We promote the usage and retention of data ecosystems via gamification and providing additional value","title":"Data Ecosystem Principles"},{"location":"architecture/#use-cases","text":"Nevermined is a platform agnostic solution enabling data use cases where different parties don't trust each other. It allows to provide data ecosystems where DATA OWNERS need to share and monetize their data with third-party people, but they want to keep the privacy and the control of their data. Typical use cases for sector are: Banking - Data Sharing with the regulator or internal across different jurisdictions Telco - Anonymized Data Sharing with the regulator and partners. AI within moving the data Health & Pharma - AI over medical results of different hospitals without revealing PI Supply Chain - Provenance, integrity and tracking of goods Automotive - Data Sharing for AI to promote the autonomous cars Others - Real estate, digital assets tokenization, ..","title":"Use Cases"},{"location":"architecture/#capabilities","text":"Nevermined is based in three core building blocks:","title":"Capabilities"},{"location":"architecture/#data-sharing","text":"It enables the data sharing capabilities between unstructured parties. The main users involved in this scenario are: Organizations with data that need to share and monetize ( Data Owners ). Organizations or individuals looking for data sets to train their models ( Data Consumers ). Typically Data Owners & Consumers don't know or trust each other. Nevermined provides a generic solution where both can share data in a decentralized and secure way. The main benefits for them are: Data Owners can get some benefit of their existing data Data Consumers can get access to datasets they couldn't get access in other conditions Nevermined Data Sharing flow In this use case the CONSUMERS can get access to the datasets, so it's ideal for problems with low data privacy constraints. The main capabilities are: Allowing data monetization. Data owners can make available their data and get some rewards/benefits when others get access to it. Allows an easy data publishing or data access from the users. Provides a Decentralized Access Control where untrusted members can feel confident that other members of the system will play honestly Supports free or paid access scenarios All the interactions related with the assets or services (when are created in the system, who has access, when the access was granted, etc.) is tracked The decentralized access control can be used in public or private blockchain networks You can find more details about the technical implementation of the Data Sharing use case in the ACCESS SPEC .","title":"Data Sharing"},{"location":"architecture/#data-in-situ-computation-disc","text":"It facilitates the use cases where data owners allow third parties to execute some algorithms where the data is. For the use cases with more privacy restrictions in which the Data Owner never wants to lose control of their data, and this source data can't be accessed directly, Nevermined provides a Data In Situ Computation solution. This scenario is based on the premise that data doesn't want to be moved. Moving data of their existing premises is a liability. The data can be leaked in transit and because the private nature of the data, moving it implies some regulatory issues. In that case, Nevermined provides a solution where the Data Owner allows the execution of an algorithm (tensorflow, spark, etc.) in the infrastructure where the data is. It means the Data Consumer provides the algorithm to execute, and this is moved to the Data Owner infrastructure where the data is being kept. The Data Consumer receives the result of the execution of the algorithm on top of the data. Data In Situ Computation You can find more details about the technical implementation of the Data In Situ Computation use case in the COMPUTE SPEC . The main capabilities of the Data In Situ Computation building block are: Solution designed to support different computation or backend paradigms Implemented 2 different backends, one of them orchestrating Kubernetes containers in the Data Provider environment. Other via the integration of a Federated Learning framework Framework or programming language independent The data never moves, algorithm goes where data is Consumer never get access to the real data The algorithm is moved where the data is. An ephemeral environment is created to support the computation It supports the orchestration of computing pipelines All the access control and execution is controlled via the integration with the service agreements Can be run in cloud providers or on-premise Permits the monitoring of the workflows execution","title":"Data In Situ Computation (DISC)"},{"location":"architecture/#compute-backends","text":"Nevermined supports to plug different compute backends that could be more convenient depending on the use cases. The rest of the ecosystem keeps the same (services, api\u2019s, applications on top, etc.), but depending on how the use case is, Nevermined will orchestrate the compute jobs in different ways. At this point in time Nevermined integrates 2 different compute backends:","title":"Compute backends"},{"location":"architecture/#kubernetes-backend","text":"This backend is perfect for compute jobs that can be executed in the data provider data center and don\u2019t have high privacy constraints. In this scenario the Client can implement the algorithm using different languages or frameworks, and the Nevermined Compute solution will be in charge of orchestrating the infrastructure for moving the algorithm where the data is. Kubernetes orchestration As you can see in the above diagram, the Compute API will be in charge of triggering the compute workflow interacting with the Kubernetes infrastructure via Argo . This includes: Download the algorithm provided by the Data Scientist/Engineer Starts the right Docker container in the infrastructure Mount as volume with the data Execute the algorithm passing as parameter the path where the data is mounted Stop the Compute pod where the algorithm is running Publishing the result as a new asset Destroy all the ephemeral environment","title":"Kubernetes backend"},{"location":"architecture/#federated-learning-backend","text":"This backend fits for the execution of federated learning jobs using the data of providers having federated environments. In this scenario the Client can implement the data training model using a generic federated learning framework, and the Nevermined Compute solution will be in charge of orchestrating the execution across all the participants. In this scenario the Compute backend starts two independent tasks, the coordinator and the aggregator. The coordinator will do all the management of the participants as part of a federated job. The aggregator will do the secure aggregation of the trained models. Both the coordinator and aggregator are ephemeral nodes created by demand, so after the job is executed they will be stopped till a new execution request is triggered. Federated Learning backend","title":"Federated Learning backend"},{"location":"architecture/#data-marketplace-and-cataloging","text":"It facilitates the search, discovery and management of the existing assets in the data ecosystem. The main capabilities are: Improved User Experience Integration with the Data Governance and Data Catalog tools Easy search and discovery Native integration with the data sharing and data in situ computation building blocks Internal data catalog and APIs Tokenization and incentives","title":"Data Marketplace and Cataloging"},{"location":"architecture/#architecture","text":"","title":"Architecture"},{"location":"architecture/#technical-components","text":"The complete description of the architecture components & licenses can be found here . A brief summary of some of them: SMART CONTRACTS - Solidity Smart Contracts providing the Service Agreements business logic. GATEWAY - Microservice to be executed by PUBLISHERS. It exposes an HTTP REST API permitting access to PUBLISHER assets or additional services such as computation. METADATA-API - Microservice to be executed by MARKETPLACES. Facilitates creating, updating, deleting and searching the asset metadata registered by the PUBLISHERS. This metadata is included as part of a DDO (see DID SPEC and METADATA SPEC ) and also includes the services associated with the asset (consumption, computation, etc.). SDK - Software library encapsulating the Nevermined business logic. It's used to interact with all the components & APIs of the system. It's currently implemented in the following packages: nevermined-sdk-js - JavaScript version of the Nevermined SDK to be integrated with front-end applications. nevermined-sdk-py - Python version of the Nevermined SDK to be integrated with back-end applications. The primary users are data scientists. nevermined-sdk-java - Java version of the Nevermined SDK to be integrated with JVM applications. The primary users are data engineers. MARKETPLACE - Exposes a web interface allowing users to publish and purchase assets. It also facilitates the discovery of assets.","title":"Technical components"},{"location":"architecture/#nevermined-specifications-specs","text":"The core of the platform is documented in detail in Specification documents (aka SPECs). Here you can find a list of the most relevant SPECs: Short Name Title Version Status Editor DID Decentralized Identifiers 0.1 Raw @aaitor META Metadata 0.1 Raw @aaitor ACCESS Decentralized Access Control 0.1 Raw @aaitor COMPUTE Data In Situ Computation 0.1 Raw @aaitor KEYTRANSFER Data transfer proofs 0.1 Raw @mrsmkl FL Federated Learning Orchestration 0.1 Raw @rodolphe PROV Decentralized Data Provenance 0.1 Raw @aaitor IDM Identity management with on-chain access control 0.1 Raw @aaitor The DID, META, ACCESS & COMPUTE specs are an evolution of Ocean Protocol Enhancement Proposals - OEPs .","title":"Nevermined Specifications (Specs)"},{"location":"architecture/components/","text":"Nevermined Components \u00b6 Nevermined is a data ecosystems where different entities can share and monetize their data and make an efficient and secure usage of it even with untrusted parties. Nevermined packages, automate and augment multiple independent open and private software components providing a fully functional data ecosystem adapted to the requirements of the enterprises. The complete technical solution includes the following components: Architecture of Components \u00b6 Nevermined components Smart Contracts \u00b6 Nevermined Smart Contracts provide the core of the Data Ecosystem. Using an Ethereum network and implemented in Solidity, the Smart Contracts provide the following functionality: ERC20 Token - Utility token used within the platform allowing to build all the payment mechanisms used across the system. DID Registry - Nevermined uses W3C Decentralized Identifiers (DID) to identify and register assets in the platform. The DID Registry allows the registering and resolving capabilities of assets across multiple Metadata providers. Service Execution Agreements (SEAs) - The core engine of the platform. They allow to define on-chain condition pipelines enabling to the users to define complex use cases. The SEAs orchestrate the execution of the Data Access and Data Computation use cases of Nevermined. Conditions - Small modules that can be plugged into the SEAs allowing to add validations logic Contract Templates - Pre-defined contract templates implementing some basic use cases Dispenser - Contract that allows to dispense token under request Libraries - Utility libraries used across the contracts All the previous contracts are Open Source software and provide the core of the Nevermined network. In addition to those, Nevermined provides some extensions of the contracts with extended functionalities: Group and individual whitelisting conditions - Enterprise users typically manage their corporate identity using Active Directory solutions or similar. In those platforms exist the mapping between the user identity and the groups where those users are part of. The advanced whitelisting conditions allow to map complex identity systems with the Smart Contracts logic allowing to provide access control mechanisms on-chain. Interface for external Tokens - It allows to plug in the system an external ERC20 Token avoiding to use the Nevermined ERC20 token. Additional SEAs Templates - The additional Service Execution Templates provide a richer set of use cases to be used in the platform. Improved SEA - Allowing to have faster agreements and simpler negotiations Smart Contracts Governance \u00b6 The control of the Smart Contracts (deployment, upgrade) is typically a responsibility of the Governance committee of the Data Ecosystem. The team responsible for the definition, deployment and maintenance of the whole system. A typical user of the ecosystem doesn\u2019t need to know anything about the underlying Smart Contracts or Blockchain. All the business logic is encapsulated in the client libraries so typically there is no direct integration between the users and the Smart Contracts. Metadata API \u00b6 The Nevermined Metadata API is an Open Source micro-service that allows to store Assets metadata in an off-chain repository. It provides a plugins system allowing to persist the Metadata in ElasticSearch or MongoDB. The Metadata API exposes the functionality for searching metadata using multiple filters and parameters. The Metadata API is typically the backend used for Data Marketplaces or Data Catalogs for storing all the Metadata of a specific domain related to a Marketplace or Catalog . Nevermined provides the package and automation of the micro-service allowing an easy integration and deployment in cloud providers and Kubernetes clusters. Gateway \u00b6 The Nevermined Gateway is an Open Source micro-service in the Nevermined ecosystem. The Gateway is the technical component executed by Data/Compute Providers allowing them to provide extended data services (e.g. storage and compute). The Nevermined Gateway, as part of the Publisher ecosystem, includes the credentials to interact with the infrastructure (initially cloud, but could be on-premise). The Gateway allows also the encryption and decryption of components using the following mechanisms: RSA ECDSA Parity Secret Store Nevermined provides the package and automation of the micro-service allowing an easy integration and deployment in cloud providers and Kubernetes clusters. Compute API \u00b6 The Nevermined Compute API is an Open Source micro-service in the Nevermined ecosystem. It\u2019s a component in charge of orchestrating the execution of compute jobs in the premises of the Data/Compute Providers. In Nevermined the Data/Compute Providers can publish services saying they offer compute capabilities to the network on top of their data under some conditions for a given price. The Compute API is in charge of, after all the verifications made by the Gateway, to manage all the infrastructure to move the algorithm where the data is and track the execution of these ephemeral environments. The Compute API is a generic service exposing a REST API that can plugs different compute backends. At this point in time the Compute API integrates 2 different backends: Kubernetes backend - It allows the orchestration of Kubernetes clusters for setting up compute workflows in cloud or on-premise environments. Federated Learning backend - It manages the execution of FL jobs in different federated environments. It starts the coordinator and an aggregator tasks doing the management of the participants as part of a federated job and the secure aggregation of the trained models. Nevermined provides the package and automation of the micro-service allowing an easy integration and deployment in cloud providers and Kubernetes clusters. Software Development Kits (SDK's) \u00b6 SDK's are the software libraries encapsulating the Nevermined business logic. They are used to interact with all the components & APIs of the system. Nevermined provides 3 different Open Source implementation of SDK's allowing the integration and implementation of complex use cases on top of the Nevermined Data Ecosystems. Nevermined SDK JS - JavaScript version of the Nevermined SDK to be integrated with front-end applications. Nevermined SDK PY - Python version of the Nevermined SDK to be integrated with back-end applications. The primary users are data scientists. Nevermined SDK JAVA - Java version of the Nevermined SDK to be integrated with JVM applications. The primary users are data engineers. The libraries are packaged and delivered in the typical formats for each language allowing easy integration: NPM Nevermined SDK JS NPM Nevermined SDK PY NPM Nevermined SDK JAVA Secret Store \u00b6 Nevermined integrates the Parity Secret Store to support use cases with high security requirements for the secret management. These secrets are being used for the encryption and distributed decryption of the access information to user assets. Parity Secret Store is a feature included as part of the Parity Ethereum client that allows users to store a fragmented ECDSA key on the blockchain, such that retrievals are controlled by a permissioned Smart Contract. The Secret Store implements a threshold retrieval system, so individual Secret Store nodes are unable to reconstruct the keys to decrypt documents by themselves. A Secret Store node only saves a portion of the ECDSA key. The decryption key can only be generated if a consensus is reached by an amount of Secret Store nodes bigger than the threshold that the publisher of the secret chooses. The Secret Store is integrated into Nevermined as an optional component for supporting the encryption and decryption. Command Line Interface (CLI) tool \u00b6 The Nevermined CLI tool enables to connect to the Nevermined Data Ecosystem and interact with it using the command line interface. It orchestrates all the underlaying components allowing to: Publish assets Get access to assets Search and discovery Running remote compute jobs Checking the state of Service Agreements Operational \u00b6 Are the Nevermined tools (not Open Source) allowing to automate, integrate and operate the rest of the components of the stack. The main tools available are: Contract Tools \u00b6 Nevermined Contract Tools . The Nevermined Zeppelin OS contract management framework. Deploying and upgrading Smart Contracts in multiple environments is not an easy thing. The Nevermined Contract Tools allow to deploy and upgrade smart contracts across multiple networks (production or testnet, public or private) mitigating the risk loose the control of the Smart Contracts or leave them in a non-functional way. Development and Integration \u00b6 The Nevermined Tools allows to execute all the components included in the stack in a local environment. Nevermined Tools make use of all the containers of the components and orchestrate the execution of them having a fully functional solution using the same software that you can find in a production environment. This approach allows to: Develop and integrate functionalities with a lower risk of issues when you move to a staging or production environment Automate the integration tests in the CI environments having fully functional networks used for testing Connect to remote blockchain networks from your local environment Multisig Wallet \u00b6 Nevermined Multisig Wallet helps during the token governance process. The purpose of multisig wallets is to increase security by requiring multiple parties to agree on transactions before execution. Transactions can be executed only when confirmed by a predefined number of owners. Monitoring \u00b6 The Nevermined Monitoring component is an integration of the Keyko Web3 Monitoring component adapted to the Nevermined use cases. It allows to monitor: The execution of the Service Agreements Assets registered Token Payments Compute use cases Blocks, Events and Transactions of the network The monitoring tool exposes the dashboards for an easy understanding of what's going on in the network.","title":"Components"},{"location":"architecture/components/#nevermined-components","text":"Nevermined is a data ecosystems where different entities can share and monetize their data and make an efficient and secure usage of it even with untrusted parties. Nevermined packages, automate and augment multiple independent open and private software components providing a fully functional data ecosystem adapted to the requirements of the enterprises. The complete technical solution includes the following components:","title":"Nevermined Components"},{"location":"architecture/components/#architecture-of-components","text":"Nevermined components","title":"Architecture of Components"},{"location":"architecture/components/#smart-contracts","text":"Nevermined Smart Contracts provide the core of the Data Ecosystem. Using an Ethereum network and implemented in Solidity, the Smart Contracts provide the following functionality: ERC20 Token - Utility token used within the platform allowing to build all the payment mechanisms used across the system. DID Registry - Nevermined uses W3C Decentralized Identifiers (DID) to identify and register assets in the platform. The DID Registry allows the registering and resolving capabilities of assets across multiple Metadata providers. Service Execution Agreements (SEAs) - The core engine of the platform. They allow to define on-chain condition pipelines enabling to the users to define complex use cases. The SEAs orchestrate the execution of the Data Access and Data Computation use cases of Nevermined. Conditions - Small modules that can be plugged into the SEAs allowing to add validations logic Contract Templates - Pre-defined contract templates implementing some basic use cases Dispenser - Contract that allows to dispense token under request Libraries - Utility libraries used across the contracts All the previous contracts are Open Source software and provide the core of the Nevermined network. In addition to those, Nevermined provides some extensions of the contracts with extended functionalities: Group and individual whitelisting conditions - Enterprise users typically manage their corporate identity using Active Directory solutions or similar. In those platforms exist the mapping between the user identity and the groups where those users are part of. The advanced whitelisting conditions allow to map complex identity systems with the Smart Contracts logic allowing to provide access control mechanisms on-chain. Interface for external Tokens - It allows to plug in the system an external ERC20 Token avoiding to use the Nevermined ERC20 token. Additional SEAs Templates - The additional Service Execution Templates provide a richer set of use cases to be used in the platform. Improved SEA - Allowing to have faster agreements and simpler negotiations","title":"Smart Contracts"},{"location":"architecture/components/#smart-contracts-governance","text":"The control of the Smart Contracts (deployment, upgrade) is typically a responsibility of the Governance committee of the Data Ecosystem. The team responsible for the definition, deployment and maintenance of the whole system. A typical user of the ecosystem doesn\u2019t need to know anything about the underlying Smart Contracts or Blockchain. All the business logic is encapsulated in the client libraries so typically there is no direct integration between the users and the Smart Contracts.","title":"Smart Contracts Governance"},{"location":"architecture/components/#metadata-api","text":"The Nevermined Metadata API is an Open Source micro-service that allows to store Assets metadata in an off-chain repository. It provides a plugins system allowing to persist the Metadata in ElasticSearch or MongoDB. The Metadata API exposes the functionality for searching metadata using multiple filters and parameters. The Metadata API is typically the backend used for Data Marketplaces or Data Catalogs for storing all the Metadata of a specific domain related to a Marketplace or Catalog . Nevermined provides the package and automation of the micro-service allowing an easy integration and deployment in cloud providers and Kubernetes clusters.","title":"Metadata API"},{"location":"architecture/components/#gateway","text":"The Nevermined Gateway is an Open Source micro-service in the Nevermined ecosystem. The Gateway is the technical component executed by Data/Compute Providers allowing them to provide extended data services (e.g. storage and compute). The Nevermined Gateway, as part of the Publisher ecosystem, includes the credentials to interact with the infrastructure (initially cloud, but could be on-premise). The Gateway allows also the encryption and decryption of components using the following mechanisms: RSA ECDSA Parity Secret Store Nevermined provides the package and automation of the micro-service allowing an easy integration and deployment in cloud providers and Kubernetes clusters.","title":"Gateway"},{"location":"architecture/components/#compute-api","text":"The Nevermined Compute API is an Open Source micro-service in the Nevermined ecosystem. It\u2019s a component in charge of orchestrating the execution of compute jobs in the premises of the Data/Compute Providers. In Nevermined the Data/Compute Providers can publish services saying they offer compute capabilities to the network on top of their data under some conditions for a given price. The Compute API is in charge of, after all the verifications made by the Gateway, to manage all the infrastructure to move the algorithm where the data is and track the execution of these ephemeral environments. The Compute API is a generic service exposing a REST API that can plugs different compute backends. At this point in time the Compute API integrates 2 different backends: Kubernetes backend - It allows the orchestration of Kubernetes clusters for setting up compute workflows in cloud or on-premise environments. Federated Learning backend - It manages the execution of FL jobs in different federated environments. It starts the coordinator and an aggregator tasks doing the management of the participants as part of a federated job and the secure aggregation of the trained models. Nevermined provides the package and automation of the micro-service allowing an easy integration and deployment in cloud providers and Kubernetes clusters.","title":"Compute API"},{"location":"architecture/components/#software-development-kits-sdks","text":"SDK's are the software libraries encapsulating the Nevermined business logic. They are used to interact with all the components & APIs of the system. Nevermined provides 3 different Open Source implementation of SDK's allowing the integration and implementation of complex use cases on top of the Nevermined Data Ecosystems. Nevermined SDK JS - JavaScript version of the Nevermined SDK to be integrated with front-end applications. Nevermined SDK PY - Python version of the Nevermined SDK to be integrated with back-end applications. The primary users are data scientists. Nevermined SDK JAVA - Java version of the Nevermined SDK to be integrated with JVM applications. The primary users are data engineers. The libraries are packaged and delivered in the typical formats for each language allowing easy integration: NPM Nevermined SDK JS NPM Nevermined SDK PY NPM Nevermined SDK JAVA","title":"Software Development Kits (SDK's)"},{"location":"architecture/components/#secret-store","text":"Nevermined integrates the Parity Secret Store to support use cases with high security requirements for the secret management. These secrets are being used for the encryption and distributed decryption of the access information to user assets. Parity Secret Store is a feature included as part of the Parity Ethereum client that allows users to store a fragmented ECDSA key on the blockchain, such that retrievals are controlled by a permissioned Smart Contract. The Secret Store implements a threshold retrieval system, so individual Secret Store nodes are unable to reconstruct the keys to decrypt documents by themselves. A Secret Store node only saves a portion of the ECDSA key. The decryption key can only be generated if a consensus is reached by an amount of Secret Store nodes bigger than the threshold that the publisher of the secret chooses. The Secret Store is integrated into Nevermined as an optional component for supporting the encryption and decryption.","title":"Secret Store"},{"location":"architecture/components/#command-line-interface-cli-tool","text":"The Nevermined CLI tool enables to connect to the Nevermined Data Ecosystem and interact with it using the command line interface. It orchestrates all the underlaying components allowing to: Publish assets Get access to assets Search and discovery Running remote compute jobs Checking the state of Service Agreements","title":"Command Line Interface (CLI) tool"},{"location":"architecture/components/#operational","text":"Are the Nevermined tools (not Open Source) allowing to automate, integrate and operate the rest of the components of the stack. The main tools available are:","title":"Operational"},{"location":"architecture/components/#contract-tools","text":"Nevermined Contract Tools . The Nevermined Zeppelin OS contract management framework. Deploying and upgrading Smart Contracts in multiple environments is not an easy thing. The Nevermined Contract Tools allow to deploy and upgrade smart contracts across multiple networks (production or testnet, public or private) mitigating the risk loose the control of the Smart Contracts or leave them in a non-functional way.","title":"Contract Tools"},{"location":"architecture/components/#development-and-integration","text":"The Nevermined Tools allows to execute all the components included in the stack in a local environment. Nevermined Tools make use of all the containers of the components and orchestrate the execution of them having a fully functional solution using the same software that you can find in a production environment. This approach allows to: Develop and integrate functionalities with a lower risk of issues when you move to a staging or production environment Automate the integration tests in the CI environments having fully functional networks used for testing Connect to remote blockchain networks from your local environment","title":"Development and Integration"},{"location":"architecture/components/#multisig-wallet","text":"Nevermined Multisig Wallet helps during the token governance process. The purpose of multisig wallets is to increase security by requiring multiple parties to agree on transactions before execution. Transactions can be executed only when confirmed by a predefined number of owners.","title":"Multisig Wallet"},{"location":"architecture/components/#monitoring","text":"The Nevermined Monitoring component is an integration of the Keyko Web3 Monitoring component adapted to the Nevermined use cases. It allows to monitor: The execution of the Service Agreements Assets registered Token Payments Compute use cases Blocks, Events and Transactions of the network The monitoring tool exposes the dashboards for an easy understanding of what's going on in the network.","title":"Monitoring"},{"location":"architecture/repos/","text":"Repositories \u00b6 The complete description of the architecture components & licenses can be found here . A brief summary of some of them: SMART CONTRACTS - Solidity Smart Contracts providing the Service Agreements business logic. GATEWAY - Microservice to be executed by PUBLISHERS. It exposes an HTTP REST API permitting access to PUBLISHER assets or additional services such as computation. METADATA-API - Microservice to be executed by MARKETPLACES. Facilitates creating, updating, deleting and searching the asset metadata registered by the PUBLISHERS. This metadata is included as part of a DDO (see DID SPEC and METADATA SPEC ) and also includes the services associated with the asset (consumption, computation, etc.). SDK - Software library encapsulating the Nevermined business logic. It's used to interact with all the components & APIs of the system. It's currently implemented in the following packages: nevermined-sdk-js - JavaScript version of the Nevermined SDK to be integrated with front-end applications. nevermined-sdk-py - Python version of the Nevermined SDK to be integrated with back-end applications. The primary users are data scientists. nevermined-sdk-java - Java version of the Nevermined SDK to be integrated with JVM applications. The primary users are data engineers. MARKETPLACE - Exposes a web interface allowing users to publish and purchase assets. It also facilitates the discovery of assets.","title":"Repositories"},{"location":"architecture/repos/#repositories","text":"The complete description of the architecture components & licenses can be found here . A brief summary of some of them: SMART CONTRACTS - Solidity Smart Contracts providing the Service Agreements business logic. GATEWAY - Microservice to be executed by PUBLISHERS. It exposes an HTTP REST API permitting access to PUBLISHER assets or additional services such as computation. METADATA-API - Microservice to be executed by MARKETPLACES. Facilitates creating, updating, deleting and searching the asset metadata registered by the PUBLISHERS. This metadata is included as part of a DDO (see DID SPEC and METADATA SPEC ) and also includes the services associated with the asset (consumption, computation, etc.). SDK - Software library encapsulating the Nevermined business logic. It's used to interact with all the components & APIs of the system. It's currently implemented in the following packages: nevermined-sdk-js - JavaScript version of the Nevermined SDK to be integrated with front-end applications. nevermined-sdk-py - Python version of the Nevermined SDK to be integrated with back-end applications. The primary users are data scientists. nevermined-sdk-java - Java version of the Nevermined SDK to be integrated with JVM applications. The primary users are data engineers. MARKETPLACE - Exposes a web interface allowing users to publish and purchase assets. It also facilitates the discovery of assets.","title":"Repositories"},{"location":"architecture/components/catalog/getting-started/","text":"Getting Started \u00b6 This section provides information about how to get started with the Nevermined Components Catalog. Pre-requisites \u00b6 The Nevermined Components Catalog is a package built with React and Typescript. It requires Node JS v14 or higher. You can find online instructions about How to install Node JS . How to install ? \u00b6 yarn add @nevermined-io/components-catalog or npm install --save @nevermined-io/components-catalog How to integrate ? \u00b6 import Catalog from '@nevermined-io/components-catalog' ; import App from 'app' ; import { Config } from '@nevermined-io/nevermined-sdk-js' ; const appConfig : Config = { web3Provider : new Web3 ( window . ethereum ), nodeUri , gatewayUri , faucetUri , verbose , gatewayAddress , secretStoreUri , graphHttpUri , marketplaceAuthToken , marketplaceUri , artifactsFolder }; ReactDOM . render ( < div > < Catalog . NeverminedProvider config = { appConfig } > < App /> < /Catalog.NeverminedProvider> < /div>, document . getElementById ( 'root' ) as HTMLElement ); How to use ? \u00b6 const SingleAsset = () => { const did = 'did:nv:f8a00...' ; const assetData : AssetState = Catalog . useAsset ( did ); return ( <> < div > Asset { did } :< /div> < div > { JSON . stringify ( assetData . ddo )} < /div> < /> ); }; For a full example .","title":"Catalog"},{"location":"architecture/components/catalog/getting-started/#getting-started","text":"This section provides information about how to get started with the Nevermined Components Catalog.","title":"Getting Started"},{"location":"architecture/components/catalog/getting-started/#pre-requisites","text":"The Nevermined Components Catalog is a package built with React and Typescript. It requires Node JS v14 or higher. You can find online instructions about How to install Node JS .","title":"Pre-requisites"},{"location":"architecture/components/catalog/getting-started/#how-to-install","text":"yarn add @nevermined-io/components-catalog or npm install --save @nevermined-io/components-catalog","title":"How to install ?"},{"location":"architecture/components/catalog/getting-started/#how-to-integrate","text":"import Catalog from '@nevermined-io/components-catalog' ; import App from 'app' ; import { Config } from '@nevermined-io/nevermined-sdk-js' ; const appConfig : Config = { web3Provider : new Web3 ( window . ethereum ), nodeUri , gatewayUri , faucetUri , verbose , gatewayAddress , secretStoreUri , graphHttpUri , marketplaceAuthToken , marketplaceUri , artifactsFolder }; ReactDOM . render ( < div > < Catalog . NeverminedProvider config = { appConfig } > < App /> < /Catalog.NeverminedProvider> < /div>, document . getElementById ( 'root' ) as HTMLElement );","title":"How to integrate ?"},{"location":"architecture/components/catalog/getting-started/#how-to-use","text":"const SingleAsset = () => { const did = 'did:nv:f8a00...' ; const assetData : AssetState = Catalog . useAsset ( did ); return ( <> < div > Asset { did } :< /div> < div > { JSON . stringify ( assetData . ddo )} < /div> < /> ); }; For a full example .","title":"How to use ?"},{"location":"architecture/contracts/","text":"Solidity API \u00b6 TestDisputeManager \u00b6 accept \u00b6 mapping ( bytes32 => bool ) accept accepted \u00b6 function accepted ( address provider , address buyer , bytes32 orig , bytes32 crypted ) public view returns ( bool ) setAccepted \u00b6 function setAccepted ( bytes32 orig , bytes32 crypted , address provider , address buyer ) public PlonkVerifier \u00b6 n \u00b6 uint32 n nPublic \u00b6 uint16 nPublic nLagrange \u00b6 uint16 nLagrange Qmx \u00b6 uint256 Qmx Qmy \u00b6 uint256 Qmy Qlx \u00b6 uint256 Qlx Qly \u00b6 uint256 Qly Qrx \u00b6 uint256 Qrx Qry \u00b6 uint256 Qry Qox \u00b6 uint256 Qox Qoy \u00b6 uint256 Qoy Qcx \u00b6 uint256 Qcx Qcy \u00b6 uint256 Qcy S1x \u00b6 uint256 S1x S1y \u00b6 uint256 S1y S2x \u00b6 uint256 S2x S2y \u00b6 uint256 S2y S3x \u00b6 uint256 S3x S3y \u00b6 uint256 S3y k1 \u00b6 uint256 k1 k2 \u00b6 uint256 k2 X2x1 \u00b6 uint256 X2x1 X2x2 \u00b6 uint256 X2x2 X2y1 \u00b6 uint256 X2y1 X2y2 \u00b6 uint256 X2y2 q \u00b6 uint256 q qf \u00b6 uint256 qf w1 \u00b6 uint256 w1 G1x \u00b6 uint256 G1x G1y \u00b6 uint256 G1y G2x1 \u00b6 uint256 G2x1 G2x2 \u00b6 uint256 G2x2 G2y1 \u00b6 uint256 G2y1 G2y2 \u00b6 uint256 G2y2 pA \u00b6 uint16 pA pB \u00b6 uint16 pB pC \u00b6 uint16 pC pZ \u00b6 uint16 pZ pT1 \u00b6 uint16 pT1 pT2 \u00b6 uint16 pT2 pT3 \u00b6 uint16 pT3 pWxi \u00b6 uint16 pWxi pWxiw \u00b6 uint16 pWxiw pEval_a \u00b6 uint16 pEval_a pEval_b \u00b6 uint16 pEval_b pEval_c \u00b6 uint16 pEval_c pEval_s1 \u00b6 uint16 pEval_s1 pEval_s2 \u00b6 uint16 pEval_s2 pEval_zw \u00b6 uint16 pEval_zw pEval_r \u00b6 uint16 pEval_r pAlpha \u00b6 uint16 pAlpha pBeta \u00b6 uint16 pBeta pGamma \u00b6 uint16 pGamma pXi \u00b6 uint16 pXi pXin \u00b6 uint16 pXin pBetaXi \u00b6 uint16 pBetaXi pV1 \u00b6 uint16 pV1 pV2 \u00b6 uint16 pV2 pV3 \u00b6 uint16 pV3 pV4 \u00b6 uint16 pV4 pV5 \u00b6 uint16 pV5 pV6 \u00b6 uint16 pV6 pU \u00b6 uint16 pU pPl \u00b6 uint16 pPl pEval_t \u00b6 uint16 pEval_t pA1 \u00b6 uint16 pA1 pB1 \u00b6 uint16 pB1 pZh \u00b6 uint16 pZh pZhInv \u00b6 uint16 pZhInv pEval_l1 \u00b6 uint16 pEval_l1 pEval_l2 \u00b6 uint16 pEval_l2 pEval_l3 \u00b6 uint16 pEval_l3 pEval_l4 \u00b6 uint16 pEval_l4 pEval_l5 \u00b6 uint16 pEval_l5 pEval_l6 \u00b6 uint16 pEval_l6 pEval_l7 \u00b6 uint16 pEval_l7 lastMem \u00b6 uint16 lastMem verifyProof \u00b6 function verifyProof ( bytes proof , uint256 [] pubSignals ) public view returns ( bool ) Common \u00b6 getCurrentBlockNumber \u00b6 function getCurrentBlockNumber () external view returns ( uint256 ) getCurrentBlockNumber get block number Name Type Description [0] uint256 the current block number isContract \u00b6 function isContract ( address addr ) public view returns ( bool ) isContract detect whether the address is is a contract address or externally owned account Name Type Description [0] bool true if it is a contract address provenanceSignatureIsCorrect \u00b6 function provenanceSignatureIsCorrect ( address _agentId , bytes32 _hash , bytes _signature ) public pure returns ( bool ) Name Type Description _agentId address The address of the agent _hash bytes32 bytes32 message, the hash is the signed message. What is recovered is the signer address. _signature bytes Signatures provided by the agent Name Type Description [0] bool true if the signature correspond to the agent address calculateTotalAmount \u00b6 function calculateTotalAmount ( uint256 [] _amounts ) public pure returns ( uint256 ) Sum the total amount given an uint array Name Type Description [0] uint256 the total amount addressToBytes32 \u00b6 function addressToBytes32 ( address _addr ) public pure returns ( bytes32 ) bytes32ToAddress \u00b6 function bytes32ToAddress ( bytes32 _b32 ) public pure returns ( address ) Dispenser \u00b6 tokenRequests \u00b6 mapping ( address => uint256 ) tokenRequests totalMintAmount \u00b6 uint256 totalMintAmount maxAmount \u00b6 uint256 maxAmount maxMintAmount \u00b6 uint256 maxMintAmount minPeriod \u00b6 uint256 minPeriod scale \u00b6 uint256 scale token \u00b6 contract NeverminedToken token RequestFrequencyExceeded \u00b6 event RequestFrequencyExceeded ( address requester , uint256 minPeriod ) RequestLimitExceeded \u00b6 event RequestLimitExceeded ( address requester , uint256 amount , uint256 maxAmount ) isValidAddress \u00b6 modifier isValidAddress ( address _address ) initialize \u00b6 function initialize ( address _tokenAddress , address _owner ) external Dispenser Initializer Name Type Description _tokenAddress address The deployed contract address of an ERC20 _owner address The owner of the Dispenser Runs only on initial contract creation. requestTokens \u00b6 function requestTokens ( uint256 amount ) external returns ( bool tokensTransferred ) user can request some tokens for testing Name Type Description amount uint256 the amount of tokens to be requested Name Type Description tokensTransferred bool Boolean indication of tokens are requested setMinPeriod \u00b6 function setMinPeriod ( uint256 period ) external the Owner can set the min period for token requests Name Type Description period uint256 the min amount of time before next request setMaxAmount \u00b6 function setMaxAmount ( uint256 amount ) external the Owner can set the max amount for token requests Name Type Description amount uint256 the max amount of tokens that can be requested setMaxMintAmount \u00b6 function setMaxMintAmount ( uint256 amount ) external the Owner can set the max amount for token requests Name Type Description amount uint256 the max amount of tokens that can be requested HashLists \u00b6 Hash lists contract is a sample list contract in which uses HashListLibrary.sol in order to store, retrieve, remove, and update bytes32 values in hash lists. This is a reference implementation for IList interface. It is used for whitelisting condition. Any entity can have its own implementation of the interface in which could be used for the same condition. lists \u00b6 mapping ( bytes32 => struct HashListLibrary . List ) lists initialize \u00b6 function initialize ( address _owner ) public HashLists Initializer Name Type Description _owner address The owner of the hash list Runs only upon contract creation. hash \u00b6 function hash ( address account ) public pure returns ( bytes32 ) hash ethereum accounts Name Type Description account address Ethereum address Name Type Description [0] bytes32 bytes32 hash of the account add \u00b6 function add ( bytes32 [] values ) external returns ( bool ) put an array of elements without indexing this meant to save gas in case of large arrays Name Type Description values bytes32[] is an array of elements value Name Type Description [0] bool true if values are added successfully add \u00b6 function add ( bytes32 value ) external returns ( bool ) add indexes an element then adds it to a list Name Type Description value bytes32 is a bytes32 value Name Type Description [0] bool true if value is added successfully update \u00b6 function update ( bytes32 oldValue , bytes32 newValue ) external returns ( bool ) update the value with a new value and maintain indices Name Type Description oldValue bytes32 is an element value in a list newValue bytes32 new value Name Type Description [0] bool true if value is updated successfully index \u00b6 function index ( uint256 from , uint256 to ) external returns ( bool ) index is used to map each element value to its index on the list Name Type Description from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing Name Type Description [0] bool true if the sub list is indexed has \u00b6 function has ( bytes32 id , bytes32 value ) external view returns ( bool ) has checks whether a value is exist Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list Name Type Description [0] bool true if the value exists has \u00b6 function has ( bytes32 value ) external view returns ( bool ) has checks whether a value is exist Name Type Description value bytes32 is element value in list Name Type Description [0] bool true if the value exists remove \u00b6 function remove ( bytes32 value ) external returns ( bool ) remove value from a list, updates indices, and list size Name Type Description value bytes32 is an element value in a list Name Type Description [0] bool true if value is removed successfully get \u00b6 function get ( bytes32 id , uint256 _index ) external view returns ( bytes32 ) has value by index Name Type Description id bytes32 the list identifier (the hash of list owner's address) _index uint256 is where is value is stored in the list Name Type Description [0] bytes32 the value if exists size \u00b6 function size ( bytes32 id ) external view returns ( uint256 ) size gets the list size Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] uint256 total length of the list all \u00b6 function all ( bytes32 id ) external view returns ( bytes32 []) all returns all list elements Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] bytes32[] all list elements indexOf \u00b6 function indexOf ( bytes32 id , bytes32 value ) external view returns ( uint256 ) indexOf gets the index of a value in a list Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list Name Type Description [0] uint256 value index in list ownedBy \u00b6 function ownedBy ( bytes32 id ) external view returns ( address ) ownedBy gets the list owner Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] address list owner isIndexed \u00b6 function isIndexed ( bytes32 id ) external view returns ( bool ) isIndexed checks if the list is indexed Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] bool true if the list is indexed NeverminedToken \u00b6 Implementation of a Test Token. Test Token is an ERC20 token only for testing purposes initialize \u00b6 function initialize ( address _owner , address payable _initialMinter ) public NeverminedToken Initializer Runs only on initial contract creation. Name Type Description _owner address refers to the owner of the contract _initialMinter address payable is the first token minter added _beforeTokenTransfer \u00b6 function _beforeTokenTransfer ( address from , address to , uint256 amount ) internal _See {ERC20-_beforeTokenTransfer}. Requirements: minted tokens must not cause the total supply to go over the cap._ mint \u00b6 function mint ( address account , uint256 amount ) external returns ( bool ) _Creates amount tokens and assigns them to account , increasing the total supply. Emits a {Transfer} event with from set to the zero address. Requirements: to cannot be the zero address._ AgreementStoreLibrary \u00b6 Implementation of the Agreement Store Library. The agreement store library holds the business logic in which manages the life cycle of SEA agreement, each agreement is linked to the DID of an asset, template, and condition IDs. Agreement \u00b6 struct Agreement { bytes32 did ; address templateId ; bytes32 [] conditionIds ; address lastUpdatedBy ; uint256 blockNumberUpdated ; } AgreementList \u00b6 struct AgreementList { mapping ( bytes32 &# x3D ; & gt ; struct AgreementStoreLibrary . Agreement ) agreements ; mapping ( bytes32 &# x3D ; & gt ; bytes32 []) didToAgreementIds ; mapping ( address &# x3D ; & gt ; bytes32 []) templateIdToAgreementIds ; bytes32 [] agreementIds ; } create \u00b6 function create ( struct AgreementStoreLibrary . AgreementList _self , bytes32 _id , bytes32 , address _templateId , bytes32 []) internal create new agreement checks whether the agreement Id exists, creates new agreement instance, including the template, conditions and DID. Name Type Description _self struct AgreementStoreLibrary.AgreementList is AgreementList storage pointer _id bytes32 agreement identifier bytes32 _templateId address template identifier bytes32[] Template \u00b6 getConditionTypes \u00b6 function getConditionTypes () external view returns ( address []) AgreementStoreManager \u00b6 _Implementation of the Agreement Store. The agreement store generates conditions for an agreement template. Agreement templates must to be approved in the Template Store Each agreement is linked to the DID of an asset._ PROXY_ROLE \u00b6 bytes32 PROXY_ROLE grantProxyRole \u00b6 function grantProxyRole ( address _address ) public revokeProxyRole \u00b6 function revokeProxyRole ( address _address ) public agreementList \u00b6 struct AgreementStoreLibrary . AgreementList agreementList state storage for the agreements conditionStoreManager \u00b6 contract ConditionStoreManager conditionStoreManager templateStoreManager \u00b6 contract TemplateStoreManager templateStoreManager didRegistry \u00b6 contract DIDRegistry didRegistry initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _templateStoreManagerAddress , address _didRegistryAddress ) public initialize AgreementStoreManager Initializer Initializes Ownable. Only on contract creation. Name Type Description _owner address refers to the owner of the contract _conditionStoreManagerAddress address is the address of the connected condition store _templateStoreManagerAddress address is the address of the connected template store _didRegistryAddress address is the address of the connected DID Registry fullConditionId \u00b6 function fullConditionId ( bytes32 _agreementId , address _condType , bytes32 _valueHash ) public pure returns ( bytes32 ) agreementId \u00b6 function agreementId ( bytes32 _agreementId , address _creator ) public pure returns ( bytes32 ) createAgreement \u00b6 function createAgreement ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts ) public Create a new agreement. The agreement will create conditions of conditionType with conditionId. Only \"approved\" templates can access this function. Name Type Description _id bytes32 is the ID of the new agreement. Must be unique. _did bytes32 is the bytes32 DID of the asset. The DID must be registered beforehand. _conditionTypes address[] is a list of addresses that point to Condition contracts. _conditionIds bytes32[] is a list of bytes32 content-addressed Condition IDs _timeLocks uint256[] is a list of uint time lock values associated to each Condition _timeOuts uint256[] is a list of uint time out values associated to each Condition CreateAgreementArgs \u00b6 struct CreateAgreementArgs { bytes32 _id ; bytes32 _did ; address [] _conditionTypes ; bytes32 [] _conditionIds ; uint256 [] _timeLocks ; uint256 [] _timeOuts ; address _creator ; uint256 _idx ; address payable _rewardAddress ; address _tokenAddress ; uint256 [] _amounts ; address [] _receivers ; } createAgreementAndPay \u00b6 function createAgreementAndPay ( struct AgreementStoreManager . CreateAgreementArgs args ) public payable createAgreementAndFulfill \u00b6 function createAgreementAndFulfill ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address [] _account , uint256 [] _idx , bytes [] params ) public payable getAgreementTemplate \u00b6 function getAgreementTemplate ( bytes32 _id ) external view returns ( address ) getDIDRegistryAddress \u00b6 function getDIDRegistryAddress () public view virtual returns ( address ) getDIDRegistryAddress utility function used by other contracts or any EOA. Name Type Description [0] address the DIDRegistry address AccessCondition \u00b6 _Implementation of the Access Condition Access Secret Store Condition is special condition where a client or Parity secret store can encrypt/decrypt documents based on the on-chain granted permissions. For a given DID document, and agreement ID, the owner/provider of the DID will fulfill the condition. Consequently secret store will check whether the permission is granted for the consumer in order to encrypt/decrypt the document._ CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE DocumentPermission \u00b6 struct DocumentPermission { bytes32 agreementIdDeprecated ; mapping ( address &# x3D ; & gt ; bool ) permission ; } documentPermissions \u00b6 mapping ( bytes32 => struct AccessCondition . DocumentPermission ) documentPermissions agreementStoreManager \u00b6 contract AgreementStoreManager agreementStoreManager didRegistry \u00b6 contract DIDRegistry didRegistry Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _documentId , address _grantee , bytes32 _conditionId ) onlyDIDOwnerOrProvider \u00b6 modifier onlyDIDOwnerOrProvider ( bytes32 _documentId ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address reinitialize \u00b6 function reinitialize () external Should be called when the contract has been upgraded. hashValues \u00b6 function hashValues ( bytes32 _documentId , address _grantee ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill access secret store condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) grantPermission \u00b6 function grantPermission ( address _grantee , bytes32 _documentId ) public grantPermission is called only by DID owner or provider Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys renouncePermission \u00b6 function renouncePermission ( address _grantee , bytes32 _documentId ) public renouncePermission is called only by DID owner or provider Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys checkPermissions \u00b6 function checkPermissions ( address _grantee , bytes32 _documentId ) external view returns ( bool permissionGranted ) checkPermissions is called by Parity secret store Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys Name Type Description permissionGranted bool true if the access was granted IDisputeManager \u00b6 verifyProof \u00b6 function verifyProof ( bytes proof , uint256 [] pubSignals ) external view returns ( bool ) AccessProofCondition \u00b6 Implementation of the Access Condition with transfer proof. The idea is that the hash of the decryption key is known before hand, and the key matching this hash is passed from data provider to the buyer using this smart contract. Using ZK proof the key is kept hidden from outsiders. For the protocol to work, both the provider and buyer need to have public keys in the babyjub curve. To initiate the deal, buyer will pass the key hash and the public keys of participants. The provider needs to pass the cipher text encrypted using MIMC (symmetric encryption). The secret key for MIMC is computed using ECDH (requires one public key and one secret key for the curve). The hash function that is used is Poseidon. CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE agreementStoreManager \u00b6 contract AgreementStoreManager agreementStoreManager disputeManager \u00b6 contract IDisputeManager disputeManager Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider , uint256 [ 2 ] _cipher , bytes _proof , bytes32 _conditionId ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress , address _disputeManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address _disputeManagerAddress address dispute manager address changeDisputeManager \u00b6 function changeDisputeManager ( address _disputeManagerAddress ) external hashValues \u00b6 function hashValues ( uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _origHash uint256 is the hash of the key _buyer uint256[2] buyer public key _provider uint256[2] provider public key Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider , uint256 [ 2 ] _cipher , bytes _proof ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill key transfer The key with hash _origHash is transferred to the _buyer from _provider. Name Type Description _agreementId bytes32 associated agreement _origHash uint256 is the hash of data to access _buyer uint256[2] buyer public key _provider uint256[2] provider public key _cipher uint256[2] encrypted version of the key _proof bytes SNARK proof that the cipher text can be decrypted by buyer to give the key with hash _origHash Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) ComputeExecutionCondition \u00b6 Implementation of the Compute Execution Condition This condition is meant to be a signal in which triggers the execution of a compute service. The compute service is fully described in the associated DID document. The provider of the compute service will send this signal to its workers by fulfilling the condition where they are listening to the fulfilled event. CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE computeExecutionStatus \u00b6 mapping ( bytes32 => mapping ( address => bool )) computeExecutionStatus agreementStoreManager \u00b6 contract AgreementStoreManager agreementStoreManager Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _computeConsumer , bytes32 _conditionId ) onlyDIDOwnerOrProvider \u00b6 modifier onlyDIDOwnerOrProvider ( bytes32 _did ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address hashValues \u00b6 function hashValues ( bytes32 _did , address _computeConsumer ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _computeConsumer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill compute execution condition only the compute provider can fulfill this condition. By fulfilling this condition the compute provider will trigger the execution of the offered job/compute. The compute service is described in a DID document. Name Type Description _agreementId bytes32 agreement identifier _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) wasComputeTriggered \u00b6 function wasComputeTriggered ( bytes32 _did , address _computeConsumer ) public view returns ( bool ) wasComputeTriggered checks whether the compute is triggered or not. Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the compute consumer's address Name Type Description [0] bool true if the compute is triggered Condition \u00b6 _Implementation of the Condition Each condition has a validation function that returns either FULFILLED, ABORTED or UNFULFILLED. When a condition is successfully solved, we call it FULFILLED. If a condition cannot be FULFILLED anymore due to a timeout or other types of counter-proofs, the condition is ABORTED. UNFULFILLED values imply that a condition has not been provably FULFILLED or ABORTED. All initialized conditions start out as UNFULFILLED._ conditionStoreManager \u00b6 contract ConditionStoreManager conditionStoreManager generateId \u00b6 function generateId ( bytes32 _agreementId , bytes32 _valueHash ) public view returns ( bytes32 ) generateId condition Id from the following parameters Name Type Description _agreementId bytes32 SEA agreement ID _valueHash bytes32 hash of all the condition input values fulfill \u00b6 function fulfill ( bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) internal returns ( enum ConditionStoreLibrary . ConditionState ) fulfill set the condition state to Fulfill | Abort Name Type Description _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState new condition state (Fulfill/Abort) Name Type Description [0] enum ConditionStoreLibrary.ConditionState the updated condition state abortByTimeOut \u00b6 function abortByTimeOut ( bytes32 _id ) external returns ( enum ConditionStoreLibrary . ConditionState ) abortByTimeOut set condition state to Aborted if the condition is timed out Name Type Description _id bytes32 condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState the updated condition state ConditionStoreLibrary \u00b6 _Implementation of the Condition Store Library. Condition is a key component in the service execution agreement. This library holds the logic for creating and updating condition Any Condition has only four state transitions starts with Uninitialized, Unfulfilled, Fulfilled, and Aborted. Condition state transition goes only forward from Unintialized -> Unfulfilled -> {Fulfilled || Aborted}_ ConditionState \u00b6 enum ConditionState { Uninitialized , Unfulfilled , Fulfilled , Aborted } Condition \u00b6 struct Condition { address typeRef ; enum ConditionStoreLibrary . ConditionState state ; address createdBy ; address lastUpdatedBy ; uint256 blockNumberUpdated ; } ConditionList \u00b6 struct ConditionList { mapping ( bytes32 &# x3D ; & gt ; struct ConditionStoreLibrary . Condition ) conditions ; mapping ( bytes32 &# x3D ; & gt ; mapping ( bytes32 &# x3D ; & gt ; bytes32 )) map ; bytes32 [] conditionIds ; } create \u00b6 function create ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , address _typeRef ) internal create new condition check whether the condition exists, assigns condition type, condition state, last updated by, and update at (which is the current block number) Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 valid condition identifier _typeRef address condition contract address updateState \u00b6 function updateState ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) internal updateState update the condition state check whether the condition state transition is right, assign the new state, update last updated by and updated at. Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState the new state of the condition updateKeyValue \u00b6 function updateKeyValue ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , bytes32 _key , bytes32 _value ) internal ConditionStoreManager \u00b6 _Implementation of the Condition Store Manager. Condition store manager is responsible for enforcing the the business logic behind creating/updating the condition state based on the assigned role to each party. Only specific type of contracts are allowed to call this contract, therefore there are two types of roles, create role that in which is able to create conditions. The second role is the update role, which is can update the condition state. Also, it support delegating the roles to other contract(s)/account(s)._ PROXY_ROLE \u00b6 bytes32 PROXY_ROLE RoleType \u00b6 enum RoleType { Create , Update } createRole \u00b6 address createRole conditionList \u00b6 struct ConditionStoreLibrary . ConditionList conditionList epochList \u00b6 struct EpochLibrary . EpochList epochList nvmConfigAddress \u00b6 address nvmConfigAddress ConditionCreated \u00b6 event ConditionCreated ( bytes32 _id , address _typeRef , address _who ) ConditionUpdated \u00b6 event ConditionUpdated ( bytes32 _id , address _typeRef , enum ConditionStoreLibrary . ConditionState _state , address _who ) onlyCreateRole \u00b6 modifier onlyCreateRole () onlyUpdateRole \u00b6 modifier onlyUpdateRole ( bytes32 _id ) onlyValidType \u00b6 modifier onlyValidType ( address typeRef ) initialize \u00b6 function initialize ( address _creator , address _owner , address _nvmConfigAddress ) public initialize ConditionStoreManager Initializer Initialize Ownable. Only on contract creation, Name Type Description _creator address refers to the creator of the contract _owner address refers to the owner of the contract _nvmConfigAddress address refers to the contract address of NeverminedConfig getCreateRole \u00b6 function getCreateRole () external view returns ( address ) getCreateRole get the address of contract which has the create role Name Type Description [0] address create condition role address getNvmConfigAddress \u00b6 function getNvmConfigAddress () external view returns ( address ) getNvmConfigAddress get the address of the NeverminedConfig contract Name Type Description [0] address NeverminedConfig contract address setNvmConfigAddress \u00b6 function setNvmConfigAddress ( address _addr ) external delegateCreateRole \u00b6 function delegateCreateRole ( address delegatee ) external delegateCreateRole only owner can delegate the create condition role to a different address Name Type Description delegatee address delegatee address delegateUpdateRole \u00b6 function delegateUpdateRole ( bytes32 _id , address delegatee ) external delegateUpdateRole only owner can delegate the update role to a different address for specific condition Id which has the create role Name Type Description _id bytes32 delegatee address delegatee address grantProxyRole \u00b6 function grantProxyRole ( address _address ) public revokeProxyRole \u00b6 function revokeProxyRole ( address _address ) public createCondition \u00b6 function createCondition ( bytes32 _id , address _typeRef ) external createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled. Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address createCondition2 \u00b6 function createCondition2 ( bytes32 _id , address _typeRef ) external createCondition \u00b6 function createCondition ( bytes32 _id , address _typeRef , uint256 _timeLock , uint256 _timeOut ) public createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled. Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address _timeLock uint256 start of the time window _timeOut uint256 end of the time window updateConditionState \u00b6 function updateConditionState ( bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) external returns ( enum ConditionStoreLibrary . ConditionState ) updateConditionState only called by update role address. It enforce the condition state transition to either Fulfill or Aborted state Name Type Description _id bytes32 unique condition identifier _newState enum ConditionStoreLibrary.ConditionState Name Type Description [0] enum ConditionStoreLibrary.ConditionState the current condition state updateConditionMapping \u00b6 function updateConditionMapping ( bytes32 _id , bytes32 _key , bytes32 _value ) external updateConditionMappingProxy \u00b6 function updateConditionMappingProxy ( bytes32 _id , bytes32 _key , bytes32 _value ) external getCondition \u00b6 function getCondition ( bytes32 _id ) external view returns ( address typeRef , enum ConditionStoreLibrary . ConditionState state , uint256 timeLock , uint256 timeOut , uint256 blockNumber ) getCondition Name Type Description typeRef address the type reference state enum ConditionStoreLibrary.ConditionState condition state timeLock uint256 the time lock timeOut uint256 time out blockNumber uint256 block number getConditionState \u00b6 function getConditionState ( bytes32 _id ) external view virtual returns ( enum ConditionStoreLibrary . ConditionState ) getConditionState Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state getConditionTypeRef \u00b6 function getConditionTypeRef ( bytes32 _id ) external view virtual returns ( address ) getConditionTypeRef Name Type Description [0] address condition typeRef getMappingValue \u00b6 function getMappingValue ( bytes32 _id , bytes32 _key ) external view virtual returns ( bytes32 ) getConditionState Name Type Description [0] bytes32 condition state isConditionTimeLocked \u00b6 function isConditionTimeLocked ( bytes32 _id ) public view returns ( bool ) isConditionTimeLocked Name Type Description [0] bool whether the condition is timedLock ended isConditionTimedOut \u00b6 function isConditionTimedOut ( bytes32 _id ) public view returns ( bool ) isConditionTimedOut Name Type Description [0] bool whether the condition is timed out HashLockCondition \u00b6 Implementation of the Hash Lock Condition CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( uint256 _preimage ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _preimage uint256 refers uint value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values hashValues \u00b6 function hashValues ( string _preimage ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _preimage string refers string value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values hashValues \u00b6 function hashValues ( bytes32 _preimage ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _preimage bytes32 refers bytes32 value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , uint256 _preimage ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image uint value Name Type Description _agreementId bytes32 SEA agreement identifier _preimage uint256 Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state fulfill \u00b6 function fulfill ( bytes32 _agreementId , string _preimage ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image string value Name Type Description _agreementId bytes32 SEA agreement identifier _preimage string Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _preimage ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image bytes32 value Name Type Description _agreementId bytes32 SEA agreement identifier _preimage bytes32 Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state _fulfill \u00b6 function _fulfill ( bytes32 _generatedId ) private returns ( enum ConditionStoreLibrary . ConditionState ) _fulfill calls super fulfil method Name Type Description _generatedId bytes32 SEA agreement identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state ICondition \u00b6 fulfillProxy \u00b6 function fulfillProxy ( address _account , bytes32 _agreementId , bytes params ) external payable ILockPayment \u00b6 Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId , address _rewardAddress , address _tokenAddress , address [] _receivers , uint256 [] _amounts ) hashValues \u00b6 function hashValues ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires valid token transfer in order to lock the amount of tokens based on the SEA Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state LockPaymentCondition \u00b6 Implementation of the Lock Payment Condition This condition allows to lock payment for multiple receivers taking into account the royalties to be paid to the original creators in a secondary market. didRegistry \u00b6 contract DIDRegistry didRegistry nvmConfig \u00b6 contract INVMConfig nvmConfig CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE KEY_ASSET_RECEIVER \u00b6 bytes32 KEY_ASSET_RECEIVER PROXY_ROLE \u00b6 bytes32 PROXY_ROLE ALLOWED_EXTERNAL_CONTRACT_ROLE \u00b6 bytes32 ALLOWED_EXTERNAL_CONTRACT_ROLE grantProxyRole \u00b6 function grantProxyRole ( address _address ) public revokeProxyRole \u00b6 function revokeProxyRole ( address _address ) public grantExternalContractRole \u00b6 function grantExternalContractRole ( address _address ) public revokeExternalContractRole \u00b6 function revokeExternalContractRole ( address _address ) public initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address reinitialize \u00b6 function reinitialize () external Should be called when the contract has been upgraded. hashValues \u00b6 function hashValues ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires valid token transfer in order to lock the amount of tokens based on the SEA Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state fulfillExternal \u00b6 function fulfillExternal ( bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _externalContract , bytes32 _remoteId , uint256 [] _amounts , address [] _receivers ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) fulfill lock condition using the funds locked in an external contract (auction, bonding curve, lottery, etc) Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _externalContract address the address of the contract with the lock funds are locked _remoteId bytes32 the id used to identify into the external contract _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state encodeParams \u00b6 function encodeParams ( bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external pure returns ( bytes ) fulfillInternal \u00b6 function fulfillInternal ( address _account , bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) internal returns ( enum ConditionStoreLibrary . ConditionState ) fulfillProxy \u00b6 function fulfillProxy ( address _account , bytes32 _agreementId , bytes params ) external payable _transferERC20Proxy \u00b6 function _transferERC20Proxy ( address _senderAddress , address _rewardAddress , address _tokenAddress , uint256 _amount ) internal _transferERC20Proxy transfer ERC20 tokens Will throw if transfer fails Name Type Description _senderAddress address the address to send the tokens from _rewardAddress address the address to receive the tokens _tokenAddress address the ERC20 contract address to use during the payment _amount uint256 token amount to be locked/released _transferETH \u00b6 function _transferETH ( address payable _rewardAddress , uint256 _amount ) internal _transferETH transfer ETH Name Type Description _rewardAddress address payable the address to receive the ETH _amount uint256 ETH amount to be locked/released allowedExternalContract \u00b6 modifier allowedExternalContract ( address _externalContractAddress ) areMarketplaceFeesIncluded \u00b6 function areMarketplaceFeesIncluded ( uint256 [] _amounts , address [] _receivers ) internal view returns ( bool ) DistributeNFTCollateralCondition \u00b6 Implementation of a condition allowing to transfer a NFT to an account or another depending on the final state of a lock condition CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE aaveCreditVault \u00b6 contract AaveCreditVault aaveCreditVault _lockConditionAddress \u00b6 address _lockConditionAddress Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _receiver , bytes32 _conditionId , address _contract ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _lockNFTConditionAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _lockNFTConditionAddress address Lock NFT Condition address hashValues \u00b6 function hashValues ( bytes32 _did , address _vaultAddress , address _nftContractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _vaultAddress address The contract address of the vault _nftContractAddress address NFT contract to use Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _nftContractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _vaultAddress address The contract address of the vault _nftContractAddress address NFT contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) INFTAccess \u00b6 Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _documentId , address _grantee , bytes32 _conditionId ) hashValues \u00b6 function hashValues ( bytes32 _documentId , address _grantee , address _contractAddress ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access conditions only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) INFTHolder \u00b6 Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _address , bytes32 _conditionId , uint256 _amount ) hashValues \u00b6 function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state INFTLock \u00b6 Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _lockAddress , bytes32 _conditionId , uint256 _amount , address _receiver , address _nftContractAddress ) hashValues \u00b6 function hashValues ( bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the NFTs locked _nftContractAddress address Is the address of the NFT (ERC-721, ERC-1155) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values hashValuesMarked \u00b6 function hashValuesMarked ( bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) external pure returns ( bytes32 ) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) fulfillMarked \u00b6 function fulfillMarked ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) ITransferNFT \u00b6 Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _receiver , uint256 _amount , bytes32 _conditionId , address _contract ) hashValues \u00b6 function hashValues ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockCondition , address _contract , bool _transfer ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _contract address _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _contract , bool _transfer ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _contract address _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) getNFTDefaultAddress \u00b6 function getNFTDefaultAddress () external view returns ( address ) returns if the default NFT contract address The default NFT contract address was given to the Transfer Condition during the contract initialization Name Type Description [0] address the NFT contract address used by default in the transfer condition NFT721HolderCondition \u00b6 Implementation of the Nft Holder Condition CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state NFT721LockCondition \u00b6 Implementation of the NFT Lock Condition for ERC-721 based NFTs CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values hashValuesMarked \u00b6 function hashValuesMarked ( bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) public pure returns ( bytes32 ) fulfillMarked \u00b6 function fulfillMarked ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method lock a NFT into the _lockAddress . Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens (1) _receiver address _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) onERC721Received \u00b6 function onERC721Received ( address , address , uint256 , bytes ) public virtual returns ( bytes4 ) Always returns IERC721Receiver.onERC721Received.selector . NFTAccessCondition \u00b6 _Implementation of the Access Condition specific for NFTs NFT Access Condition is special condition used to give access to a specific NFT related to a DID._ CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE DocumentPermission \u00b6 struct DocumentPermission { bytes32 agreementIdDeprecated ; mapping ( address &# x3D ; & gt ; bool ) permission ; } nftPermissions \u00b6 mapping ( bytes32 => struct NFTAccessCondition . DocumentPermission ) nftPermissions didRegistry \u00b6 contract DIDRegistry didRegistry onlyDIDOwnerOrProvider \u00b6 modifier onlyDIDOwnerOrProvider ( bytes32 _documentId ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID registry address hashValues \u00b6 function hashValues ( bytes32 _documentId , address _grantee ) public view returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values hashValues \u00b6 function hashValues ( bytes32 _documentId , address _grantee , address _contractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee , address _contractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address is the contract address of the NFT implementation (ERC-1155 or ERC-721) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) grantPermission \u00b6 function grantPermission ( address _grantee , bytes32 _documentId ) public grantPermission is called only by DID owner or provider Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys checkPermissions \u00b6 function checkPermissions ( address _grantee , bytes32 _documentId ) external view returns ( bool permissionGranted ) checkPermissions is called to validate the permissions of user related to the NFT attached to an asset Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID Name Type Description permissionGranted bool true if the access was granted NFTHolderCondition \u00b6 Implementation of the Nft Holder Condition erc1155 \u00b6 contract ERC1155BurnableUpgradeable erc1155 CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _ercAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _ercAddress address Nevermined ERC-1155 address hashValues \u00b6 function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount ) public view returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder Name Type Description [0] bytes32 bytes32 hash of all these values hashValues \u00b6 function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state NFTLockCondition \u00b6 Implementation of the NFT Lock Condition erc1155 \u00b6 contract IERC1155Upgradeable erc1155 CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE ERC1155_ACCEPTED \u00b6 bytes4 ERC1155_ACCEPTED ERC1155_BATCH_ACCEPTED \u00b6 bytes4 ERC1155_BATCH_ACCEPTED initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _ercAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _ercAddress address Nevermined ERC-1155 address hashValues \u00b6 function hashValues ( bytes32 _did , address _lockAddress , uint256 _amount ) public view returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens Name Type Description [0] bytes32 bytes32 hash of all these values hashValues \u00b6 function hashValues ( bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-1155) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values hashValuesMarked \u00b6 function hashValuesMarked ( bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) public pure returns ( bytes32 ) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _nft ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfillMarked \u00b6 function fulfillMarked ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _receiver address _nftContractAddress address Is the address of the NFT (ERC-1155) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) onERC1155Received \u00b6 function onERC1155Received ( address , address , uint256 , uint256 , bytes ) external pure returns ( bytes4 ) onERC1155BatchReceived \u00b6 function onERC1155BatchReceived ( address , address , uint256 [], uint256 [], bytes ) external pure returns ( bytes4 ) supportsInterface \u00b6 function supportsInterface ( bytes4 interfaceId ) external pure returns ( bool ) _Returns true if this contract implements the interface defined by interfaceId . See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas._ TransferNFT721Condition \u00b6 Implementation of condition allowing to transfer an NFT between the original owner and a receiver CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE MARKET_ROLE \u00b6 bytes32 MARKET_ROLE erc721 \u00b6 contract NFT721Upgradeable erc721 _lockConditionAddress \u00b6 address _lockConditionAddress PROXY_ROLE \u00b6 bytes32 PROXY_ROLE didRegistry \u00b6 contract DIDRegistry didRegistry grantProxyRole \u00b6 function grantProxyRole ( address _address ) public revokeProxyRole \u00b6 function revokeProxyRole ( address _address ) public initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress , address _ercAddress , address _lockNFTConditionAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address _ercAddress address Nevermined ERC-721 address _lockNFTConditionAddress address getNFTDefaultAddress \u00b6 function getNFTDefaultAddress () external view returns ( address ) returns if the default NFT contract address The default NFT contract address was given to the Transfer Condition during the contract initialization Name Type Description [0] address the NFT contract address used by default in the transfer condition hashValues \u00b6 function hashValues ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockCondition , address _contract , bool _transfer ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _contract address NFT contract to use _transfer bool Name Type Description [0] bytes32 bytes32 hash of all these values encodeParams \u00b6 function encodeParams ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) external pure returns ( bytes ) Encodes/serialize all the parameters received Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address the NFT contract to use _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] bytes the encoded parameters fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _contract , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _contract address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) fulfillProxy \u00b6 function fulfillProxy ( address _account , bytes32 _agreementId , bytes _params ) external payable fulfill the transfer NFT condition by a proxy Fulfill method transfer a certain amount of NFTs Name Type Description _account address NFT Holder _agreementId bytes32 agreement identifier _params bytes encoded parameters fulfillInternal \u00b6 function fulfillInternal ( address _account , bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _contract , bool _transfer ) internal returns ( enum ConditionStoreLibrary . ConditionState ) fulfillForDelegate \u00b6 function fulfillForDelegate ( bytes32 _agreementId , bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address in the DIDRegistry contract. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) TransferNFTCondition \u00b6 Implementation of condition allowing to transfer an NFT between the original owner and a receiver CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE MARKET_ROLE \u00b6 bytes32 MARKET_ROLE erc1155 \u00b6 contract NFTUpgradeable erc1155 didRegistry \u00b6 contract DIDRegistry didRegistry PROXY_ROLE \u00b6 bytes32 PROXY_ROLE grantProxyRole \u00b6 function grantProxyRole ( address _address ) public revokeProxyRole \u00b6 function revokeProxyRole ( address _address ) public initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress , address _ercAddress , address _nftContractAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address _ercAddress address Nevermined ERC-1155 address _nftContractAddress address Market address grantMarketRole \u00b6 function grantMarketRole ( address _nftContractAddress ) public revokeMarketRole \u00b6 function revokeMarketRole ( address _nftContractAddress ) public getNFTDefaultAddress \u00b6 function getNFTDefaultAddress () external view returns ( address ) returns if the default NFT contract address The default NFT contract address was given to the Transfer Condition during the contract initialization Name Type Description [0] address the NFT contract address used by default in the transfer condition hashValues \u00b6 function hashValues ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockCondition ) public view returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values hashValues \u00b6 function hashValues ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockCondition , address _nftContractAddress , bool _transfer ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _nftContractAddress address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition ) public returns ( enum ConditionStoreLibrary . ConditionState ) encodeParams \u00b6 function encodeParams ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) external pure returns ( bytes ) Encodes/serialize all the parameters received Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address the NFT contract to use _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] bytes the encoded parameters fulfillProxy \u00b6 function fulfillProxy ( address _account , bytes32 _agreementId , bytes _params ) external payable fulfill the transfer NFT condition by a proxy Fulfill method transfer a certain amount of NFTs Name Type Description _account address NFT Holder _agreementId bytes32 agreement identifier _params bytes encoded parameters fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) fulfillInternal \u00b6 function fulfillInternal ( address _account , bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) internal returns ( enum ConditionStoreLibrary . ConditionState ) fulfillForDelegate \u00b6 function fulfillForDelegate ( bytes32 _agreementId , bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address in the DIDRegistry contract. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) SignCondition \u00b6 Implementation of the Sign Condition CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _message , address _publicKey ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _message bytes32 the message to be signed _publicKey address the public key of the signing address Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _message , address _publicKey , bytes _signature ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill validate the signed message and fulfill the condition Name Type Description _agreementId bytes32 SEA agreement identifier _message bytes32 the message to be signed _publicKey address the public key of the signing address _signature bytes signature of the signed message using the public key Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state ThresholdCondition \u00b6 _Implementation of the Threshold Condition Threshold condition acts as a filter for a set of input condition(s) in which sends a signal whether to complete the flow execution or abort it. This type of conditions works as intermediary conditions where they wire SEA conditions in order to support more complex scenarios._ CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 [] inputConditions , uint256 threshold ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 [] _inputConditions , uint256 threshold ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill threshold condition the fulfill method check whether input conditions are fulfilled or not. Name Type Description _agreementId bytes32 agreement identifier _inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) canFulfill \u00b6 function canFulfill ( bytes32 [] _inputConditions , uint256 threshold ) private view returns ( bool _fulfill ) canFulfill check if condition can be fulfilled Name Type Description _inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description _fulfill bool true if can fulfill TransferDIDOwnershipCondition \u00b6 Implementation of condition allowing to transfer the ownership between the original owner and a receiver CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE didRegistry \u00b6 contract DIDRegistry didRegistry Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _receiver , bytes32 _conditionId ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address hashValues \u00b6 function hashValues ( bytes32 _did , address _receiver ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _receiver ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer DID ownership condition only DID owner or DID provider can call this method. Fulfill method transfer full ownership permissions to to _receiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) WhitelistingCondition \u00b6 Implementation of the Whitelisting Condition CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( address _listAddress , bytes32 _item ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _listAddress address list contract address _item bytes32 item in the list Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , address _listAddress , bytes32 _item ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill check whether address is whitelisted in order to fulfill the condition. This method will be called by any one in this whitelist. Name Type Description _agreementId bytes32 SEA agreement identifier _listAddress address list contract address _item bytes32 item in the list Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state AaveBorrowCondition \u00b6 Implementation of the Aave Borrow Credit Condition aaveCreditVault \u00b6 contract AaveCreditVault aaveCreditVault CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , address _vaultAddress , address _assetToBorrow , uint256 _amount , uint256 _interestRateMode ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToBorrow address the address of the asset to borrow (i.e DAI) _amount uint256 the amount of the ERC-20 the assets to borrow (i.e 50 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _assetToBorrow , uint256 _amount , uint256 _interestRateMode ) external returns ( enum ConditionStoreLibrary . ConditionState ) It allows the borrower to borrow the asset deposited by the lender Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToBorrow address the address of the asset to borrow (i.e DAI) _amount uint256 the amount of the ERC-20 the assets to borrow (i.e 50 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good) AaveCollateralDepositCondition \u00b6 Implementation of the Aave Collateral Deposit Condition This condition allows a Lender to deposit the collateral that into account the royalties to be paid to the original creators in a secondary market. aaveCreditVault \u00b6 contract AaveCreditVault aaveCreditVault CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , address _vaultAddress , address _collateralAsset , uint256 _collateralAmount , address _delegatedAsset , uint256 _delegatedAmount , uint256 _interestRateMode ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the ERC-20 that will be used as collateral (i.e WETH) _collateralAmount uint256 the amount of the ERC-20 that will be used as collateral (i.e 10 WETH) _delegatedAsset address the address of the ERC-20 that will be delegated to the borrower (i.e DAI) _delegatedAmount uint256 the amount of the ERC-20 that will be delegated to the borrower (i.e 500 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _collateralAsset , uint256 _collateralAmount , address _delegatedAsset , uint256 _delegatedAmount , uint256 _interestRateMode ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) It fulfills the condition if the collateral can be deposited into the vault Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the ERC-20 that will be used as collateral (i.e WETH) _collateralAmount uint256 the amount of the ERC-20 that will be used as collateral (i.e 10 WETH) _delegatedAsset address the address of the ERC-20 that will be delegated to the borrower (i.e DAI) _delegatedAmount uint256 the amount of the ERC-20 that will be delegated to the borrower (i.e 500 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good) AaveCollateralWithdrawCondition \u00b6 Implementation of the Collateral Withdraw Condition This condition allows to credit delegator withdraw the collateral and fees after the agreement expiration aaveCreditVault \u00b6 contract AaveCreditVault aaveCreditVault CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , address _vaultAddress , address _collateralAsset ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the asset used as collateral (i.e DAI) Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _collateralAsset ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) It allows the borrower to repay the loan Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the asset used as collateral (i.e DAI) Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good) AaveCreditVault \u00b6 lendingPool \u00b6 contract ILendingPool lendingPool dataProvider \u00b6 contract IProtocolDataProvider dataProvider weth \u00b6 contract IWETHGateway weth addressProvider \u00b6 contract ILendingPoolAddressesProvider addressProvider priceOracle \u00b6 contract IPriceOracleGetter priceOracle borrowedAsset \u00b6 address borrowedAsset borrowedAmount \u00b6 uint256 borrowedAmount nvmFee \u00b6 uint256 nvmFee agreementFee \u00b6 uint256 agreementFee FEE_BASE \u00b6 uint256 FEE_BASE treasuryAddress \u00b6 address treasuryAddress borrower \u00b6 address borrower lender \u00b6 address lender repayConditionId \u00b6 bytes32 repayConditionId nftId \u00b6 uint256 nftId nftAddress \u00b6 address nftAddress BORROWER_ROLE \u00b6 bytes32 BORROWER_ROLE LENDER_ROLE \u00b6 bytes32 LENDER_ROLE CONDITION_ROLE \u00b6 bytes32 CONDITION_ROLE initialize \u00b6 function initialize ( address _lendingPool , address _dataProvider , address _weth , uint256 _nvmFee , uint256 _agreementFee , address _treasuryAddress , address _borrower , address _lender , address [] _conditions ) public Vault constructor, creates a unique vault for each agreement Name Type Description _lendingPool address Aave lending pool address _dataProvider address Aave data provider address _weth address WETH address _nvmFee uint256 Nevermined fee that will apply to this agreeement _agreementFee uint256 Agreement fee that lender will receive on agreement maturity _treasuryAddress address Address of nevermined contract to store fees _borrower address _lender address _conditions address[] isLender \u00b6 function isLender ( address _address ) public view returns ( bool ) isBorrower \u00b6 function isBorrower ( address _address ) public view returns ( bool ) deposit \u00b6 function deposit ( address _collateralAsset , uint256 _amount ) public payable Deposit function. Receives the funds from the delegator and deposits the funds in the Aave contracts Name Type Description _collateralAsset address collateral asset that will be deposit on Aave _amount uint256 Amount of collateral to deposit approveBorrower \u00b6 function approveBorrower ( address _borrower , uint256 _amount , address _asset , uint256 _interestRateMode ) public Appproves delegatee to borrow funds from Aave on behalf of delegator Name Type Description _borrower address delegatee that will borrow the funds _amount uint256 Amount of funds to delegate _asset address Asset to delegate the borrow _interestRateMode uint256 interest rate type stable 1, variable 2 delegatedAmount \u00b6 function delegatedAmount ( address _borrower , address _asset , uint256 _interestRateMode ) public view returns ( uint256 ) Return the actual delegated amount for the borrower in the specific asset Name Type Description _borrower address The borrower of the funds (i.e. delgatee) _asset address The asset they are allowed to borrow _interestRateMode uint256 interest rate type stable 1, variable 2 borrow \u00b6 function borrow ( address _assetToBorrow , uint256 _amount , address _delgatee , uint256 _interestRateMode ) public Borrower can call this function to borrow the delegated funds Name Type Description _assetToBorrow address The asset they are allowed to borrow _amount uint256 Amount to borrow _delgatee address Address where the funds will be transfered _interestRateMode uint256 interest rate type stable 1, variable 2 repay \u00b6 function repay ( address _asset , uint256 _interestRateMode , bytes32 _repayConditionId ) public Repay an uncollaterised loan Name Type Description _asset address The asset to be repaid _interestRateMode uint256 interest rate type stable 1, variable 2 _repayConditionId bytes32 identifier of the condition id working as lock for other vault methods setRepayConditionId \u00b6 function setRepayConditionId ( bytes32 _repayConditionId ) public getBorrowedAmount \u00b6 function getBorrowedAmount () public view returns ( uint256 ) Returns the borrowed amount from the delegatee on this agreement getAssetPrice \u00b6 function getAssetPrice ( address _asset ) public view returns ( uint256 ) Returns the priceof the asset in the Aave oracles Name Type Description _asset address The asset to get the actual price getCreditAssetDebt \u00b6 function getCreditAssetDebt () public view returns ( uint256 ) Returns the total debt of the credit in the Aave protocol expressed in token units getActualCreditDebt \u00b6 function getActualCreditDebt () public view returns ( uint256 ) Returns the total debt of the credit in the Aave protocol expressed in ETH units getTotalActualDebt \u00b6 function getTotalActualDebt () public view returns ( uint256 ) Returns the total actual debt of the agreement credit + fees in token units withdrawCollateral \u00b6 function withdrawCollateral ( address _asset , address _delegator ) public Withdraw all of a collateral as the underlying asset, if no outstanding loans delegated Name Type Description _asset address The underlying asset to withdraw _delegator address Delegator address that deposited the collateral transferNFT \u00b6 function transferNFT ( uint256 _tokenId , address _receiver ) public Transfer a NFT (ERC-721) locked into the vault to a receiver address Name Type Description _tokenId uint256 the token id _receiver address the receiver adddress _transferERC20 \u00b6 function _transferERC20 ( address _collateralAsset , uint256 _amount ) internal Transfers the ERC20 token deposited to the Aave contracts Name Type Description _collateralAsset address collateral asset that will be deposit on Aave _amount uint256 Amount of collateral to deposit onERC721Received \u00b6 function onERC721Received ( address , address , uint256 _tokenId , bytes ) public virtual returns ( bytes4 ) Handle the receipt of an NFT _The ERC721 smart contract calls this function on the recipient after a {IERC721-safeTransferFrom}. This function MUST return the function selector, otherwise the caller will revert the transaction. Note: the ERC721 contract address is always the message sender. (param not used): operator The address which called safeTransferFrom function (param not used): from The address which previously owned the token_ Name Type Description address address _tokenId uint256 The NFT identifier which is being transferred (param not used): data Additional data with no specified format bytes Name Type Description [0] bytes4 bytes4 bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")) AaveRepayCondition \u00b6 Implementation of the Aave Repay Condition This condition allows to a borrower to repay a credit as part of a credit template aaveCreditVault \u00b6 contract AaveCreditVault aaveCreditVault CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , address _vaultAddress , address _assetToRepay , uint256 _amountToRepay , uint256 _interestRateMode ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToRepay address the address of the asset to repay (i.e DAI) _amountToRepay uint256 Amount to repay _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _assetToRepay , uint256 _amountToRepay , uint256 _interestRateMode ) external returns ( enum ConditionStoreLibrary . ConditionState ) It allows the borrower to repay the loan Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToRepay address the address of the asset to repay (i.e DAI) _amountToRepay uint256 Amount to repay _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good) EscrowPaymentCondition \u00b6 _Implementation of the Escrow Payment Condition The Escrow payment is reward condition in which only can release reward if lock and release conditions are fulfilled._ CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE USED_PAYMENT_ID \u00b6 bytes32 USED_PAYMENT_ID Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , address _tokenAddress , address [] _receivers , bytes32 _conditionId , uint256 [] _amounts ) Received \u00b6 event Received ( address _from , uint256 _value ) receive \u00b6 receive () external payable initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValuesMulti \u00b6 function hashValuesMulti ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values encodeParams \u00b6 function encodeParams ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public pure returns ( bytes ) hashValues \u00b6 function hashValues ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 _releaseCondition ) public pure returns ( bytes32 ) hashValuesLockPayment \u00b6 function hashValuesLockPayment ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public pure returns ( bytes32 ) hashValuesLockPayment generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values fulfillMulti \u00b6 function fulfillMulti ( bytes32 _agreementId , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill escrow reward condition fulfill method checks whether the lock and release conditions are fulfilled in order to release/refund the reward to receiver/sender respectively. Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) Args \u00b6 struct Args { bytes32 _agreementId ; bytes32 _did ; uint256 [] _amounts ; address [] _receivers ; address _returnAddress ; address _lockPaymentAddress ; address _tokenAddress ; bytes32 _lockCondition ; bytes32 [] _releaseConditions ; } fulfillKludge \u00b6 function fulfillKludge ( struct EscrowPaymentCondition . Args a ) internal returns ( enum ConditionStoreLibrary . ConditionState ) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 _releaseCondition ) external returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfillERC20 \u00b6 function _transferAndFulfillERC20 ( bytes32 _id , address _tokenAddress , address [] _receivers , uint256 [] _amounts ) private returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfill transfer ERC20 tokens and fulfill the condition Name Type Description _id bytes32 condition identifier _tokenAddress address the ERC20 contract address to use during the payment _receivers address[] receiver's address _amounts uint256[] token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) _transferAndFulfillETH \u00b6 function _transferAndFulfillETH ( bytes32 _id , address [] _receivers , uint256 [] _amounts ) private returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfill transfer ETH and fulfill the condition Name Type Description _id bytes32 condition identifier _receivers address[] receiver's address _amounts uint256[] token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) INFTEscrow \u00b6 Common interface for ERC-721 and ERC-1155 Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , address _tokenAddress , bytes32 _did , address _receivers , bytes32 _conditionId , uint256 _amounts ) NFT721EscrowPaymentCondition \u00b6 _Implementation of the Escrow Payment Condition The Escrow payment is reward condition in which only can release reward if lock and release conditions are fulfilled._ CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE Received \u00b6 event Received ( address _from , uint256 _value ) receive \u00b6 receive () external payable initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , uint256 _amounts , address _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 asset decentralized identifier _amounts uint256 token amounts to be locked/released _receivers address receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values hashValuesLockPayment \u00b6 function hashValuesLockPayment ( bytes32 _did , address _lockAddress , address _nftContractAddress , uint256 _amount , address _receiver ) public pure returns ( bytes32 ) hashValuesLockPayment generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _lockAddress address the contract address where the reward is locked _nftContractAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amount uint256 token amounts to be locked/released _receiver address receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , uint256 _amount , address _receiver , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill escrow reward condition fulfill method checks whether the lock and release conditions are fulfilled in order to release/refund the reward to receiver/sender respectively. Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amount uint256 token amounts to be locked/released _receiver address receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) Args \u00b6 struct Args { bytes32 _agreementId ; bytes32 _did ; uint256 _amount ; address _receiver ; address _returnAddress ; address _lockPaymentAddress ; address _tokenAddress ; bytes32 _lockCondition ; bytes32 [] _releaseConditions ; } fulfillKludge \u00b6 function fulfillKludge ( struct NFT721EscrowPaymentCondition . Args a ) internal returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfillNFT \u00b6 function _transferAndFulfillNFT ( bytes32 _agreementId , bytes32 _id , bytes32 _did , address _tokenAddress , address _receiver , uint256 _amount ) private returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfill transfer ERC20 tokens and fulfill the condition Name Type Description _agreementId bytes32 _id bytes32 condition identifier _did bytes32 _tokenAddress address the ERC20 contract address to use during the payment _receiver address receiver's address _amount uint256 token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) onERC721Received \u00b6 function onERC721Received ( address , address , uint256 , bytes ) public virtual returns ( bytes4 ) NFTEscrowPaymentCondition \u00b6 _Implementation of the Escrow Payment Condition The Escrow payment is reward condition in which only can release reward if lock and release conditions are fulfilled._ CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE LOCK_CONDITION_TYPE \u00b6 bytes32 LOCK_CONDITION_TYPE Received \u00b6 event Received ( address _from , uint256 _value ) receive \u00b6 receive () external payable initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , uint256 _amounts , address _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 asset decentralized identifier _amounts uint256 token amounts to be locked/released _receivers address receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values hashValuesLockPayment \u00b6 function hashValuesLockPayment ( bytes32 _did , address _lockAddress , address _nftContractAddress , uint256 _amount , address _receiver ) public pure returns ( bytes32 ) hashValuesLockPayment generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _lockAddress address the contract address where the reward is locked _nftContractAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amount uint256 token amounts to be locked/released _receiver address receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , uint256 _amount , address _receiver , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill escrow reward condition fulfill method checks whether the lock and release conditions are fulfilled in order to release/refund the reward to receiver/sender respectively. Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amount uint256 token amounts to be locked/released _receiver address receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) Args \u00b6 struct Args { bytes32 _agreementId ; bytes32 _did ; uint256 _amount ; address _receiver ; address _returnAddress ; address _lockPaymentAddress ; address _tokenAddress ; bytes32 _lockCondition ; bytes32 [] _releaseConditions ; } fulfillKludge \u00b6 function fulfillKludge ( struct NFTEscrowPaymentCondition . Args a ) internal returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfillNFT \u00b6 function _transferAndFulfillNFT ( bytes32 _agreementId , bytes32 _id , bytes32 _did , address _tokenAddress , address _receiver , uint256 _amount ) private returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfill transfer ERC20 tokens and fulfill the condition Name Type Description _agreementId bytes32 _id bytes32 condition identifier _did bytes32 _tokenAddress address the ERC20 contract address to use during the payment _receiver address receiver's address _amount uint256 token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) ERC1155_ACCEPTED \u00b6 bytes4 ERC1155_ACCEPTED ERC1155_BATCH_ACCEPTED \u00b6 bytes4 ERC1155_BATCH_ACCEPTED onERC1155Received \u00b6 function onERC1155Received ( address , address , uint256 , uint256 , bytes ) external pure returns ( bytes4 ) onERC1155BatchReceived \u00b6 function onERC1155BatchReceived ( address , address , uint256 [], uint256 [], bytes ) external pure returns ( bytes4 ) supportsInterface \u00b6 function supportsInterface ( bytes4 interfaceId ) external pure returns ( bool ) _Returns true if this contract implements the interface defined by interfaceId . See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas._ Reward \u00b6 _Implementation of the Reward. Generic reward condition_ INVMConfig \u00b6 GOVERNOR_ROLE \u00b6 bytes32 GOVERNOR_ROLE NeverminedConfigChange \u00b6 event NeverminedConfigChange ( address _whoChanged , bytes32 _parameter ) Event that is emitted when a parameter is changed Name Type Description _whoChanged address the address of the governor changing the parameter _parameter bytes32 the hash of the name of the parameter changed initialize \u00b6 function initialize ( address _owner , address _governor ) external virtual Used to initialize the contract during delegator constructor Name Type Description _owner address The owner of the contract _governor address The address to be granted with the GOVERNOR_ROLE setMarketplaceFees \u00b6 function setMarketplaceFees ( uint256 _marketplaceFee , address _feeReceiver ) external virtual The governor can update the Nevermined Marketplace fees Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee isGovernor \u00b6 function isGovernor ( address _address ) external view virtual returns ( bool ) Indicates if an address is a having the GOVERNOR role Name Type Description _address address The address to validate Name Type Description [0] bool true if is a governor getMarketplaceFee \u00b6 function getMarketplaceFee () external view virtual returns ( uint256 ) Returns the marketplace fee Name Type Description [0] uint256 the marketplace fee getFeeReceiver \u00b6 function getFeeReceiver () external view virtual returns ( address ) Returns the receiver address of the marketplace fee Name Type Description [0] address the receiver address NeverminedConfig \u00b6 marketplaceFee \u00b6 uint256 marketplaceFee feeReceiver \u00b6 address feeReceiver initialize \u00b6 function initialize ( address _owner , address _governor ) public Used to initialize the contract during delegator constructor Name Type Description _owner address The owner of the contract _governor address The address to be granted with the GOVERNOR_ROLE setMarketplaceFees \u00b6 function setMarketplaceFees ( uint256 _marketplaceFee , address _feeReceiver ) external virtual The governor can update the Nevermined Marketplace fees Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee setGovernor \u00b6 function setGovernor ( address _address ) external isGovernor \u00b6 function isGovernor ( address _address ) external view returns ( bool ) Indicates if an address is a having the GOVERNOR role Name Type Description _address address The address to validate Name Type Description [0] bool true if is a governor getMarketplaceFee \u00b6 function getMarketplaceFee () external view returns ( uint256 ) Returns the marketplace fee Name Type Description [0] uint256 the marketplace fee getFeeReceiver \u00b6 function getFeeReceiver () external view returns ( address ) Returns the receiver address of the marketplace fee Name Type Description [0] address the receiver address onlyGovernor \u00b6 modifier onlyGovernor ( address _address ) IERC20 \u00b6 totalSupply \u00b6 function totalSupply () external view returns ( uint256 ) Returns the amount of tokens in existence. balanceOf \u00b6 function balanceOf ( address account ) external view returns ( uint256 ) Returns the amount of tokens owned by account . transfer \u00b6 function transfer ( address recipient , uint256 amount ) external returns ( bool ) _Moves amount tokens from the caller's account to recipient . Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event._ allowance \u00b6 function allowance ( address owner , address spender ) external view returns ( uint256 ) _Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called._ approve \u00b6 function approve ( address spender , uint256 amount ) external returns ( bool ) _Sets amount as the allowance of spender over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event._ transferFrom \u00b6 function transferFrom ( address sender , address recipient , uint256 amount ) external returns ( bool ) _Moves amount tokens from sender to recipient using the allowance mechanism. amount is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event._ Transfer \u00b6 event Transfer ( address from , address to , uint256 value ) _Emitted when value tokens are moved from one account ( from ) to another ( to ). Note that value may be zero._ Approval \u00b6 event Approval ( address owner , address spender , uint256 value ) Emitted when the allowance of a spender for an owner is set by a call to {approve}. value is the new allowance. IPriceOracleGetter \u00b6 Interface for the Aave price oracle. getAssetPrice \u00b6 function getAssetPrice ( address asset ) external view returns ( uint256 ) returns the asset price in ETH Name Type Description asset address the address of the asset Name Type Description [0] uint256 the ETH price of the asset IProtocolDataProvider \u00b6 TokenData \u00b6 struct TokenData { string symbol ; address tokenAddress ; } ADDRESSES_PROVIDER \u00b6 function ADDRESSES_PROVIDER () external view returns ( contract ILendingPoolAddressesProvider ) getAllReservesTokens \u00b6 function getAllReservesTokens () external view returns ( struct IProtocolDataProvider . TokenData []) getAllATokens \u00b6 function getAllATokens () external view returns ( struct IProtocolDataProvider . TokenData []) getReserveConfigurationData \u00b6 function getReserveConfigurationData ( address asset ) external view returns ( uint256 decimals , uint256 ltv , uint256 liquidationThreshold , uint256 liquidationBonus , uint256 reserveFactor , bool usageAsCollateralEnabled , bool borrowingEnabled , bool stableBorrowRateEnabled , bool isActive , bool isFrozen ) getReserveData \u00b6 function getReserveData ( address asset ) external view returns ( uint256 availableLiquidity , uint256 totalStableDebt , uint256 totalVariableDebt , uint256 liquidityRate , uint256 variableBorrowRate , uint256 stableBorrowRate , uint256 averageStableBorrowRate , uint256 liquidityIndex , uint256 variableBorrowIndex , uint40 lastUpdateTimestamp ) getUserReserveData \u00b6 function getUserReserveData ( address asset , address user ) external view returns ( uint256 currentATokenBalance , uint256 currentStableDebt , uint256 currentVariableDebt , uint256 principalStableDebt , uint256 scaledVariableDebt , uint256 stableBorrowRate , uint256 liquidityRate , uint40 stableRateLastUpdated , bool usageAsCollateralEnabled ) getReserveTokensAddresses \u00b6 function getReserveTokensAddresses ( address asset ) external view returns ( address aTokenAddress , address stableDebtTokenAddress , address variableDebtTokenAddress ) ILendingPoolAddressesProvider \u00b6 MarketIdSet \u00b6 event MarketIdSet ( string newMarketId ) LendingPoolUpdated \u00b6 event LendingPoolUpdated ( address newAddress ) ConfigurationAdminUpdated \u00b6 event ConfigurationAdminUpdated ( address newAddress ) EmergencyAdminUpdated \u00b6 event EmergencyAdminUpdated ( address newAddress ) LendingPoolConfiguratorUpdated \u00b6 event LendingPoolConfiguratorUpdated ( address newAddress ) LendingPoolCollateralManagerUpdated \u00b6 event LendingPoolCollateralManagerUpdated ( address newAddress ) PriceOracleUpdated \u00b6 event PriceOracleUpdated ( address newAddress ) LendingRateOracleUpdated \u00b6 event LendingRateOracleUpdated ( address newAddress ) ProxyCreated \u00b6 event ProxyCreated ( bytes32 id , address newAddress ) AddressSet \u00b6 event AddressSet ( bytes32 id , address newAddress , bool hasProxy ) getMarketId \u00b6 function getMarketId () external view returns ( string ) setMarketId \u00b6 function setMarketId ( string marketId ) external setAddress \u00b6 function setAddress ( bytes32 id , address newAddress ) external setAddressAsProxy \u00b6 function setAddressAsProxy ( bytes32 id , address impl ) external getAddress \u00b6 function getAddress ( bytes32 id ) external view returns ( address ) getLendingPool \u00b6 function getLendingPool () external view returns ( address ) setLendingPoolImpl \u00b6 function setLendingPoolImpl ( address pool ) external getLendingPoolConfigurator \u00b6 function getLendingPoolConfigurator () external view returns ( address ) setLendingPoolConfiguratorImpl \u00b6 function setLendingPoolConfiguratorImpl ( address configurator ) external getLendingPoolCollateralManager \u00b6 function getLendingPoolCollateralManager () external view returns ( address ) setLendingPoolCollateralManager \u00b6 function setLendingPoolCollateralManager ( address manager ) external getPoolAdmin \u00b6 function getPoolAdmin () external view returns ( address ) setPoolAdmin \u00b6 function setPoolAdmin ( address admin ) external getEmergencyAdmin \u00b6 function getEmergencyAdmin () external view returns ( address ) setEmergencyAdmin \u00b6 function setEmergencyAdmin ( address admin ) external getPriceOracle \u00b6 function getPriceOracle () external view returns ( address ) setPriceOracle \u00b6 function setPriceOracle ( address priceOracle ) external getLendingRateOracle \u00b6 function getLendingRateOracle () external view returns ( address ) setLendingRateOracle \u00b6 function setLendingRateOracle ( address lendingRateOracle ) external ILendingPool \u00b6 Deposit \u00b6 event Deposit ( address reserve , address user , address onBehalfOf , uint256 amount , uint16 referral ) Emitted on deposit() Name Type Description reserve address The address of the underlying asset of the reserve user address The address initiating the deposit onBehalfOf address The beneficiary of the deposit, receiving the aTokens amount uint256 The amount deposited referral uint16 The referral code used Withdraw \u00b6 event Withdraw ( address reserve , address user , address to , uint256 amount ) Emitted on withdraw() Name Type Description reserve address The address of the underlyng asset being withdrawn user address The address initiating the withdrawal, owner of aTokens to address Address that will receive the underlying amount uint256 The amount to be withdrawn Borrow \u00b6 event Borrow ( address reserve , address user , address onBehalfOf , uint256 amount , uint256 borrowRateMode , uint256 borrowRate , uint16 referral ) Emitted on borrow() and flashLoan() when debt needs to be opened Name Type Description reserve address The address of the underlying asset being borrowed user address The address of the user initiating the borrow(), receiving the funds on borrow() or just initiator of the transaction on flashLoan() onBehalfOf address The address that will be getting the debt amount uint256 The amount borrowed out borrowRateMode uint256 The rate mode: 1 for Stable, 2 for Variable borrowRate uint256 The numeric rate at which the user has borrowed referral uint16 The referral code used Repay \u00b6 event Repay ( address reserve , address user , address repayer , uint256 amount ) Emitted on repay() Name Type Description reserve address The address of the underlying asset of the reserve user address The beneficiary of the repayment, getting his debt reduced repayer address The address of the user initiating the repay(), providing the funds amount uint256 The amount repaid Swap \u00b6 event Swap ( address reserve , address user , uint256 rateMode ) Emitted on swapBorrowRateMode() Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user swapping his rate mode rateMode uint256 The rate mode that the user wants to swap to ReserveUsedAsCollateralEnabled \u00b6 event ReserveUsedAsCollateralEnabled ( address reserve , address user ) Emitted on setUserUseReserveAsCollateral() Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user enabling the usage as collateral ReserveUsedAsCollateralDisabled \u00b6 event ReserveUsedAsCollateralDisabled ( address reserve , address user ) Emitted on setUserUseReserveAsCollateral() Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user enabling the usage as collateral RebalanceStableBorrowRate \u00b6 event RebalanceStableBorrowRate ( address reserve , address user ) Emitted on rebalanceStableBorrowRate() Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user for which the rebalance has been executed FlashLoan \u00b6 event FlashLoan ( address target , address initiator , address asset , uint256 amount , uint256 premium , uint16 referralCode ) Emitted on flashLoan() Name Type Description target address The address of the flash loan receiver contract initiator address The address initiating the flash loan asset address The address of the asset being flash borrowed amount uint256 The amount flash borrowed premium uint256 The fee flash borrowed referralCode uint16 The referral code used Paused \u00b6 event Paused () Emitted when the pause is triggered. Unpaused \u00b6 event Unpaused () Emitted when the pause is lifted. LiquidationCall \u00b6 event LiquidationCall ( address collateralAsset , address debtAsset , address user , uint256 debtToCover , uint256 liquidatedCollateralAmount , address liquidator , bool receiveAToken ) Emitted when a borrower is liquidated. This event is emitted by the LendingPool via LendingPoolCollateral manager using a DELEGATECALL This allows to have the events in the generated ABI for LendingPool. Name Type Description collateralAsset address The address of the underlying asset used as collateral, to receive as result of the liquidation debtAsset address The address of the underlying borrowed asset to be repaid with the liquidation user address The address of the borrower getting liquidated debtToCover uint256 The debt amount of borrowed asset the liquidator wants to cover liquidatedCollateralAmount uint256 The amount of collateral received by the liiquidator liquidator address The address of the liquidator receiveAToken bool true if the liquidators wants to receive the collateral aTokens, false if he wants to receive the underlying collateral asset directly ReserveDataUpdated \u00b6 event ReserveDataUpdated ( address reserve , uint256 liquidityRate , uint256 stableBorrowRate , uint256 variableBorrowRate , uint256 liquidityIndex , uint256 variableBorrowIndex ) Emitted when the state of a reserve is updated. NOTE: This event is actually declared in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal, the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it gets added to the LendingPool ABI Name Type Description reserve address The address of the underlying asset of the reserve liquidityRate uint256 The new liquidity rate stableBorrowRate uint256 The new stable borrow rate variableBorrowRate uint256 The new variable borrow rate liquidityIndex uint256 The new liquidity index variableBorrowIndex uint256 The new variable borrow index deposit \u00b6 function deposit ( address asset , uint256 amount , address onBehalfOf , uint16 referralCode ) external Deposits an amount of underlying asset into the reserve, receiving in return overlying aTokens. - E.g. User deposits 100 USDC and gets in return 100 aUSDC Name Type Description asset address The address of the underlying asset to deposit amount uint256 The amount to be deposited onBehalfOf address The address that will receive the aTokens, same as msg.sender if the user wants to receive them on his own wallet, or a different address if the beneficiary of aTokens is a different wallet referralCode uint16 Code used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-man withdraw \u00b6 function withdraw ( address asset , uint256 amount , address to ) external returns ( uint256 ) Withdraws an amount of underlying asset from the reserve, burning the equivalent aTokens owned E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC Name Type Description asset address The address of the underlying asset to withdraw amount uint256 The underlying amount to be withdrawn - Send the value type(uint256).max in order to withdraw the whole aToken balance to address Address that will receive the underlying, same as msg.sender if the user wants to receive it on his own wallet, or a different address if the beneficiary is a different wallet Name Type Description [0] uint256 The final amount withdrawn borrow \u00b6 function borrow ( address asset , uint256 amount , uint256 interestRateMode , uint16 referralCode , address onBehalfOf ) external Allows users to borrow a specific amount of the reserve underlying asset, provided that the borrower already deposited enough collateral, or he was given enough allowance by a credit delegator on the corresponding debt token (StableDebtToken or VariableDebtToken) - E.g. User borrows 100 USDC passing as onBehalfOf his own address, receiving the 100 USDC in his wallet and 100 stable/variable debt tokens, depending on the interestRateMode Name Type Description asset address The address of the underlying asset to borrow amount uint256 The amount to be borrowed interestRateMode uint256 The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable referralCode uint16 Code used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-man onBehalfOf address Address of the user who will receive the debt. Should be the address of the borrower itself calling the function if he wants to borrow against his own collateral, or the address of the credit delegator if he has been given credit delegation allowance repay \u00b6 function repay ( address asset , uint256 amount , uint256 rateMode , address onBehalfOf ) external returns ( uint256 ) Repays a borrowed amount on a specific reserve, burning the equivalent debt tokens owned - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the onBehalfOf address Name Type Description asset address The address of the borrowed underlying asset previously borrowed amount uint256 The amount to repay - Send the value type(uint256).max in order to repay the whole debt for asset on the specific debtMode rateMode uint256 The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable onBehalfOf address Address of the user who will get his debt reduced/removed. Should be the address of the user calling the function if he wants to reduce/remove his own debt, or the address of any other other borrower whose debt should be removed Name Type Description [0] uint256 The final amount repaid swapBorrowRateMode \u00b6 function swapBorrowRateMode ( address asset , uint256 rateMode ) external Allows a borrower to swap his debt between stable and variable mode, or viceversa Name Type Description asset address The address of the underlying asset borrowed rateMode uint256 The rate mode that the user wants to swap to rebalanceStableBorrowRate \u00b6 function rebalanceStableBorrowRate ( address asset , address user ) external Rebalances the stable interest rate of a user to the current stable rate defined on the reserve. - Users can be rebalanced if the following conditions are satisfied: 1. Usage ratio is above 95% 2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been borrowed at a stable rate and depositors are not earning enough Name Type Description asset address The address of the underlying asset borrowed user address The address of the user to be rebalanced setUserUseReserveAsCollateral \u00b6 function setUserUseReserveAsCollateral ( address asset , bool useAsCollateral ) external Allows depositors to enable/disable a specific deposited asset as collateral Name Type Description asset address The address of the underlying asset deposited useAsCollateral bool true if the user wants to use the deposit as collateral, false otherwise liquidationCall \u00b6 function liquidationCall ( address collateralAsset , address debtAsset , address user , uint256 debtToCover , bool receiveAToken ) external Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1 - The caller (liquidator) covers debtToCover amount of debt of the user getting liquidated, and receives a proportionally amount of the collateralAsset plus a bonus to cover market risk Name Type Description collateralAsset address The address of the underlying asset used as collateral, to receive as result of the liquidation debtAsset address The address of the underlying borrowed asset to be repaid with the liquidation user address The address of the borrower getting liquidated debtToCover uint256 The debt amount of borrowed asset the liquidator wants to cover receiveAToken bool true if the liquidators wants to receive the collateral aTokens, false if he wants to receive the underlying collateral asset directly flashLoan \u00b6 function flashLoan ( address receiverAddress , address [] assets , uint256 [] amounts , uint256 [] modes , address onBehalfOf , bytes params , uint16 referralCode ) external Allows smartcontracts to access the liquidity of the pool within one transaction, as long as the amount taken plus a fee is returned. IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration. For further details please visit https://developers.aave.com Name Type Description receiverAddress address The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface assets address[] The addresses of the assets being flash-borrowed amounts uint256[] The amounts amounts being flash-borrowed modes uint256[] Types of the debt to open if the flash loan is not returned: 0 -> Don't open any debt, just revert if funds can't be transferred from the receiver 1 -> Open debt at stable rate for the value of the amount flash-borrowed to the onBehalfOf address 2 -> Open debt at variable rate for the value of the amount flash-borrowed to the onBehalfOf address onBehalfOf address The address that will receive the debt in the case of using on modes 1 or 2 params bytes Variadic packed params to pass to the receiver as extra information referralCode uint16 Code used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-man getUserAccountData \u00b6 function getUserAccountData ( address user ) external view returns ( uint256 totalCollateralETH , uint256 totalDebtETH , uint256 availableBorrowsETH , uint256 currentLiquidationThreshold , uint256 ltv , uint256 healthFactor ) Returns the user account data across all the reserves Name Type Description user address The address of the user Name Type Description totalCollateralETH uint256 the total collateral in ETH of the user totalDebtETH uint256 the total debt in ETH of the user availableBorrowsETH uint256 the borrowing power left of the user currentLiquidationThreshold uint256 the liquidation threshold of the user ltv uint256 the loan to value of the user healthFactor uint256 the current health factor of the user initReserve \u00b6 function initReserve ( address reserve , address aTokenAddress , address stableDebtAddress , address variableDebtAddress , address interestRateStrategyAddress ) external setReserveInterestRateStrategyAddress \u00b6 function setReserveInterestRateStrategyAddress ( address reserve , address rateStrategyAddress ) external setConfiguration \u00b6 function setConfiguration ( address reserve , uint256 configuration ) external getConfiguration \u00b6 function getConfiguration ( address asset ) external view returns ( struct DataTypes . ReserveConfigurationMap ) Returns the configuration of the reserve Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] struct DataTypes.ReserveConfigurationMap The configuration of the reserve getUserConfiguration \u00b6 function getUserConfiguration ( address user ) external view returns ( struct DataTypes . UserConfigurationMap ) Returns the configuration of the user across all the reserves Name Type Description user address The user address Name Type Description [0] struct DataTypes.UserConfigurationMap The configuration of the user getReserveNormalizedIncome \u00b6 function getReserveNormalizedIncome ( address asset ) external view returns ( uint256 ) Returns the normalized income normalized income of the reserve Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] uint256 The reserve's normalized income getReserveNormalizedVariableDebt \u00b6 function getReserveNormalizedVariableDebt ( address asset ) external view returns ( uint256 ) Returns the normalized variable debt per unit of asset Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] uint256 The reserve normalized variable debt getReserveData \u00b6 function getReserveData ( address asset ) external view returns ( struct DataTypes . ReserveData ) Returns the state and configuration of the reserve Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] struct DataTypes.ReserveData The state of the reserve finalizeTransfer \u00b6 function finalizeTransfer ( address asset , address from , address to , uint256 amount , uint256 balanceFromAfter , uint256 balanceToBefore ) external getReservesList \u00b6 function getReservesList () external view returns ( address []) getAddressesProvider \u00b6 function getAddressesProvider () external view returns ( contract ILendingPoolAddressesProvider ) setPause \u00b6 function setPause ( bool val ) external paused \u00b6 function paused () external view returns ( bool ) IStableDebtToken \u00b6 Mint \u00b6 event Mint ( address user , address onBehalfOf , uint256 amount , uint256 currentBalance , uint256 balanceIncrease , uint256 newRate , uint256 avgStableRate , uint256 newTotalSupply ) Emitted when new stable debt is minted Name Type Description user address The address of the user who triggered the minting onBehalfOf address The recipient of stable debt tokens amount uint256 The amount minted currentBalance uint256 The current balance of the user balanceIncrease uint256 The increase in balance since the last action of the user newRate uint256 The rate of the debt after the minting avgStableRate uint256 The new average stable rate after the minting newTotalSupply uint256 The new total supply of the stable debt token after the action Burn \u00b6 event Burn ( address user , uint256 amount , uint256 currentBalance , uint256 balanceIncrease , uint256 avgStableRate , uint256 newTotalSupply ) Emitted when new stable debt is burned Name Type Description user address The address of the user amount uint256 The amount being burned currentBalance uint256 The current balance of the user balanceIncrease uint256 The the increase in balance since the last action of the user avgStableRate uint256 The new average stable rate after the burning newTotalSupply uint256 The new total supply of the stable debt token after the action approveDelegation \u00b6 function approveDelegation ( address delegatee , uint256 amount ) external delegates borrowing power to a user on the specific debt token Name Type Description delegatee address the address receiving the delegated borrowing power amount uint256 the maximum amount being delegated. Delegation will still respect the liquidation constraints (even if delegated, a delegatee cannot force a delegator HF to go below 1) borrowAllowance \u00b6 function borrowAllowance ( address fromUser , address toUser ) external view returns ( uint256 ) returns the borrow allowance of the user Name Type Description fromUser address The user to giving allowance toUser address The user to give allowance to Name Type Description [0] uint256 the current allowance of toUser mint \u00b6 function mint ( address user , address onBehalfOf , uint256 amount , uint256 rate ) external returns ( bool ) Mints debt token to the onBehalfOf address. - The resulting rate is the weighted average between the rate of the new debt and the rate of the previous debt Name Type Description user address The address receiving the borrowed underlying, being the delegatee in case of credit delegate, or same as onBehalfOf otherwise onBehalfOf address The address receiving the debt tokens amount uint256 The amount of debt tokens to mint rate uint256 The rate of the debt being minted burn \u00b6 function burn ( address user , uint256 amount ) external Burns debt of user - The resulting rate is the weighted average between the rate of the new debt and the rate of the previous debt Name Type Description user address The address of the user getting his debt burned amount uint256 The amount of debt tokens getting burned getAverageStableRate \u00b6 function getAverageStableRate () external view returns ( uint256 ) Returns the average rate of all the stable rate loans. Name Type Description [0] uint256 The average stable rate getUserStableRate \u00b6 function getUserStableRate ( address user ) external view returns ( uint256 ) Returns the stable rate of the user debt Name Type Description [0] uint256 The stable rate of the user getUserLastUpdated \u00b6 function getUserLastUpdated ( address user ) external view returns ( uint40 ) Returns the timestamp of the last update of the user Name Type Description [0] uint40 The timestamp getSupplyData \u00b6 function getSupplyData () external view returns ( uint256 , uint256 , uint256 , uint40 ) Returns the principal, the total supply and the average stable rate getTotalSupplyLastUpdated \u00b6 function getTotalSupplyLastUpdated () external view returns ( uint40 ) Returns the timestamp of the last update of the total supply Name Type Description [0] uint40 The timestamp getTotalSupplyAndAvgRate \u00b6 function getTotalSupplyAndAvgRate () external view returns ( uint256 , uint256 ) Returns the total supply and the average stable rate principalBalanceOf \u00b6 function principalBalanceOf ( address user ) external view returns ( uint256 ) Returns the principal debt balance of the user Name Type Description [0] uint256 The debt balance of the user since the last burn/mint action IDynamicPricing \u00b6 DynamicPricingState \u00b6 enum DynamicPricingState { NotStarted , Finished , InProgress , Aborted } getPricingType \u00b6 function getPricingType () external view returns ( bytes32 ) getPrice \u00b6 function getPrice ( bytes32 did ) external view returns ( uint256 ) getTokenAddress \u00b6 function getTokenAddress ( bytes32 did ) external view returns ( address ) getStatus \u00b6 function getStatus ( bytes32 did ) external view returns ( enum IDynamicPricing . DynamicPricingState , uint256 , address ) canBePurchased \u00b6 function canBePurchased ( bytes32 did ) external view returns ( bool ) withdraw \u00b6 function withdraw ( bytes32 did , address withdrawAddress ) external returns ( bool ) IList \u00b6 has \u00b6 function has ( bytes32 value ) external view returns ( bool ) has \u00b6 function has ( bytes32 value , bytes32 id ) external view returns ( bool ) IRoyaltyScheme \u00b6 check \u00b6 function check ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _tokenAddress ) external view returns ( bool ) check that royalties are correct Name Type Description _did bytes32 compute royalties for this DID _amounts uint256[] amounts in payment _receivers address[] receivers of payments _tokenAddress address payment token. zero address means native token (ether) ISecretStore \u00b6 checkPermissions \u00b6 function checkPermissions ( address user , bytes32 documentKeyId ) external view returns ( bool permissionGranted ) checkPermissions is called by Parity secret store ISecretStorePermission \u00b6 grantPermission \u00b6 function grantPermission ( address user , bytes32 documentKeyId ) external grantPermission is called only by documentKeyId Owner or provider renouncePermission \u00b6 function renouncePermission ( address user , bytes32 documentKeyId ) external renouncePermission is called only by documentKeyId Owner or provider IWETHGateway \u00b6 depositETH \u00b6 function depositETH ( address lendingPool , address onBehalfOf , uint16 referralCode ) external payable withdrawETH \u00b6 function withdrawETH ( address lendingPool , uint256 amount , address to ) external repayETH \u00b6 function repayETH ( address lendingPool , uint256 amount , uint256 rateMode , address onBehalfOf ) external payable borrowETH \u00b6 function borrowETH ( address lendingPool , uint256 amount , uint256 interesRateMode , uint16 referralCode ) external DataTypes \u00b6 ReserveData \u00b6 struct ReserveData { struct DataTypes . ReserveConfigurationMap configuration ; uint128 liquidityIndex ; uint128 variableBorrowIndex ; uint128 currentLiquidityRate ; uint128 currentVariableBorrowRate ; uint128 currentStableBorrowRate ; uint40 lastUpdateTimestamp ; address aTokenAddress ; address stableDebtTokenAddress ; address variableDebtTokenAddress ; address interestRateStrategyAddress ; uint8 id ; } ReserveConfigurationMap \u00b6 struct ReserveConfigurationMap { uint256 data ; } UserConfigurationMap \u00b6 struct UserConfigurationMap { uint256 data ; } InterestRateMode \u00b6 enum InterestRateMode { NONE , STABLE , VARIABLE } SafeMath \u00b6 add \u00b6 function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the addition of two unsigned integers, reverting on overflow. Counterpart to Solidity's + operator. Requirements: - Addition cannot overflow._ sub \u00b6 function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the subtraction of two unsigned integers, reverting on overflow (when the result is negative). Counterpart to Solidity's - operator. Requirements: - Subtraction cannot overflow._ sub \u00b6 function sub ( uint256 a , uint256 b , string errorMessage ) internal pure returns ( uint256 ) _Returns the subtraction of two unsigned integers, reverting with custom message on overflow (when the result is negative). Counterpart to Solidity's - operator. Requirements: - Subtraction cannot overflow._ mul \u00b6 function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the multiplication of two unsigned integers, reverting on overflow. Counterpart to Solidity's * operator. Requirements: - Multiplication cannot overflow._ div \u00b6 function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the integer division of two unsigned integers. Reverts on division by zero. The result is rounded towards zero. Counterpart to Solidity's / operator. Note: this function uses a revert opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas). Requirements: - The divisor cannot be zero._ div \u00b6 function div ( uint256 a , uint256 b , string errorMessage ) internal pure returns ( uint256 ) _Returns the integer division of two unsigned integers. Reverts with custom message on division by zero. The result is rounded towards zero. Counterpart to Solidity's / operator. Note: this function uses a revert opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas). Requirements: - The divisor cannot be zero._ mod \u00b6 function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), Reverts when dividing by zero. Counterpart to Solidity's % operator. This function uses a revert opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas). Requirements: - The divisor cannot be zero._ mod \u00b6 function mod ( uint256 a , uint256 b , string errorMessage ) internal pure returns ( uint256 ) _Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), Reverts with custom message when dividing by zero. Counterpart to Solidity's % operator. This function uses a revert opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas). Requirements: - The divisor cannot be zero._ Address \u00b6 isContract \u00b6 function isContract ( address account ) internal view returns ( bool ) _Returns true if account is a contract. [IMPORTANT] \u00b6 It is unsafe to assume that an address for which this function returns false is an externally-owned account (EOA) and not a contract. Among others, isContract will return false for the following types of addresses: an externally-owned account a contract in construction an address where a contract will be created an address where a contract lived, but was destroyed ====_ sendValue \u00b6 function sendValue ( address payable recipient , uint256 amount ) internal _Replacement for Solidity's transfer : sends amount wei to recipient , forwarding all available gas and reverting on errors. https://eips.ethereum.org/EIPS/eip-1884[EIP1884 ] increases the gas cost of certain opcodes, possibly making contracts go over the 2300 gas limit imposed by transfer , making them unable to receive funds via transfer . {sendValue} removes this limitation. https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. IMPORTANT: because control is transferred to recipient , care must be taken to not create reentrancy vulnerabilities. Consider using {ReentrancyGuard} or the https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern]._ SafeERC20 \u00b6 Wrappers around ERC20 operations that throw on failure (when the token contract returns false). Tokens that return no value (and instead revert or throw on failure) are also supported, non-reverting calls are assumed to be successful. To use this library you can add a using SafeERC20 for IERC20; statement to your contract, which allows you to call the safe operations as token.safeTransfer(...) , etc. safeTransfer \u00b6 function safeTransfer ( contract IERC20 token , address to , uint256 value ) internal safeTransferFrom \u00b6 function safeTransferFrom ( contract IERC20 token , address from , address to , uint256 value ) internal safeApprove \u00b6 function safeApprove ( contract IERC20 token , address spender , uint256 value ) internal callOptionalReturn \u00b6 function callOptionalReturn ( contract IERC20 token , bytes data ) private CloneFactory \u00b6 createClone \u00b6 function createClone ( address target ) internal returns ( address result ) isClone \u00b6 function isClone ( address target , address query ) internal view returns ( bool result ) EpochLibrary \u00b6 Implementation of Epoch Library. For an arbitrary Epoch, this library manages the life cycle of an Epoch. Usually this library is used for handling the time window between conditions in an agreement. Epoch \u00b6 struct Epoch { uint256 timeLock ; uint256 timeOut ; uint256 blockNumber ; } EpochList \u00b6 struct EpochList { mapping ( bytes32 &# x3D ; & gt ; struct EpochLibrary . Epoch ) epochs ; bytes32 [] epochIds ; } create \u00b6 function create ( struct EpochLibrary . EpochList _self , bytes32 _id , uint256 _timeLock , uint256 _timeOut ) internal create creates new Epoch Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 _timeLock uint256 value in block count (can not fulfill before) _timeOut uint256 value in block count (can not fulfill after) isTimedOut \u00b6 function isTimedOut ( struct EpochLibrary . EpochList _self , bytes32 _id ) external view returns ( bool ) isTimedOut means you cannot fulfill after Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 Name Type Description [0] bool true if the current block number is gt timeOut isTimeLocked \u00b6 function isTimeLocked ( struct EpochLibrary . EpochList _self , bytes32 _id ) external view returns ( bool ) isTimeLocked means you cannot fulfill before Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 Name Type Description [0] bool true if the current block number is gt timeLock getEpochTimeOut \u00b6 function getEpochTimeOut ( struct EpochLibrary . Epoch _self ) public view returns ( uint256 ) getEpochTimeOut Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer getEpochTimeLock \u00b6 function getEpochTimeLock ( struct EpochLibrary . Epoch _self ) public view returns ( uint256 ) getEpochTimeLock Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer HashListLibrary \u00b6 Implementation of the basic functionality of list of hash values. This library allows other contracts to build and maintain lists and also preserves the privacy of the data by accepting only hashed content (bytes32 based data type) List \u00b6 struct List { address _owner ; bytes32 [] values ; mapping ( bytes32 &# x3D ; & gt ; uint256 ) indices ; } onlyListOwner \u00b6 modifier onlyListOwner ( struct HashListLibrary . List _self ) add \u00b6 function add ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) add index an element then add it to a list Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is a bytes32 value Name Type Description [0] bool true if value is added successfully add \u00b6 function add ( struct HashListLibrary . List _self , bytes32 [] values ) public returns ( bool ) put an array of elements without indexing this meant to save gas in case of large arrays Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage values bytes32[] is an array of elements value Name Type Description [0] bool true if values are added successfully update \u00b6 function update ( struct HashListLibrary . List _self , bytes32 oldValue , bytes32 newValue ) public returns ( bool ) update the value with a new value and maintain indices Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage oldValue bytes32 is an element value in a list newValue bytes32 new value Name Type Description [0] bool true if value is updated successfully remove \u00b6 function remove ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) remove value from a list, updates indices, and list size Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is an element value in a list Name Type Description [0] bool true if value is removed successfully get \u00b6 function get ( struct HashListLibrary . List _self , uint256 __index ) public view returns ( bytes32 ) has value by index Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage __index uint256 is where is value is stored in the list Name Type Description [0] bytes32 the value if exists index \u00b6 function index ( struct HashListLibrary . List _self , uint256 from , uint256 to ) public returns ( bool ) index is used to map each element value to its index on the list Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing Name Type Description [0] bool true if the sub list is indexed setOwner \u00b6 function setOwner ( struct HashListLibrary . List _self , address _owner ) public setOwner set list owner param _owner owner address indexOf \u00b6 function indexOf ( struct HashListLibrary . List _self , bytes32 value ) public view returns ( uint256 ) indexOf gets the index of a value in a list Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list Name Type Description [0] uint256 value index in list isIndexed \u00b6 function isIndexed ( struct HashListLibrary . List _self ) public view returns ( bool ) isIndexed checks if the list is indexed Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] bool true if the list is indexed all \u00b6 function all ( struct HashListLibrary . List _self ) public view returns ( bytes32 []) all returns all list elements Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] bytes32[] all list elements has \u00b6 function has ( struct HashListLibrary . List _self , bytes32 value ) public view returns ( bool ) size returns the list size Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list Name Type Description [0] bool true if the value exists size \u00b6 function size ( struct HashListLibrary . List _self ) public view returns ( uint256 ) size gets the list size Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] uint256 total length of the list ownedBy \u00b6 function ownedBy ( struct HashListLibrary . List _self ) public view returns ( address ) ownedBy gets the list owner Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] address list owner _index \u00b6 function _index ( struct HashListLibrary . List _self , uint256 from , uint256 to ) private returns ( bool ) __index assign index to the list elements_ Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage from uint256 is the starting index id to uint256 is the ending index id AbstractAuction \u00b6 AUCTION_MANAGER_ROLE \u00b6 bytes32 AUCTION_MANAGER_ROLE NVM_AGREEMENT_ROLE \u00b6 bytes32 NVM_AGREEMENT_ROLE Auction \u00b6 struct Auction { bytes32 did ; enum IDynamicPricing . DynamicPricingState state ; address creator ; uint256 blockNumberCreated ; uint256 floor ; uint256 starts ; uint256 ends ; uint256 price ; address tokenAddress ; address whoCanClaim ; string hash ; } auctions \u00b6 mapping ( bytes32 => struct AbstractAuction . Auction ) auctions auctionBids \u00b6 mapping ( bytes32 => mapping ( address => uint256 )) auctionBids AuctionCreated \u00b6 event AuctionCreated ( bytes32 auctionId , bytes32 did , address creator , uint256 blockNumberCreated , uint256 floor , uint256 starts , uint256 ends , address tokenAddress ) AuctionChangedState \u00b6 event AuctionChangedState ( bytes32 auctionId , address who , enum IDynamicPricing . DynamicPricingState previousState , enum IDynamicPricing . DynamicPricingState newState ) AuctionBidReceived \u00b6 event AuctionBidReceived ( bytes32 auctionId , address bidder , address tokenAddress , uint256 amount ) AuctionWithdrawal \u00b6 event AuctionWithdrawal ( bytes32 auctionId , address receiver , address tokenAddress , uint256 amount ) receive \u00b6 receive () external payable abortAuction \u00b6 function abortAuction ( bytes32 _auctionId ) external virtual withdraw \u00b6 function withdraw ( bytes32 _auctionId , address _withdrawAddress ) external virtual returns ( bool ) getPricingType \u00b6 function getPricingType () external pure virtual returns ( bytes32 ) getPrice \u00b6 function getPrice ( bytes32 _auctionId ) external view returns ( uint256 ) getTokenAddress \u00b6 function getTokenAddress ( bytes32 _auctionId ) external view returns ( address ) getStatus \u00b6 function getStatus ( bytes32 _auctionId ) external view returns ( enum IDynamicPricing . DynamicPricingState state , uint256 price , address whoCanClaim ) canBePurchased \u00b6 function canBePurchased ( bytes32 _auctionId ) external view virtual returns ( bool ) addNVMAgreementRole \u00b6 function addNVMAgreementRole ( address account ) public onlyCreator \u00b6 modifier onlyCreator ( bytes32 _auctionId ) onlyCreatorOrAdmin \u00b6 modifier onlyCreatorOrAdmin ( bytes32 _auctionId ) onlyNotCreator \u00b6 modifier onlyNotCreator ( bytes32 _auctionId ) onlyAfterStart \u00b6 modifier onlyAfterStart ( bytes32 _auctionId ) onlyBeforeStarts \u00b6 modifier onlyBeforeStarts ( bytes32 _auctionId ) onlyBeforeEnd \u00b6 modifier onlyBeforeEnd ( bytes32 _auctionId ) onlyNotAbortedOrFinished \u00b6 modifier onlyNotAbortedOrFinished ( bytes32 _auctionId ) onlyAbortedOrFinished \u00b6 modifier onlyAbortedOrFinished ( bytes32 _auctionId ) onlyNotAborted \u00b6 modifier onlyNotAborted ( bytes32 _auctionId ) onlyFinishedOrAborted \u00b6 modifier onlyFinishedOrAborted ( bytes32 _auctionId ) DutchAuction \u00b6 initialize \u00b6 function initialize ( address _owner ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address create \u00b6 function create ( bytes32 _auctionId , bytes32 _did , uint256 _startPrice , uint256 _starts , uint256 _ends , address _tokenAddress , string _hash ) external virtual It creates a new Auction given some setup parameters Name Type Description _auctionId bytes32 unique auction identifier _did bytes32 reference to the asset part of the auction _startPrice uint256 start price (and max) for the auction _starts uint256 block number when the auction starts _ends uint256 block number of when the auction ends _tokenAddress address token address to use for the auction. If address(0) means native token _hash string ipfs hash referring to the auction metadata placeNativeTokenBid \u00b6 function placeNativeTokenBid ( bytes32 _auctionId ) external payable virtual placeERC20Bid \u00b6 function placeERC20Bid ( bytes32 _auctionId , uint256 _bidAmount ) external virtual withdraw \u00b6 function withdraw ( bytes32 _auctionId , address _withdrawAddress ) external virtual returns ( bool ) getPricingType \u00b6 function getPricingType () external pure returns ( bytes32 ) EnglishAuction \u00b6 initialize \u00b6 function initialize ( address _owner ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address create \u00b6 function create ( bytes32 _auctionId , bytes32 _did , uint256 _floor , uint256 _starts , uint256 _ends , address _tokenAddress , string _hash ) external virtual It creates a new Auction given some setup parameters Name Type Description _auctionId bytes32 unique auction identifier _did bytes32 reference to the asset part of the auction _floor uint256 floor price _starts uint256 block number when the auction starts _ends uint256 block number of when the auction ends _tokenAddress address token address to use for the auction. If address(0) means native token _hash string ipfs hash referring to the auction metadata placeNativeTokenBid \u00b6 function placeNativeTokenBid ( bytes32 _auctionId ) external payable virtual placeERC20Bid \u00b6 function placeERC20Bid ( bytes32 _auctionId , uint256 _bidAmount ) external virtual getPricingType \u00b6 function getPricingType () external pure returns ( bytes32 ) DIDFactory \u00b6 Implementation of the DID Registry. didRegisterList \u00b6 struct DIDRegistryLibrary . DIDRegisterList didRegisterList state storage for the DID registry didPermissions \u00b6 mapping ( bytes32 => mapping ( address => bool )) didPermissions manager \u00b6 address manager onlyDIDOwner \u00b6 modifier onlyDIDOwner ( bytes32 _did ) onlyManager \u00b6 modifier onlyManager () onlyOwnerProviderOrDelegated \u00b6 modifier onlyOwnerProviderOrDelegated ( bytes32 _did ) onlyValidAttributes \u00b6 modifier onlyValidAttributes ( string _attributes ) nftIsInitialized \u00b6 modifier nftIsInitialized ( bytes32 _did ) nft721IsInitialized \u00b6 modifier nft721IsInitialized ( bytes32 _did ) DIDAttributeRegistered \u00b6 event DIDAttributeRegistered ( bytes32 _did , address _owner , bytes32 _checksum , string _value , address _lastUpdatedBy , uint256 _blockNumberUpdated ) DID Events DIDProviderRemoved \u00b6 event DIDProviderRemoved ( bytes32 _did , address _provider , bool state ) DIDProviderAdded \u00b6 event DIDProviderAdded ( bytes32 _did , address _provider ) DIDOwnershipTransferred \u00b6 event DIDOwnershipTransferred ( bytes32 _did , address _previousOwner , address _newOwner ) DIDPermissionGranted \u00b6 event DIDPermissionGranted ( bytes32 _did , address _owner , address _grantee ) DIDPermissionRevoked \u00b6 event DIDPermissionRevoked ( bytes32 _did , address _owner , address _grantee ) DIDProvenanceDelegateRemoved \u00b6 event DIDProvenanceDelegateRemoved ( bytes32 _did , address _delegate , bool state ) DIDProvenanceDelegateAdded \u00b6 event DIDProvenanceDelegateAdded ( bytes32 _did , address _delegate ) setManager \u00b6 function setManager ( address _addr ) external Sets the manager role. Should be the TransferCondition contract address registerAttribute \u00b6 function registerAttribute ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url ) public virtual Register DID attributes. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] _url string refers to the attribute value, limited to 2048 bytes. registerDID \u00b6 function registerDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , bytes32 _activityId , string _attributes ) public virtual Register DID attributes. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). The final DID will be calculated with the creator address using the hashDID function _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _activityId bytes32 refers to activity _attributes string refers to the provenance attributes hashDID \u00b6 function hashDID ( bytes32 _didSeed , address _creator ) public pure returns ( bytes32 ) It generates a DID using as seed a bytes32 and the address of the DID creator Name Type Description _didSeed bytes32 refers to DID Seed used as base to generate the final DID _creator address address of the creator of the DID Name Type Description [0] bytes32 the new DID created areRoyaltiesValid \u00b6 function areRoyaltiesValid ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _tokenAddress ) public view returns ( bool ) areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards _tokenAddress address Name Type Description [0] bool true if the rewards distribution respect the original creator royalties wasGeneratedBy \u00b6 function wasGeneratedBy ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal returns ( bool ) used \u00b6 function used ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , bytes _signatureUsing , string _attributes ) public returns ( bool success ) wasDerivedFrom \u00b6 function wasDerivedFrom ( bytes32 _provId , bytes32 _newEntityDid , bytes32 _usedEntityDid , address _agentId , bytes32 _activityId , string _attributes ) public returns ( bool success ) wasAssociatedWith \u00b6 function wasAssociatedWith ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) public returns ( bool success ) actedOnBehalf \u00b6 function actedOnBehalf ( bytes32 _provId , bytes32 _did , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes _signatureDelegate , string _attributes ) public returns ( bool success ) Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId & _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId) Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered addDIDProvider \u00b6 function addDIDProvider ( bytes32 _did , address _provider ) external addDIDProvider add new DID provider. it adds new DID provider to the providers list. A provider is any entity that can serve the registered asset Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address. removeDIDProvider \u00b6 function removeDIDProvider ( bytes32 _did , address _provider ) external removeDIDProvider delete an existing DID provider. Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address. addDIDProvenanceDelegate \u00b6 function addDIDProvenanceDelegate ( bytes32 _did , address _delegate ) public addDIDProvenanceDelegate add new DID provenance delegate. it adds new DID provenance delegate to the delegates list. A delegate is any entity that interact with the provenance entries of one DID Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegates's address. removeDIDProvenanceDelegate \u00b6 function removeDIDProvenanceDelegate ( bytes32 _did , address _delegate ) external removeDIDProvenanceDelegate delete an existing DID delegate. Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address. transferDIDOwnership \u00b6 function transferDIDOwnership ( bytes32 _did , address _newOwner ) external transferDIDOwnership transfer DID ownership Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _newOwner address new owner address transferDIDOwnershipManaged \u00b6 function transferDIDOwnershipManaged ( address _sender , bytes32 _did , address _newOwner ) external transferDIDOwnershipManaged transfer DID ownership Name Type Description _sender address _did bytes32 refers to decentralized identifier (a bytes32 length ID) _newOwner address new owner address _transferDIDOwnership \u00b6 function _transferDIDOwnership ( address _sender , bytes32 _did , address _newOwner ) internal grantPermission \u00b6 function grantPermission ( bytes32 _did , address _grantee ) external grantPermission grants access permission to grantee Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address revokePermission \u00b6 function revokePermission ( bytes32 _did , address _grantee ) external revokePermission revokes access permission from grantee Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address getPermission \u00b6 function getPermission ( bytes32 _did , address _grantee ) external view returns ( bool ) getPermission gets access permission of a grantee Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address Name Type Description [0] bool true if grantee has access permission to a DID isDIDProvider \u00b6 function isDIDProvider ( bytes32 _did , address _provider ) public view returns ( bool ) isDIDProvider check whether a given DID provider exists Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address. isDIDProviderOrOwner \u00b6 function isDIDProviderOrOwner ( bytes32 _did , address _provider ) public view returns ( bool ) getDIDRegister \u00b6 function getDIDRegister ( bytes32 _did ) public view returns ( address owner , bytes32 lastChecksum , string url , address lastUpdatedBy , uint256 blockNumberUpdated , address [] providers , uint256 nftSupply , uint256 mintCap , uint256 royalties ) Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description owner address the did owner lastChecksum bytes32 last checksum url string URL to the DID metadata lastUpdatedBy address who was the last updating the DID blockNumberUpdated uint256 In which block was the DID updated providers address[] the list of providers nftSupply uint256 the supply of nfts mintCap uint256 the maximum number of nfts that can be minted royalties uint256 the royalties amount getDIDSupply \u00b6 function getDIDSupply ( bytes32 _did ) public view returns ( uint256 nftSupply , uint256 mintCap ) getBlockNumberUpdated \u00b6 function getBlockNumberUpdated ( bytes32 _did ) public view returns ( uint256 blockNumberUpdated ) Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description blockNumberUpdated uint256 last modified (update) block number of a DID. getDIDOwner \u00b6 function getDIDOwner ( bytes32 _did ) public view returns ( address didOwner ) Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description didOwner address the address of the DID owner. getDIDRoyaltyRecipient \u00b6 function getDIDRoyaltyRecipient ( bytes32 _did ) public view returns ( address ) getDIDRoyaltyScheme \u00b6 function getDIDRoyaltyScheme ( bytes32 _did ) public view returns ( address ) getDIDCreator \u00b6 function getDIDCreator ( bytes32 _did ) public view returns ( address ) _grantPermission \u00b6 function _grantPermission ( bytes32 _did , address _grantee ) internal __grantPermission grants access permission to grantee_ Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address _revokePermission \u00b6 function _revokePermission ( bytes32 _did , address _grantee ) internal __revokePermission revokes access permission from grantee_ Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address _getPermission \u00b6 function _getPermission ( bytes32 _did , address _grantee ) internal view returns ( bool ) __getPermission gets access permission of a grantee_ Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address Name Type Description [0] bool true if grantee has access permission to a DID getProvenanceEntry \u00b6 function getProvenanceEntry ( bytes32 _provId ) public view returns ( bytes32 did , bytes32 relatedDid , address agentId , bytes32 activityId , address agentInvolvedId , uint8 method , address createdBy , uint256 blockNumberUpdated , bytes signature ) Fetch the complete provenance entry attributes Name Type Description _provId bytes32 refers to the provenance identifier Name Type Description did bytes32 to what DID refers this entry relatedDid bytes32 DID related with the entry agentId address the agent identifier activityId bytes32 referring to the id of the activity agentInvolvedId address agent involved with the action method uint8 the w3c provenance method createdBy address who is creating this entry blockNumberUpdated uint256 in which block was updated signature bytes digital signature isDIDOwner \u00b6 function isDIDOwner ( address _address , bytes32 _did ) public view returns ( bool ) isDIDOwner check whether a given address is owner for a DID Name Type Description _address address user address. _did bytes32 refers to decentralized identifier (a bytes32 length ID). isOwnerProviderOrDelegate \u00b6 function isOwnerProviderOrDelegate ( bytes32 _did ) public view returns ( bool ) isOwnerProviderOrDelegate check whether msg.sender is owner, provider or delegate for a DID given Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description [0] bool boolean true if yes isProvenanceDelegate \u00b6 function isProvenanceDelegate ( bytes32 _did , address _delegate ) public view returns ( bool ) isProvenanceDelegate check whether a given DID delegate exists Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address. Name Type Description [0] bool boolean true if yes getProvenanceOwner \u00b6 function getProvenanceOwner ( bytes32 _did ) public view returns ( address provenanceOwner ) Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description provenanceOwner address the address of the Provenance owner. DIDRegistry \u00b6 Implementation of a Mintable DID Registry. erc1155 \u00b6 contract NFTUpgradeable erc1155 erc721 \u00b6 contract NFT721Upgradeable erc721 royaltiesCheckers \u00b6 mapping ( address => bool ) royaltiesCheckers initialize \u00b6 function initialize ( address _owner , address _erc1155 , address _erc721 ) public DIDRegistry Initializer Initialize Ownable. Only on contract creation. Name Type Description _owner address refers to the owner of the contract. _erc1155 address _erc721 address registerRoyaltiesChecker \u00b6 function registerRoyaltiesChecker ( address _addr ) public DIDRoyaltiesAdded \u00b6 event DIDRoyaltiesAdded ( bytes32 did , address addr ) DIDRoyaltyRecipientChanged \u00b6 event DIDRoyaltyRecipientChanged ( bytes32 did , address addr ) setDIDRoyalties \u00b6 function setDIDRoyalties ( bytes32 _did , address _royalties ) public setDIDRoyaltyRecipient \u00b6 function setDIDRoyaltyRecipient ( bytes32 _did , address _recipient ) public registerMintableDID \u00b6 function registerMintableDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , uint256 _cap , uint8 _royalties , bool _mint , bytes32 _activityId , string _nftMetadata ) public Register a Mintable DID using NFTs based in the ERC-1155 standard. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if true it mints the ERC-1155 NFTs attached to the asset _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata registerMintableDID721 \u00b6 function registerMintableDID721 ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , uint8 _royalties , bool _mint , bytes32 _activityId , string _nftMetadata ) public Register a Mintable DID using NFTs based in the ERC-721 standard. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if true it mints the ERC-1155 NFTs attached to the asset _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata registerMintableDID \u00b6 function registerMintableDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , uint256 _cap , uint8 _royalties , bytes32 _activityId , string _nftMetadata ) public Register a Mintable DID. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata enableAndMintDidNft \u00b6 function enableAndMintDidNft ( bytes32 _did , uint256 _cap , uint8 _royalties , bool _mint , string _nftMetadata ) public returns ( bool success ) enableDidNft creates the initial setup of NFTs minting and royalties distribution for ERC-1155 NFTs. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if is true mint directly the amount capped tokens and lock in the _lockAddress _nftMetadata string refers to the url providing the NFT Metadata enableAndMintDidNft721 \u00b6 function enableAndMintDidNft721 ( bytes32 _did , uint8 _royalties , bool _mint , string _nftMetadata ) public returns ( bool success ) enableAndMintDidNft721 creates the initial setup of NFTs minting and royalties distribution for ERC-721 NFTs. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if is true mint directly the amount capped tokens and lock in the _lockAddress _nftMetadata string refers to the url providing the NFT Metadata mint \u00b6 function mint ( bytes32 _did , uint256 _amount , address _receiver ) public Mints a NFT associated to the DID Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both Only the DID owner can mint NFTs associated to the DID Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to mint _receiver address the address that will receive the new nfts minted mint \u00b6 function mint ( bytes32 _did , uint256 _amount ) public mint721 \u00b6 function mint721 ( bytes32 _did , address _receiver ) public Mints a ERC-721 NFT associated to the DID Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _receiver address the address that will receive the new nfts minted mint721 \u00b6 function mint721 ( bytes32 _did ) public burn \u00b6 function burn ( bytes32 _did , uint256 _amount ) public Burns NFTs associated to the DID Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both Only the DID owner can burn NFTs associated to the DID Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to burn burn721 \u00b6 function burn721 ( bytes32 _did ) public DIDRegistryLibrary \u00b6 All function calls are currently implemented without side effects DIDRegister \u00b6 struct DIDRegister { address owner ; uint8 royalties ; bool nftInitialized ; bool nft721Initialized ; address creator ; bytes32 lastChecksum ; string url ; address lastUpdatedBy ; uint256 blockNumberUpdated ; address [] providers ; address [] delegates ; uint256 nftSupply ; uint256 mintCap ; address royaltyRecipient ; contract IRoyaltyScheme royaltyScheme ; } DIDRegisterList \u00b6 struct DIDRegisterList { mapping ( bytes32 &# x3D ; & gt ; struct DIDRegistryLibrary . DIDRegister ) didRegisters ; bytes32 [] didRegisterIds ; } update \u00b6 function update ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , bytes32 _checksum , string _url ) external update the DID store access modifiers and storage pointer should be implemented in DIDRegistry Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _checksum bytes32 includes a one-way HASH calculated using the DDO content _url string includes the url resolving to the DID Document (DDO) initializeNftConfig \u00b6 function initializeNftConfig ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint256 _cap , uint8 _royalties ) internal initializeNftConfig creates the initial setup of NFTs minting and royalties distribution. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market The royalties in secondary market for the creator should be between 0% >= x < 100% initializeNft721Config \u00b6 function initializeNft721Config ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint8 _royalties ) internal areRoyaltiesValid \u00b6 function areRoyaltiesValid ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _tokenAddress ) internal view returns ( bool ) areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards _tokenAddress address Name Type Description [0] bool true if the rewards distribution respect the original creator royalties addProvider \u00b6 function addProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address provider ) internal addProvider add provider to DID registry update the DID registry providers list by adding a new provider Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) provider address the provider's address removeProvider \u00b6 function removeProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _provider ) internal returns ( bool ) removeProvider remove provider from DID registry update the DID registry providers list by removing an existing provider Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address updateDIDOwner \u00b6 function updateDIDOwner ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _newOwner ) internal updateDIDOwner transfer DID ownership to a new owner Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _newOwner address the new DID owner address isProvider \u00b6 function isProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _provider ) public view returns ( bool ) isProvider check whether DID provider exists Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address Name Type Description [0] bool true if the provider already exists getProviderIndex \u00b6 function getProviderIndex ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address provider ) private view returns ( int256 ) getProviderIndex get the index of a provider Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) provider address the provider's address Name Type Description [0] int256 the index if the provider exists otherwise return -1 addDelegate \u00b6 function addDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address delegate ) internal addDelegate add delegate to DID registry update the DID registry delegates list by adding a new delegate Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) delegate address the delegate's address removeDelegate \u00b6 function removeDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _delegate ) internal returns ( bool ) removeDelegate remove delegate from DID registry update the DID registry delegates list by removing an existing delegate Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address isDelegate \u00b6 function isDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _delegate ) public view returns ( bool ) isDelegate check whether DID delegate exists Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address Name Type Description [0] bool true if the delegate already exists getDelegateIndex \u00b6 function getDelegateIndex ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address delegate ) private view returns ( int256 ) getDelegateIndex get the index of a delegate Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) delegate address the delegate's address Name Type Description [0] int256 the index if the delegate exists otherwise return -1 ProvenanceRegistry \u00b6 All function calls are currently implemented without side effects __ProvenanceRegistry_init \u00b6 function __ProvenanceRegistry_init () internal __ProvenanceRegistry_init_unchained \u00b6 function __ProvenanceRegistry_init_unchained () internal Provenance \u00b6 struct Provenance { bytes32 did ; bytes32 relatedDid ; address agentId ; bytes32 activityId ; address agentInvolvedId ; uint8 method ; address createdBy ; uint256 blockNumberUpdated ; bytes signature ; } ProvenanceRegistryList \u00b6 struct ProvenanceRegistryList { mapping ( bytes32 &# x3D ; & gt ; struct ProvenanceRegistry . Provenance ) list ; } provenanceRegistry \u00b6 struct ProvenanceRegistry . ProvenanceRegistryList provenanceRegistry ProvenanceMethod \u00b6 enum ProvenanceMethod { ENTITY , ACTIVITY , WAS_GENERATED_BY , USED , WAS_INFORMED_BY , WAS_STARTED_BY , WAS_ENDED_BY , WAS_INVALIDATED_BY , WAS_DERIVED_FROM , AGENT , WAS_ATTRIBUTED_TO , WAS_ASSOCIATED_WITH , ACTED_ON_BEHALF } ProvenanceAttributeRegistered \u00b6 event ProvenanceAttributeRegistered ( bytes32 provId , bytes32 _did , address _agentId , bytes32 _activityId , bytes32 _relatedDid , address _agentInvolvedId , enum ProvenanceRegistry . ProvenanceMethod _method , string _attributes , uint256 _blockNumberUpdated ) Provenance Events WasGeneratedBy \u00b6 event WasGeneratedBy ( bytes32 _did , address _agentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated ) Used \u00b6 event Used ( bytes32 _did , address _agentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated ) WasDerivedFrom \u00b6 event WasDerivedFrom ( bytes32 _newEntityDid , bytes32 _usedEntityDid , address _agentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated ) WasAssociatedWith \u00b6 event WasAssociatedWith ( bytes32 _entityDid , address _agentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated ) ActedOnBehalf \u00b6 event ActedOnBehalf ( bytes32 _entityDid , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated ) createProvenanceEntry \u00b6 function createProvenanceEntry ( bytes32 _provId , bytes32 _did , bytes32 _relatedDid , address _agentId , bytes32 _activityId , address _agentInvolvedId , enum ProvenanceRegistry . ProvenanceMethod _method , address _createdBy , bytes _signatureDelegate , string _attributes ) internal returns ( bool ) create an event in the Provenance store access modifiers and storage pointer should be implemented in ProvenanceRegistry Name Type Description _provId bytes32 refers to provenance event identifier _did bytes32 refers to decentralized identifier (a byte32 length ID) _relatedDid bytes32 refers to decentralized identifier (a byte32 length ID) of a related entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _agentInvolvedId address refers to address of the agent involved with the provenance record _method enum ProvenanceRegistry.ProvenanceMethod refers to the W3C Provenance method _createdBy address refers to address of the agent triggering the activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string _wasGeneratedBy \u00b6 function _wasGeneratedBy ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal virtual returns ( bool ) Implements the W3C PROV Generation action Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description [0] bool the number of the new provenance size _used \u00b6 function _used ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , bytes _signatureUsing , string _attributes ) internal virtual returns ( bool success ) Implements the W3C PROV Usage action Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _signatureUsing bytes refers to the digital signature provided by the agent using the _did _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered _wasDerivedFrom \u00b6 function _wasDerivedFrom ( bytes32 _provId , bytes32 _newEntityDid , bytes32 _usedEntityDid , address _agentId , bytes32 _activityId , string _attributes ) internal virtual returns ( bool success ) Implements the W3C PROV Derivation action Name Type Description _provId bytes32 unique identifier referring to the provenance entry _newEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _usedEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity used to derive the new did _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered _wasAssociatedWith \u00b6 function _wasAssociatedWith ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal virtual returns ( bool success ) Implements the W3C PROV Association action Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered _actedOnBehalf \u00b6 function _actedOnBehalf ( bytes32 _provId , bytes32 _did , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes _signatureDelegate , string _attributes ) internal virtual returns ( bool success ) Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId & _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId) Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered CurveRoyalties \u00b6 registry \u00b6 contract DIDRegistry registry DENOMINATOR \u00b6 uint256 DENOMINATOR royalties \u00b6 mapping ( bytes32 => uint256 ) royalties initialize \u00b6 function initialize ( address _registry ) public royaltyCurve \u00b6 function royaltyCurve ( uint256 num , uint256 max , uint256 rate ) public pure virtual returns ( uint256 ) setRoyalty \u00b6 function setRoyalty ( bytes32 _did , uint256 _royalty ) public Set royalties for a DID Can only be called by creator of the DID Name Type Description _did bytes32 DID for which the royalties are set _royalty uint256 Royalty, the actual royalty will be _royalty / 10000 percent check \u00b6 function check ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _token ) external view returns ( bool ) RewardsDistributor \u00b6 used \u00b6 mapping ( bytes32 => bool ) used receivers \u00b6 mapping ( bytes32 => address []) receivers registry \u00b6 contract DIDRegistry registry conditionStoreManager \u00b6 contract ConditionStoreManager conditionStoreManager escrow \u00b6 address escrow initialize \u00b6 function initialize ( address _registry , address _conditionStoreManager , address _escrow ) public setReceivers \u00b6 function setReceivers ( bytes32 _did , address [] _addr ) public set receivers for did Name Type Description _did bytes32 DID _addr address[] list of receivers claimReward \u00b6 function claimReward ( bytes32 _agreementId , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public distribute rewards associated with an escrow condition as paramemeters, it just gets the same parameters as fulfill for escrow condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier StandardRoyalties \u00b6 registry \u00b6 contract DIDRegistry registry DENOMINATOR \u00b6 uint256 DENOMINATOR royalties \u00b6 mapping ( bytes32 => uint256 ) royalties initialize \u00b6 function initialize ( address _registry ) public setRoyalty \u00b6 function setRoyalty ( bytes32 _did , uint256 _royalty ) public Set royalties for a DID Can only be called by creator of the DID Name Type Description _did bytes32 DID for which the royalties are set _royalty uint256 Royalty, the actual royalty will be _royalty / 10000 percent check \u00b6 function check ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address ) external view returns ( bool ) AaveCreditTemplate \u00b6 Implementation of the Aaven Credit Agreement Template 0. Initialize the agreement 1. LockNFT - Delegatee locks the NFT 2. AaveCollateralDeposit - Delegator deposits the collateral into Aave. And approves the delegation flow 3. AaveBorrowCondition - The Delegatee claim the credit amount from Aave 4. AaveRepayCondition. Options: 4.a Fulfilled state - The Delegatee pay back the loan (including fee) into Aave and gets back the NFT 4.b Aborted state - The Delegatee doesn't pay the loan in time so the Delegator gets the NFT. The Delegator pays the loan to Aave 5. TransferNFT. Options: 5.a if AaveRepayCondition was fulfilled, it will allow transfer back to the Delegatee or Borrower 5.b if AaveRepayCondition was aborted, it will allow transfer the NFT to the Delegator or Lender didRegistry \u00b6 contract DIDRegistry didRegistry nftLockCondition \u00b6 contract INFTLock nftLockCondition depositCondition \u00b6 contract AaveCollateralDepositCondition depositCondition borrowCondition \u00b6 contract AaveBorrowCondition borrowCondition repayCondition \u00b6 contract AaveRepayCondition repayCondition transferCondition \u00b6 contract DistributeNFTCollateralCondition transferCondition withdrawCondition \u00b6 contract AaveCollateralWithdrawCondition withdrawCondition vaultAddress \u00b6 mapping ( bytes32 => address ) vaultAddress nvmFee \u00b6 uint256 nvmFee vaultLibrary \u00b6 address vaultLibrary VaultCreated \u00b6 event VaultCreated ( address _vaultAddress , address _creator , address _lender , address _borrower ) initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _nftLockConditionAddress , address _depositConditionAddress , address _borrowConditionAddress , address _repayConditionAddress , address _withdrawCollateralAddress , address _transferConditionAddress , address _vaultLibrary ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftLockConditionAddress address NFT Lock Condition contract address _depositConditionAddress address Aave collateral deposit Condition address _borrowConditionAddress address Aave borrow deposit Condition address _repayConditionAddress address Aave repay credit Condition address _withdrawCollateralAddress address _transferConditionAddress address NFT Transfer Condition address _vaultLibrary address createVaultAgreement \u00b6 function createVaultAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _vaultAddress ) public createAgreement \u00b6 function createAgreement ( bytes32 _id , address _lendingPool , address _dataProvider , address _weth , uint256 _agreementFee , address _treasuryAddress , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _lender ) public deployVault \u00b6 function deployVault ( address _lendingPool , address _dataProvider , address _weth , uint256 _agreementFee , address _treasuryAddress , address _borrower , address _lender ) public returns ( address ) getVaultForAgreement \u00b6 function getVaultForAgreement ( bytes32 _agreementId ) public view returns ( address ) updateNVMFee \u00b6 function updateNVMFee ( uint256 _newFee ) public Updates the nevermined fee for this type of agreement Name Type Description _newFee uint256 New nevermined fee expressed in basis points changeCreditVaultLibrary \u00b6 function changeCreditVaultLibrary ( address _vaultLibrary ) public AccessProofTemplate \u00b6 Implementation of Access Agreement Template didRegistry \u00b6 contract DIDRegistry didRegistry accessCondition \u00b6 contract AccessProofCondition accessCondition lockCondition \u00b6 contract LockPaymentCondition lockCondition escrowReward \u00b6 contract EscrowPaymentCondition escrowReward initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _accessConditionAddress , address _lockConditionAddress , address payable _escrowConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address AccessTemplate \u00b6 _Implementation of Access Agreement Template Access template is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an on-chain SEA. The template is a composite of three basic conditions. Once the agreement is created, the consumer will lock an amount of tokens (as listed in the DID document - off-chain metadata) to the the lock reward contract which in turn will fire an event. ON the other hand the provider is listening to all the emitted events, the provider will catch the event and grant permissions to the consumer through secret store contract, the consumer now is able to download the data set by asking the off-chain component of secret store to decrypt the DID and encrypt it using the consumer's public key. Then the secret store will provide an on-chain proof that the consumer had access to the data set. Finally, the provider can call the escrow reward condition in order to release the payment. Every condition has a time window (time lock and time out). This implies that if the provider didn't grant the access to the consumer through secret store within this time window, the consumer can ask for refund._ didRegistry \u00b6 contract DIDRegistry didRegistry accessCondition \u00b6 contract AccessCondition accessCondition lockCondition \u00b6 contract LockPaymentCondition lockCondition escrowReward \u00b6 contract EscrowPaymentCondition escrowReward initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _accessConditionAddress , address _lockConditionAddress , address payable _escrowConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address AgreementTemplate \u00b6 _Implementation of Agreement Template Agreement template is a reference template where it has the ability to create agreements from whitelisted template_ conditionTypes \u00b6 address [] conditionTypes agreementStoreManager \u00b6 contract AgreementStoreManager agreementStoreManager createAgreement \u00b6 function createAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts ) public createAgreement create new agreement Name Type Description _id bytes32 agreement unique identifier _did bytes32 refers to decentralized identifier (a bytes32 length ID). _conditionIds bytes32[] list of condition identifiers _timeLocks uint256[] list of time locks, each time lock will be assigned to the same condition that has the same index _timeOuts uint256[] list of time outs, each time out will be assigned to the same condition that has the same index createAgreementAndPay \u00b6 function createAgreementAndPay ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , uint256 _idx , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public payable createAgreementAndFulfill \u00b6 function createAgreementAndFulfill ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , uint256 [] _indices , address [] _accounts , bytes [] _params ) internal getConditionTypes \u00b6 function getConditionTypes () public view returns ( address []) getConditionTypes gets the conditions addresses list for the current template returns list of condition contracts addresses Name Type Description [0] address[] list of conditions contract addresses BaseEscrowTemplate \u00b6 agreementData \u00b6 struct BaseEscrowTemplate . AgreementData agreementData AgreementCreated \u00b6 event AgreementCreated ( bytes32 _agreementId , bytes32 _did , address _accessConsumer , address _accessProvider , uint256 [] _timeLocks , uint256 [] _timeOuts , bytes32 [] _conditionIdSeeds , bytes32 [] _conditionIds , bytes32 _idSeed , address _creator ) AgreementDataModel \u00b6 struct AgreementDataModel { address accessConsumer ; address accessProvider ; bytes32 did ; } AgreementData \u00b6 struct AgreementData { mapping ( bytes32 &# x3D ; & gt ; struct BaseEscrowTemplate . AgreementDataModel ) agreementDataItems ; bytes32 [] agreementIds ; } createAgreement \u00b6 function createAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer ) public createAgreement creates agreements through agreement template this function initializes the agreement by setting the DID, conditions ID, timeouts, time locks and the consumer address. The DID provider/owner is automatically detected by the DID Registry Name Type Description _id bytes32 SEA agreement unique identifier _did bytes32 Decentralized Identifier (DID) _conditionIds bytes32[] conditions ID associated with the condition types _timeLocks uint256[] the starting point of the time window ,time lock is in block number not seconds _timeOuts uint256[] the ending point of the time window ,time lock is in block number not seconds _accessConsumer address consumer address createAgreementAndPayEscrow \u00b6 function createAgreementAndPayEscrow ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer , uint256 _idx , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public payable createAgreementAndFulfill \u00b6 function createAgreementAndFulfill ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer , uint256 [] _indices , address [] _accounts , bytes [] _params ) internal _makeIds \u00b6 function _makeIds ( bytes32 _idSeed , bytes32 [] _conditionIds ) internal view returns ( bytes32 []) _initAgreement \u00b6 function _initAgreement ( bytes32 _idSeed , bytes32 _did , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer , bytes32 [] _conditionIds ) internal getAgreementData \u00b6 function getAgreementData ( bytes32 _id ) external view returns ( address accessConsumer , address accessProvider ) getAgreementData return the agreement Data Name Type Description _id bytes32 SEA agreement unique identifier Name Type Description accessConsumer address the agreement consumer accessProvider address the provider addresses DIDSalesTemplate \u00b6 _Implementation of DID Sales Template The DID Sales template supports an scenario where an Asset owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing an Asset owner to get transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer DID Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the ownership transfer of an asset from the current owner for a specific DID._ didRegistry \u00b6 contract DIDRegistry didRegistry lockPaymentCondition \u00b6 contract LockPaymentCondition lockPaymentCondition transferCondition \u00b6 contract TransferDIDOwnershipCondition transferCondition rewardCondition \u00b6 contract EscrowPaymentCondition rewardCondition id \u00b6 function id () public pure returns ( uint256 ) initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockConditionAddress address lock reward condition contract address _transferConditionAddress address transfer ownership condition contract address _escrowPaymentAddress address payable escrow reward condition contract address DynamicAccessTemplate \u00b6 Implementation of Agreement Template This is a dynamic template that allows to setup flexible conditions depending on the use case. didRegistry \u00b6 contract DIDRegistry didRegistry templateConfig \u00b6 struct DynamicAccessTemplate . TemplateConditions templateConfig TemplateConditions \u00b6 struct TemplateConditions { mapping ( address &# x3D ; & gt ; contract Condition ) templateConditions ; } initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address addTemplateCondition \u00b6 function addTemplateCondition ( address _conditionAddress ) external returns ( uint256 length ) addTemplateCondition adds a new condition to the template Name Type Description _conditionAddress address condition contract address Name Type Description length uint256 conditionTypes array size removeLastTemplateCondition \u00b6 function removeLastTemplateCondition () external returns ( address []) removeLastTemplateCondition removes last condition added to the template Name Type Description [0] address[] conditionTypes existing in the array EscrowComputeExecutionTemplate \u00b6 _Implementation of a Compute Execution Agreement Template EscrowComputeExecutionTemplate is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an on-chain SEA. The template is a composite of three basic conditions. Once the agreement is created, the consumer will lock an amount of tokens (as listed in the DID document - off-chain metadata) to the the lock reward contract which in turn will fire an event. ON the other hand the provider is listening to all the emitted events, the provider will catch the event and grant permissions to trigger a computation granting the execution via the ComputeExecutionCondition contract. The consumer now is able to trigger that computation by asking the off-chain gateway to start the execution of a compute workflow. Finally, the provider can call the escrow reward condition in order to release the payment. Every condition has a time window (time lock and time out). This implies that if the provider didn't grant the execution to the consumer within this time window, the consumer can ask for refund._ didRegistry \u00b6 contract DIDRegistry didRegistry computeExecutionCondition \u00b6 contract ComputeExecutionCondition computeExecutionCondition lockPaymentCondition \u00b6 contract LockPaymentCondition lockPaymentCondition escrowPayment \u00b6 contract EscrowPaymentCondition escrowPayment initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _computeExecutionConditionAddress , address _lockPaymentConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including service executor condition, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _computeExecutionConditionAddress address service executor condition contract address _lockPaymentConditionAddress address lock reward condition contract address _escrowPaymentAddress address payable escrow reward contract address name \u00b6 function name () public pure returns ( string ) NFT721AccessProofTemplate \u00b6 Implementation of NFT721 Access Proof Template NFT721AccessSwapTemplate \u00b6 NFT721AccessTemplate \u00b6 Implementation of NFT Access Template NFT721SalesTemplate \u00b6 Implementation of NFT Sales Template NFT721SalesWithAccessTemplate \u00b6 NFTAccessProofTemplate \u00b6 _Implementation of NFT Access Template The NFT Access template is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing NFT holders to get access to Nevermined services. The template is a composite of 2 basic conditions: - NFT Holding Condition - Access Condition Once the agreement is created, the consumer can demonstrate is holding a NFT for a specific DID. If that's the case the Access condition can be fulfilled by the asset owner or provider and all the agreement is fulfilled. This can be used in scenarios where a data or services owner, can allow users to get access to exclusive services only when they demonstrate the are holding a specific number of NFTs of a DID. This is very useful in use cases like arts._ didRegistry \u00b6 contract DIDRegistry didRegistry nftHolderCondition \u00b6 contract INFTHolder nftHolderCondition accessCondition \u00b6 contract AccessProofCondition accessCondition initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _nftHolderConditionAddress , address _accessConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftHolderConditionAddress address lock reward condition contract address _accessConditionAddress address access condition contract address NFTAccessSwapTemplate \u00b6 _Implementation of NFT Sales Template The NFT Sales template supports an scenario where a NFT owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing a NFT owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer NFT Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the transfer of the NFT from the current owner for a specific DID._ didRegistry \u00b6 contract DIDRegistry didRegistry lockPaymentCondition \u00b6 contract INFTLock lockPaymentCondition rewardCondition \u00b6 contract INFTEscrow rewardCondition accessCondition \u00b6 contract AccessProofCondition accessCondition id \u00b6 function id () public pure returns ( uint256 ) initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockPaymentConditionAddress , address payable _escrowPaymentAddress , address _accessCondition ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _escrowPaymentAddress address payable escrow reward condition contract address _accessCondition address NFTAccessTemplate \u00b6 _Implementation of NFT Access Template The NFT Access template is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing NFT holders to get access to Nevermined services. The template is a composite of 2 basic conditions: - NFT Holding Condition - Access Condition Once the agreement is created, the consumer can demonstrate is holding a NFT for a specific DID. If that's the case the Access condition can be fulfilled by the asset owner or provider and all the agreement is fulfilled. This can be used in scenarios where a data or services owner, can allow users to get access to exclusive services only when they demonstrate the are holding a specific number of NFTs of a DID. This is very useful in use cases like arts._ didRegistry \u00b6 contract DIDRegistry didRegistry nftHolderCondition \u00b6 contract INFTHolder nftHolderCondition accessCondition \u00b6 contract INFTAccess accessCondition initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _nftHolderConditionAddress , address _accessConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftHolderConditionAddress address lock reward condition contract address _accessConditionAddress address access condition contract address NFTSalesTemplate \u00b6 _Implementation of NFT Sales Template The NFT Sales template supports an scenario where a NFT owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing a NFT owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer NFT Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the transfer of the NFT from the current owner for a specific DID._ didRegistry \u00b6 contract DIDRegistry didRegistry lockPaymentCondition \u00b6 contract LockPaymentCondition lockPaymentCondition transferCondition \u00b6 contract ITransferNFT transferCondition rewardCondition \u00b6 contract EscrowPaymentCondition rewardCondition id \u00b6 function id () public pure returns ( uint256 ) initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockPaymentConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _transferConditionAddress address transfer NFT condition contract address _escrowPaymentAddress address payable escrow reward condition contract address nftPrice \u00b6 mapping ( address => mapping ( address => mapping ( address => mapping ( bytes32 => uint256 )))) nftPrice nftSale \u00b6 function nftSale ( address nftAddress , bytes32 nftId , address token , uint256 amount ) external checkParamsTransfer \u00b6 function checkParamsTransfer ( bytes [] _params , bytes32 lockPaymentConditionId , bytes32 _did ) internal view returns ( address ) checkParamsEscrow \u00b6 function checkParamsEscrow ( bytes [] _params , bytes32 lockPaymentId , bytes32 transferId ) internal pure createAgreementFulfill \u00b6 function createAgreementFulfill ( bytes32 _id , bytes32 _did , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer , bytes [] _params ) external payable NFTSalesWithAccessTemplate \u00b6 _Implementation of NFT Sales Template The NFT Sales template supports an scenario where a NFT owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing a NFT owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer NFT Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the transfer of the NFT from the current owner for a specific DID._ didRegistry \u00b6 contract DIDRegistry didRegistry lockPaymentCondition \u00b6 contract LockPaymentCondition lockPaymentCondition transferCondition \u00b6 contract ITransferNFT transferCondition rewardCondition \u00b6 contract EscrowPaymentCondition rewardCondition accessCondition \u00b6 contract AccessProofCondition accessCondition initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockPaymentConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress , address _accessCondition ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _transferConditionAddress address transfer NFT condition contract address _escrowPaymentAddress address payable escrow reward condition contract address _accessCondition address TemplateStoreLibrary \u00b6 _Implementation of the Template Store Library. Templates are blueprints for modular SEAs. When creating an Agreement, a templateId defines the condition and reward types that are instantiated in the ConditionStore._ TemplateState \u00b6 enum TemplateState { Uninitialized , Proposed , Approved , Revoked } Template \u00b6 struct Template { enum TemplateStoreLibrary . TemplateState state ; address owner ; address lastUpdatedBy ; uint256 blockNumberUpdated ; } TemplateList \u00b6 struct TemplateList { mapping ( address &# x3D ; & gt ; struct TemplateStoreLibrary . Template ) templates ; address [] templateIds ; } propose \u00b6 function propose ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal returns ( uint256 size ) propose new template Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address Name Type Description size uint256 which is the index of the proposed template approve \u00b6 function approve ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal approve new template Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address revoke \u00b6 function revoke ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal revoke new template Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address approved template contract address TemplateStoreManager \u00b6 Implementation of the Template Store Manager. Templates are blueprints for modular SEAs. When creating an Agreement, a templateId defines the condition and reward types that are instantiated in the ConditionStore. This contract manages the life cycle of the template ( Propose \u2192 Approve \u2192 Revoke ). templateList \u00b6 struct TemplateStoreLibrary . TemplateList templateList onlyOwnerOrTemplateOwner \u00b6 modifier onlyOwnerOrTemplateOwner ( address _id ) initialize \u00b6 function initialize ( address _owner ) public initialize TemplateStoreManager Initializer Initializes Ownable. Only on contract creation. Name Type Description _owner address refers to the owner of the contract proposeTemplate \u00b6 function proposeTemplate ( address _id ) external returns ( uint256 size ) proposeTemplate proposes a new template Name Type Description _id address unique template identifier which is basically the template contract address approveTemplate \u00b6 function approveTemplate ( address _id ) external approveTemplate approves a template Name Type Description _id address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) can approve this template. revokeTemplate \u00b6 function revokeTemplate ( address _id ) external revokeTemplate revoke a template Name Type Description _id address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) or template owner can revoke this template. getTemplate \u00b6 function getTemplate ( address _id ) external view returns ( enum TemplateStoreLibrary . TemplateState state , address owner , address lastUpdatedBy , uint256 blockNumberUpdated ) getTemplate get more information about a template Name Type Description _id address unique template identifier which is basically the template contract address. Name Type Description state enum TemplateStoreLibrary.TemplateState template status owner address template owner lastUpdatedBy address last updated by blockNumberUpdated uint256 last updated at. getTemplateListSize \u00b6 function getTemplateListSize () external view virtual returns ( uint256 size ) getTemplateListSize number of templates Name Type Description size uint256 number of templates isTemplateApproved \u00b6 function isTemplateApproved ( address _id ) external view returns ( bool ) isTemplateApproved check whether the template is approved Name Type Description _id address unique template identifier which is basically the template contract address. Name Type Description [0] bool true if the template is approved AgreementStoreManagerChangeFunctionSignature \u00b6 createAgreement \u00b6 function createAgreement ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _creator , address _sender ) public AgreementStoreManagerChangeInStorage \u00b6 agreementCount \u00b6 uint256 agreementCount AgreementStoreManagerChangeInStorageAndLogic \u00b6 AgreementStoreManagerExtraFunctionality \u00b6 dummyFunction \u00b6 function dummyFunction () public pure returns ( bool ) AgreementStoreManagerWithBug \u00b6 getDIDRegistryAddress \u00b6 function getDIDRegistryAddress () public pure returns ( address ) getDIDRegistryAddress utility function used by other contracts or any EOA. Name Type Description [0] address the DIDRegistry address ConditionStoreChangeFunctionSignature \u00b6 createCondition \u00b6 function createCondition ( bytes32 _id , address _typeRef , address _sender ) public ConditionStoreChangeInStorage \u00b6 conditionCount \u00b6 uint256 conditionCount ConditionStoreChangeInStorageAndLogic \u00b6 ConditionStoreExtraFunctionality \u00b6 dummyFunction \u00b6 function dummyFunction () public pure returns ( bool ) ConditionStoreWithBug \u00b6 getConditionState \u00b6 function getConditionState ( bytes32 _id ) public view returns ( enum ConditionStoreLibrary . ConditionState ) getConditionState Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state DIDRegistryChangeFunctionSignature \u00b6 registerAttribute \u00b6 function registerAttribute ( bytes32 _didSeed , address [] _providers , bytes32 _checksum , string _url ) public DIDRegistryChangeInStorage \u00b6 timeOfRegister \u00b6 mapping ( bytes32 => uint256 ) timeOfRegister DIDRegistryChangeInStorageAndLogic \u00b6 DIDRegistryExtraFunctionality \u00b6 getNumber \u00b6 function getNumber () public pure returns ( uint256 ) DIDRegistryWithBug \u00b6 registerAttribute \u00b6 function registerAttribute ( bytes32 _checksum , bytes32 _didSeed , address [] _providers , string _url ) public registerAttribute is called only by DID owner. this function registers DID attributes Name Type Description _checksum bytes32 includes a one-way HASH calculated using the DDO content _didSeed bytes32 refers to decentralized identifier (a byte32 length ID) _providers address[] _url string refers to the attribute value IPNFT \u00b6 TokenURIChanged \u00b6 event TokenURIChanged ( uint256 tokenId , string newURI ) initialize \u00b6 function initialize ( string _name , string _symbol ) public setTokenURI \u00b6 function setTokenURI ( uint256 tokenId , string _tokenURI ) public mint \u00b6 function mint ( address to , uint256 _tokenId , string _tokenURI ) public returns ( bool ) mintWithoutTokenURI \u00b6 function mintWithoutTokenURI ( address to , uint256 _tokenId ) external transfer \u00b6 function transfer ( address from , address to , uint256 _tokenId ) public NeverminedConfigChangeInStorage \u00b6 newVariable \u00b6 uint256 newVariable NeverminedConfigChangeFunctionSignature \u00b6 setMarketplaceFees \u00b6 function setMarketplaceFees ( uint256 _marketplaceFee , address _feeReceiver , uint256 _newParameter ) external virtual NeverminedConfigChangeInStorageAndLogic \u00b6 NeverminedConfigWithBug \u00b6 setMarketplaceFees \u00b6 function setMarketplaceFees ( uint256 _marketplaceFee , address _feeReceiver ) external virtual The governor can update the Nevermined Marketplace fees Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee TemplateStoreChangeFunctionSignature \u00b6 proposeTemplate \u00b6 function proposeTemplate ( address _id , address _sender ) external returns ( uint256 size ) TemplateStoreChangeInStorage \u00b6 templateCount \u00b6 uint256 templateCount TemplateStoreChangeInStorageAndLogic \u00b6 TemplateStoreExtraFunctionality \u00b6 dummyFunction \u00b6 function dummyFunction () public pure returns ( bool ) TemplateStoreWithBug \u00b6 getTemplateListSize \u00b6 function getTemplateListSize () external view returns ( uint256 size ) getTemplateListSize number of templates Name Type Description size uint256 number of templates TestERC721 \u00b6 initialize \u00b6 function initialize () public mint \u00b6 function mint ( uint256 id ) public DIDRegistryLibraryProxy \u00b6 didRegister \u00b6 struct DIDRegistryLibrary . DIDRegister didRegister didRegisterList \u00b6 struct DIDRegistryLibrary . DIDRegisterList didRegisterList areRoyaltiesValid \u00b6 function areRoyaltiesValid ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _tokenAddress ) public view returns ( bool ) updateDIDOwner \u00b6 function updateDIDOwner ( bytes32 _did , address _newOwner ) public update \u00b6 function update ( bytes32 _did , bytes32 _checksum , string _url ) public initializeNftConfig \u00b6 function initializeNftConfig ( bytes32 _did , uint256 _cap , uint8 _royalties ) public initializeNft721Config \u00b6 function initializeNft721Config ( bytes32 _did , uint8 _royalties ) public getDIDInfo \u00b6 function getDIDInfo ( bytes32 _did ) public view returns ( address owner , address creator , uint256 royalties ) EpochLibraryProxy \u00b6 epoch \u00b6 struct EpochLibrary . Epoch epoch epochList \u00b6 struct EpochLibrary . EpochList epochList create \u00b6 function create ( bytes32 _id , uint256 _timeLock , uint256 _timeOut ) external HashListLibraryProxy \u00b6 testData \u00b6 struct HashListLibrary . List testData initialize \u00b6 function initialize ( address _owner ) public hash \u00b6 function hash ( address _address ) public pure returns ( bytes32 ) add \u00b6 function add ( bytes32 [] values ) external returns ( bool ) add \u00b6 function add ( bytes32 value ) external returns ( bool ) update \u00b6 function update ( bytes32 oldValue , bytes32 newValue ) external returns ( bool ) index \u00b6 function index ( uint256 from , uint256 to ) external returns ( bool ) has \u00b6 function has ( bytes32 value ) external view returns ( bool ) remove \u00b6 function remove ( bytes32 value ) external returns ( bool ) get \u00b6 function get ( uint256 _index ) external view returns ( bytes32 ) size \u00b6 function size () external view returns ( uint256 ) all \u00b6 function all () external view returns ( bytes32 []) indexOf \u00b6 function indexOf ( bytes32 value ) external view returns ( uint256 ) ownedBy \u00b6 function ownedBy () external view returns ( address ) isIndexed \u00b6 function isIndexed () external view returns ( bool ) NFTBase \u00b6 Implementation of the Royalties EIP-2981 base contract See https://eips.ethereum.org/EIPS/eip-2981 _proxyApprovals \u00b6 mapping ( address => bool ) _proxyApprovals MINTER_ROLE \u00b6 bytes32 MINTER_ROLE RoyaltyInfo \u00b6 struct RoyaltyInfo { address receiver ; uint256 royaltyAmount ; } NFTMetadata \u00b6 struct NFTMetadata { string nftURI ; } _royalties \u00b6 mapping ( uint256 => struct NFTBase . RoyaltyInfo ) _royalties _metadata \u00b6 mapping ( uint256 => struct NFTBase . NFTMetadata ) _metadata _expiration \u00b6 mapping ( address => uint256 ) _expiration ProxyApproval \u00b6 event ProxyApproval ( address sender , address operator , bool approved ) Event for recording proxy approvals. setProxyApproval \u00b6 function setProxyApproval ( address operator , bool approved ) public virtual _setNFTMetadata \u00b6 function _setNFTMetadata ( uint256 tokenId , string tokenURI ) internal _setTokenRoyalty \u00b6 function _setTokenRoyalty ( uint256 tokenId , address receiver , uint256 royaltyAmount ) internal royaltyInfo \u00b6 function royaltyInfo ( uint256 tokenId , uint256 value ) external view returns ( address receiver , uint256 royaltyAmount ) @inheritdoc IERC2981Upgradeable NFTUpgradeable \u00b6 Implementation of the basic standard multi-token. See https://eips.ethereum.org/EIPS/eip-1155 initialize \u00b6 function initialize ( string uri_ ) public See {_setURI}. isApprovedForAll \u00b6 function isApprovedForAll ( address account , address operator ) public view virtual returns ( bool ) See {IERC1155-isApprovedForAll}. mint \u00b6 function mint ( address to , uint256 id , uint256 amount , bytes data ) public burn \u00b6 function burn ( address to , uint256 id , uint256 amount ) public addMinter \u00b6 function addMinter ( address account ) public uri \u00b6 function uri ( uint256 tokenId ) public view returns ( string ) setNFTMetadata \u00b6 function setNFTMetadata ( uint256 tokenId , string nftURI ) public Record some NFT Metadata Name Type Description tokenId uint256 the id of the asset with the royalties associated nftURI string the URI (https, ipfs, etc) to the metadata describing the NFT setTokenRoyalty \u00b6 function setTokenRoyalty ( uint256 tokenId , address receiver , uint256 royaltyAmount ) public Record the asset royalties Name Type Description tokenId uint256 the id of the asset with the royalties associated receiver address the receiver of the royalties (the original creator) royaltyAmount uint256 percentage (no decimals, between 0 and 100) supportsInterface \u00b6 function supportsInterface ( bytes4 interfaceId ) public view virtual returns ( bool ) NFT721SubscriptionUpgradeable \u00b6 mint \u00b6 function mint ( address to , uint256 id , uint256 expirationBlock ) public balanceOf \u00b6 function balanceOf ( address owner ) public view returns ( uint256 ) See {IERC721-balanceOf}. NFT721Upgradeable \u00b6 Implementation of the basic standard multi-token. initialize \u00b6 function initialize ( string name , string symbol ) public virtual initialize \u00b6 function initialize () public virtual isApprovedForAll \u00b6 function isApprovedForAll ( address account , address operator ) public view virtual returns ( bool ) See {IERC1155-isApprovedForAll}. addMinter \u00b6 function addMinter ( address account ) public mint \u00b6 function mint ( address to , uint256 id ) public virtual burn \u00b6 function burn ( uint256 id ) public tokenURI \u00b6 function tokenURI ( uint256 tokenId ) public view virtual returns ( string ) See {IERC721Metadata-tokenURI}. setNFTMetadata \u00b6 function setNFTMetadata ( uint256 tokenId , string nftURI ) public Record some NFT Metadata Name Type Description tokenId uint256 the id of the asset with the royalties associated nftURI string the URI (https, ipfs, etc) to the metadata describing the NFT setTokenRoyalty \u00b6 function setTokenRoyalty ( uint256 tokenId , address receiver , uint256 royaltyAmount ) public Record the asset royalties Name Type Description tokenId uint256 the id of the asset with the royalties associated receiver address the receiver of the royalties (the original creator) royaltyAmount uint256 percentage (no decimals, between 0 and 100) supportsInterface \u00b6 function supportsInterface ( bytes4 interfaceId ) public view virtual returns ( bool ) POAPUpgradeable \u00b6 _tokenIdCounter \u00b6 struct CountersUpgradeable . Counter _tokenIdCounter _tokenEvent \u00b6 mapping ( uint256 => uint256 ) _tokenEvent initialize \u00b6 function initialize () public initialize \u00b6 function initialize ( string name , string symbol ) public virtual mint \u00b6 function mint ( address to , string uri , uint256 eventId ) public mint \u00b6 function mint ( address to , uint256 id ) public tokenEvent \u00b6 function tokenEvent ( uint256 tokenId ) public view returns ( uint256 ) _beforeTokenTransfer \u00b6 function _beforeTokenTransfer ( address from , address to , uint256 tokenId ) internal _burn \u00b6 function _burn ( uint256 tokenId ) internal tokenDetailsOfOwner \u00b6 function tokenDetailsOfOwner ( address owner ) public view returns ( uint256 [] tokenIds , uint256 [] eventIds ) tokenURI \u00b6 function tokenURI ( uint256 tokenId ) public view returns ( string ) isApprovedForAll \u00b6 function isApprovedForAll ( address account , address operator ) public view returns ( bool ) supportsInterface \u00b6 function supportsInterface ( bytes4 interfaceId ) public view virtual returns ( bool )","title":"Smart Contracts"},{"location":"architecture/contracts/#solidity-api","text":"","title":"Solidity API"},{"location":"architecture/contracts/#testdisputemanager","text":"","title":"TestDisputeManager"},{"location":"architecture/contracts/#accept","text":"mapping ( bytes32 => bool ) accept","title":"accept"},{"location":"architecture/contracts/#accepted","text":"function accepted ( address provider , address buyer , bytes32 orig , bytes32 crypted ) public view returns ( bool )","title":"accepted"},{"location":"architecture/contracts/#setaccepted","text":"function setAccepted ( bytes32 orig , bytes32 crypted , address provider , address buyer ) public","title":"setAccepted"},{"location":"architecture/contracts/#plonkverifier","text":"","title":"PlonkVerifier"},{"location":"architecture/contracts/#n","text":"uint32 n","title":"n"},{"location":"architecture/contracts/#npublic","text":"uint16 nPublic","title":"nPublic"},{"location":"architecture/contracts/#nlagrange","text":"uint16 nLagrange","title":"nLagrange"},{"location":"architecture/contracts/#qmx","text":"uint256 Qmx","title":"Qmx"},{"location":"architecture/contracts/#qmy","text":"uint256 Qmy","title":"Qmy"},{"location":"architecture/contracts/#qlx","text":"uint256 Qlx","title":"Qlx"},{"location":"architecture/contracts/#qly","text":"uint256 Qly","title":"Qly"},{"location":"architecture/contracts/#qrx","text":"uint256 Qrx","title":"Qrx"},{"location":"architecture/contracts/#qry","text":"uint256 Qry","title":"Qry"},{"location":"architecture/contracts/#qox","text":"uint256 Qox","title":"Qox"},{"location":"architecture/contracts/#qoy","text":"uint256 Qoy","title":"Qoy"},{"location":"architecture/contracts/#qcx","text":"uint256 Qcx","title":"Qcx"},{"location":"architecture/contracts/#qcy","text":"uint256 Qcy","title":"Qcy"},{"location":"architecture/contracts/#s1x","text":"uint256 S1x","title":"S1x"},{"location":"architecture/contracts/#s1y","text":"uint256 S1y","title":"S1y"},{"location":"architecture/contracts/#s2x","text":"uint256 S2x","title":"S2x"},{"location":"architecture/contracts/#s2y","text":"uint256 S2y","title":"S2y"},{"location":"architecture/contracts/#s3x","text":"uint256 S3x","title":"S3x"},{"location":"architecture/contracts/#s3y","text":"uint256 S3y","title":"S3y"},{"location":"architecture/contracts/#k1","text":"uint256 k1","title":"k1"},{"location":"architecture/contracts/#k2","text":"uint256 k2","title":"k2"},{"location":"architecture/contracts/#x2x1","text":"uint256 X2x1","title":"X2x1"},{"location":"architecture/contracts/#x2x2","text":"uint256 X2x2","title":"X2x2"},{"location":"architecture/contracts/#x2y1","text":"uint256 X2y1","title":"X2y1"},{"location":"architecture/contracts/#x2y2","text":"uint256 X2y2","title":"X2y2"},{"location":"architecture/contracts/#q","text":"uint256 q","title":"q"},{"location":"architecture/contracts/#qf","text":"uint256 qf","title":"qf"},{"location":"architecture/contracts/#w1","text":"uint256 w1","title":"w1"},{"location":"architecture/contracts/#g1x","text":"uint256 G1x","title":"G1x"},{"location":"architecture/contracts/#g1y","text":"uint256 G1y","title":"G1y"},{"location":"architecture/contracts/#g2x1","text":"uint256 G2x1","title":"G2x1"},{"location":"architecture/contracts/#g2x2","text":"uint256 G2x2","title":"G2x2"},{"location":"architecture/contracts/#g2y1","text":"uint256 G2y1","title":"G2y1"},{"location":"architecture/contracts/#g2y2","text":"uint256 G2y2","title":"G2y2"},{"location":"architecture/contracts/#pa","text":"uint16 pA","title":"pA"},{"location":"architecture/contracts/#pb","text":"uint16 pB","title":"pB"},{"location":"architecture/contracts/#pc","text":"uint16 pC","title":"pC"},{"location":"architecture/contracts/#pz","text":"uint16 pZ","title":"pZ"},{"location":"architecture/contracts/#pt1","text":"uint16 pT1","title":"pT1"},{"location":"architecture/contracts/#pt2","text":"uint16 pT2","title":"pT2"},{"location":"architecture/contracts/#pt3","text":"uint16 pT3","title":"pT3"},{"location":"architecture/contracts/#pwxi","text":"uint16 pWxi","title":"pWxi"},{"location":"architecture/contracts/#pwxiw","text":"uint16 pWxiw","title":"pWxiw"},{"location":"architecture/contracts/#peval_a","text":"uint16 pEval_a","title":"pEval_a"},{"location":"architecture/contracts/#peval_b","text":"uint16 pEval_b","title":"pEval_b"},{"location":"architecture/contracts/#peval_c","text":"uint16 pEval_c","title":"pEval_c"},{"location":"architecture/contracts/#peval_s1","text":"uint16 pEval_s1","title":"pEval_s1"},{"location":"architecture/contracts/#peval_s2","text":"uint16 pEval_s2","title":"pEval_s2"},{"location":"architecture/contracts/#peval_zw","text":"uint16 pEval_zw","title":"pEval_zw"},{"location":"architecture/contracts/#peval_r","text":"uint16 pEval_r","title":"pEval_r"},{"location":"architecture/contracts/#palpha","text":"uint16 pAlpha","title":"pAlpha"},{"location":"architecture/contracts/#pbeta","text":"uint16 pBeta","title":"pBeta"},{"location":"architecture/contracts/#pgamma","text":"uint16 pGamma","title":"pGamma"},{"location":"architecture/contracts/#pxi","text":"uint16 pXi","title":"pXi"},{"location":"architecture/contracts/#pxin","text":"uint16 pXin","title":"pXin"},{"location":"architecture/contracts/#pbetaxi","text":"uint16 pBetaXi","title":"pBetaXi"},{"location":"architecture/contracts/#pv1","text":"uint16 pV1","title":"pV1"},{"location":"architecture/contracts/#pv2","text":"uint16 pV2","title":"pV2"},{"location":"architecture/contracts/#pv3","text":"uint16 pV3","title":"pV3"},{"location":"architecture/contracts/#pv4","text":"uint16 pV4","title":"pV4"},{"location":"architecture/contracts/#pv5","text":"uint16 pV5","title":"pV5"},{"location":"architecture/contracts/#pv6","text":"uint16 pV6","title":"pV6"},{"location":"architecture/contracts/#pu","text":"uint16 pU","title":"pU"},{"location":"architecture/contracts/#ppl","text":"uint16 pPl","title":"pPl"},{"location":"architecture/contracts/#peval_t","text":"uint16 pEval_t","title":"pEval_t"},{"location":"architecture/contracts/#pa1","text":"uint16 pA1","title":"pA1"},{"location":"architecture/contracts/#pb1","text":"uint16 pB1","title":"pB1"},{"location":"architecture/contracts/#pzh","text":"uint16 pZh","title":"pZh"},{"location":"architecture/contracts/#pzhinv","text":"uint16 pZhInv","title":"pZhInv"},{"location":"architecture/contracts/#peval_l1","text":"uint16 pEval_l1","title":"pEval_l1"},{"location":"architecture/contracts/#peval_l2","text":"uint16 pEval_l2","title":"pEval_l2"},{"location":"architecture/contracts/#peval_l3","text":"uint16 pEval_l3","title":"pEval_l3"},{"location":"architecture/contracts/#peval_l4","text":"uint16 pEval_l4","title":"pEval_l4"},{"location":"architecture/contracts/#peval_l5","text":"uint16 pEval_l5","title":"pEval_l5"},{"location":"architecture/contracts/#peval_l6","text":"uint16 pEval_l6","title":"pEval_l6"},{"location":"architecture/contracts/#peval_l7","text":"uint16 pEval_l7","title":"pEval_l7"},{"location":"architecture/contracts/#lastmem","text":"uint16 lastMem","title":"lastMem"},{"location":"architecture/contracts/#verifyproof","text":"function verifyProof ( bytes proof , uint256 [] pubSignals ) public view returns ( bool )","title":"verifyProof"},{"location":"architecture/contracts/#common","text":"","title":"Common"},{"location":"architecture/contracts/#getcurrentblocknumber","text":"function getCurrentBlockNumber () external view returns ( uint256 ) getCurrentBlockNumber get block number Name Type Description [0] uint256 the current block number","title":"getCurrentBlockNumber"},{"location":"architecture/contracts/#iscontract","text":"function isContract ( address addr ) public view returns ( bool ) isContract detect whether the address is is a contract address or externally owned account Name Type Description [0] bool true if it is a contract address","title":"isContract"},{"location":"architecture/contracts/#provenancesignatureiscorrect","text":"function provenanceSignatureIsCorrect ( address _agentId , bytes32 _hash , bytes _signature ) public pure returns ( bool ) Name Type Description _agentId address The address of the agent _hash bytes32 bytes32 message, the hash is the signed message. What is recovered is the signer address. _signature bytes Signatures provided by the agent Name Type Description [0] bool true if the signature correspond to the agent address","title":"provenanceSignatureIsCorrect"},{"location":"architecture/contracts/#calculatetotalamount","text":"function calculateTotalAmount ( uint256 [] _amounts ) public pure returns ( uint256 ) Sum the total amount given an uint array Name Type Description [0] uint256 the total amount","title":"calculateTotalAmount"},{"location":"architecture/contracts/#addresstobytes32","text":"function addressToBytes32 ( address _addr ) public pure returns ( bytes32 )","title":"addressToBytes32"},{"location":"architecture/contracts/#bytes32toaddress","text":"function bytes32ToAddress ( bytes32 _b32 ) public pure returns ( address )","title":"bytes32ToAddress"},{"location":"architecture/contracts/#dispenser","text":"","title":"Dispenser"},{"location":"architecture/contracts/#tokenrequests","text":"mapping ( address => uint256 ) tokenRequests","title":"tokenRequests"},{"location":"architecture/contracts/#totalmintamount","text":"uint256 totalMintAmount","title":"totalMintAmount"},{"location":"architecture/contracts/#maxamount","text":"uint256 maxAmount","title":"maxAmount"},{"location":"architecture/contracts/#maxmintamount","text":"uint256 maxMintAmount","title":"maxMintAmount"},{"location":"architecture/contracts/#minperiod","text":"uint256 minPeriod","title":"minPeriod"},{"location":"architecture/contracts/#scale","text":"uint256 scale","title":"scale"},{"location":"architecture/contracts/#token","text":"contract NeverminedToken token","title":"token"},{"location":"architecture/contracts/#requestfrequencyexceeded","text":"event RequestFrequencyExceeded ( address requester , uint256 minPeriod )","title":"RequestFrequencyExceeded"},{"location":"architecture/contracts/#requestlimitexceeded","text":"event RequestLimitExceeded ( address requester , uint256 amount , uint256 maxAmount )","title":"RequestLimitExceeded"},{"location":"architecture/contracts/#isvalidaddress","text":"modifier isValidAddress ( address _address )","title":"isValidAddress"},{"location":"architecture/contracts/#initialize","text":"function initialize ( address _tokenAddress , address _owner ) external Dispenser Initializer Name Type Description _tokenAddress address The deployed contract address of an ERC20 _owner address The owner of the Dispenser Runs only on initial contract creation.","title":"initialize"},{"location":"architecture/contracts/#requesttokens","text":"function requestTokens ( uint256 amount ) external returns ( bool tokensTransferred ) user can request some tokens for testing Name Type Description amount uint256 the amount of tokens to be requested Name Type Description tokensTransferred bool Boolean indication of tokens are requested","title":"requestTokens"},{"location":"architecture/contracts/#setminperiod","text":"function setMinPeriod ( uint256 period ) external the Owner can set the min period for token requests Name Type Description period uint256 the min amount of time before next request","title":"setMinPeriod"},{"location":"architecture/contracts/#setmaxamount","text":"function setMaxAmount ( uint256 amount ) external the Owner can set the max amount for token requests Name Type Description amount uint256 the max amount of tokens that can be requested","title":"setMaxAmount"},{"location":"architecture/contracts/#setmaxmintamount","text":"function setMaxMintAmount ( uint256 amount ) external the Owner can set the max amount for token requests Name Type Description amount uint256 the max amount of tokens that can be requested","title":"setMaxMintAmount"},{"location":"architecture/contracts/#hashlists","text":"Hash lists contract is a sample list contract in which uses HashListLibrary.sol in order to store, retrieve, remove, and update bytes32 values in hash lists. This is a reference implementation for IList interface. It is used for whitelisting condition. Any entity can have its own implementation of the interface in which could be used for the same condition.","title":"HashLists"},{"location":"architecture/contracts/#lists","text":"mapping ( bytes32 => struct HashListLibrary . List ) lists","title":"lists"},{"location":"architecture/contracts/#initialize_1","text":"function initialize ( address _owner ) public HashLists Initializer Name Type Description _owner address The owner of the hash list Runs only upon contract creation.","title":"initialize"},{"location":"architecture/contracts/#hash","text":"function hash ( address account ) public pure returns ( bytes32 ) hash ethereum accounts Name Type Description account address Ethereum address Name Type Description [0] bytes32 bytes32 hash of the account","title":"hash"},{"location":"architecture/contracts/#add","text":"function add ( bytes32 [] values ) external returns ( bool ) put an array of elements without indexing this meant to save gas in case of large arrays Name Type Description values bytes32[] is an array of elements value Name Type Description [0] bool true if values are added successfully","title":"add"},{"location":"architecture/contracts/#add_1","text":"function add ( bytes32 value ) external returns ( bool ) add indexes an element then adds it to a list Name Type Description value bytes32 is a bytes32 value Name Type Description [0] bool true if value is added successfully","title":"add"},{"location":"architecture/contracts/#update","text":"function update ( bytes32 oldValue , bytes32 newValue ) external returns ( bool ) update the value with a new value and maintain indices Name Type Description oldValue bytes32 is an element value in a list newValue bytes32 new value Name Type Description [0] bool true if value is updated successfully","title":"update"},{"location":"architecture/contracts/#index","text":"function index ( uint256 from , uint256 to ) external returns ( bool ) index is used to map each element value to its index on the list Name Type Description from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing Name Type Description [0] bool true if the sub list is indexed","title":"index"},{"location":"architecture/contracts/#has","text":"function has ( bytes32 id , bytes32 value ) external view returns ( bool ) has checks whether a value is exist Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list Name Type Description [0] bool true if the value exists","title":"has"},{"location":"architecture/contracts/#has_1","text":"function has ( bytes32 value ) external view returns ( bool ) has checks whether a value is exist Name Type Description value bytes32 is element value in list Name Type Description [0] bool true if the value exists","title":"has"},{"location":"architecture/contracts/#remove","text":"function remove ( bytes32 value ) external returns ( bool ) remove value from a list, updates indices, and list size Name Type Description value bytes32 is an element value in a list Name Type Description [0] bool true if value is removed successfully","title":"remove"},{"location":"architecture/contracts/#get","text":"function get ( bytes32 id , uint256 _index ) external view returns ( bytes32 ) has value by index Name Type Description id bytes32 the list identifier (the hash of list owner's address) _index uint256 is where is value is stored in the list Name Type Description [0] bytes32 the value if exists","title":"get"},{"location":"architecture/contracts/#size","text":"function size ( bytes32 id ) external view returns ( uint256 ) size gets the list size Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] uint256 total length of the list","title":"size"},{"location":"architecture/contracts/#all","text":"function all ( bytes32 id ) external view returns ( bytes32 []) all returns all list elements Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] bytes32[] all list elements","title":"all"},{"location":"architecture/contracts/#indexof","text":"function indexOf ( bytes32 id , bytes32 value ) external view returns ( uint256 ) indexOf gets the index of a value in a list Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list Name Type Description [0] uint256 value index in list","title":"indexOf"},{"location":"architecture/contracts/#ownedby","text":"function ownedBy ( bytes32 id ) external view returns ( address ) ownedBy gets the list owner Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] address list owner","title":"ownedBy"},{"location":"architecture/contracts/#isindexed","text":"function isIndexed ( bytes32 id ) external view returns ( bool ) isIndexed checks if the list is indexed Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] bool true if the list is indexed","title":"isIndexed"},{"location":"architecture/contracts/#neverminedtoken","text":"Implementation of a Test Token. Test Token is an ERC20 token only for testing purposes","title":"NeverminedToken"},{"location":"architecture/contracts/#initialize_2","text":"function initialize ( address _owner , address payable _initialMinter ) public NeverminedToken Initializer Runs only on initial contract creation. Name Type Description _owner address refers to the owner of the contract _initialMinter address payable is the first token minter added","title":"initialize"},{"location":"architecture/contracts/#_beforetokentransfer","text":"function _beforeTokenTransfer ( address from , address to , uint256 amount ) internal _See {ERC20-_beforeTokenTransfer}. Requirements: minted tokens must not cause the total supply to go over the cap._","title":"_beforeTokenTransfer"},{"location":"architecture/contracts/#mint","text":"function mint ( address account , uint256 amount ) external returns ( bool ) _Creates amount tokens and assigns them to account , increasing the total supply. Emits a {Transfer} event with from set to the zero address. Requirements: to cannot be the zero address._","title":"mint"},{"location":"architecture/contracts/#agreementstorelibrary","text":"Implementation of the Agreement Store Library. The agreement store library holds the business logic in which manages the life cycle of SEA agreement, each agreement is linked to the DID of an asset, template, and condition IDs.","title":"AgreementStoreLibrary"},{"location":"architecture/contracts/#agreement","text":"struct Agreement { bytes32 did ; address templateId ; bytes32 [] conditionIds ; address lastUpdatedBy ; uint256 blockNumberUpdated ; }","title":"Agreement"},{"location":"architecture/contracts/#agreementlist","text":"struct AgreementList { mapping ( bytes32 &# x3D ; & gt ; struct AgreementStoreLibrary . Agreement ) agreements ; mapping ( bytes32 &# x3D ; & gt ; bytes32 []) didToAgreementIds ; mapping ( address &# x3D ; & gt ; bytes32 []) templateIdToAgreementIds ; bytes32 [] agreementIds ; }","title":"AgreementList"},{"location":"architecture/contracts/#create","text":"function create ( struct AgreementStoreLibrary . AgreementList _self , bytes32 _id , bytes32 , address _templateId , bytes32 []) internal create new agreement checks whether the agreement Id exists, creates new agreement instance, including the template, conditions and DID. Name Type Description _self struct AgreementStoreLibrary.AgreementList is AgreementList storage pointer _id bytes32 agreement identifier bytes32 _templateId address template identifier bytes32[]","title":"create"},{"location":"architecture/contracts/#template","text":"","title":"Template"},{"location":"architecture/contracts/#getconditiontypes","text":"function getConditionTypes () external view returns ( address [])","title":"getConditionTypes"},{"location":"architecture/contracts/#agreementstoremanager","text":"_Implementation of the Agreement Store. The agreement store generates conditions for an agreement template. Agreement templates must to be approved in the Template Store Each agreement is linked to the DID of an asset._","title":"AgreementStoreManager"},{"location":"architecture/contracts/#proxy_role","text":"bytes32 PROXY_ROLE","title":"PROXY_ROLE"},{"location":"architecture/contracts/#grantproxyrole","text":"function grantProxyRole ( address _address ) public","title":"grantProxyRole"},{"location":"architecture/contracts/#revokeproxyrole","text":"function revokeProxyRole ( address _address ) public","title":"revokeProxyRole"},{"location":"architecture/contracts/#agreementlist_1","text":"struct AgreementStoreLibrary . AgreementList agreementList state storage for the agreements","title":"agreementList"},{"location":"architecture/contracts/#conditionstoremanager","text":"contract ConditionStoreManager conditionStoreManager","title":"conditionStoreManager"},{"location":"architecture/contracts/#templatestoremanager","text":"contract TemplateStoreManager templateStoreManager","title":"templateStoreManager"},{"location":"architecture/contracts/#didregistry","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#initialize_3","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _templateStoreManagerAddress , address _didRegistryAddress ) public initialize AgreementStoreManager Initializer Initializes Ownable. Only on contract creation. Name Type Description _owner address refers to the owner of the contract _conditionStoreManagerAddress address is the address of the connected condition store _templateStoreManagerAddress address is the address of the connected template store _didRegistryAddress address is the address of the connected DID Registry","title":"initialize"},{"location":"architecture/contracts/#fullconditionid","text":"function fullConditionId ( bytes32 _agreementId , address _condType , bytes32 _valueHash ) public pure returns ( bytes32 )","title":"fullConditionId"},{"location":"architecture/contracts/#agreementid","text":"function agreementId ( bytes32 _agreementId , address _creator ) public pure returns ( bytes32 )","title":"agreementId"},{"location":"architecture/contracts/#createagreement","text":"function createAgreement ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts ) public Create a new agreement. The agreement will create conditions of conditionType with conditionId. Only \"approved\" templates can access this function. Name Type Description _id bytes32 is the ID of the new agreement. Must be unique. _did bytes32 is the bytes32 DID of the asset. The DID must be registered beforehand. _conditionTypes address[] is a list of addresses that point to Condition contracts. _conditionIds bytes32[] is a list of bytes32 content-addressed Condition IDs _timeLocks uint256[] is a list of uint time lock values associated to each Condition _timeOuts uint256[] is a list of uint time out values associated to each Condition","title":"createAgreement"},{"location":"architecture/contracts/#createagreementargs","text":"struct CreateAgreementArgs { bytes32 _id ; bytes32 _did ; address [] _conditionTypes ; bytes32 [] _conditionIds ; uint256 [] _timeLocks ; uint256 [] _timeOuts ; address _creator ; uint256 _idx ; address payable _rewardAddress ; address _tokenAddress ; uint256 [] _amounts ; address [] _receivers ; }","title":"CreateAgreementArgs"},{"location":"architecture/contracts/#createagreementandpay","text":"function createAgreementAndPay ( struct AgreementStoreManager . CreateAgreementArgs args ) public payable","title":"createAgreementAndPay"},{"location":"architecture/contracts/#createagreementandfulfill","text":"function createAgreementAndFulfill ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address [] _account , uint256 [] _idx , bytes [] params ) public payable","title":"createAgreementAndFulfill"},{"location":"architecture/contracts/#getagreementtemplate","text":"function getAgreementTemplate ( bytes32 _id ) external view returns ( address )","title":"getAgreementTemplate"},{"location":"architecture/contracts/#getdidregistryaddress","text":"function getDIDRegistryAddress () public view virtual returns ( address ) getDIDRegistryAddress utility function used by other contracts or any EOA. Name Type Description [0] address the DIDRegistry address","title":"getDIDRegistryAddress"},{"location":"architecture/contracts/#accesscondition","text":"_Implementation of the Access Condition Access Secret Store Condition is special condition where a client or Parity secret store can encrypt/decrypt documents based on the on-chain granted permissions. For a given DID document, and agreement ID, the owner/provider of the DID will fulfill the condition. Consequently secret store will check whether the permission is granted for the consumer in order to encrypt/decrypt the document._","title":"AccessCondition"},{"location":"architecture/contracts/#condition_type","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#documentpermission","text":"struct DocumentPermission { bytes32 agreementIdDeprecated ; mapping ( address &# x3D ; & gt ; bool ) permission ; }","title":"DocumentPermission"},{"location":"architecture/contracts/#documentpermissions","text":"mapping ( bytes32 => struct AccessCondition . DocumentPermission ) documentPermissions","title":"documentPermissions"},{"location":"architecture/contracts/#agreementstoremanager_1","text":"contract AgreementStoreManager agreementStoreManager","title":"agreementStoreManager"},{"location":"architecture/contracts/#didregistry_1","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#fulfilled","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _documentId , address _grantee , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/#onlydidownerorprovider","text":"modifier onlyDIDOwnerOrProvider ( bytes32 _documentId )","title":"onlyDIDOwnerOrProvider"},{"location":"architecture/contracts/#initialize_4","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address","title":"initialize"},{"location":"architecture/contracts/#reinitialize","text":"function reinitialize () external Should be called when the contract has been upgraded.","title":"reinitialize"},{"location":"architecture/contracts/#hashvalues","text":"function hashValues ( bytes32 _documentId , address _grantee ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill","text":"function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill access secret store condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#grantpermission","text":"function grantPermission ( address _grantee , bytes32 _documentId ) public grantPermission is called only by DID owner or provider Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys","title":"grantPermission"},{"location":"architecture/contracts/#renouncepermission","text":"function renouncePermission ( address _grantee , bytes32 _documentId ) public renouncePermission is called only by DID owner or provider Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys","title":"renouncePermission"},{"location":"architecture/contracts/#checkpermissions","text":"function checkPermissions ( address _grantee , bytes32 _documentId ) external view returns ( bool permissionGranted ) checkPermissions is called by Parity secret store Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys Name Type Description permissionGranted bool true if the access was granted","title":"checkPermissions"},{"location":"architecture/contracts/#idisputemanager","text":"","title":"IDisputeManager"},{"location":"architecture/contracts/#verifyproof_1","text":"function verifyProof ( bytes proof , uint256 [] pubSignals ) external view returns ( bool )","title":"verifyProof"},{"location":"architecture/contracts/#accessproofcondition","text":"Implementation of the Access Condition with transfer proof. The idea is that the hash of the decryption key is known before hand, and the key matching this hash is passed from data provider to the buyer using this smart contract. Using ZK proof the key is kept hidden from outsiders. For the protocol to work, both the provider and buyer need to have public keys in the babyjub curve. To initiate the deal, buyer will pass the key hash and the public keys of participants. The provider needs to pass the cipher text encrypted using MIMC (symmetric encryption). The secret key for MIMC is computed using ECDH (requires one public key and one secret key for the curve). The hash function that is used is Poseidon.","title":"AccessProofCondition"},{"location":"architecture/contracts/#condition_type_1","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#agreementstoremanager_2","text":"contract AgreementStoreManager agreementStoreManager","title":"agreementStoreManager"},{"location":"architecture/contracts/#disputemanager","text":"contract IDisputeManager disputeManager","title":"disputeManager"},{"location":"architecture/contracts/#fulfilled_1","text":"event Fulfilled ( bytes32 _agreementId , uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider , uint256 [ 2 ] _cipher , bytes _proof , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/#initialize_5","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress , address _disputeManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address _disputeManagerAddress address dispute manager address","title":"initialize"},{"location":"architecture/contracts/#changedisputemanager","text":"function changeDisputeManager ( address _disputeManagerAddress ) external","title":"changeDisputeManager"},{"location":"architecture/contracts/#hashvalues_1","text":"function hashValues ( uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _origHash uint256 is the hash of the key _buyer uint256[2] buyer public key _provider uint256[2] provider public key Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_1","text":"function fulfill ( bytes32 _agreementId , uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider , uint256 [ 2 ] _cipher , bytes _proof ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill key transfer The key with hash _origHash is transferred to the _buyer from _provider. Name Type Description _agreementId bytes32 associated agreement _origHash uint256 is the hash of data to access _buyer uint256[2] buyer public key _provider uint256[2] provider public key _cipher uint256[2] encrypted version of the key _proof bytes SNARK proof that the cipher text can be decrypted by buyer to give the key with hash _origHash Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#computeexecutioncondition","text":"Implementation of the Compute Execution Condition This condition is meant to be a signal in which triggers the execution of a compute service. The compute service is fully described in the associated DID document. The provider of the compute service will send this signal to its workers by fulfilling the condition where they are listening to the fulfilled event.","title":"ComputeExecutionCondition"},{"location":"architecture/contracts/#condition_type_2","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#computeexecutionstatus","text":"mapping ( bytes32 => mapping ( address => bool )) computeExecutionStatus","title":"computeExecutionStatus"},{"location":"architecture/contracts/#agreementstoremanager_3","text":"contract AgreementStoreManager agreementStoreManager","title":"agreementStoreManager"},{"location":"architecture/contracts/#fulfilled_2","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _computeConsumer , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/#onlydidownerorprovider_1","text":"modifier onlyDIDOwnerOrProvider ( bytes32 _did )","title":"onlyDIDOwnerOrProvider"},{"location":"architecture/contracts/#initialize_6","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_2","text":"function hashValues ( bytes32 _did , address _computeConsumer ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_2","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _computeConsumer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill compute execution condition only the compute provider can fulfill this condition. By fulfilling this condition the compute provider will trigger the execution of the offered job/compute. The compute service is described in a DID document. Name Type Description _agreementId bytes32 agreement identifier _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#wascomputetriggered","text":"function wasComputeTriggered ( bytes32 _did , address _computeConsumer ) public view returns ( bool ) wasComputeTriggered checks whether the compute is triggered or not. Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the compute consumer's address Name Type Description [0] bool true if the compute is triggered","title":"wasComputeTriggered"},{"location":"architecture/contracts/#condition","text":"_Implementation of the Condition Each condition has a validation function that returns either FULFILLED, ABORTED or UNFULFILLED. When a condition is successfully solved, we call it FULFILLED. If a condition cannot be FULFILLED anymore due to a timeout or other types of counter-proofs, the condition is ABORTED. UNFULFILLED values imply that a condition has not been provably FULFILLED or ABORTED. All initialized conditions start out as UNFULFILLED._","title":"Condition"},{"location":"architecture/contracts/#conditionstoremanager_1","text":"contract ConditionStoreManager conditionStoreManager","title":"conditionStoreManager"},{"location":"architecture/contracts/#generateid","text":"function generateId ( bytes32 _agreementId , bytes32 _valueHash ) public view returns ( bytes32 ) generateId condition Id from the following parameters Name Type Description _agreementId bytes32 SEA agreement ID _valueHash bytes32 hash of all the condition input values","title":"generateId"},{"location":"architecture/contracts/#fulfill_3","text":"function fulfill ( bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) internal returns ( enum ConditionStoreLibrary . ConditionState ) fulfill set the condition state to Fulfill | Abort Name Type Description _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState new condition state (Fulfill/Abort) Name Type Description [0] enum ConditionStoreLibrary.ConditionState the updated condition state","title":"fulfill"},{"location":"architecture/contracts/#abortbytimeout","text":"function abortByTimeOut ( bytes32 _id ) external returns ( enum ConditionStoreLibrary . ConditionState ) abortByTimeOut set condition state to Aborted if the condition is timed out Name Type Description _id bytes32 condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState the updated condition state","title":"abortByTimeOut"},{"location":"architecture/contracts/#conditionstorelibrary","text":"_Implementation of the Condition Store Library. Condition is a key component in the service execution agreement. This library holds the logic for creating and updating condition Any Condition has only four state transitions starts with Uninitialized, Unfulfilled, Fulfilled, and Aborted. Condition state transition goes only forward from Unintialized -> Unfulfilled -> {Fulfilled || Aborted}_","title":"ConditionStoreLibrary"},{"location":"architecture/contracts/#conditionstate","text":"enum ConditionState { Uninitialized , Unfulfilled , Fulfilled , Aborted }","title":"ConditionState"},{"location":"architecture/contracts/#condition_1","text":"struct Condition { address typeRef ; enum ConditionStoreLibrary . ConditionState state ; address createdBy ; address lastUpdatedBy ; uint256 blockNumberUpdated ; }","title":"Condition"},{"location":"architecture/contracts/#conditionlist","text":"struct ConditionList { mapping ( bytes32 &# x3D ; & gt ; struct ConditionStoreLibrary . Condition ) conditions ; mapping ( bytes32 &# x3D ; & gt ; mapping ( bytes32 &# x3D ; & gt ; bytes32 )) map ; bytes32 [] conditionIds ; }","title":"ConditionList"},{"location":"architecture/contracts/#create_1","text":"function create ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , address _typeRef ) internal create new condition check whether the condition exists, assigns condition type, condition state, last updated by, and update at (which is the current block number) Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 valid condition identifier _typeRef address condition contract address","title":"create"},{"location":"architecture/contracts/#updatestate","text":"function updateState ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) internal updateState update the condition state check whether the condition state transition is right, assign the new state, update last updated by and updated at. Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState the new state of the condition","title":"updateState"},{"location":"architecture/contracts/#updatekeyvalue","text":"function updateKeyValue ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , bytes32 _key , bytes32 _value ) internal","title":"updateKeyValue"},{"location":"architecture/contracts/#conditionstoremanager_2","text":"_Implementation of the Condition Store Manager. Condition store manager is responsible for enforcing the the business logic behind creating/updating the condition state based on the assigned role to each party. Only specific type of contracts are allowed to call this contract, therefore there are two types of roles, create role that in which is able to create conditions. The second role is the update role, which is can update the condition state. Also, it support delegating the roles to other contract(s)/account(s)._","title":"ConditionStoreManager"},{"location":"architecture/contracts/#proxy_role_1","text":"bytes32 PROXY_ROLE","title":"PROXY_ROLE"},{"location":"architecture/contracts/#roletype","text":"enum RoleType { Create , Update }","title":"RoleType"},{"location":"architecture/contracts/#createrole","text":"address createRole","title":"createRole"},{"location":"architecture/contracts/#conditionlist_1","text":"struct ConditionStoreLibrary . ConditionList conditionList","title":"conditionList"},{"location":"architecture/contracts/#epochlist","text":"struct EpochLibrary . EpochList epochList","title":"epochList"},{"location":"architecture/contracts/#nvmconfigaddress","text":"address nvmConfigAddress","title":"nvmConfigAddress"},{"location":"architecture/contracts/#conditioncreated","text":"event ConditionCreated ( bytes32 _id , address _typeRef , address _who )","title":"ConditionCreated"},{"location":"architecture/contracts/#conditionupdated","text":"event ConditionUpdated ( bytes32 _id , address _typeRef , enum ConditionStoreLibrary . ConditionState _state , address _who )","title":"ConditionUpdated"},{"location":"architecture/contracts/#onlycreaterole","text":"modifier onlyCreateRole ()","title":"onlyCreateRole"},{"location":"architecture/contracts/#onlyupdaterole","text":"modifier onlyUpdateRole ( bytes32 _id )","title":"onlyUpdateRole"},{"location":"architecture/contracts/#onlyvalidtype","text":"modifier onlyValidType ( address typeRef )","title":"onlyValidType"},{"location":"architecture/contracts/#initialize_7","text":"function initialize ( address _creator , address _owner , address _nvmConfigAddress ) public initialize ConditionStoreManager Initializer Initialize Ownable. Only on contract creation, Name Type Description _creator address refers to the creator of the contract _owner address refers to the owner of the contract _nvmConfigAddress address refers to the contract address of NeverminedConfig","title":"initialize"},{"location":"architecture/contracts/#getcreaterole","text":"function getCreateRole () external view returns ( address ) getCreateRole get the address of contract which has the create role Name Type Description [0] address create condition role address","title":"getCreateRole"},{"location":"architecture/contracts/#getnvmconfigaddress","text":"function getNvmConfigAddress () external view returns ( address ) getNvmConfigAddress get the address of the NeverminedConfig contract Name Type Description [0] address NeverminedConfig contract address","title":"getNvmConfigAddress"},{"location":"architecture/contracts/#setnvmconfigaddress","text":"function setNvmConfigAddress ( address _addr ) external","title":"setNvmConfigAddress"},{"location":"architecture/contracts/#delegatecreaterole","text":"function delegateCreateRole ( address delegatee ) external delegateCreateRole only owner can delegate the create condition role to a different address Name Type Description delegatee address delegatee address","title":"delegateCreateRole"},{"location":"architecture/contracts/#delegateupdaterole","text":"function delegateUpdateRole ( bytes32 _id , address delegatee ) external delegateUpdateRole only owner can delegate the update role to a different address for specific condition Id which has the create role Name Type Description _id bytes32 delegatee address delegatee address","title":"delegateUpdateRole"},{"location":"architecture/contracts/#grantproxyrole_1","text":"function grantProxyRole ( address _address ) public","title":"grantProxyRole"},{"location":"architecture/contracts/#revokeproxyrole_1","text":"function revokeProxyRole ( address _address ) public","title":"revokeProxyRole"},{"location":"architecture/contracts/#createcondition","text":"function createCondition ( bytes32 _id , address _typeRef ) external createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled. Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address","title":"createCondition"},{"location":"architecture/contracts/#createcondition2","text":"function createCondition2 ( bytes32 _id , address _typeRef ) external","title":"createCondition2"},{"location":"architecture/contracts/#createcondition_1","text":"function createCondition ( bytes32 _id , address _typeRef , uint256 _timeLock , uint256 _timeOut ) public createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled. Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address _timeLock uint256 start of the time window _timeOut uint256 end of the time window","title":"createCondition"},{"location":"architecture/contracts/#updateconditionstate","text":"function updateConditionState ( bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) external returns ( enum ConditionStoreLibrary . ConditionState ) updateConditionState only called by update role address. It enforce the condition state transition to either Fulfill or Aborted state Name Type Description _id bytes32 unique condition identifier _newState enum ConditionStoreLibrary.ConditionState Name Type Description [0] enum ConditionStoreLibrary.ConditionState the current condition state","title":"updateConditionState"},{"location":"architecture/contracts/#updateconditionmapping","text":"function updateConditionMapping ( bytes32 _id , bytes32 _key , bytes32 _value ) external","title":"updateConditionMapping"},{"location":"architecture/contracts/#updateconditionmappingproxy","text":"function updateConditionMappingProxy ( bytes32 _id , bytes32 _key , bytes32 _value ) external","title":"updateConditionMappingProxy"},{"location":"architecture/contracts/#getcondition","text":"function getCondition ( bytes32 _id ) external view returns ( address typeRef , enum ConditionStoreLibrary . ConditionState state , uint256 timeLock , uint256 timeOut , uint256 blockNumber ) getCondition Name Type Description typeRef address the type reference state enum ConditionStoreLibrary.ConditionState condition state timeLock uint256 the time lock timeOut uint256 time out blockNumber uint256 block number","title":"getCondition"},{"location":"architecture/contracts/#getconditionstate","text":"function getConditionState ( bytes32 _id ) external view virtual returns ( enum ConditionStoreLibrary . ConditionState ) getConditionState Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"getConditionState"},{"location":"architecture/contracts/#getconditiontyperef","text":"function getConditionTypeRef ( bytes32 _id ) external view virtual returns ( address ) getConditionTypeRef Name Type Description [0] address condition typeRef","title":"getConditionTypeRef"},{"location":"architecture/contracts/#getmappingvalue","text":"function getMappingValue ( bytes32 _id , bytes32 _key ) external view virtual returns ( bytes32 ) getConditionState Name Type Description [0] bytes32 condition state","title":"getMappingValue"},{"location":"architecture/contracts/#isconditiontimelocked","text":"function isConditionTimeLocked ( bytes32 _id ) public view returns ( bool ) isConditionTimeLocked Name Type Description [0] bool whether the condition is timedLock ended","title":"isConditionTimeLocked"},{"location":"architecture/contracts/#isconditiontimedout","text":"function isConditionTimedOut ( bytes32 _id ) public view returns ( bool ) isConditionTimedOut Name Type Description [0] bool whether the condition is timed out","title":"isConditionTimedOut"},{"location":"architecture/contracts/#hashlockcondition","text":"Implementation of the Hash Lock Condition","title":"HashLockCondition"},{"location":"architecture/contracts/#condition_type_3","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#initialize_8","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_3","text":"function hashValues ( uint256 _preimage ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _preimage uint256 refers uint value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#hashvalues_4","text":"function hashValues ( string _preimage ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _preimage string refers string value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#hashvalues_5","text":"function hashValues ( bytes32 _preimage ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _preimage bytes32 refers bytes32 value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_4","text":"function fulfill ( bytes32 _agreementId , uint256 _preimage ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image uint value Name Type Description _agreementId bytes32 SEA agreement identifier _preimage uint256 Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/#fulfill_5","text":"function fulfill ( bytes32 _agreementId , string _preimage ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image string value Name Type Description _agreementId bytes32 SEA agreement identifier _preimage string Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/#fulfill_6","text":"function fulfill ( bytes32 _agreementId , bytes32 _preimage ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image bytes32 value Name Type Description _agreementId bytes32 SEA agreement identifier _preimage bytes32 Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/#_fulfill","text":"function _fulfill ( bytes32 _generatedId ) private returns ( enum ConditionStoreLibrary . ConditionState ) _fulfill calls super fulfil method Name Type Description _generatedId bytes32 SEA agreement identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"_fulfill"},{"location":"architecture/contracts/#icondition","text":"","title":"ICondition"},{"location":"architecture/contracts/#fulfillproxy","text":"function fulfillProxy ( address _account , bytes32 _agreementId , bytes params ) external payable","title":"fulfillProxy"},{"location":"architecture/contracts/#ilockpayment","text":"","title":"ILockPayment"},{"location":"architecture/contracts/#fulfilled_3","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId , address _rewardAddress , address _tokenAddress , address [] _receivers , uint256 [] _amounts )","title":"Fulfilled"},{"location":"architecture/contracts/#hashvalues_6","text":"function hashValues ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_7","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires valid token transfer in order to lock the amount of tokens based on the SEA Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/#lockpaymentcondition","text":"Implementation of the Lock Payment Condition This condition allows to lock payment for multiple receivers taking into account the royalties to be paid to the original creators in a secondary market.","title":"LockPaymentCondition"},{"location":"architecture/contracts/#didregistry_2","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#nvmconfig","text":"contract INVMConfig nvmConfig","title":"nvmConfig"},{"location":"architecture/contracts/#condition_type_4","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#key_asset_receiver","text":"bytes32 KEY_ASSET_RECEIVER","title":"KEY_ASSET_RECEIVER"},{"location":"architecture/contracts/#proxy_role_2","text":"bytes32 PROXY_ROLE","title":"PROXY_ROLE"},{"location":"architecture/contracts/#allowed_external_contract_role","text":"bytes32 ALLOWED_EXTERNAL_CONTRACT_ROLE","title":"ALLOWED_EXTERNAL_CONTRACT_ROLE"},{"location":"architecture/contracts/#grantproxyrole_2","text":"function grantProxyRole ( address _address ) public","title":"grantProxyRole"},{"location":"architecture/contracts/#revokeproxyrole_2","text":"function revokeProxyRole ( address _address ) public","title":"revokeProxyRole"},{"location":"architecture/contracts/#grantexternalcontractrole","text":"function grantExternalContractRole ( address _address ) public","title":"grantExternalContractRole"},{"location":"architecture/contracts/#revokeexternalcontractrole","text":"function revokeExternalContractRole ( address _address ) public","title":"revokeExternalContractRole"},{"location":"architecture/contracts/#initialize_9","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address","title":"initialize"},{"location":"architecture/contracts/#reinitialize_1","text":"function reinitialize () external Should be called when the contract has been upgraded.","title":"reinitialize"},{"location":"architecture/contracts/#hashvalues_7","text":"function hashValues ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_8","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires valid token transfer in order to lock the amount of tokens based on the SEA Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/#fulfillexternal","text":"function fulfillExternal ( bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _externalContract , bytes32 _remoteId , uint256 [] _amounts , address [] _receivers ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) fulfill lock condition using the funds locked in an external contract (auction, bonding curve, lottery, etc) Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _externalContract address the address of the contract with the lock funds are locked _remoteId bytes32 the id used to identify into the external contract _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfillExternal"},{"location":"architecture/contracts/#encodeparams","text":"function encodeParams ( bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external pure returns ( bytes )","title":"encodeParams"},{"location":"architecture/contracts/#fulfillinternal","text":"function fulfillInternal ( address _account , bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) internal returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfillInternal"},{"location":"architecture/contracts/#fulfillproxy_1","text":"function fulfillProxy ( address _account , bytes32 _agreementId , bytes params ) external payable","title":"fulfillProxy"},{"location":"architecture/contracts/#_transfererc20proxy","text":"function _transferERC20Proxy ( address _senderAddress , address _rewardAddress , address _tokenAddress , uint256 _amount ) internal _transferERC20Proxy transfer ERC20 tokens Will throw if transfer fails Name Type Description _senderAddress address the address to send the tokens from _rewardAddress address the address to receive the tokens _tokenAddress address the ERC20 contract address to use during the payment _amount uint256 token amount to be locked/released","title":"_transferERC20Proxy"},{"location":"architecture/contracts/#_transfereth","text":"function _transferETH ( address payable _rewardAddress , uint256 _amount ) internal _transferETH transfer ETH Name Type Description _rewardAddress address payable the address to receive the ETH _amount uint256 ETH amount to be locked/released","title":"_transferETH"},{"location":"architecture/contracts/#allowedexternalcontract","text":"modifier allowedExternalContract ( address _externalContractAddress )","title":"allowedExternalContract"},{"location":"architecture/contracts/#aremarketplacefeesincluded","text":"function areMarketplaceFeesIncluded ( uint256 [] _amounts , address [] _receivers ) internal view returns ( bool )","title":"areMarketplaceFeesIncluded"},{"location":"architecture/contracts/#distributenftcollateralcondition","text":"Implementation of a condition allowing to transfer a NFT to an account or another depending on the final state of a lock condition","title":"DistributeNFTCollateralCondition"},{"location":"architecture/contracts/#condition_type_5","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#aavecreditvault","text":"contract AaveCreditVault aaveCreditVault","title":"aaveCreditVault"},{"location":"architecture/contracts/#_lockconditionaddress","text":"address _lockConditionAddress","title":"_lockConditionAddress"},{"location":"architecture/contracts/#fulfilled_4","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _receiver , bytes32 _conditionId , address _contract )","title":"Fulfilled"},{"location":"architecture/contracts/#initialize_10","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _lockNFTConditionAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _lockNFTConditionAddress address Lock NFT Condition address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_8","text":"function hashValues ( bytes32 _did , address _vaultAddress , address _nftContractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _vaultAddress address The contract address of the vault _nftContractAddress address NFT contract to use Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_9","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _nftContractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _vaultAddress address The contract address of the vault _nftContractAddress address NFT contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#inftaccess","text":"","title":"INFTAccess"},{"location":"architecture/contracts/#fulfilled_5","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _documentId , address _grantee , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/#hashvalues_9","text":"function hashValues ( bytes32 _documentId , address _grantee , address _contractAddress ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_10","text":"function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access conditions only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#inftholder","text":"","title":"INFTHolder"},{"location":"architecture/contracts/#fulfilled_6","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _address , bytes32 _conditionId , uint256 _amount )","title":"Fulfilled"},{"location":"architecture/contracts/#hashvalues_10","text":"function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_11","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/#inftlock","text":"","title":"INFTLock"},{"location":"architecture/contracts/#fulfilled_7","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _lockAddress , bytes32 _conditionId , uint256 _amount , address _receiver , address _nftContractAddress )","title":"Fulfilled"},{"location":"architecture/contracts/#hashvalues_11","text":"function hashValues ( bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the NFTs locked _nftContractAddress address Is the address of the NFT (ERC-721, ERC-1155) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#hashvaluesmarked","text":"function hashValuesMarked ( bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) external pure returns ( bytes32 )","title":"hashValuesMarked"},{"location":"architecture/contracts/#fulfill_12","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#fulfillmarked","text":"function fulfillMarked ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfillMarked"},{"location":"architecture/contracts/#itransfernft","text":"","title":"ITransferNFT"},{"location":"architecture/contracts/#fulfilled_8","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _receiver , uint256 _amount , bytes32 _conditionId , address _contract )","title":"Fulfilled"},{"location":"architecture/contracts/#hashvalues_12","text":"function hashValues ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockCondition , address _contract , bool _transfer ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _contract address _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_13","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _contract , bool _transfer ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _contract address _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#getnftdefaultaddress","text":"function getNFTDefaultAddress () external view returns ( address ) returns if the default NFT contract address The default NFT contract address was given to the Transfer Condition during the contract initialization Name Type Description [0] address the NFT contract address used by default in the transfer condition","title":"getNFTDefaultAddress"},{"location":"architecture/contracts/#nft721holdercondition","text":"Implementation of the Nft Holder Condition","title":"NFT721HolderCondition"},{"location":"architecture/contracts/#condition_type_6","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#initialize_11","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_13","text":"function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_14","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/#nft721lockcondition","text":"Implementation of the NFT Lock Condition for ERC-721 based NFTs","title":"NFT721LockCondition"},{"location":"architecture/contracts/#condition_type_7","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#initialize_12","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_14","text":"function hashValues ( bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#hashvaluesmarked_1","text":"function hashValuesMarked ( bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) public pure returns ( bytes32 )","title":"hashValuesMarked"},{"location":"architecture/contracts/#fulfillmarked_1","text":"function fulfillMarked ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method lock a NFT into the _lockAddress . Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens (1) _receiver address _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfillMarked"},{"location":"architecture/contracts/#fulfill_15","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#onerc721received","text":"function onERC721Received ( address , address , uint256 , bytes ) public virtual returns ( bytes4 ) Always returns IERC721Receiver.onERC721Received.selector .","title":"onERC721Received"},{"location":"architecture/contracts/#nftaccesscondition","text":"_Implementation of the Access Condition specific for NFTs NFT Access Condition is special condition used to give access to a specific NFT related to a DID._","title":"NFTAccessCondition"},{"location":"architecture/contracts/#condition_type_8","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#documentpermission_1","text":"struct DocumentPermission { bytes32 agreementIdDeprecated ; mapping ( address &# x3D ; & gt ; bool ) permission ; }","title":"DocumentPermission"},{"location":"architecture/contracts/#nftpermissions","text":"mapping ( bytes32 => struct NFTAccessCondition . DocumentPermission ) nftPermissions","title":"nftPermissions"},{"location":"architecture/contracts/#didregistry_3","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#onlydidownerorprovider_2","text":"modifier onlyDIDOwnerOrProvider ( bytes32 _documentId )","title":"onlyDIDOwnerOrProvider"},{"location":"architecture/contracts/#initialize_13","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID registry address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_15","text":"function hashValues ( bytes32 _documentId , address _grantee ) public view returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#hashvalues_16","text":"function hashValues ( bytes32 _documentId , address _grantee , address _contractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_16","text":"function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#fulfill_17","text":"function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee , address _contractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address is the contract address of the NFT implementation (ERC-1155 or ERC-721) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#grantpermission_1","text":"function grantPermission ( address _grantee , bytes32 _documentId ) public grantPermission is called only by DID owner or provider Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys","title":"grantPermission"},{"location":"architecture/contracts/#checkpermissions_1","text":"function checkPermissions ( address _grantee , bytes32 _documentId ) external view returns ( bool permissionGranted ) checkPermissions is called to validate the permissions of user related to the NFT attached to an asset Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID Name Type Description permissionGranted bool true if the access was granted","title":"checkPermissions"},{"location":"architecture/contracts/#nftholdercondition","text":"Implementation of the Nft Holder Condition","title":"NFTHolderCondition"},{"location":"architecture/contracts/#erc1155","text":"contract ERC1155BurnableUpgradeable erc1155","title":"erc1155"},{"location":"architecture/contracts/#condition_type_9","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#initialize_14","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _ercAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _ercAddress address Nevermined ERC-1155 address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_17","text":"function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount ) public view returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#hashvalues_18","text":"function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_18","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/#fulfill_19","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/#nftlockcondition","text":"Implementation of the NFT Lock Condition","title":"NFTLockCondition"},{"location":"architecture/contracts/#erc1155_1","text":"contract IERC1155Upgradeable erc1155","title":"erc1155"},{"location":"architecture/contracts/#condition_type_10","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#erc1155_accepted","text":"bytes4 ERC1155_ACCEPTED","title":"ERC1155_ACCEPTED"},{"location":"architecture/contracts/#erc1155_batch_accepted","text":"bytes4 ERC1155_BATCH_ACCEPTED","title":"ERC1155_BATCH_ACCEPTED"},{"location":"architecture/contracts/#initialize_15","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _ercAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _ercAddress address Nevermined ERC-1155 address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_19","text":"function hashValues ( bytes32 _did , address _lockAddress , uint256 _amount ) public view returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#hashvalues_20","text":"function hashValues ( bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-1155) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#hashvaluesmarked_2","text":"function hashValuesMarked ( bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) public pure returns ( bytes32 )","title":"hashValuesMarked"},{"location":"architecture/contracts/#fulfill_20","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#fulfill_21","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _nft ) public returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfill"},{"location":"architecture/contracts/#fulfillmarked_2","text":"function fulfillMarked ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _receiver address _nftContractAddress address Is the address of the NFT (ERC-1155) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfillMarked"},{"location":"architecture/contracts/#onerc1155received","text":"function onERC1155Received ( address , address , uint256 , uint256 , bytes ) external pure returns ( bytes4 )","title":"onERC1155Received"},{"location":"architecture/contracts/#onerc1155batchreceived","text":"function onERC1155BatchReceived ( address , address , uint256 [], uint256 [], bytes ) external pure returns ( bytes4 )","title":"onERC1155BatchReceived"},{"location":"architecture/contracts/#supportsinterface","text":"function supportsInterface ( bytes4 interfaceId ) external pure returns ( bool ) _Returns true if this contract implements the interface defined by interfaceId . See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas._","title":"supportsInterface"},{"location":"architecture/contracts/#transfernft721condition","text":"Implementation of condition allowing to transfer an NFT between the original owner and a receiver","title":"TransferNFT721Condition"},{"location":"architecture/contracts/#condition_type_11","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#market_role","text":"bytes32 MARKET_ROLE","title":"MARKET_ROLE"},{"location":"architecture/contracts/#erc721","text":"contract NFT721Upgradeable erc721","title":"erc721"},{"location":"architecture/contracts/#_lockconditionaddress_1","text":"address _lockConditionAddress","title":"_lockConditionAddress"},{"location":"architecture/contracts/#proxy_role_3","text":"bytes32 PROXY_ROLE","title":"PROXY_ROLE"},{"location":"architecture/contracts/#didregistry_4","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#grantproxyrole_3","text":"function grantProxyRole ( address _address ) public","title":"grantProxyRole"},{"location":"architecture/contracts/#revokeproxyrole_3","text":"function revokeProxyRole ( address _address ) public","title":"revokeProxyRole"},{"location":"architecture/contracts/#initialize_16","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress , address _ercAddress , address _lockNFTConditionAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address _ercAddress address Nevermined ERC-721 address _lockNFTConditionAddress address","title":"initialize"},{"location":"architecture/contracts/#getnftdefaultaddress_1","text":"function getNFTDefaultAddress () external view returns ( address ) returns if the default NFT contract address The default NFT contract address was given to the Transfer Condition during the contract initialization Name Type Description [0] address the NFT contract address used by default in the transfer condition","title":"getNFTDefaultAddress"},{"location":"architecture/contracts/#hashvalues_21","text":"function hashValues ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockCondition , address _contract , bool _transfer ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _contract address NFT contract to use _transfer bool Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#encodeparams_1","text":"function encodeParams ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) external pure returns ( bytes ) Encodes/serialize all the parameters received Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address the NFT contract to use _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] bytes the encoded parameters","title":"encodeParams"},{"location":"architecture/contracts/#fulfill_22","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _contract , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _contract address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#fulfillproxy_2","text":"function fulfillProxy ( address _account , bytes32 _agreementId , bytes _params ) external payable fulfill the transfer NFT condition by a proxy Fulfill method transfer a certain amount of NFTs Name Type Description _account address NFT Holder _agreementId bytes32 agreement identifier _params bytes encoded parameters","title":"fulfillProxy"},{"location":"architecture/contracts/#fulfillinternal_1","text":"function fulfillInternal ( address _account , bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _contract , bool _transfer ) internal returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfillInternal"},{"location":"architecture/contracts/#fulfillfordelegate","text":"function fulfillForDelegate ( bytes32 _agreementId , bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address in the DIDRegistry contract. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfillForDelegate"},{"location":"architecture/contracts/#transfernftcondition","text":"Implementation of condition allowing to transfer an NFT between the original owner and a receiver","title":"TransferNFTCondition"},{"location":"architecture/contracts/#condition_type_12","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#market_role_1","text":"bytes32 MARKET_ROLE","title":"MARKET_ROLE"},{"location":"architecture/contracts/#erc1155_2","text":"contract NFTUpgradeable erc1155","title":"erc1155"},{"location":"architecture/contracts/#didregistry_5","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#proxy_role_4","text":"bytes32 PROXY_ROLE","title":"PROXY_ROLE"},{"location":"architecture/contracts/#grantproxyrole_4","text":"function grantProxyRole ( address _address ) public","title":"grantProxyRole"},{"location":"architecture/contracts/#revokeproxyrole_4","text":"function revokeProxyRole ( address _address ) public","title":"revokeProxyRole"},{"location":"architecture/contracts/#initialize_17","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress , address _ercAddress , address _nftContractAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address _ercAddress address Nevermined ERC-1155 address _nftContractAddress address Market address","title":"initialize"},{"location":"architecture/contracts/#grantmarketrole","text":"function grantMarketRole ( address _nftContractAddress ) public","title":"grantMarketRole"},{"location":"architecture/contracts/#revokemarketrole","text":"function revokeMarketRole ( address _nftContractAddress ) public","title":"revokeMarketRole"},{"location":"architecture/contracts/#getnftdefaultaddress_2","text":"function getNFTDefaultAddress () external view returns ( address ) returns if the default NFT contract address The default NFT contract address was given to the Transfer Condition during the contract initialization Name Type Description [0] address the NFT contract address used by default in the transfer condition","title":"getNFTDefaultAddress"},{"location":"architecture/contracts/#hashvalues_22","text":"function hashValues ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockCondition ) public view returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#hashvalues_23","text":"function hashValues ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockCondition , address _nftContractAddress , bool _transfer ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _nftContractAddress address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_23","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition ) public returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfill"},{"location":"architecture/contracts/#encodeparams_2","text":"function encodeParams ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) external pure returns ( bytes ) Encodes/serialize all the parameters received Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address the NFT contract to use _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] bytes the encoded parameters","title":"encodeParams"},{"location":"architecture/contracts/#fulfillproxy_3","text":"function fulfillProxy ( address _account , bytes32 _agreementId , bytes _params ) external payable fulfill the transfer NFT condition by a proxy Fulfill method transfer a certain amount of NFTs Name Type Description _account address NFT Holder _agreementId bytes32 agreement identifier _params bytes encoded parameters","title":"fulfillProxy"},{"location":"architecture/contracts/#fulfill_24","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#fulfillinternal_2","text":"function fulfillInternal ( address _account , bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) internal returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfillInternal"},{"location":"architecture/contracts/#fulfillfordelegate_1","text":"function fulfillForDelegate ( bytes32 _agreementId , bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address in the DIDRegistry contract. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfillForDelegate"},{"location":"architecture/contracts/#signcondition","text":"Implementation of the Sign Condition","title":"SignCondition"},{"location":"architecture/contracts/#condition_type_13","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#initialize_18","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_24","text":"function hashValues ( bytes32 _message , address _publicKey ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _message bytes32 the message to be signed _publicKey address the public key of the signing address Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_25","text":"function fulfill ( bytes32 _agreementId , bytes32 _message , address _publicKey , bytes _signature ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill validate the signed message and fulfill the condition Name Type Description _agreementId bytes32 SEA agreement identifier _message bytes32 the message to be signed _publicKey address the public key of the signing address _signature bytes signature of the signed message using the public key Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/#thresholdcondition","text":"_Implementation of the Threshold Condition Threshold condition acts as a filter for a set of input condition(s) in which sends a signal whether to complete the flow execution or abort it. This type of conditions works as intermediary conditions where they wire SEA conditions in order to support more complex scenarios._","title":"ThresholdCondition"},{"location":"architecture/contracts/#condition_type_14","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#initialize_19","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_25","text":"function hashValues ( bytes32 [] inputConditions , uint256 threshold ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_26","text":"function fulfill ( bytes32 _agreementId , bytes32 [] _inputConditions , uint256 threshold ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill threshold condition the fulfill method check whether input conditions are fulfilled or not. Name Type Description _agreementId bytes32 agreement identifier _inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#canfulfill","text":"function canFulfill ( bytes32 [] _inputConditions , uint256 threshold ) private view returns ( bool _fulfill ) canFulfill check if condition can be fulfilled Name Type Description _inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description _fulfill bool true if can fulfill","title":"canFulfill"},{"location":"architecture/contracts/#transferdidownershipcondition","text":"Implementation of condition allowing to transfer the ownership between the original owner and a receiver","title":"TransferDIDOwnershipCondition"},{"location":"architecture/contracts/#condition_type_15","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#didregistry_6","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#fulfilled_9","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _receiver , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/#initialize_20","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_26","text":"function hashValues ( bytes32 _did , address _receiver ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_27","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _receiver ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer DID ownership condition only DID owner or DID provider can call this method. Fulfill method transfer full ownership permissions to to _receiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#whitelistingcondition","text":"Implementation of the Whitelisting Condition","title":"WhitelistingCondition"},{"location":"architecture/contracts/#condition_type_16","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#initialize_21","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_27","text":"function hashValues ( address _listAddress , bytes32 _item ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _listAddress address list contract address _item bytes32 item in the list Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_28","text":"function fulfill ( bytes32 _agreementId , address _listAddress , bytes32 _item ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill check whether address is whitelisted in order to fulfill the condition. This method will be called by any one in this whitelist. Name Type Description _agreementId bytes32 SEA agreement identifier _listAddress address list contract address _item bytes32 item in the list Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/#aaveborrowcondition","text":"Implementation of the Aave Borrow Credit Condition","title":"AaveBorrowCondition"},{"location":"architecture/contracts/#aavecreditvault_1","text":"contract AaveCreditVault aaveCreditVault","title":"aaveCreditVault"},{"location":"architecture/contracts/#condition_type_17","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#fulfilled_10","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/#initialize_22","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_28","text":"function hashValues ( bytes32 _did , address _vaultAddress , address _assetToBorrow , uint256 _amount , uint256 _interestRateMode ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToBorrow address the address of the asset to borrow (i.e DAI) _amount uint256 the amount of the ERC-20 the assets to borrow (i.e 50 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_29","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _assetToBorrow , uint256 _amount , uint256 _interestRateMode ) external returns ( enum ConditionStoreLibrary . ConditionState ) It allows the borrower to borrow the asset deposited by the lender Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToBorrow address the address of the asset to borrow (i.e DAI) _amount uint256 the amount of the ERC-20 the assets to borrow (i.e 50 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good)","title":"fulfill"},{"location":"architecture/contracts/#aavecollateraldepositcondition","text":"Implementation of the Aave Collateral Deposit Condition This condition allows a Lender to deposit the collateral that into account the royalties to be paid to the original creators in a secondary market.","title":"AaveCollateralDepositCondition"},{"location":"architecture/contracts/#aavecreditvault_2","text":"contract AaveCreditVault aaveCreditVault","title":"aaveCreditVault"},{"location":"architecture/contracts/#condition_type_18","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#fulfilled_11","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/#initialize_23","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_29","text":"function hashValues ( bytes32 _did , address _vaultAddress , address _collateralAsset , uint256 _collateralAmount , address _delegatedAsset , uint256 _delegatedAmount , uint256 _interestRateMode ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the ERC-20 that will be used as collateral (i.e WETH) _collateralAmount uint256 the amount of the ERC-20 that will be used as collateral (i.e 10 WETH) _delegatedAsset address the address of the ERC-20 that will be delegated to the borrower (i.e DAI) _delegatedAmount uint256 the amount of the ERC-20 that will be delegated to the borrower (i.e 500 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_30","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _collateralAsset , uint256 _collateralAmount , address _delegatedAsset , uint256 _delegatedAmount , uint256 _interestRateMode ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) It fulfills the condition if the collateral can be deposited into the vault Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the ERC-20 that will be used as collateral (i.e WETH) _collateralAmount uint256 the amount of the ERC-20 that will be used as collateral (i.e 10 WETH) _delegatedAsset address the address of the ERC-20 that will be delegated to the borrower (i.e DAI) _delegatedAmount uint256 the amount of the ERC-20 that will be delegated to the borrower (i.e 500 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good)","title":"fulfill"},{"location":"architecture/contracts/#aavecollateralwithdrawcondition","text":"Implementation of the Collateral Withdraw Condition This condition allows to credit delegator withdraw the collateral and fees after the agreement expiration","title":"AaveCollateralWithdrawCondition"},{"location":"architecture/contracts/#aavecreditvault_3","text":"contract AaveCreditVault aaveCreditVault","title":"aaveCreditVault"},{"location":"architecture/contracts/#condition_type_19","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#fulfilled_12","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/#initialize_24","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_30","text":"function hashValues ( bytes32 _did , address _vaultAddress , address _collateralAsset ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the asset used as collateral (i.e DAI) Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_31","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _collateralAsset ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) It allows the borrower to repay the loan Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the asset used as collateral (i.e DAI) Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good)","title":"fulfill"},{"location":"architecture/contracts/#aavecreditvault_4","text":"","title":"AaveCreditVault"},{"location":"architecture/contracts/#lendingpool","text":"contract ILendingPool lendingPool","title":"lendingPool"},{"location":"architecture/contracts/#dataprovider","text":"contract IProtocolDataProvider dataProvider","title":"dataProvider"},{"location":"architecture/contracts/#weth","text":"contract IWETHGateway weth","title":"weth"},{"location":"architecture/contracts/#addressprovider","text":"contract ILendingPoolAddressesProvider addressProvider","title":"addressProvider"},{"location":"architecture/contracts/#priceoracle","text":"contract IPriceOracleGetter priceOracle","title":"priceOracle"},{"location":"architecture/contracts/#borrowedasset","text":"address borrowedAsset","title":"borrowedAsset"},{"location":"architecture/contracts/#borrowedamount","text":"uint256 borrowedAmount","title":"borrowedAmount"},{"location":"architecture/contracts/#nvmfee","text":"uint256 nvmFee","title":"nvmFee"},{"location":"architecture/contracts/#agreementfee","text":"uint256 agreementFee","title":"agreementFee"},{"location":"architecture/contracts/#fee_base","text":"uint256 FEE_BASE","title":"FEE_BASE"},{"location":"architecture/contracts/#treasuryaddress","text":"address treasuryAddress","title":"treasuryAddress"},{"location":"architecture/contracts/#borrower","text":"address borrower","title":"borrower"},{"location":"architecture/contracts/#lender","text":"address lender","title":"lender"},{"location":"architecture/contracts/#repayconditionid","text":"bytes32 repayConditionId","title":"repayConditionId"},{"location":"architecture/contracts/#nftid","text":"uint256 nftId","title":"nftId"},{"location":"architecture/contracts/#nftaddress","text":"address nftAddress","title":"nftAddress"},{"location":"architecture/contracts/#borrower_role","text":"bytes32 BORROWER_ROLE","title":"BORROWER_ROLE"},{"location":"architecture/contracts/#lender_role","text":"bytes32 LENDER_ROLE","title":"LENDER_ROLE"},{"location":"architecture/contracts/#condition_role","text":"bytes32 CONDITION_ROLE","title":"CONDITION_ROLE"},{"location":"architecture/contracts/#initialize_25","text":"function initialize ( address _lendingPool , address _dataProvider , address _weth , uint256 _nvmFee , uint256 _agreementFee , address _treasuryAddress , address _borrower , address _lender , address [] _conditions ) public Vault constructor, creates a unique vault for each agreement Name Type Description _lendingPool address Aave lending pool address _dataProvider address Aave data provider address _weth address WETH address _nvmFee uint256 Nevermined fee that will apply to this agreeement _agreementFee uint256 Agreement fee that lender will receive on agreement maturity _treasuryAddress address Address of nevermined contract to store fees _borrower address _lender address _conditions address[]","title":"initialize"},{"location":"architecture/contracts/#islender","text":"function isLender ( address _address ) public view returns ( bool )","title":"isLender"},{"location":"architecture/contracts/#isborrower","text":"function isBorrower ( address _address ) public view returns ( bool )","title":"isBorrower"},{"location":"architecture/contracts/#deposit","text":"function deposit ( address _collateralAsset , uint256 _amount ) public payable Deposit function. Receives the funds from the delegator and deposits the funds in the Aave contracts Name Type Description _collateralAsset address collateral asset that will be deposit on Aave _amount uint256 Amount of collateral to deposit","title":"deposit"},{"location":"architecture/contracts/#approveborrower","text":"function approveBorrower ( address _borrower , uint256 _amount , address _asset , uint256 _interestRateMode ) public Appproves delegatee to borrow funds from Aave on behalf of delegator Name Type Description _borrower address delegatee that will borrow the funds _amount uint256 Amount of funds to delegate _asset address Asset to delegate the borrow _interestRateMode uint256 interest rate type stable 1, variable 2","title":"approveBorrower"},{"location":"architecture/contracts/#delegatedamount","text":"function delegatedAmount ( address _borrower , address _asset , uint256 _interestRateMode ) public view returns ( uint256 ) Return the actual delegated amount for the borrower in the specific asset Name Type Description _borrower address The borrower of the funds (i.e. delgatee) _asset address The asset they are allowed to borrow _interestRateMode uint256 interest rate type stable 1, variable 2","title":"delegatedAmount"},{"location":"architecture/contracts/#borrow","text":"function borrow ( address _assetToBorrow , uint256 _amount , address _delgatee , uint256 _interestRateMode ) public Borrower can call this function to borrow the delegated funds Name Type Description _assetToBorrow address The asset they are allowed to borrow _amount uint256 Amount to borrow _delgatee address Address where the funds will be transfered _interestRateMode uint256 interest rate type stable 1, variable 2","title":"borrow"},{"location":"architecture/contracts/#repay","text":"function repay ( address _asset , uint256 _interestRateMode , bytes32 _repayConditionId ) public Repay an uncollaterised loan Name Type Description _asset address The asset to be repaid _interestRateMode uint256 interest rate type stable 1, variable 2 _repayConditionId bytes32 identifier of the condition id working as lock for other vault methods","title":"repay"},{"location":"architecture/contracts/#setrepayconditionid","text":"function setRepayConditionId ( bytes32 _repayConditionId ) public","title":"setRepayConditionId"},{"location":"architecture/contracts/#getborrowedamount","text":"function getBorrowedAmount () public view returns ( uint256 ) Returns the borrowed amount from the delegatee on this agreement","title":"getBorrowedAmount"},{"location":"architecture/contracts/#getassetprice","text":"function getAssetPrice ( address _asset ) public view returns ( uint256 ) Returns the priceof the asset in the Aave oracles Name Type Description _asset address The asset to get the actual price","title":"getAssetPrice"},{"location":"architecture/contracts/#getcreditassetdebt","text":"function getCreditAssetDebt () public view returns ( uint256 ) Returns the total debt of the credit in the Aave protocol expressed in token units","title":"getCreditAssetDebt"},{"location":"architecture/contracts/#getactualcreditdebt","text":"function getActualCreditDebt () public view returns ( uint256 ) Returns the total debt of the credit in the Aave protocol expressed in ETH units","title":"getActualCreditDebt"},{"location":"architecture/contracts/#gettotalactualdebt","text":"function getTotalActualDebt () public view returns ( uint256 ) Returns the total actual debt of the agreement credit + fees in token units","title":"getTotalActualDebt"},{"location":"architecture/contracts/#withdrawcollateral","text":"function withdrawCollateral ( address _asset , address _delegator ) public Withdraw all of a collateral as the underlying asset, if no outstanding loans delegated Name Type Description _asset address The underlying asset to withdraw _delegator address Delegator address that deposited the collateral","title":"withdrawCollateral"},{"location":"architecture/contracts/#transfernft","text":"function transferNFT ( uint256 _tokenId , address _receiver ) public Transfer a NFT (ERC-721) locked into the vault to a receiver address Name Type Description _tokenId uint256 the token id _receiver address the receiver adddress","title":"transferNFT"},{"location":"architecture/contracts/#_transfererc20","text":"function _transferERC20 ( address _collateralAsset , uint256 _amount ) internal Transfers the ERC20 token deposited to the Aave contracts Name Type Description _collateralAsset address collateral asset that will be deposit on Aave _amount uint256 Amount of collateral to deposit","title":"_transferERC20"},{"location":"architecture/contracts/#onerc721received_1","text":"function onERC721Received ( address , address , uint256 _tokenId , bytes ) public virtual returns ( bytes4 ) Handle the receipt of an NFT _The ERC721 smart contract calls this function on the recipient after a {IERC721-safeTransferFrom}. This function MUST return the function selector, otherwise the caller will revert the transaction. Note: the ERC721 contract address is always the message sender. (param not used): operator The address which called safeTransferFrom function (param not used): from The address which previously owned the token_ Name Type Description address address _tokenId uint256 The NFT identifier which is being transferred (param not used): data Additional data with no specified format bytes Name Type Description [0] bytes4 bytes4 bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))","title":"onERC721Received"},{"location":"architecture/contracts/#aaverepaycondition","text":"Implementation of the Aave Repay Condition This condition allows to a borrower to repay a credit as part of a credit template","title":"AaveRepayCondition"},{"location":"architecture/contracts/#aavecreditvault_5","text":"contract AaveCreditVault aaveCreditVault","title":"aaveCreditVault"},{"location":"architecture/contracts/#condition_type_20","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#fulfilled_13","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/#initialize_26","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_31","text":"function hashValues ( bytes32 _did , address _vaultAddress , address _assetToRepay , uint256 _amountToRepay , uint256 _interestRateMode ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToRepay address the address of the asset to repay (i.e DAI) _amountToRepay uint256 Amount to repay _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#fulfill_32","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _assetToRepay , uint256 _amountToRepay , uint256 _interestRateMode ) external returns ( enum ConditionStoreLibrary . ConditionState ) It allows the borrower to repay the loan Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToRepay address the address of the asset to repay (i.e DAI) _amountToRepay uint256 Amount to repay _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good)","title":"fulfill"},{"location":"architecture/contracts/#escrowpaymentcondition","text":"_Implementation of the Escrow Payment Condition The Escrow payment is reward condition in which only can release reward if lock and release conditions are fulfilled._","title":"EscrowPaymentCondition"},{"location":"architecture/contracts/#condition_type_21","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#used_payment_id","text":"bytes32 USED_PAYMENT_ID","title":"USED_PAYMENT_ID"},{"location":"architecture/contracts/#fulfilled_14","text":"event Fulfilled ( bytes32 _agreementId , address _tokenAddress , address [] _receivers , bytes32 _conditionId , uint256 [] _amounts )","title":"Fulfilled"},{"location":"architecture/contracts/#received","text":"event Received ( address _from , uint256 _value )","title":"Received"},{"location":"architecture/contracts/#receive","text":"receive () external payable","title":"receive"},{"location":"architecture/contracts/#initialize_27","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/#hashvaluesmulti","text":"function hashValuesMulti ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValuesMulti"},{"location":"architecture/contracts/#encodeparams_3","text":"function encodeParams ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public pure returns ( bytes )","title":"encodeParams"},{"location":"architecture/contracts/#hashvalues_32","text":"function hashValues ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 _releaseCondition ) public pure returns ( bytes32 )","title":"hashValues"},{"location":"architecture/contracts/#hashvalueslockpayment","text":"function hashValuesLockPayment ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public pure returns ( bytes32 ) hashValuesLockPayment generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValuesLockPayment"},{"location":"architecture/contracts/#fulfillmulti","text":"function fulfillMulti ( bytes32 _agreementId , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill escrow reward condition fulfill method checks whether the lock and release conditions are fulfilled in order to release/refund the reward to receiver/sender respectively. Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfillMulti"},{"location":"architecture/contracts/#args","text":"struct Args { bytes32 _agreementId ; bytes32 _did ; uint256 [] _amounts ; address [] _receivers ; address _returnAddress ; address _lockPaymentAddress ; address _tokenAddress ; bytes32 _lockCondition ; bytes32 [] _releaseConditions ; }","title":"Args"},{"location":"architecture/contracts/#fulfillkludge","text":"function fulfillKludge ( struct EscrowPaymentCondition . Args a ) internal returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfillKludge"},{"location":"architecture/contracts/#fulfill_33","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 _releaseCondition ) external returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfill"},{"location":"architecture/contracts/#_transferandfulfillerc20","text":"function _transferAndFulfillERC20 ( bytes32 _id , address _tokenAddress , address [] _receivers , uint256 [] _amounts ) private returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfill transfer ERC20 tokens and fulfill the condition Name Type Description _id bytes32 condition identifier _tokenAddress address the ERC20 contract address to use during the payment _receivers address[] receiver's address _amounts uint256[] token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"_transferAndFulfillERC20"},{"location":"architecture/contracts/#_transferandfulfilleth","text":"function _transferAndFulfillETH ( bytes32 _id , address [] _receivers , uint256 [] _amounts ) private returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfill transfer ETH and fulfill the condition Name Type Description _id bytes32 condition identifier _receivers address[] receiver's address _amounts uint256[] token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"_transferAndFulfillETH"},{"location":"architecture/contracts/#inftescrow","text":"Common interface for ERC-721 and ERC-1155","title":"INFTEscrow"},{"location":"architecture/contracts/#fulfilled_15","text":"event Fulfilled ( bytes32 _agreementId , address _tokenAddress , bytes32 _did , address _receivers , bytes32 _conditionId , uint256 _amounts )","title":"Fulfilled"},{"location":"architecture/contracts/#nft721escrowpaymentcondition","text":"_Implementation of the Escrow Payment Condition The Escrow payment is reward condition in which only can release reward if lock and release conditions are fulfilled._","title":"NFT721EscrowPaymentCondition"},{"location":"architecture/contracts/#condition_type_22","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#received_1","text":"event Received ( address _from , uint256 _value )","title":"Received"},{"location":"architecture/contracts/#receive_1","text":"receive () external payable","title":"receive"},{"location":"architecture/contracts/#initialize_28","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_33","text":"function hashValues ( bytes32 _did , uint256 _amounts , address _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 asset decentralized identifier _amounts uint256 token amounts to be locked/released _receivers address receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#hashvalueslockpayment_1","text":"function hashValuesLockPayment ( bytes32 _did , address _lockAddress , address _nftContractAddress , uint256 _amount , address _receiver ) public pure returns ( bytes32 ) hashValuesLockPayment generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _lockAddress address the contract address where the reward is locked _nftContractAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amount uint256 token amounts to be locked/released _receiver address receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValuesLockPayment"},{"location":"architecture/contracts/#fulfill_34","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , uint256 _amount , address _receiver , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill escrow reward condition fulfill method checks whether the lock and release conditions are fulfilled in order to release/refund the reward to receiver/sender respectively. Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amount uint256 token amounts to be locked/released _receiver address receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#args_1","text":"struct Args { bytes32 _agreementId ; bytes32 _did ; uint256 _amount ; address _receiver ; address _returnAddress ; address _lockPaymentAddress ; address _tokenAddress ; bytes32 _lockCondition ; bytes32 [] _releaseConditions ; }","title":"Args"},{"location":"architecture/contracts/#fulfillkludge_1","text":"function fulfillKludge ( struct NFT721EscrowPaymentCondition . Args a ) internal returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfillKludge"},{"location":"architecture/contracts/#_transferandfulfillnft","text":"function _transferAndFulfillNFT ( bytes32 _agreementId , bytes32 _id , bytes32 _did , address _tokenAddress , address _receiver , uint256 _amount ) private returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfill transfer ERC20 tokens and fulfill the condition Name Type Description _agreementId bytes32 _id bytes32 condition identifier _did bytes32 _tokenAddress address the ERC20 contract address to use during the payment _receiver address receiver's address _amount uint256 token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"_transferAndFulfillNFT"},{"location":"architecture/contracts/#onerc721received_2","text":"function onERC721Received ( address , address , uint256 , bytes ) public virtual returns ( bytes4 )","title":"onERC721Received"},{"location":"architecture/contracts/#nftescrowpaymentcondition","text":"_Implementation of the Escrow Payment Condition The Escrow payment is reward condition in which only can release reward if lock and release conditions are fulfilled._","title":"NFTEscrowPaymentCondition"},{"location":"architecture/contracts/#condition_type_23","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/#lock_condition_type","text":"bytes32 LOCK_CONDITION_TYPE","title":"LOCK_CONDITION_TYPE"},{"location":"architecture/contracts/#received_2","text":"event Received ( address _from , uint256 _value )","title":"Received"},{"location":"architecture/contracts/#receive_2","text":"receive () external payable","title":"receive"},{"location":"architecture/contracts/#initialize_29","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/#hashvalues_34","text":"function hashValues ( bytes32 _did , uint256 _amounts , address _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 asset decentralized identifier _amounts uint256 token amounts to be locked/released _receivers address receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/#hashvalueslockpayment_2","text":"function hashValuesLockPayment ( bytes32 _did , address _lockAddress , address _nftContractAddress , uint256 _amount , address _receiver ) public pure returns ( bytes32 ) hashValuesLockPayment generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _lockAddress address the contract address where the reward is locked _nftContractAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amount uint256 token amounts to be locked/released _receiver address receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValuesLockPayment"},{"location":"architecture/contracts/#fulfill_35","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , uint256 _amount , address _receiver , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill escrow reward condition fulfill method checks whether the lock and release conditions are fulfilled in order to release/refund the reward to receiver/sender respectively. Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amount uint256 token amounts to be locked/released _receiver address receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/#args_2","text":"struct Args { bytes32 _agreementId ; bytes32 _did ; uint256 _amount ; address _receiver ; address _returnAddress ; address _lockPaymentAddress ; address _tokenAddress ; bytes32 _lockCondition ; bytes32 [] _releaseConditions ; }","title":"Args"},{"location":"architecture/contracts/#fulfillkludge_2","text":"function fulfillKludge ( struct NFTEscrowPaymentCondition . Args a ) internal returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfillKludge"},{"location":"architecture/contracts/#_transferandfulfillnft_1","text":"function _transferAndFulfillNFT ( bytes32 _agreementId , bytes32 _id , bytes32 _did , address _tokenAddress , address _receiver , uint256 _amount ) private returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfill transfer ERC20 tokens and fulfill the condition Name Type Description _agreementId bytes32 _id bytes32 condition identifier _did bytes32 _tokenAddress address the ERC20 contract address to use during the payment _receiver address receiver's address _amount uint256 token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"_transferAndFulfillNFT"},{"location":"architecture/contracts/#erc1155_accepted_1","text":"bytes4 ERC1155_ACCEPTED","title":"ERC1155_ACCEPTED"},{"location":"architecture/contracts/#erc1155_batch_accepted_1","text":"bytes4 ERC1155_BATCH_ACCEPTED","title":"ERC1155_BATCH_ACCEPTED"},{"location":"architecture/contracts/#onerc1155received_1","text":"function onERC1155Received ( address , address , uint256 , uint256 , bytes ) external pure returns ( bytes4 )","title":"onERC1155Received"},{"location":"architecture/contracts/#onerc1155batchreceived_1","text":"function onERC1155BatchReceived ( address , address , uint256 [], uint256 [], bytes ) external pure returns ( bytes4 )","title":"onERC1155BatchReceived"},{"location":"architecture/contracts/#supportsinterface_1","text":"function supportsInterface ( bytes4 interfaceId ) external pure returns ( bool ) _Returns true if this contract implements the interface defined by interfaceId . See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas._","title":"supportsInterface"},{"location":"architecture/contracts/#reward","text":"_Implementation of the Reward. Generic reward condition_","title":"Reward"},{"location":"architecture/contracts/#invmconfig","text":"","title":"INVMConfig"},{"location":"architecture/contracts/#governor_role","text":"bytes32 GOVERNOR_ROLE","title":"GOVERNOR_ROLE"},{"location":"architecture/contracts/#neverminedconfigchange","text":"event NeverminedConfigChange ( address _whoChanged , bytes32 _parameter ) Event that is emitted when a parameter is changed Name Type Description _whoChanged address the address of the governor changing the parameter _parameter bytes32 the hash of the name of the parameter changed","title":"NeverminedConfigChange"},{"location":"architecture/contracts/#initialize_30","text":"function initialize ( address _owner , address _governor ) external virtual Used to initialize the contract during delegator constructor Name Type Description _owner address The owner of the contract _governor address The address to be granted with the GOVERNOR_ROLE","title":"initialize"},{"location":"architecture/contracts/#setmarketplacefees","text":"function setMarketplaceFees ( uint256 _marketplaceFee , address _feeReceiver ) external virtual The governor can update the Nevermined Marketplace fees Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee","title":"setMarketplaceFees"},{"location":"architecture/contracts/#isgovernor","text":"function isGovernor ( address _address ) external view virtual returns ( bool ) Indicates if an address is a having the GOVERNOR role Name Type Description _address address The address to validate Name Type Description [0] bool true if is a governor","title":"isGovernor"},{"location":"architecture/contracts/#getmarketplacefee","text":"function getMarketplaceFee () external view virtual returns ( uint256 ) Returns the marketplace fee Name Type Description [0] uint256 the marketplace fee","title":"getMarketplaceFee"},{"location":"architecture/contracts/#getfeereceiver","text":"function getFeeReceiver () external view virtual returns ( address ) Returns the receiver address of the marketplace fee Name Type Description [0] address the receiver address","title":"getFeeReceiver"},{"location":"architecture/contracts/#neverminedconfig","text":"","title":"NeverminedConfig"},{"location":"architecture/contracts/#marketplacefee","text":"uint256 marketplaceFee","title":"marketplaceFee"},{"location":"architecture/contracts/#feereceiver","text":"address feeReceiver","title":"feeReceiver"},{"location":"architecture/contracts/#initialize_31","text":"function initialize ( address _owner , address _governor ) public Used to initialize the contract during delegator constructor Name Type Description _owner address The owner of the contract _governor address The address to be granted with the GOVERNOR_ROLE","title":"initialize"},{"location":"architecture/contracts/#setmarketplacefees_1","text":"function setMarketplaceFees ( uint256 _marketplaceFee , address _feeReceiver ) external virtual The governor can update the Nevermined Marketplace fees Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee","title":"setMarketplaceFees"},{"location":"architecture/contracts/#setgovernor","text":"function setGovernor ( address _address ) external","title":"setGovernor"},{"location":"architecture/contracts/#isgovernor_1","text":"function isGovernor ( address _address ) external view returns ( bool ) Indicates if an address is a having the GOVERNOR role Name Type Description _address address The address to validate Name Type Description [0] bool true if is a governor","title":"isGovernor"},{"location":"architecture/contracts/#getmarketplacefee_1","text":"function getMarketplaceFee () external view returns ( uint256 ) Returns the marketplace fee Name Type Description [0] uint256 the marketplace fee","title":"getMarketplaceFee"},{"location":"architecture/contracts/#getfeereceiver_1","text":"function getFeeReceiver () external view returns ( address ) Returns the receiver address of the marketplace fee Name Type Description [0] address the receiver address","title":"getFeeReceiver"},{"location":"architecture/contracts/#onlygovernor","text":"modifier onlyGovernor ( address _address )","title":"onlyGovernor"},{"location":"architecture/contracts/#ierc20","text":"","title":"IERC20"},{"location":"architecture/contracts/#totalsupply","text":"function totalSupply () external view returns ( uint256 ) Returns the amount of tokens in existence.","title":"totalSupply"},{"location":"architecture/contracts/#balanceof","text":"function balanceOf ( address account ) external view returns ( uint256 ) Returns the amount of tokens owned by account .","title":"balanceOf"},{"location":"architecture/contracts/#transfer","text":"function transfer ( address recipient , uint256 amount ) external returns ( bool ) _Moves amount tokens from the caller's account to recipient . Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event._","title":"transfer"},{"location":"architecture/contracts/#allowance","text":"function allowance ( address owner , address spender ) external view returns ( uint256 ) _Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called._","title":"allowance"},{"location":"architecture/contracts/#approve","text":"function approve ( address spender , uint256 amount ) external returns ( bool ) _Sets amount as the allowance of spender over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event._","title":"approve"},{"location":"architecture/contracts/#transferfrom","text":"function transferFrom ( address sender , address recipient , uint256 amount ) external returns ( bool ) _Moves amount tokens from sender to recipient using the allowance mechanism. amount is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event._","title":"transferFrom"},{"location":"architecture/contracts/#transfer_1","text":"event Transfer ( address from , address to , uint256 value ) _Emitted when value tokens are moved from one account ( from ) to another ( to ). Note that value may be zero._","title":"Transfer"},{"location":"architecture/contracts/#approval","text":"event Approval ( address owner , address spender , uint256 value ) Emitted when the allowance of a spender for an owner is set by a call to {approve}. value is the new allowance.","title":"Approval"},{"location":"architecture/contracts/#ipriceoraclegetter","text":"Interface for the Aave price oracle.","title":"IPriceOracleGetter"},{"location":"architecture/contracts/#getassetprice_1","text":"function getAssetPrice ( address asset ) external view returns ( uint256 ) returns the asset price in ETH Name Type Description asset address the address of the asset Name Type Description [0] uint256 the ETH price of the asset","title":"getAssetPrice"},{"location":"architecture/contracts/#iprotocoldataprovider","text":"","title":"IProtocolDataProvider"},{"location":"architecture/contracts/#tokendata","text":"struct TokenData { string symbol ; address tokenAddress ; }","title":"TokenData"},{"location":"architecture/contracts/#addresses_provider","text":"function ADDRESSES_PROVIDER () external view returns ( contract ILendingPoolAddressesProvider )","title":"ADDRESSES_PROVIDER"},{"location":"architecture/contracts/#getallreservestokens","text":"function getAllReservesTokens () external view returns ( struct IProtocolDataProvider . TokenData [])","title":"getAllReservesTokens"},{"location":"architecture/contracts/#getallatokens","text":"function getAllATokens () external view returns ( struct IProtocolDataProvider . TokenData [])","title":"getAllATokens"},{"location":"architecture/contracts/#getreserveconfigurationdata","text":"function getReserveConfigurationData ( address asset ) external view returns ( uint256 decimals , uint256 ltv , uint256 liquidationThreshold , uint256 liquidationBonus , uint256 reserveFactor , bool usageAsCollateralEnabled , bool borrowingEnabled , bool stableBorrowRateEnabled , bool isActive , bool isFrozen )","title":"getReserveConfigurationData"},{"location":"architecture/contracts/#getreservedata","text":"function getReserveData ( address asset ) external view returns ( uint256 availableLiquidity , uint256 totalStableDebt , uint256 totalVariableDebt , uint256 liquidityRate , uint256 variableBorrowRate , uint256 stableBorrowRate , uint256 averageStableBorrowRate , uint256 liquidityIndex , uint256 variableBorrowIndex , uint40 lastUpdateTimestamp )","title":"getReserveData"},{"location":"architecture/contracts/#getuserreservedata","text":"function getUserReserveData ( address asset , address user ) external view returns ( uint256 currentATokenBalance , uint256 currentStableDebt , uint256 currentVariableDebt , uint256 principalStableDebt , uint256 scaledVariableDebt , uint256 stableBorrowRate , uint256 liquidityRate , uint40 stableRateLastUpdated , bool usageAsCollateralEnabled )","title":"getUserReserveData"},{"location":"architecture/contracts/#getreservetokensaddresses","text":"function getReserveTokensAddresses ( address asset ) external view returns ( address aTokenAddress , address stableDebtTokenAddress , address variableDebtTokenAddress )","title":"getReserveTokensAddresses"},{"location":"architecture/contracts/#ilendingpooladdressesprovider","text":"","title":"ILendingPoolAddressesProvider"},{"location":"architecture/contracts/#marketidset","text":"event MarketIdSet ( string newMarketId )","title":"MarketIdSet"},{"location":"architecture/contracts/#lendingpoolupdated","text":"event LendingPoolUpdated ( address newAddress )","title":"LendingPoolUpdated"},{"location":"architecture/contracts/#configurationadminupdated","text":"event ConfigurationAdminUpdated ( address newAddress )","title":"ConfigurationAdminUpdated"},{"location":"architecture/contracts/#emergencyadminupdated","text":"event EmergencyAdminUpdated ( address newAddress )","title":"EmergencyAdminUpdated"},{"location":"architecture/contracts/#lendingpoolconfiguratorupdated","text":"event LendingPoolConfiguratorUpdated ( address newAddress )","title":"LendingPoolConfiguratorUpdated"},{"location":"architecture/contracts/#lendingpoolcollateralmanagerupdated","text":"event LendingPoolCollateralManagerUpdated ( address newAddress )","title":"LendingPoolCollateralManagerUpdated"},{"location":"architecture/contracts/#priceoracleupdated","text":"event PriceOracleUpdated ( address newAddress )","title":"PriceOracleUpdated"},{"location":"architecture/contracts/#lendingrateoracleupdated","text":"event LendingRateOracleUpdated ( address newAddress )","title":"LendingRateOracleUpdated"},{"location":"architecture/contracts/#proxycreated","text":"event ProxyCreated ( bytes32 id , address newAddress )","title":"ProxyCreated"},{"location":"architecture/contracts/#addressset","text":"event AddressSet ( bytes32 id , address newAddress , bool hasProxy )","title":"AddressSet"},{"location":"architecture/contracts/#getmarketid","text":"function getMarketId () external view returns ( string )","title":"getMarketId"},{"location":"architecture/contracts/#setmarketid","text":"function setMarketId ( string marketId ) external","title":"setMarketId"},{"location":"architecture/contracts/#setaddress","text":"function setAddress ( bytes32 id , address newAddress ) external","title":"setAddress"},{"location":"architecture/contracts/#setaddressasproxy","text":"function setAddressAsProxy ( bytes32 id , address impl ) external","title":"setAddressAsProxy"},{"location":"architecture/contracts/#getaddress","text":"function getAddress ( bytes32 id ) external view returns ( address )","title":"getAddress"},{"location":"architecture/contracts/#getlendingpool","text":"function getLendingPool () external view returns ( address )","title":"getLendingPool"},{"location":"architecture/contracts/#setlendingpoolimpl","text":"function setLendingPoolImpl ( address pool ) external","title":"setLendingPoolImpl"},{"location":"architecture/contracts/#getlendingpoolconfigurator","text":"function getLendingPoolConfigurator () external view returns ( address )","title":"getLendingPoolConfigurator"},{"location":"architecture/contracts/#setlendingpoolconfiguratorimpl","text":"function setLendingPoolConfiguratorImpl ( address configurator ) external","title":"setLendingPoolConfiguratorImpl"},{"location":"architecture/contracts/#getlendingpoolcollateralmanager","text":"function getLendingPoolCollateralManager () external view returns ( address )","title":"getLendingPoolCollateralManager"},{"location":"architecture/contracts/#setlendingpoolcollateralmanager","text":"function setLendingPoolCollateralManager ( address manager ) external","title":"setLendingPoolCollateralManager"},{"location":"architecture/contracts/#getpooladmin","text":"function getPoolAdmin () external view returns ( address )","title":"getPoolAdmin"},{"location":"architecture/contracts/#setpooladmin","text":"function setPoolAdmin ( address admin ) external","title":"setPoolAdmin"},{"location":"architecture/contracts/#getemergencyadmin","text":"function getEmergencyAdmin () external view returns ( address )","title":"getEmergencyAdmin"},{"location":"architecture/contracts/#setemergencyadmin","text":"function setEmergencyAdmin ( address admin ) external","title":"setEmergencyAdmin"},{"location":"architecture/contracts/#getpriceoracle","text":"function getPriceOracle () external view returns ( address )","title":"getPriceOracle"},{"location":"architecture/contracts/#setpriceoracle","text":"function setPriceOracle ( address priceOracle ) external","title":"setPriceOracle"},{"location":"architecture/contracts/#getlendingrateoracle","text":"function getLendingRateOracle () external view returns ( address )","title":"getLendingRateOracle"},{"location":"architecture/contracts/#setlendingrateoracle","text":"function setLendingRateOracle ( address lendingRateOracle ) external","title":"setLendingRateOracle"},{"location":"architecture/contracts/#ilendingpool","text":"","title":"ILendingPool"},{"location":"architecture/contracts/#deposit_1","text":"event Deposit ( address reserve , address user , address onBehalfOf , uint256 amount , uint16 referral ) Emitted on deposit() Name Type Description reserve address The address of the underlying asset of the reserve user address The address initiating the deposit onBehalfOf address The beneficiary of the deposit, receiving the aTokens amount uint256 The amount deposited referral uint16 The referral code used","title":"Deposit"},{"location":"architecture/contracts/#withdraw","text":"event Withdraw ( address reserve , address user , address to , uint256 amount ) Emitted on withdraw() Name Type Description reserve address The address of the underlyng asset being withdrawn user address The address initiating the withdrawal, owner of aTokens to address Address that will receive the underlying amount uint256 The amount to be withdrawn","title":"Withdraw"},{"location":"architecture/contracts/#borrow_1","text":"event Borrow ( address reserve , address user , address onBehalfOf , uint256 amount , uint256 borrowRateMode , uint256 borrowRate , uint16 referral ) Emitted on borrow() and flashLoan() when debt needs to be opened Name Type Description reserve address The address of the underlying asset being borrowed user address The address of the user initiating the borrow(), receiving the funds on borrow() or just initiator of the transaction on flashLoan() onBehalfOf address The address that will be getting the debt amount uint256 The amount borrowed out borrowRateMode uint256 The rate mode: 1 for Stable, 2 for Variable borrowRate uint256 The numeric rate at which the user has borrowed referral uint16 The referral code used","title":"Borrow"},{"location":"architecture/contracts/#repay_1","text":"event Repay ( address reserve , address user , address repayer , uint256 amount ) Emitted on repay() Name Type Description reserve address The address of the underlying asset of the reserve user address The beneficiary of the repayment, getting his debt reduced repayer address The address of the user initiating the repay(), providing the funds amount uint256 The amount repaid","title":"Repay"},{"location":"architecture/contracts/#swap","text":"event Swap ( address reserve , address user , uint256 rateMode ) Emitted on swapBorrowRateMode() Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user swapping his rate mode rateMode uint256 The rate mode that the user wants to swap to","title":"Swap"},{"location":"architecture/contracts/#reserveusedascollateralenabled","text":"event ReserveUsedAsCollateralEnabled ( address reserve , address user ) Emitted on setUserUseReserveAsCollateral() Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user enabling the usage as collateral","title":"ReserveUsedAsCollateralEnabled"},{"location":"architecture/contracts/#reserveusedascollateraldisabled","text":"event ReserveUsedAsCollateralDisabled ( address reserve , address user ) Emitted on setUserUseReserveAsCollateral() Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user enabling the usage as collateral","title":"ReserveUsedAsCollateralDisabled"},{"location":"architecture/contracts/#rebalancestableborrowrate","text":"event RebalanceStableBorrowRate ( address reserve , address user ) Emitted on rebalanceStableBorrowRate() Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user for which the rebalance has been executed","title":"RebalanceStableBorrowRate"},{"location":"architecture/contracts/#flashloan","text":"event FlashLoan ( address target , address initiator , address asset , uint256 amount , uint256 premium , uint16 referralCode ) Emitted on flashLoan() Name Type Description target address The address of the flash loan receiver contract initiator address The address initiating the flash loan asset address The address of the asset being flash borrowed amount uint256 The amount flash borrowed premium uint256 The fee flash borrowed referralCode uint16 The referral code used","title":"FlashLoan"},{"location":"architecture/contracts/#paused","text":"event Paused () Emitted when the pause is triggered.","title":"Paused"},{"location":"architecture/contracts/#unpaused","text":"event Unpaused () Emitted when the pause is lifted.","title":"Unpaused"},{"location":"architecture/contracts/#liquidationcall","text":"event LiquidationCall ( address collateralAsset , address debtAsset , address user , uint256 debtToCover , uint256 liquidatedCollateralAmount , address liquidator , bool receiveAToken ) Emitted when a borrower is liquidated. This event is emitted by the LendingPool via LendingPoolCollateral manager using a DELEGATECALL This allows to have the events in the generated ABI for LendingPool. Name Type Description collateralAsset address The address of the underlying asset used as collateral, to receive as result of the liquidation debtAsset address The address of the underlying borrowed asset to be repaid with the liquidation user address The address of the borrower getting liquidated debtToCover uint256 The debt amount of borrowed asset the liquidator wants to cover liquidatedCollateralAmount uint256 The amount of collateral received by the liiquidator liquidator address The address of the liquidator receiveAToken bool true if the liquidators wants to receive the collateral aTokens, false if he wants to receive the underlying collateral asset directly","title":"LiquidationCall"},{"location":"architecture/contracts/#reservedataupdated","text":"event ReserveDataUpdated ( address reserve , uint256 liquidityRate , uint256 stableBorrowRate , uint256 variableBorrowRate , uint256 liquidityIndex , uint256 variableBorrowIndex ) Emitted when the state of a reserve is updated. NOTE: This event is actually declared in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal, the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it gets added to the LendingPool ABI Name Type Description reserve address The address of the underlying asset of the reserve liquidityRate uint256 The new liquidity rate stableBorrowRate uint256 The new stable borrow rate variableBorrowRate uint256 The new variable borrow rate liquidityIndex uint256 The new liquidity index variableBorrowIndex uint256 The new variable borrow index","title":"ReserveDataUpdated"},{"location":"architecture/contracts/#deposit_2","text":"function deposit ( address asset , uint256 amount , address onBehalfOf , uint16 referralCode ) external Deposits an amount of underlying asset into the reserve, receiving in return overlying aTokens. - E.g. User deposits 100 USDC and gets in return 100 aUSDC Name Type Description asset address The address of the underlying asset to deposit amount uint256 The amount to be deposited onBehalfOf address The address that will receive the aTokens, same as msg.sender if the user wants to receive them on his own wallet, or a different address if the beneficiary of aTokens is a different wallet referralCode uint16 Code used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-man","title":"deposit"},{"location":"architecture/contracts/#withdraw_1","text":"function withdraw ( address asset , uint256 amount , address to ) external returns ( uint256 ) Withdraws an amount of underlying asset from the reserve, burning the equivalent aTokens owned E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC Name Type Description asset address The address of the underlying asset to withdraw amount uint256 The underlying amount to be withdrawn - Send the value type(uint256).max in order to withdraw the whole aToken balance to address Address that will receive the underlying, same as msg.sender if the user wants to receive it on his own wallet, or a different address if the beneficiary is a different wallet Name Type Description [0] uint256 The final amount withdrawn","title":"withdraw"},{"location":"architecture/contracts/#borrow_2","text":"function borrow ( address asset , uint256 amount , uint256 interestRateMode , uint16 referralCode , address onBehalfOf ) external Allows users to borrow a specific amount of the reserve underlying asset, provided that the borrower already deposited enough collateral, or he was given enough allowance by a credit delegator on the corresponding debt token (StableDebtToken or VariableDebtToken) - E.g. User borrows 100 USDC passing as onBehalfOf his own address, receiving the 100 USDC in his wallet and 100 stable/variable debt tokens, depending on the interestRateMode Name Type Description asset address The address of the underlying asset to borrow amount uint256 The amount to be borrowed interestRateMode uint256 The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable referralCode uint16 Code used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-man onBehalfOf address Address of the user who will receive the debt. Should be the address of the borrower itself calling the function if he wants to borrow against his own collateral, or the address of the credit delegator if he has been given credit delegation allowance","title":"borrow"},{"location":"architecture/contracts/#repay_2","text":"function repay ( address asset , uint256 amount , uint256 rateMode , address onBehalfOf ) external returns ( uint256 ) Repays a borrowed amount on a specific reserve, burning the equivalent debt tokens owned - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the onBehalfOf address Name Type Description asset address The address of the borrowed underlying asset previously borrowed amount uint256 The amount to repay - Send the value type(uint256).max in order to repay the whole debt for asset on the specific debtMode rateMode uint256 The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable onBehalfOf address Address of the user who will get his debt reduced/removed. Should be the address of the user calling the function if he wants to reduce/remove his own debt, or the address of any other other borrower whose debt should be removed Name Type Description [0] uint256 The final amount repaid","title":"repay"},{"location":"architecture/contracts/#swapborrowratemode","text":"function swapBorrowRateMode ( address asset , uint256 rateMode ) external Allows a borrower to swap his debt between stable and variable mode, or viceversa Name Type Description asset address The address of the underlying asset borrowed rateMode uint256 The rate mode that the user wants to swap to","title":"swapBorrowRateMode"},{"location":"architecture/contracts/#rebalancestableborrowrate_1","text":"function rebalanceStableBorrowRate ( address asset , address user ) external Rebalances the stable interest rate of a user to the current stable rate defined on the reserve. - Users can be rebalanced if the following conditions are satisfied: 1. Usage ratio is above 95% 2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been borrowed at a stable rate and depositors are not earning enough Name Type Description asset address The address of the underlying asset borrowed user address The address of the user to be rebalanced","title":"rebalanceStableBorrowRate"},{"location":"architecture/contracts/#setuserusereserveascollateral","text":"function setUserUseReserveAsCollateral ( address asset , bool useAsCollateral ) external Allows depositors to enable/disable a specific deposited asset as collateral Name Type Description asset address The address of the underlying asset deposited useAsCollateral bool true if the user wants to use the deposit as collateral, false otherwise","title":"setUserUseReserveAsCollateral"},{"location":"architecture/contracts/#liquidationcall_1","text":"function liquidationCall ( address collateralAsset , address debtAsset , address user , uint256 debtToCover , bool receiveAToken ) external Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1 - The caller (liquidator) covers debtToCover amount of debt of the user getting liquidated, and receives a proportionally amount of the collateralAsset plus a bonus to cover market risk Name Type Description collateralAsset address The address of the underlying asset used as collateral, to receive as result of the liquidation debtAsset address The address of the underlying borrowed asset to be repaid with the liquidation user address The address of the borrower getting liquidated debtToCover uint256 The debt amount of borrowed asset the liquidator wants to cover receiveAToken bool true if the liquidators wants to receive the collateral aTokens, false if he wants to receive the underlying collateral asset directly","title":"liquidationCall"},{"location":"architecture/contracts/#flashloan_1","text":"function flashLoan ( address receiverAddress , address [] assets , uint256 [] amounts , uint256 [] modes , address onBehalfOf , bytes params , uint16 referralCode ) external Allows smartcontracts to access the liquidity of the pool within one transaction, as long as the amount taken plus a fee is returned. IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration. For further details please visit https://developers.aave.com Name Type Description receiverAddress address The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface assets address[] The addresses of the assets being flash-borrowed amounts uint256[] The amounts amounts being flash-borrowed modes uint256[] Types of the debt to open if the flash loan is not returned: 0 -> Don't open any debt, just revert if funds can't be transferred from the receiver 1 -> Open debt at stable rate for the value of the amount flash-borrowed to the onBehalfOf address 2 -> Open debt at variable rate for the value of the amount flash-borrowed to the onBehalfOf address onBehalfOf address The address that will receive the debt in the case of using on modes 1 or 2 params bytes Variadic packed params to pass to the receiver as extra information referralCode uint16 Code used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-man","title":"flashLoan"},{"location":"architecture/contracts/#getuseraccountdata","text":"function getUserAccountData ( address user ) external view returns ( uint256 totalCollateralETH , uint256 totalDebtETH , uint256 availableBorrowsETH , uint256 currentLiquidationThreshold , uint256 ltv , uint256 healthFactor ) Returns the user account data across all the reserves Name Type Description user address The address of the user Name Type Description totalCollateralETH uint256 the total collateral in ETH of the user totalDebtETH uint256 the total debt in ETH of the user availableBorrowsETH uint256 the borrowing power left of the user currentLiquidationThreshold uint256 the liquidation threshold of the user ltv uint256 the loan to value of the user healthFactor uint256 the current health factor of the user","title":"getUserAccountData"},{"location":"architecture/contracts/#initreserve","text":"function initReserve ( address reserve , address aTokenAddress , address stableDebtAddress , address variableDebtAddress , address interestRateStrategyAddress ) external","title":"initReserve"},{"location":"architecture/contracts/#setreserveinterestratestrategyaddress","text":"function setReserveInterestRateStrategyAddress ( address reserve , address rateStrategyAddress ) external","title":"setReserveInterestRateStrategyAddress"},{"location":"architecture/contracts/#setconfiguration","text":"function setConfiguration ( address reserve , uint256 configuration ) external","title":"setConfiguration"},{"location":"architecture/contracts/#getconfiguration","text":"function getConfiguration ( address asset ) external view returns ( struct DataTypes . ReserveConfigurationMap ) Returns the configuration of the reserve Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] struct DataTypes.ReserveConfigurationMap The configuration of the reserve","title":"getConfiguration"},{"location":"architecture/contracts/#getuserconfiguration","text":"function getUserConfiguration ( address user ) external view returns ( struct DataTypes . UserConfigurationMap ) Returns the configuration of the user across all the reserves Name Type Description user address The user address Name Type Description [0] struct DataTypes.UserConfigurationMap The configuration of the user","title":"getUserConfiguration"},{"location":"architecture/contracts/#getreservenormalizedincome","text":"function getReserveNormalizedIncome ( address asset ) external view returns ( uint256 ) Returns the normalized income normalized income of the reserve Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] uint256 The reserve's normalized income","title":"getReserveNormalizedIncome"},{"location":"architecture/contracts/#getreservenormalizedvariabledebt","text":"function getReserveNormalizedVariableDebt ( address asset ) external view returns ( uint256 ) Returns the normalized variable debt per unit of asset Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] uint256 The reserve normalized variable debt","title":"getReserveNormalizedVariableDebt"},{"location":"architecture/contracts/#getreservedata_1","text":"function getReserveData ( address asset ) external view returns ( struct DataTypes . ReserveData ) Returns the state and configuration of the reserve Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] struct DataTypes.ReserveData The state of the reserve","title":"getReserveData"},{"location":"architecture/contracts/#finalizetransfer","text":"function finalizeTransfer ( address asset , address from , address to , uint256 amount , uint256 balanceFromAfter , uint256 balanceToBefore ) external","title":"finalizeTransfer"},{"location":"architecture/contracts/#getreserveslist","text":"function getReservesList () external view returns ( address [])","title":"getReservesList"},{"location":"architecture/contracts/#getaddressesprovider","text":"function getAddressesProvider () external view returns ( contract ILendingPoolAddressesProvider )","title":"getAddressesProvider"},{"location":"architecture/contracts/#setpause","text":"function setPause ( bool val ) external","title":"setPause"},{"location":"architecture/contracts/#paused_1","text":"function paused () external view returns ( bool )","title":"paused"},{"location":"architecture/contracts/#istabledebttoken","text":"","title":"IStableDebtToken"},{"location":"architecture/contracts/#mint_1","text":"event Mint ( address user , address onBehalfOf , uint256 amount , uint256 currentBalance , uint256 balanceIncrease , uint256 newRate , uint256 avgStableRate , uint256 newTotalSupply ) Emitted when new stable debt is minted Name Type Description user address The address of the user who triggered the minting onBehalfOf address The recipient of stable debt tokens amount uint256 The amount minted currentBalance uint256 The current balance of the user balanceIncrease uint256 The increase in balance since the last action of the user newRate uint256 The rate of the debt after the minting avgStableRate uint256 The new average stable rate after the minting newTotalSupply uint256 The new total supply of the stable debt token after the action","title":"Mint"},{"location":"architecture/contracts/#burn","text":"event Burn ( address user , uint256 amount , uint256 currentBalance , uint256 balanceIncrease , uint256 avgStableRate , uint256 newTotalSupply ) Emitted when new stable debt is burned Name Type Description user address The address of the user amount uint256 The amount being burned currentBalance uint256 The current balance of the user balanceIncrease uint256 The the increase in balance since the last action of the user avgStableRate uint256 The new average stable rate after the burning newTotalSupply uint256 The new total supply of the stable debt token after the action","title":"Burn"},{"location":"architecture/contracts/#approvedelegation","text":"function approveDelegation ( address delegatee , uint256 amount ) external delegates borrowing power to a user on the specific debt token Name Type Description delegatee address the address receiving the delegated borrowing power amount uint256 the maximum amount being delegated. Delegation will still respect the liquidation constraints (even if delegated, a delegatee cannot force a delegator HF to go below 1)","title":"approveDelegation"},{"location":"architecture/contracts/#borrowallowance","text":"function borrowAllowance ( address fromUser , address toUser ) external view returns ( uint256 ) returns the borrow allowance of the user Name Type Description fromUser address The user to giving allowance toUser address The user to give allowance to Name Type Description [0] uint256 the current allowance of toUser","title":"borrowAllowance"},{"location":"architecture/contracts/#mint_2","text":"function mint ( address user , address onBehalfOf , uint256 amount , uint256 rate ) external returns ( bool ) Mints debt token to the onBehalfOf address. - The resulting rate is the weighted average between the rate of the new debt and the rate of the previous debt Name Type Description user address The address receiving the borrowed underlying, being the delegatee in case of credit delegate, or same as onBehalfOf otherwise onBehalfOf address The address receiving the debt tokens amount uint256 The amount of debt tokens to mint rate uint256 The rate of the debt being minted","title":"mint"},{"location":"architecture/contracts/#burn_1","text":"function burn ( address user , uint256 amount ) external Burns debt of user - The resulting rate is the weighted average between the rate of the new debt and the rate of the previous debt Name Type Description user address The address of the user getting his debt burned amount uint256 The amount of debt tokens getting burned","title":"burn"},{"location":"architecture/contracts/#getaveragestablerate","text":"function getAverageStableRate () external view returns ( uint256 ) Returns the average rate of all the stable rate loans. Name Type Description [0] uint256 The average stable rate","title":"getAverageStableRate"},{"location":"architecture/contracts/#getuserstablerate","text":"function getUserStableRate ( address user ) external view returns ( uint256 ) Returns the stable rate of the user debt Name Type Description [0] uint256 The stable rate of the user","title":"getUserStableRate"},{"location":"architecture/contracts/#getuserlastupdated","text":"function getUserLastUpdated ( address user ) external view returns ( uint40 ) Returns the timestamp of the last update of the user Name Type Description [0] uint40 The timestamp","title":"getUserLastUpdated"},{"location":"architecture/contracts/#getsupplydata","text":"function getSupplyData () external view returns ( uint256 , uint256 , uint256 , uint40 ) Returns the principal, the total supply and the average stable rate","title":"getSupplyData"},{"location":"architecture/contracts/#gettotalsupplylastupdated","text":"function getTotalSupplyLastUpdated () external view returns ( uint40 ) Returns the timestamp of the last update of the total supply Name Type Description [0] uint40 The timestamp","title":"getTotalSupplyLastUpdated"},{"location":"architecture/contracts/#gettotalsupplyandavgrate","text":"function getTotalSupplyAndAvgRate () external view returns ( uint256 , uint256 ) Returns the total supply and the average stable rate","title":"getTotalSupplyAndAvgRate"},{"location":"architecture/contracts/#principalbalanceof","text":"function principalBalanceOf ( address user ) external view returns ( uint256 ) Returns the principal debt balance of the user Name Type Description [0] uint256 The debt balance of the user since the last burn/mint action","title":"principalBalanceOf"},{"location":"architecture/contracts/#idynamicpricing","text":"","title":"IDynamicPricing"},{"location":"architecture/contracts/#dynamicpricingstate","text":"enum DynamicPricingState { NotStarted , Finished , InProgress , Aborted }","title":"DynamicPricingState"},{"location":"architecture/contracts/#getpricingtype","text":"function getPricingType () external view returns ( bytes32 )","title":"getPricingType"},{"location":"architecture/contracts/#getprice","text":"function getPrice ( bytes32 did ) external view returns ( uint256 )","title":"getPrice"},{"location":"architecture/contracts/#gettokenaddress","text":"function getTokenAddress ( bytes32 did ) external view returns ( address )","title":"getTokenAddress"},{"location":"architecture/contracts/#getstatus","text":"function getStatus ( bytes32 did ) external view returns ( enum IDynamicPricing . DynamicPricingState , uint256 , address )","title":"getStatus"},{"location":"architecture/contracts/#canbepurchased","text":"function canBePurchased ( bytes32 did ) external view returns ( bool )","title":"canBePurchased"},{"location":"architecture/contracts/#withdraw_2","text":"function withdraw ( bytes32 did , address withdrawAddress ) external returns ( bool )","title":"withdraw"},{"location":"architecture/contracts/#ilist","text":"","title":"IList"},{"location":"architecture/contracts/#has_2","text":"function has ( bytes32 value ) external view returns ( bool )","title":"has"},{"location":"architecture/contracts/#has_3","text":"function has ( bytes32 value , bytes32 id ) external view returns ( bool )","title":"has"},{"location":"architecture/contracts/#iroyaltyscheme","text":"","title":"IRoyaltyScheme"},{"location":"architecture/contracts/#check","text":"function check ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _tokenAddress ) external view returns ( bool ) check that royalties are correct Name Type Description _did bytes32 compute royalties for this DID _amounts uint256[] amounts in payment _receivers address[] receivers of payments _tokenAddress address payment token. zero address means native token (ether)","title":"check"},{"location":"architecture/contracts/#isecretstore","text":"","title":"ISecretStore"},{"location":"architecture/contracts/#checkpermissions_2","text":"function checkPermissions ( address user , bytes32 documentKeyId ) external view returns ( bool permissionGranted ) checkPermissions is called by Parity secret store","title":"checkPermissions"},{"location":"architecture/contracts/#isecretstorepermission","text":"","title":"ISecretStorePermission"},{"location":"architecture/contracts/#grantpermission_2","text":"function grantPermission ( address user , bytes32 documentKeyId ) external grantPermission is called only by documentKeyId Owner or provider","title":"grantPermission"},{"location":"architecture/contracts/#renouncepermission_1","text":"function renouncePermission ( address user , bytes32 documentKeyId ) external renouncePermission is called only by documentKeyId Owner or provider","title":"renouncePermission"},{"location":"architecture/contracts/#iwethgateway","text":"","title":"IWETHGateway"},{"location":"architecture/contracts/#depositeth","text":"function depositETH ( address lendingPool , address onBehalfOf , uint16 referralCode ) external payable","title":"depositETH"},{"location":"architecture/contracts/#withdraweth","text":"function withdrawETH ( address lendingPool , uint256 amount , address to ) external","title":"withdrawETH"},{"location":"architecture/contracts/#repayeth","text":"function repayETH ( address lendingPool , uint256 amount , uint256 rateMode , address onBehalfOf ) external payable","title":"repayETH"},{"location":"architecture/contracts/#borroweth","text":"function borrowETH ( address lendingPool , uint256 amount , uint256 interesRateMode , uint16 referralCode ) external","title":"borrowETH"},{"location":"architecture/contracts/#datatypes","text":"","title":"DataTypes"},{"location":"architecture/contracts/#reservedata","text":"struct ReserveData { struct DataTypes . ReserveConfigurationMap configuration ; uint128 liquidityIndex ; uint128 variableBorrowIndex ; uint128 currentLiquidityRate ; uint128 currentVariableBorrowRate ; uint128 currentStableBorrowRate ; uint40 lastUpdateTimestamp ; address aTokenAddress ; address stableDebtTokenAddress ; address variableDebtTokenAddress ; address interestRateStrategyAddress ; uint8 id ; }","title":"ReserveData"},{"location":"architecture/contracts/#reserveconfigurationmap","text":"struct ReserveConfigurationMap { uint256 data ; }","title":"ReserveConfigurationMap"},{"location":"architecture/contracts/#userconfigurationmap","text":"struct UserConfigurationMap { uint256 data ; }","title":"UserConfigurationMap"},{"location":"architecture/contracts/#interestratemode","text":"enum InterestRateMode { NONE , STABLE , VARIABLE }","title":"InterestRateMode"},{"location":"architecture/contracts/#safemath","text":"","title":"SafeMath"},{"location":"architecture/contracts/#add_2","text":"function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the addition of two unsigned integers, reverting on overflow. Counterpart to Solidity's + operator. Requirements: - Addition cannot overflow._","title":"add"},{"location":"architecture/contracts/#sub","text":"function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the subtraction of two unsigned integers, reverting on overflow (when the result is negative). Counterpart to Solidity's - operator. Requirements: - Subtraction cannot overflow._","title":"sub"},{"location":"architecture/contracts/#sub_1","text":"function sub ( uint256 a , uint256 b , string errorMessage ) internal pure returns ( uint256 ) _Returns the subtraction of two unsigned integers, reverting with custom message on overflow (when the result is negative). Counterpart to Solidity's - operator. Requirements: - Subtraction cannot overflow._","title":"sub"},{"location":"architecture/contracts/#mul","text":"function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the multiplication of two unsigned integers, reverting on overflow. Counterpart to Solidity's * operator. Requirements: - Multiplication cannot overflow._","title":"mul"},{"location":"architecture/contracts/#div","text":"function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the integer division of two unsigned integers. Reverts on division by zero. The result is rounded towards zero. Counterpart to Solidity's / operator. Note: this function uses a revert opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas). Requirements: - The divisor cannot be zero._","title":"div"},{"location":"architecture/contracts/#div_1","text":"function div ( uint256 a , uint256 b , string errorMessage ) internal pure returns ( uint256 ) _Returns the integer division of two unsigned integers. Reverts with custom message on division by zero. The result is rounded towards zero. Counterpart to Solidity's / operator. Note: this function uses a revert opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas). Requirements: - The divisor cannot be zero._","title":"div"},{"location":"architecture/contracts/#mod","text":"function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), Reverts when dividing by zero. Counterpart to Solidity's % operator. This function uses a revert opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas). Requirements: - The divisor cannot be zero._","title":"mod"},{"location":"architecture/contracts/#mod_1","text":"function mod ( uint256 a , uint256 b , string errorMessage ) internal pure returns ( uint256 ) _Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), Reverts with custom message when dividing by zero. Counterpart to Solidity's % operator. This function uses a revert opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas). Requirements: - The divisor cannot be zero._","title":"mod"},{"location":"architecture/contracts/#address","text":"","title":"Address"},{"location":"architecture/contracts/#iscontract_1","text":"function isContract ( address account ) internal view returns ( bool ) _Returns true if account is a contract.","title":"isContract"},{"location":"architecture/contracts/#important","text":"It is unsafe to assume that an address for which this function returns false is an externally-owned account (EOA) and not a contract. Among others, isContract will return false for the following types of addresses: an externally-owned account a contract in construction an address where a contract will be created an address where a contract lived, but was destroyed ====_","title":"[IMPORTANT]"},{"location":"architecture/contracts/#sendvalue","text":"function sendValue ( address payable recipient , uint256 amount ) internal _Replacement for Solidity's transfer : sends amount wei to recipient , forwarding all available gas and reverting on errors. https://eips.ethereum.org/EIPS/eip-1884[EIP1884 ] increases the gas cost of certain opcodes, possibly making contracts go over the 2300 gas limit imposed by transfer , making them unable to receive funds via transfer . {sendValue} removes this limitation. https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. IMPORTANT: because control is transferred to recipient , care must be taken to not create reentrancy vulnerabilities. Consider using {ReentrancyGuard} or the https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern]._","title":"sendValue"},{"location":"architecture/contracts/#safeerc20","text":"Wrappers around ERC20 operations that throw on failure (when the token contract returns false). Tokens that return no value (and instead revert or throw on failure) are also supported, non-reverting calls are assumed to be successful. To use this library you can add a using SafeERC20 for IERC20; statement to your contract, which allows you to call the safe operations as token.safeTransfer(...) , etc.","title":"SafeERC20"},{"location":"architecture/contracts/#safetransfer","text":"function safeTransfer ( contract IERC20 token , address to , uint256 value ) internal","title":"safeTransfer"},{"location":"architecture/contracts/#safetransferfrom","text":"function safeTransferFrom ( contract IERC20 token , address from , address to , uint256 value ) internal","title":"safeTransferFrom"},{"location":"architecture/contracts/#safeapprove","text":"function safeApprove ( contract IERC20 token , address spender , uint256 value ) internal","title":"safeApprove"},{"location":"architecture/contracts/#calloptionalreturn","text":"function callOptionalReturn ( contract IERC20 token , bytes data ) private","title":"callOptionalReturn"},{"location":"architecture/contracts/#clonefactory","text":"","title":"CloneFactory"},{"location":"architecture/contracts/#createclone","text":"function createClone ( address target ) internal returns ( address result )","title":"createClone"},{"location":"architecture/contracts/#isclone","text":"function isClone ( address target , address query ) internal view returns ( bool result )","title":"isClone"},{"location":"architecture/contracts/#epochlibrary","text":"Implementation of Epoch Library. For an arbitrary Epoch, this library manages the life cycle of an Epoch. Usually this library is used for handling the time window between conditions in an agreement.","title":"EpochLibrary"},{"location":"architecture/contracts/#epoch","text":"struct Epoch { uint256 timeLock ; uint256 timeOut ; uint256 blockNumber ; }","title":"Epoch"},{"location":"architecture/contracts/#epochlist_1","text":"struct EpochList { mapping ( bytes32 &# x3D ; & gt ; struct EpochLibrary . Epoch ) epochs ; bytes32 [] epochIds ; }","title":"EpochList"},{"location":"architecture/contracts/#create_2","text":"function create ( struct EpochLibrary . EpochList _self , bytes32 _id , uint256 _timeLock , uint256 _timeOut ) internal create creates new Epoch Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 _timeLock uint256 value in block count (can not fulfill before) _timeOut uint256 value in block count (can not fulfill after)","title":"create"},{"location":"architecture/contracts/#istimedout","text":"function isTimedOut ( struct EpochLibrary . EpochList _self , bytes32 _id ) external view returns ( bool ) isTimedOut means you cannot fulfill after Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 Name Type Description [0] bool true if the current block number is gt timeOut","title":"isTimedOut"},{"location":"architecture/contracts/#istimelocked","text":"function isTimeLocked ( struct EpochLibrary . EpochList _self , bytes32 _id ) external view returns ( bool ) isTimeLocked means you cannot fulfill before Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 Name Type Description [0] bool true if the current block number is gt timeLock","title":"isTimeLocked"},{"location":"architecture/contracts/#getepochtimeout","text":"function getEpochTimeOut ( struct EpochLibrary . Epoch _self ) public view returns ( uint256 ) getEpochTimeOut Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer","title":"getEpochTimeOut"},{"location":"architecture/contracts/#getepochtimelock","text":"function getEpochTimeLock ( struct EpochLibrary . Epoch _self ) public view returns ( uint256 ) getEpochTimeLock Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer","title":"getEpochTimeLock"},{"location":"architecture/contracts/#hashlistlibrary","text":"Implementation of the basic functionality of list of hash values. This library allows other contracts to build and maintain lists and also preserves the privacy of the data by accepting only hashed content (bytes32 based data type)","title":"HashListLibrary"},{"location":"architecture/contracts/#list","text":"struct List { address _owner ; bytes32 [] values ; mapping ( bytes32 &# x3D ; & gt ; uint256 ) indices ; }","title":"List"},{"location":"architecture/contracts/#onlylistowner","text":"modifier onlyListOwner ( struct HashListLibrary . List _self )","title":"onlyListOwner"},{"location":"architecture/contracts/#add_3","text":"function add ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) add index an element then add it to a list Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is a bytes32 value Name Type Description [0] bool true if value is added successfully","title":"add"},{"location":"architecture/contracts/#add_4","text":"function add ( struct HashListLibrary . List _self , bytes32 [] values ) public returns ( bool ) put an array of elements without indexing this meant to save gas in case of large arrays Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage values bytes32[] is an array of elements value Name Type Description [0] bool true if values are added successfully","title":"add"},{"location":"architecture/contracts/#update_1","text":"function update ( struct HashListLibrary . List _self , bytes32 oldValue , bytes32 newValue ) public returns ( bool ) update the value with a new value and maintain indices Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage oldValue bytes32 is an element value in a list newValue bytes32 new value Name Type Description [0] bool true if value is updated successfully","title":"update"},{"location":"architecture/contracts/#remove_1","text":"function remove ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) remove value from a list, updates indices, and list size Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is an element value in a list Name Type Description [0] bool true if value is removed successfully","title":"remove"},{"location":"architecture/contracts/#get_1","text":"function get ( struct HashListLibrary . List _self , uint256 __index ) public view returns ( bytes32 ) has value by index Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage __index uint256 is where is value is stored in the list Name Type Description [0] bytes32 the value if exists","title":"get"},{"location":"architecture/contracts/#index_1","text":"function index ( struct HashListLibrary . List _self , uint256 from , uint256 to ) public returns ( bool ) index is used to map each element value to its index on the list Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing Name Type Description [0] bool true if the sub list is indexed","title":"index"},{"location":"architecture/contracts/#setowner","text":"function setOwner ( struct HashListLibrary . List _self , address _owner ) public setOwner set list owner param _owner owner address","title":"setOwner"},{"location":"architecture/contracts/#indexof_1","text":"function indexOf ( struct HashListLibrary . List _self , bytes32 value ) public view returns ( uint256 ) indexOf gets the index of a value in a list Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list Name Type Description [0] uint256 value index in list","title":"indexOf"},{"location":"architecture/contracts/#isindexed_1","text":"function isIndexed ( struct HashListLibrary . List _self ) public view returns ( bool ) isIndexed checks if the list is indexed Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] bool true if the list is indexed","title":"isIndexed"},{"location":"architecture/contracts/#all_1","text":"function all ( struct HashListLibrary . List _self ) public view returns ( bytes32 []) all returns all list elements Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] bytes32[] all list elements","title":"all"},{"location":"architecture/contracts/#has_4","text":"function has ( struct HashListLibrary . List _self , bytes32 value ) public view returns ( bool ) size returns the list size Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list Name Type Description [0] bool true if the value exists","title":"has"},{"location":"architecture/contracts/#size_1","text":"function size ( struct HashListLibrary . List _self ) public view returns ( uint256 ) size gets the list size Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] uint256 total length of the list","title":"size"},{"location":"architecture/contracts/#ownedby_1","text":"function ownedBy ( struct HashListLibrary . List _self ) public view returns ( address ) ownedBy gets the list owner Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] address list owner","title":"ownedBy"},{"location":"architecture/contracts/#_index","text":"function _index ( struct HashListLibrary . List _self , uint256 from , uint256 to ) private returns ( bool ) __index assign index to the list elements_ Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage from uint256 is the starting index id to uint256 is the ending index id","title":"_index"},{"location":"architecture/contracts/#abstractauction","text":"","title":"AbstractAuction"},{"location":"architecture/contracts/#auction_manager_role","text":"bytes32 AUCTION_MANAGER_ROLE","title":"AUCTION_MANAGER_ROLE"},{"location":"architecture/contracts/#nvm_agreement_role","text":"bytes32 NVM_AGREEMENT_ROLE","title":"NVM_AGREEMENT_ROLE"},{"location":"architecture/contracts/#auction","text":"struct Auction { bytes32 did ; enum IDynamicPricing . DynamicPricingState state ; address creator ; uint256 blockNumberCreated ; uint256 floor ; uint256 starts ; uint256 ends ; uint256 price ; address tokenAddress ; address whoCanClaim ; string hash ; }","title":"Auction"},{"location":"architecture/contracts/#auctions","text":"mapping ( bytes32 => struct AbstractAuction . Auction ) auctions","title":"auctions"},{"location":"architecture/contracts/#auctionbids","text":"mapping ( bytes32 => mapping ( address => uint256 )) auctionBids","title":"auctionBids"},{"location":"architecture/contracts/#auctioncreated","text":"event AuctionCreated ( bytes32 auctionId , bytes32 did , address creator , uint256 blockNumberCreated , uint256 floor , uint256 starts , uint256 ends , address tokenAddress )","title":"AuctionCreated"},{"location":"architecture/contracts/#auctionchangedstate","text":"event AuctionChangedState ( bytes32 auctionId , address who , enum IDynamicPricing . DynamicPricingState previousState , enum IDynamicPricing . DynamicPricingState newState )","title":"AuctionChangedState"},{"location":"architecture/contracts/#auctionbidreceived","text":"event AuctionBidReceived ( bytes32 auctionId , address bidder , address tokenAddress , uint256 amount )","title":"AuctionBidReceived"},{"location":"architecture/contracts/#auctionwithdrawal","text":"event AuctionWithdrawal ( bytes32 auctionId , address receiver , address tokenAddress , uint256 amount )","title":"AuctionWithdrawal"},{"location":"architecture/contracts/#receive_3","text":"receive () external payable","title":"receive"},{"location":"architecture/contracts/#abortauction","text":"function abortAuction ( bytes32 _auctionId ) external virtual","title":"abortAuction"},{"location":"architecture/contracts/#withdraw_3","text":"function withdraw ( bytes32 _auctionId , address _withdrawAddress ) external virtual returns ( bool )","title":"withdraw"},{"location":"architecture/contracts/#getpricingtype_1","text":"function getPricingType () external pure virtual returns ( bytes32 )","title":"getPricingType"},{"location":"architecture/contracts/#getprice_1","text":"function getPrice ( bytes32 _auctionId ) external view returns ( uint256 )","title":"getPrice"},{"location":"architecture/contracts/#gettokenaddress_1","text":"function getTokenAddress ( bytes32 _auctionId ) external view returns ( address )","title":"getTokenAddress"},{"location":"architecture/contracts/#getstatus_1","text":"function getStatus ( bytes32 _auctionId ) external view returns ( enum IDynamicPricing . DynamicPricingState state , uint256 price , address whoCanClaim )","title":"getStatus"},{"location":"architecture/contracts/#canbepurchased_1","text":"function canBePurchased ( bytes32 _auctionId ) external view virtual returns ( bool )","title":"canBePurchased"},{"location":"architecture/contracts/#addnvmagreementrole","text":"function addNVMAgreementRole ( address account ) public","title":"addNVMAgreementRole"},{"location":"architecture/contracts/#onlycreator","text":"modifier onlyCreator ( bytes32 _auctionId )","title":"onlyCreator"},{"location":"architecture/contracts/#onlycreatororadmin","text":"modifier onlyCreatorOrAdmin ( bytes32 _auctionId )","title":"onlyCreatorOrAdmin"},{"location":"architecture/contracts/#onlynotcreator","text":"modifier onlyNotCreator ( bytes32 _auctionId )","title":"onlyNotCreator"},{"location":"architecture/contracts/#onlyafterstart","text":"modifier onlyAfterStart ( bytes32 _auctionId )","title":"onlyAfterStart"},{"location":"architecture/contracts/#onlybeforestarts","text":"modifier onlyBeforeStarts ( bytes32 _auctionId )","title":"onlyBeforeStarts"},{"location":"architecture/contracts/#onlybeforeend","text":"modifier onlyBeforeEnd ( bytes32 _auctionId )","title":"onlyBeforeEnd"},{"location":"architecture/contracts/#onlynotabortedorfinished","text":"modifier onlyNotAbortedOrFinished ( bytes32 _auctionId )","title":"onlyNotAbortedOrFinished"},{"location":"architecture/contracts/#onlyabortedorfinished","text":"modifier onlyAbortedOrFinished ( bytes32 _auctionId )","title":"onlyAbortedOrFinished"},{"location":"architecture/contracts/#onlynotaborted","text":"modifier onlyNotAborted ( bytes32 _auctionId )","title":"onlyNotAborted"},{"location":"architecture/contracts/#onlyfinishedoraborted","text":"modifier onlyFinishedOrAborted ( bytes32 _auctionId )","title":"onlyFinishedOrAborted"},{"location":"architecture/contracts/#dutchauction","text":"","title":"DutchAuction"},{"location":"architecture/contracts/#initialize_32","text":"function initialize ( address _owner ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address","title":"initialize"},{"location":"architecture/contracts/#create_3","text":"function create ( bytes32 _auctionId , bytes32 _did , uint256 _startPrice , uint256 _starts , uint256 _ends , address _tokenAddress , string _hash ) external virtual It creates a new Auction given some setup parameters Name Type Description _auctionId bytes32 unique auction identifier _did bytes32 reference to the asset part of the auction _startPrice uint256 start price (and max) for the auction _starts uint256 block number when the auction starts _ends uint256 block number of when the auction ends _tokenAddress address token address to use for the auction. If address(0) means native token _hash string ipfs hash referring to the auction metadata","title":"create"},{"location":"architecture/contracts/#placenativetokenbid","text":"function placeNativeTokenBid ( bytes32 _auctionId ) external payable virtual","title":"placeNativeTokenBid"},{"location":"architecture/contracts/#placeerc20bid","text":"function placeERC20Bid ( bytes32 _auctionId , uint256 _bidAmount ) external virtual","title":"placeERC20Bid"},{"location":"architecture/contracts/#withdraw_4","text":"function withdraw ( bytes32 _auctionId , address _withdrawAddress ) external virtual returns ( bool )","title":"withdraw"},{"location":"architecture/contracts/#getpricingtype_2","text":"function getPricingType () external pure returns ( bytes32 )","title":"getPricingType"},{"location":"architecture/contracts/#englishauction","text":"","title":"EnglishAuction"},{"location":"architecture/contracts/#initialize_33","text":"function initialize ( address _owner ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address","title":"initialize"},{"location":"architecture/contracts/#create_4","text":"function create ( bytes32 _auctionId , bytes32 _did , uint256 _floor , uint256 _starts , uint256 _ends , address _tokenAddress , string _hash ) external virtual It creates a new Auction given some setup parameters Name Type Description _auctionId bytes32 unique auction identifier _did bytes32 reference to the asset part of the auction _floor uint256 floor price _starts uint256 block number when the auction starts _ends uint256 block number of when the auction ends _tokenAddress address token address to use for the auction. If address(0) means native token _hash string ipfs hash referring to the auction metadata","title":"create"},{"location":"architecture/contracts/#placenativetokenbid_1","text":"function placeNativeTokenBid ( bytes32 _auctionId ) external payable virtual","title":"placeNativeTokenBid"},{"location":"architecture/contracts/#placeerc20bid_1","text":"function placeERC20Bid ( bytes32 _auctionId , uint256 _bidAmount ) external virtual","title":"placeERC20Bid"},{"location":"architecture/contracts/#getpricingtype_3","text":"function getPricingType () external pure returns ( bytes32 )","title":"getPricingType"},{"location":"architecture/contracts/#didfactory","text":"Implementation of the DID Registry.","title":"DIDFactory"},{"location":"architecture/contracts/#didregisterlist","text":"struct DIDRegistryLibrary . DIDRegisterList didRegisterList state storage for the DID registry","title":"didRegisterList"},{"location":"architecture/contracts/#didpermissions","text":"mapping ( bytes32 => mapping ( address => bool )) didPermissions","title":"didPermissions"},{"location":"architecture/contracts/#manager","text":"address manager","title":"manager"},{"location":"architecture/contracts/#onlydidowner","text":"modifier onlyDIDOwner ( bytes32 _did )","title":"onlyDIDOwner"},{"location":"architecture/contracts/#onlymanager","text":"modifier onlyManager ()","title":"onlyManager"},{"location":"architecture/contracts/#onlyownerproviderordelegated","text":"modifier onlyOwnerProviderOrDelegated ( bytes32 _did )","title":"onlyOwnerProviderOrDelegated"},{"location":"architecture/contracts/#onlyvalidattributes","text":"modifier onlyValidAttributes ( string _attributes )","title":"onlyValidAttributes"},{"location":"architecture/contracts/#nftisinitialized","text":"modifier nftIsInitialized ( bytes32 _did )","title":"nftIsInitialized"},{"location":"architecture/contracts/#nft721isinitialized","text":"modifier nft721IsInitialized ( bytes32 _did )","title":"nft721IsInitialized"},{"location":"architecture/contracts/#didattributeregistered","text":"event DIDAttributeRegistered ( bytes32 _did , address _owner , bytes32 _checksum , string _value , address _lastUpdatedBy , uint256 _blockNumberUpdated ) DID Events","title":"DIDAttributeRegistered"},{"location":"architecture/contracts/#didproviderremoved","text":"event DIDProviderRemoved ( bytes32 _did , address _provider , bool state )","title":"DIDProviderRemoved"},{"location":"architecture/contracts/#didprovideradded","text":"event DIDProviderAdded ( bytes32 _did , address _provider )","title":"DIDProviderAdded"},{"location":"architecture/contracts/#didownershiptransferred","text":"event DIDOwnershipTransferred ( bytes32 _did , address _previousOwner , address _newOwner )","title":"DIDOwnershipTransferred"},{"location":"architecture/contracts/#didpermissiongranted","text":"event DIDPermissionGranted ( bytes32 _did , address _owner , address _grantee )","title":"DIDPermissionGranted"},{"location":"architecture/contracts/#didpermissionrevoked","text":"event DIDPermissionRevoked ( bytes32 _did , address _owner , address _grantee )","title":"DIDPermissionRevoked"},{"location":"architecture/contracts/#didprovenancedelegateremoved","text":"event DIDProvenanceDelegateRemoved ( bytes32 _did , address _delegate , bool state )","title":"DIDProvenanceDelegateRemoved"},{"location":"architecture/contracts/#didprovenancedelegateadded","text":"event DIDProvenanceDelegateAdded ( bytes32 _did , address _delegate )","title":"DIDProvenanceDelegateAdded"},{"location":"architecture/contracts/#setmanager","text":"function setManager ( address _addr ) external Sets the manager role. Should be the TransferCondition contract address","title":"setManager"},{"location":"architecture/contracts/#registerattribute","text":"function registerAttribute ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url ) public virtual Register DID attributes. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] _url string refers to the attribute value, limited to 2048 bytes.","title":"registerAttribute"},{"location":"architecture/contracts/#registerdid","text":"function registerDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , bytes32 _activityId , string _attributes ) public virtual Register DID attributes. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). The final DID will be calculated with the creator address using the hashDID function _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _activityId bytes32 refers to activity _attributes string refers to the provenance attributes","title":"registerDID"},{"location":"architecture/contracts/#hashdid","text":"function hashDID ( bytes32 _didSeed , address _creator ) public pure returns ( bytes32 ) It generates a DID using as seed a bytes32 and the address of the DID creator Name Type Description _didSeed bytes32 refers to DID Seed used as base to generate the final DID _creator address address of the creator of the DID Name Type Description [0] bytes32 the new DID created","title":"hashDID"},{"location":"architecture/contracts/#areroyaltiesvalid","text":"function areRoyaltiesValid ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _tokenAddress ) public view returns ( bool ) areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards _tokenAddress address Name Type Description [0] bool true if the rewards distribution respect the original creator royalties","title":"areRoyaltiesValid"},{"location":"architecture/contracts/#wasgeneratedby","text":"function wasGeneratedBy ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal returns ( bool )","title":"wasGeneratedBy"},{"location":"architecture/contracts/#used","text":"function used ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , bytes _signatureUsing , string _attributes ) public returns ( bool success )","title":"used"},{"location":"architecture/contracts/#wasderivedfrom","text":"function wasDerivedFrom ( bytes32 _provId , bytes32 _newEntityDid , bytes32 _usedEntityDid , address _agentId , bytes32 _activityId , string _attributes ) public returns ( bool success )","title":"wasDerivedFrom"},{"location":"architecture/contracts/#wasassociatedwith","text":"function wasAssociatedWith ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) public returns ( bool success )","title":"wasAssociatedWith"},{"location":"architecture/contracts/#actedonbehalf","text":"function actedOnBehalf ( bytes32 _provId , bytes32 _did , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes _signatureDelegate , string _attributes ) public returns ( bool success ) Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId & _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId) Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered","title":"actedOnBehalf"},{"location":"architecture/contracts/#adddidprovider","text":"function addDIDProvider ( bytes32 _did , address _provider ) external addDIDProvider add new DID provider. it adds new DID provider to the providers list. A provider is any entity that can serve the registered asset Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address.","title":"addDIDProvider"},{"location":"architecture/contracts/#removedidprovider","text":"function removeDIDProvider ( bytes32 _did , address _provider ) external removeDIDProvider delete an existing DID provider. Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address.","title":"removeDIDProvider"},{"location":"architecture/contracts/#adddidprovenancedelegate","text":"function addDIDProvenanceDelegate ( bytes32 _did , address _delegate ) public addDIDProvenanceDelegate add new DID provenance delegate. it adds new DID provenance delegate to the delegates list. A delegate is any entity that interact with the provenance entries of one DID Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegates's address.","title":"addDIDProvenanceDelegate"},{"location":"architecture/contracts/#removedidprovenancedelegate","text":"function removeDIDProvenanceDelegate ( bytes32 _did , address _delegate ) external removeDIDProvenanceDelegate delete an existing DID delegate. Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address.","title":"removeDIDProvenanceDelegate"},{"location":"architecture/contracts/#transferdidownership","text":"function transferDIDOwnership ( bytes32 _did , address _newOwner ) external transferDIDOwnership transfer DID ownership Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _newOwner address new owner address","title":"transferDIDOwnership"},{"location":"architecture/contracts/#transferdidownershipmanaged","text":"function transferDIDOwnershipManaged ( address _sender , bytes32 _did , address _newOwner ) external transferDIDOwnershipManaged transfer DID ownership Name Type Description _sender address _did bytes32 refers to decentralized identifier (a bytes32 length ID) _newOwner address new owner address","title":"transferDIDOwnershipManaged"},{"location":"architecture/contracts/#_transferdidownership","text":"function _transferDIDOwnership ( address _sender , bytes32 _did , address _newOwner ) internal","title":"_transferDIDOwnership"},{"location":"architecture/contracts/#grantpermission_3","text":"function grantPermission ( bytes32 _did , address _grantee ) external grantPermission grants access permission to grantee Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"grantPermission"},{"location":"architecture/contracts/#revokepermission","text":"function revokePermission ( bytes32 _did , address _grantee ) external revokePermission revokes access permission from grantee Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"revokePermission"},{"location":"architecture/contracts/#getpermission","text":"function getPermission ( bytes32 _did , address _grantee ) external view returns ( bool ) getPermission gets access permission of a grantee Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address Name Type Description [0] bool true if grantee has access permission to a DID","title":"getPermission"},{"location":"architecture/contracts/#isdidprovider","text":"function isDIDProvider ( bytes32 _did , address _provider ) public view returns ( bool ) isDIDProvider check whether a given DID provider exists Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address.","title":"isDIDProvider"},{"location":"architecture/contracts/#isdidproviderorowner","text":"function isDIDProviderOrOwner ( bytes32 _did , address _provider ) public view returns ( bool )","title":"isDIDProviderOrOwner"},{"location":"architecture/contracts/#getdidregister","text":"function getDIDRegister ( bytes32 _did ) public view returns ( address owner , bytes32 lastChecksum , string url , address lastUpdatedBy , uint256 blockNumberUpdated , address [] providers , uint256 nftSupply , uint256 mintCap , uint256 royalties ) Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description owner address the did owner lastChecksum bytes32 last checksum url string URL to the DID metadata lastUpdatedBy address who was the last updating the DID blockNumberUpdated uint256 In which block was the DID updated providers address[] the list of providers nftSupply uint256 the supply of nfts mintCap uint256 the maximum number of nfts that can be minted royalties uint256 the royalties amount","title":"getDIDRegister"},{"location":"architecture/contracts/#getdidsupply","text":"function getDIDSupply ( bytes32 _did ) public view returns ( uint256 nftSupply , uint256 mintCap )","title":"getDIDSupply"},{"location":"architecture/contracts/#getblocknumberupdated","text":"function getBlockNumberUpdated ( bytes32 _did ) public view returns ( uint256 blockNumberUpdated ) Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description blockNumberUpdated uint256 last modified (update) block number of a DID.","title":"getBlockNumberUpdated"},{"location":"architecture/contracts/#getdidowner","text":"function getDIDOwner ( bytes32 _did ) public view returns ( address didOwner ) Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description didOwner address the address of the DID owner.","title":"getDIDOwner"},{"location":"architecture/contracts/#getdidroyaltyrecipient","text":"function getDIDRoyaltyRecipient ( bytes32 _did ) public view returns ( address )","title":"getDIDRoyaltyRecipient"},{"location":"architecture/contracts/#getdidroyaltyscheme","text":"function getDIDRoyaltyScheme ( bytes32 _did ) public view returns ( address )","title":"getDIDRoyaltyScheme"},{"location":"architecture/contracts/#getdidcreator","text":"function getDIDCreator ( bytes32 _did ) public view returns ( address )","title":"getDIDCreator"},{"location":"architecture/contracts/#_grantpermission","text":"function _grantPermission ( bytes32 _did , address _grantee ) internal __grantPermission grants access permission to grantee_ Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"_grantPermission"},{"location":"architecture/contracts/#_revokepermission","text":"function _revokePermission ( bytes32 _did , address _grantee ) internal __revokePermission revokes access permission from grantee_ Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"_revokePermission"},{"location":"architecture/contracts/#_getpermission","text":"function _getPermission ( bytes32 _did , address _grantee ) internal view returns ( bool ) __getPermission gets access permission of a grantee_ Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address Name Type Description [0] bool true if grantee has access permission to a DID","title":"_getPermission"},{"location":"architecture/contracts/#getprovenanceentry","text":"function getProvenanceEntry ( bytes32 _provId ) public view returns ( bytes32 did , bytes32 relatedDid , address agentId , bytes32 activityId , address agentInvolvedId , uint8 method , address createdBy , uint256 blockNumberUpdated , bytes signature ) Fetch the complete provenance entry attributes Name Type Description _provId bytes32 refers to the provenance identifier Name Type Description did bytes32 to what DID refers this entry relatedDid bytes32 DID related with the entry agentId address the agent identifier activityId bytes32 referring to the id of the activity agentInvolvedId address agent involved with the action method uint8 the w3c provenance method createdBy address who is creating this entry blockNumberUpdated uint256 in which block was updated signature bytes digital signature","title":"getProvenanceEntry"},{"location":"architecture/contracts/#isdidowner","text":"function isDIDOwner ( address _address , bytes32 _did ) public view returns ( bool ) isDIDOwner check whether a given address is owner for a DID Name Type Description _address address user address. _did bytes32 refers to decentralized identifier (a bytes32 length ID).","title":"isDIDOwner"},{"location":"architecture/contracts/#isownerproviderordelegate","text":"function isOwnerProviderOrDelegate ( bytes32 _did ) public view returns ( bool ) isOwnerProviderOrDelegate check whether msg.sender is owner, provider or delegate for a DID given Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description [0] bool boolean true if yes","title":"isOwnerProviderOrDelegate"},{"location":"architecture/contracts/#isprovenancedelegate","text":"function isProvenanceDelegate ( bytes32 _did , address _delegate ) public view returns ( bool ) isProvenanceDelegate check whether a given DID delegate exists Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address. Name Type Description [0] bool boolean true if yes","title":"isProvenanceDelegate"},{"location":"architecture/contracts/#getprovenanceowner","text":"function getProvenanceOwner ( bytes32 _did ) public view returns ( address provenanceOwner ) Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description provenanceOwner address the address of the Provenance owner.","title":"getProvenanceOwner"},{"location":"architecture/contracts/#didregistry_7","text":"Implementation of a Mintable DID Registry.","title":"DIDRegistry"},{"location":"architecture/contracts/#erc1155_3","text":"contract NFTUpgradeable erc1155","title":"erc1155"},{"location":"architecture/contracts/#erc721_1","text":"contract NFT721Upgradeable erc721","title":"erc721"},{"location":"architecture/contracts/#royaltiescheckers","text":"mapping ( address => bool ) royaltiesCheckers","title":"royaltiesCheckers"},{"location":"architecture/contracts/#initialize_34","text":"function initialize ( address _owner , address _erc1155 , address _erc721 ) public DIDRegistry Initializer Initialize Ownable. Only on contract creation. Name Type Description _owner address refers to the owner of the contract. _erc1155 address _erc721 address","title":"initialize"},{"location":"architecture/contracts/#registerroyaltieschecker","text":"function registerRoyaltiesChecker ( address _addr ) public","title":"registerRoyaltiesChecker"},{"location":"architecture/contracts/#didroyaltiesadded","text":"event DIDRoyaltiesAdded ( bytes32 did , address addr )","title":"DIDRoyaltiesAdded"},{"location":"architecture/contracts/#didroyaltyrecipientchanged","text":"event DIDRoyaltyRecipientChanged ( bytes32 did , address addr )","title":"DIDRoyaltyRecipientChanged"},{"location":"architecture/contracts/#setdidroyalties","text":"function setDIDRoyalties ( bytes32 _did , address _royalties ) public","title":"setDIDRoyalties"},{"location":"architecture/contracts/#setdidroyaltyrecipient","text":"function setDIDRoyaltyRecipient ( bytes32 _did , address _recipient ) public","title":"setDIDRoyaltyRecipient"},{"location":"architecture/contracts/#registermintabledid","text":"function registerMintableDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , uint256 _cap , uint8 _royalties , bool _mint , bytes32 _activityId , string _nftMetadata ) public Register a Mintable DID using NFTs based in the ERC-1155 standard. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if true it mints the ERC-1155 NFTs attached to the asset _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata","title":"registerMintableDID"},{"location":"architecture/contracts/#registermintabledid721","text":"function registerMintableDID721 ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , uint8 _royalties , bool _mint , bytes32 _activityId , string _nftMetadata ) public Register a Mintable DID using NFTs based in the ERC-721 standard. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if true it mints the ERC-1155 NFTs attached to the asset _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata","title":"registerMintableDID721"},{"location":"architecture/contracts/#registermintabledid_1","text":"function registerMintableDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , uint256 _cap , uint8 _royalties , bytes32 _activityId , string _nftMetadata ) public Register a Mintable DID. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata","title":"registerMintableDID"},{"location":"architecture/contracts/#enableandmintdidnft","text":"function enableAndMintDidNft ( bytes32 _did , uint256 _cap , uint8 _royalties , bool _mint , string _nftMetadata ) public returns ( bool success ) enableDidNft creates the initial setup of NFTs minting and royalties distribution for ERC-1155 NFTs. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if is true mint directly the amount capped tokens and lock in the _lockAddress _nftMetadata string refers to the url providing the NFT Metadata","title":"enableAndMintDidNft"},{"location":"architecture/contracts/#enableandmintdidnft721","text":"function enableAndMintDidNft721 ( bytes32 _did , uint8 _royalties , bool _mint , string _nftMetadata ) public returns ( bool success ) enableAndMintDidNft721 creates the initial setup of NFTs minting and royalties distribution for ERC-721 NFTs. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if is true mint directly the amount capped tokens and lock in the _lockAddress _nftMetadata string refers to the url providing the NFT Metadata","title":"enableAndMintDidNft721"},{"location":"architecture/contracts/#mint_3","text":"function mint ( bytes32 _did , uint256 _amount , address _receiver ) public Mints a NFT associated to the DID Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both Only the DID owner can mint NFTs associated to the DID Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to mint _receiver address the address that will receive the new nfts minted","title":"mint"},{"location":"architecture/contracts/#mint_4","text":"function mint ( bytes32 _did , uint256 _amount ) public","title":"mint"},{"location":"architecture/contracts/#mint721","text":"function mint721 ( bytes32 _did , address _receiver ) public Mints a ERC-721 NFT associated to the DID Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _receiver address the address that will receive the new nfts minted","title":"mint721"},{"location":"architecture/contracts/#mint721_1","text":"function mint721 ( bytes32 _did ) public","title":"mint721"},{"location":"architecture/contracts/#burn_2","text":"function burn ( bytes32 _did , uint256 _amount ) public Burns NFTs associated to the DID Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both Only the DID owner can burn NFTs associated to the DID Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to burn","title":"burn"},{"location":"architecture/contracts/#burn721","text":"function burn721 ( bytes32 _did ) public","title":"burn721"},{"location":"architecture/contracts/#didregistrylibrary","text":"All function calls are currently implemented without side effects","title":"DIDRegistryLibrary"},{"location":"architecture/contracts/#didregister","text":"struct DIDRegister { address owner ; uint8 royalties ; bool nftInitialized ; bool nft721Initialized ; address creator ; bytes32 lastChecksum ; string url ; address lastUpdatedBy ; uint256 blockNumberUpdated ; address [] providers ; address [] delegates ; uint256 nftSupply ; uint256 mintCap ; address royaltyRecipient ; contract IRoyaltyScheme royaltyScheme ; }","title":"DIDRegister"},{"location":"architecture/contracts/#didregisterlist_1","text":"struct DIDRegisterList { mapping ( bytes32 &# x3D ; & gt ; struct DIDRegistryLibrary . DIDRegister ) didRegisters ; bytes32 [] didRegisterIds ; }","title":"DIDRegisterList"},{"location":"architecture/contracts/#update_2","text":"function update ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , bytes32 _checksum , string _url ) external update the DID store access modifiers and storage pointer should be implemented in DIDRegistry Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _checksum bytes32 includes a one-way HASH calculated using the DDO content _url string includes the url resolving to the DID Document (DDO)","title":"update"},{"location":"architecture/contracts/#initializenftconfig","text":"function initializeNftConfig ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint256 _cap , uint8 _royalties ) internal initializeNftConfig creates the initial setup of NFTs minting and royalties distribution. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market The royalties in secondary market for the creator should be between 0% >= x < 100%","title":"initializeNftConfig"},{"location":"architecture/contracts/#initializenft721config","text":"function initializeNft721Config ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint8 _royalties ) internal","title":"initializeNft721Config"},{"location":"architecture/contracts/#areroyaltiesvalid_1","text":"function areRoyaltiesValid ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _tokenAddress ) internal view returns ( bool ) areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards _tokenAddress address Name Type Description [0] bool true if the rewards distribution respect the original creator royalties","title":"areRoyaltiesValid"},{"location":"architecture/contracts/#addprovider","text":"function addProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address provider ) internal addProvider add provider to DID registry update the DID registry providers list by adding a new provider Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) provider address the provider's address","title":"addProvider"},{"location":"architecture/contracts/#removeprovider","text":"function removeProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _provider ) internal returns ( bool ) removeProvider remove provider from DID registry update the DID registry providers list by removing an existing provider Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address","title":"removeProvider"},{"location":"architecture/contracts/#updatedidowner","text":"function updateDIDOwner ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _newOwner ) internal updateDIDOwner transfer DID ownership to a new owner Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _newOwner address the new DID owner address","title":"updateDIDOwner"},{"location":"architecture/contracts/#isprovider","text":"function isProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _provider ) public view returns ( bool ) isProvider check whether DID provider exists Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address Name Type Description [0] bool true if the provider already exists","title":"isProvider"},{"location":"architecture/contracts/#getproviderindex","text":"function getProviderIndex ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address provider ) private view returns ( int256 ) getProviderIndex get the index of a provider Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) provider address the provider's address Name Type Description [0] int256 the index if the provider exists otherwise return -1","title":"getProviderIndex"},{"location":"architecture/contracts/#adddelegate","text":"function addDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address delegate ) internal addDelegate add delegate to DID registry update the DID registry delegates list by adding a new delegate Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) delegate address the delegate's address","title":"addDelegate"},{"location":"architecture/contracts/#removedelegate","text":"function removeDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _delegate ) internal returns ( bool ) removeDelegate remove delegate from DID registry update the DID registry delegates list by removing an existing delegate Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address","title":"removeDelegate"},{"location":"architecture/contracts/#isdelegate","text":"function isDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _delegate ) public view returns ( bool ) isDelegate check whether DID delegate exists Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address Name Type Description [0] bool true if the delegate already exists","title":"isDelegate"},{"location":"architecture/contracts/#getdelegateindex","text":"function getDelegateIndex ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address delegate ) private view returns ( int256 ) getDelegateIndex get the index of a delegate Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) delegate address the delegate's address Name Type Description [0] int256 the index if the delegate exists otherwise return -1","title":"getDelegateIndex"},{"location":"architecture/contracts/#provenanceregistry","text":"All function calls are currently implemented without side effects","title":"ProvenanceRegistry"},{"location":"architecture/contracts/#__provenanceregistry_init","text":"function __ProvenanceRegistry_init () internal","title":"__ProvenanceRegistry_init"},{"location":"architecture/contracts/#__provenanceregistry_init_unchained","text":"function __ProvenanceRegistry_init_unchained () internal","title":"__ProvenanceRegistry_init_unchained"},{"location":"architecture/contracts/#provenance","text":"struct Provenance { bytes32 did ; bytes32 relatedDid ; address agentId ; bytes32 activityId ; address agentInvolvedId ; uint8 method ; address createdBy ; uint256 blockNumberUpdated ; bytes signature ; }","title":"Provenance"},{"location":"architecture/contracts/#provenanceregistrylist","text":"struct ProvenanceRegistryList { mapping ( bytes32 &# x3D ; & gt ; struct ProvenanceRegistry . Provenance ) list ; }","title":"ProvenanceRegistryList"},{"location":"architecture/contracts/#provenanceregistry_1","text":"struct ProvenanceRegistry . ProvenanceRegistryList provenanceRegistry","title":"provenanceRegistry"},{"location":"architecture/contracts/#provenancemethod","text":"enum ProvenanceMethod { ENTITY , ACTIVITY , WAS_GENERATED_BY , USED , WAS_INFORMED_BY , WAS_STARTED_BY , WAS_ENDED_BY , WAS_INVALIDATED_BY , WAS_DERIVED_FROM , AGENT , WAS_ATTRIBUTED_TO , WAS_ASSOCIATED_WITH , ACTED_ON_BEHALF }","title":"ProvenanceMethod"},{"location":"architecture/contracts/#provenanceattributeregistered","text":"event ProvenanceAttributeRegistered ( bytes32 provId , bytes32 _did , address _agentId , bytes32 _activityId , bytes32 _relatedDid , address _agentInvolvedId , enum ProvenanceRegistry . ProvenanceMethod _method , string _attributes , uint256 _blockNumberUpdated ) Provenance Events","title":"ProvenanceAttributeRegistered"},{"location":"architecture/contracts/#wasgeneratedby_1","text":"event WasGeneratedBy ( bytes32 _did , address _agentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated )","title":"WasGeneratedBy"},{"location":"architecture/contracts/#used_1","text":"event Used ( bytes32 _did , address _agentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated )","title":"Used"},{"location":"architecture/contracts/#wasderivedfrom_1","text":"event WasDerivedFrom ( bytes32 _newEntityDid , bytes32 _usedEntityDid , address _agentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated )","title":"WasDerivedFrom"},{"location":"architecture/contracts/#wasassociatedwith_1","text":"event WasAssociatedWith ( bytes32 _entityDid , address _agentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated )","title":"WasAssociatedWith"},{"location":"architecture/contracts/#actedonbehalf_1","text":"event ActedOnBehalf ( bytes32 _entityDid , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated )","title":"ActedOnBehalf"},{"location":"architecture/contracts/#createprovenanceentry","text":"function createProvenanceEntry ( bytes32 _provId , bytes32 _did , bytes32 _relatedDid , address _agentId , bytes32 _activityId , address _agentInvolvedId , enum ProvenanceRegistry . ProvenanceMethod _method , address _createdBy , bytes _signatureDelegate , string _attributes ) internal returns ( bool ) create an event in the Provenance store access modifiers and storage pointer should be implemented in ProvenanceRegistry Name Type Description _provId bytes32 refers to provenance event identifier _did bytes32 refers to decentralized identifier (a byte32 length ID) _relatedDid bytes32 refers to decentralized identifier (a byte32 length ID) of a related entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _agentInvolvedId address refers to address of the agent involved with the provenance record _method enum ProvenanceRegistry.ProvenanceMethod refers to the W3C Provenance method _createdBy address refers to address of the agent triggering the activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string","title":"createProvenanceEntry"},{"location":"architecture/contracts/#_wasgeneratedby","text":"function _wasGeneratedBy ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal virtual returns ( bool ) Implements the W3C PROV Generation action Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description [0] bool the number of the new provenance size","title":"_wasGeneratedBy"},{"location":"architecture/contracts/#_used","text":"function _used ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , bytes _signatureUsing , string _attributes ) internal virtual returns ( bool success ) Implements the W3C PROV Usage action Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _signatureUsing bytes refers to the digital signature provided by the agent using the _did _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered","title":"_used"},{"location":"architecture/contracts/#_wasderivedfrom","text":"function _wasDerivedFrom ( bytes32 _provId , bytes32 _newEntityDid , bytes32 _usedEntityDid , address _agentId , bytes32 _activityId , string _attributes ) internal virtual returns ( bool success ) Implements the W3C PROV Derivation action Name Type Description _provId bytes32 unique identifier referring to the provenance entry _newEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _usedEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity used to derive the new did _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered","title":"_wasDerivedFrom"},{"location":"architecture/contracts/#_wasassociatedwith","text":"function _wasAssociatedWith ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal virtual returns ( bool success ) Implements the W3C PROV Association action Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered","title":"_wasAssociatedWith"},{"location":"architecture/contracts/#_actedonbehalf","text":"function _actedOnBehalf ( bytes32 _provId , bytes32 _did , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes _signatureDelegate , string _attributes ) internal virtual returns ( bool success ) Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId & _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId) Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered","title":"_actedOnBehalf"},{"location":"architecture/contracts/#curveroyalties","text":"","title":"CurveRoyalties"},{"location":"architecture/contracts/#registry","text":"contract DIDRegistry registry","title":"registry"},{"location":"architecture/contracts/#denominator","text":"uint256 DENOMINATOR","title":"DENOMINATOR"},{"location":"architecture/contracts/#royalties","text":"mapping ( bytes32 => uint256 ) royalties","title":"royalties"},{"location":"architecture/contracts/#initialize_35","text":"function initialize ( address _registry ) public","title":"initialize"},{"location":"architecture/contracts/#royaltycurve","text":"function royaltyCurve ( uint256 num , uint256 max , uint256 rate ) public pure virtual returns ( uint256 )","title":"royaltyCurve"},{"location":"architecture/contracts/#setroyalty","text":"function setRoyalty ( bytes32 _did , uint256 _royalty ) public Set royalties for a DID Can only be called by creator of the DID Name Type Description _did bytes32 DID for which the royalties are set _royalty uint256 Royalty, the actual royalty will be _royalty / 10000 percent","title":"setRoyalty"},{"location":"architecture/contracts/#check_1","text":"function check ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _token ) external view returns ( bool )","title":"check"},{"location":"architecture/contracts/#rewardsdistributor","text":"","title":"RewardsDistributor"},{"location":"architecture/contracts/#used_2","text":"mapping ( bytes32 => bool ) used","title":"used"},{"location":"architecture/contracts/#receivers","text":"mapping ( bytes32 => address []) receivers","title":"receivers"},{"location":"architecture/contracts/#registry_1","text":"contract DIDRegistry registry","title":"registry"},{"location":"architecture/contracts/#conditionstoremanager_3","text":"contract ConditionStoreManager conditionStoreManager","title":"conditionStoreManager"},{"location":"architecture/contracts/#escrow","text":"address escrow","title":"escrow"},{"location":"architecture/contracts/#initialize_36","text":"function initialize ( address _registry , address _conditionStoreManager , address _escrow ) public","title":"initialize"},{"location":"architecture/contracts/#setreceivers","text":"function setReceivers ( bytes32 _did , address [] _addr ) public set receivers for did Name Type Description _did bytes32 DID _addr address[] list of receivers","title":"setReceivers"},{"location":"architecture/contracts/#claimreward","text":"function claimReward ( bytes32 _agreementId , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public distribute rewards associated with an escrow condition as paramemeters, it just gets the same parameters as fulfill for escrow condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier","title":"claimReward"},{"location":"architecture/contracts/#standardroyalties","text":"","title":"StandardRoyalties"},{"location":"architecture/contracts/#registry_2","text":"contract DIDRegistry registry","title":"registry"},{"location":"architecture/contracts/#denominator_1","text":"uint256 DENOMINATOR","title":"DENOMINATOR"},{"location":"architecture/contracts/#royalties_1","text":"mapping ( bytes32 => uint256 ) royalties","title":"royalties"},{"location":"architecture/contracts/#initialize_37","text":"function initialize ( address _registry ) public","title":"initialize"},{"location":"architecture/contracts/#setroyalty_1","text":"function setRoyalty ( bytes32 _did , uint256 _royalty ) public Set royalties for a DID Can only be called by creator of the DID Name Type Description _did bytes32 DID for which the royalties are set _royalty uint256 Royalty, the actual royalty will be _royalty / 10000 percent","title":"setRoyalty"},{"location":"architecture/contracts/#check_2","text":"function check ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address ) external view returns ( bool )","title":"check"},{"location":"architecture/contracts/#aavecredittemplate","text":"Implementation of the Aaven Credit Agreement Template 0. Initialize the agreement 1. LockNFT - Delegatee locks the NFT 2. AaveCollateralDeposit - Delegator deposits the collateral into Aave. And approves the delegation flow 3. AaveBorrowCondition - The Delegatee claim the credit amount from Aave 4. AaveRepayCondition. Options: 4.a Fulfilled state - The Delegatee pay back the loan (including fee) into Aave and gets back the NFT 4.b Aborted state - The Delegatee doesn't pay the loan in time so the Delegator gets the NFT. The Delegator pays the loan to Aave 5. TransferNFT. Options: 5.a if AaveRepayCondition was fulfilled, it will allow transfer back to the Delegatee or Borrower 5.b if AaveRepayCondition was aborted, it will allow transfer the NFT to the Delegator or Lender","title":"AaveCreditTemplate"},{"location":"architecture/contracts/#didregistry_8","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#nftlockcondition_1","text":"contract INFTLock nftLockCondition","title":"nftLockCondition"},{"location":"architecture/contracts/#depositcondition","text":"contract AaveCollateralDepositCondition depositCondition","title":"depositCondition"},{"location":"architecture/contracts/#borrowcondition","text":"contract AaveBorrowCondition borrowCondition","title":"borrowCondition"},{"location":"architecture/contracts/#repaycondition","text":"contract AaveRepayCondition repayCondition","title":"repayCondition"},{"location":"architecture/contracts/#transfercondition","text":"contract DistributeNFTCollateralCondition transferCondition","title":"transferCondition"},{"location":"architecture/contracts/#withdrawcondition","text":"contract AaveCollateralWithdrawCondition withdrawCondition","title":"withdrawCondition"},{"location":"architecture/contracts/#vaultaddress","text":"mapping ( bytes32 => address ) vaultAddress","title":"vaultAddress"},{"location":"architecture/contracts/#nvmfee_1","text":"uint256 nvmFee","title":"nvmFee"},{"location":"architecture/contracts/#vaultlibrary","text":"address vaultLibrary","title":"vaultLibrary"},{"location":"architecture/contracts/#vaultcreated","text":"event VaultCreated ( address _vaultAddress , address _creator , address _lender , address _borrower )","title":"VaultCreated"},{"location":"architecture/contracts/#initialize_38","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _nftLockConditionAddress , address _depositConditionAddress , address _borrowConditionAddress , address _repayConditionAddress , address _withdrawCollateralAddress , address _transferConditionAddress , address _vaultLibrary ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftLockConditionAddress address NFT Lock Condition contract address _depositConditionAddress address Aave collateral deposit Condition address _borrowConditionAddress address Aave borrow deposit Condition address _repayConditionAddress address Aave repay credit Condition address _withdrawCollateralAddress address _transferConditionAddress address NFT Transfer Condition address _vaultLibrary address","title":"initialize"},{"location":"architecture/contracts/#createvaultagreement","text":"function createVaultAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _vaultAddress ) public","title":"createVaultAgreement"},{"location":"architecture/contracts/#createagreement_1","text":"function createAgreement ( bytes32 _id , address _lendingPool , address _dataProvider , address _weth , uint256 _agreementFee , address _treasuryAddress , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _lender ) public","title":"createAgreement"},{"location":"architecture/contracts/#deployvault","text":"function deployVault ( address _lendingPool , address _dataProvider , address _weth , uint256 _agreementFee , address _treasuryAddress , address _borrower , address _lender ) public returns ( address )","title":"deployVault"},{"location":"architecture/contracts/#getvaultforagreement","text":"function getVaultForAgreement ( bytes32 _agreementId ) public view returns ( address )","title":"getVaultForAgreement"},{"location":"architecture/contracts/#updatenvmfee","text":"function updateNVMFee ( uint256 _newFee ) public Updates the nevermined fee for this type of agreement Name Type Description _newFee uint256 New nevermined fee expressed in basis points","title":"updateNVMFee"},{"location":"architecture/contracts/#changecreditvaultlibrary","text":"function changeCreditVaultLibrary ( address _vaultLibrary ) public","title":"changeCreditVaultLibrary"},{"location":"architecture/contracts/#accessprooftemplate","text":"Implementation of Access Agreement Template","title":"AccessProofTemplate"},{"location":"architecture/contracts/#didregistry_9","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#accesscondition_1","text":"contract AccessProofCondition accessCondition","title":"accessCondition"},{"location":"architecture/contracts/#lockcondition","text":"contract LockPaymentCondition lockCondition","title":"lockCondition"},{"location":"architecture/contracts/#escrowreward","text":"contract EscrowPaymentCondition escrowReward","title":"escrowReward"},{"location":"architecture/contracts/#initialize_39","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _accessConditionAddress , address _lockConditionAddress , address payable _escrowConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address","title":"initialize"},{"location":"architecture/contracts/#accesstemplate","text":"_Implementation of Access Agreement Template Access template is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an on-chain SEA. The template is a composite of three basic conditions. Once the agreement is created, the consumer will lock an amount of tokens (as listed in the DID document - off-chain metadata) to the the lock reward contract which in turn will fire an event. ON the other hand the provider is listening to all the emitted events, the provider will catch the event and grant permissions to the consumer through secret store contract, the consumer now is able to download the data set by asking the off-chain component of secret store to decrypt the DID and encrypt it using the consumer's public key. Then the secret store will provide an on-chain proof that the consumer had access to the data set. Finally, the provider can call the escrow reward condition in order to release the payment. Every condition has a time window (time lock and time out). This implies that if the provider didn't grant the access to the consumer through secret store within this time window, the consumer can ask for refund._","title":"AccessTemplate"},{"location":"architecture/contracts/#didregistry_10","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#accesscondition_2","text":"contract AccessCondition accessCondition","title":"accessCondition"},{"location":"architecture/contracts/#lockcondition_1","text":"contract LockPaymentCondition lockCondition","title":"lockCondition"},{"location":"architecture/contracts/#escrowreward_1","text":"contract EscrowPaymentCondition escrowReward","title":"escrowReward"},{"location":"architecture/contracts/#initialize_40","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _accessConditionAddress , address _lockConditionAddress , address payable _escrowConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address","title":"initialize"},{"location":"architecture/contracts/#agreementtemplate","text":"_Implementation of Agreement Template Agreement template is a reference template where it has the ability to create agreements from whitelisted template_","title":"AgreementTemplate"},{"location":"architecture/contracts/#conditiontypes","text":"address [] conditionTypes","title":"conditionTypes"},{"location":"architecture/contracts/#agreementstoremanager_4","text":"contract AgreementStoreManager agreementStoreManager","title":"agreementStoreManager"},{"location":"architecture/contracts/#createagreement_2","text":"function createAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts ) public createAgreement create new agreement Name Type Description _id bytes32 agreement unique identifier _did bytes32 refers to decentralized identifier (a bytes32 length ID). _conditionIds bytes32[] list of condition identifiers _timeLocks uint256[] list of time locks, each time lock will be assigned to the same condition that has the same index _timeOuts uint256[] list of time outs, each time out will be assigned to the same condition that has the same index","title":"createAgreement"},{"location":"architecture/contracts/#createagreementandpay_1","text":"function createAgreementAndPay ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , uint256 _idx , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public payable","title":"createAgreementAndPay"},{"location":"architecture/contracts/#createagreementandfulfill_1","text":"function createAgreementAndFulfill ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , uint256 [] _indices , address [] _accounts , bytes [] _params ) internal","title":"createAgreementAndFulfill"},{"location":"architecture/contracts/#getconditiontypes_1","text":"function getConditionTypes () public view returns ( address []) getConditionTypes gets the conditions addresses list for the current template returns list of condition contracts addresses Name Type Description [0] address[] list of conditions contract addresses","title":"getConditionTypes"},{"location":"architecture/contracts/#baseescrowtemplate","text":"","title":"BaseEscrowTemplate"},{"location":"architecture/contracts/#agreementdata","text":"struct BaseEscrowTemplate . AgreementData agreementData","title":"agreementData"},{"location":"architecture/contracts/#agreementcreated","text":"event AgreementCreated ( bytes32 _agreementId , bytes32 _did , address _accessConsumer , address _accessProvider , uint256 [] _timeLocks , uint256 [] _timeOuts , bytes32 [] _conditionIdSeeds , bytes32 [] _conditionIds , bytes32 _idSeed , address _creator )","title":"AgreementCreated"},{"location":"architecture/contracts/#agreementdatamodel","text":"struct AgreementDataModel { address accessConsumer ; address accessProvider ; bytes32 did ; }","title":"AgreementDataModel"},{"location":"architecture/contracts/#agreementdata_1","text":"struct AgreementData { mapping ( bytes32 &# x3D ; & gt ; struct BaseEscrowTemplate . AgreementDataModel ) agreementDataItems ; bytes32 [] agreementIds ; }","title":"AgreementData"},{"location":"architecture/contracts/#createagreement_3","text":"function createAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer ) public createAgreement creates agreements through agreement template this function initializes the agreement by setting the DID, conditions ID, timeouts, time locks and the consumer address. The DID provider/owner is automatically detected by the DID Registry Name Type Description _id bytes32 SEA agreement unique identifier _did bytes32 Decentralized Identifier (DID) _conditionIds bytes32[] conditions ID associated with the condition types _timeLocks uint256[] the starting point of the time window ,time lock is in block number not seconds _timeOuts uint256[] the ending point of the time window ,time lock is in block number not seconds _accessConsumer address consumer address","title":"createAgreement"},{"location":"architecture/contracts/#createagreementandpayescrow","text":"function createAgreementAndPayEscrow ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer , uint256 _idx , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public payable","title":"createAgreementAndPayEscrow"},{"location":"architecture/contracts/#createagreementandfulfill_2","text":"function createAgreementAndFulfill ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer , uint256 [] _indices , address [] _accounts , bytes [] _params ) internal","title":"createAgreementAndFulfill"},{"location":"architecture/contracts/#_makeids","text":"function _makeIds ( bytes32 _idSeed , bytes32 [] _conditionIds ) internal view returns ( bytes32 [])","title":"_makeIds"},{"location":"architecture/contracts/#_initagreement","text":"function _initAgreement ( bytes32 _idSeed , bytes32 _did , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer , bytes32 [] _conditionIds ) internal","title":"_initAgreement"},{"location":"architecture/contracts/#getagreementdata","text":"function getAgreementData ( bytes32 _id ) external view returns ( address accessConsumer , address accessProvider ) getAgreementData return the agreement Data Name Type Description _id bytes32 SEA agreement unique identifier Name Type Description accessConsumer address the agreement consumer accessProvider address the provider addresses","title":"getAgreementData"},{"location":"architecture/contracts/#didsalestemplate","text":"_Implementation of DID Sales Template The DID Sales template supports an scenario where an Asset owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing an Asset owner to get transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer DID Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the ownership transfer of an asset from the current owner for a specific DID._","title":"DIDSalesTemplate"},{"location":"architecture/contracts/#didregistry_11","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#lockpaymentcondition_1","text":"contract LockPaymentCondition lockPaymentCondition","title":"lockPaymentCondition"},{"location":"architecture/contracts/#transfercondition_1","text":"contract TransferDIDOwnershipCondition transferCondition","title":"transferCondition"},{"location":"architecture/contracts/#rewardcondition","text":"contract EscrowPaymentCondition rewardCondition","title":"rewardCondition"},{"location":"architecture/contracts/#id","text":"function id () public pure returns ( uint256 )","title":"id"},{"location":"architecture/contracts/#initialize_41","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockConditionAddress address lock reward condition contract address _transferConditionAddress address transfer ownership condition contract address _escrowPaymentAddress address payable escrow reward condition contract address","title":"initialize"},{"location":"architecture/contracts/#dynamicaccesstemplate","text":"Implementation of Agreement Template This is a dynamic template that allows to setup flexible conditions depending on the use case.","title":"DynamicAccessTemplate"},{"location":"architecture/contracts/#didregistry_12","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#templateconfig","text":"struct DynamicAccessTemplate . TemplateConditions templateConfig","title":"templateConfig"},{"location":"architecture/contracts/#templateconditions","text":"struct TemplateConditions { mapping ( address &# x3D ; & gt ; contract Condition ) templateConditions ; }","title":"TemplateConditions"},{"location":"architecture/contracts/#initialize_42","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address","title":"initialize"},{"location":"architecture/contracts/#addtemplatecondition","text":"function addTemplateCondition ( address _conditionAddress ) external returns ( uint256 length ) addTemplateCondition adds a new condition to the template Name Type Description _conditionAddress address condition contract address Name Type Description length uint256 conditionTypes array size","title":"addTemplateCondition"},{"location":"architecture/contracts/#removelasttemplatecondition","text":"function removeLastTemplateCondition () external returns ( address []) removeLastTemplateCondition removes last condition added to the template Name Type Description [0] address[] conditionTypes existing in the array","title":"removeLastTemplateCondition"},{"location":"architecture/contracts/#escrowcomputeexecutiontemplate","text":"_Implementation of a Compute Execution Agreement Template EscrowComputeExecutionTemplate is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an on-chain SEA. The template is a composite of three basic conditions. Once the agreement is created, the consumer will lock an amount of tokens (as listed in the DID document - off-chain metadata) to the the lock reward contract which in turn will fire an event. ON the other hand the provider is listening to all the emitted events, the provider will catch the event and grant permissions to trigger a computation granting the execution via the ComputeExecutionCondition contract. The consumer now is able to trigger that computation by asking the off-chain gateway to start the execution of a compute workflow. Finally, the provider can call the escrow reward condition in order to release the payment. Every condition has a time window (time lock and time out). This implies that if the provider didn't grant the execution to the consumer within this time window, the consumer can ask for refund._","title":"EscrowComputeExecutionTemplate"},{"location":"architecture/contracts/#didregistry_13","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#computeexecutioncondition_1","text":"contract ComputeExecutionCondition computeExecutionCondition","title":"computeExecutionCondition"},{"location":"architecture/contracts/#lockpaymentcondition_2","text":"contract LockPaymentCondition lockPaymentCondition","title":"lockPaymentCondition"},{"location":"architecture/contracts/#escrowpayment","text":"contract EscrowPaymentCondition escrowPayment","title":"escrowPayment"},{"location":"architecture/contracts/#initialize_43","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _computeExecutionConditionAddress , address _lockPaymentConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including service executor condition, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _computeExecutionConditionAddress address service executor condition contract address _lockPaymentConditionAddress address lock reward condition contract address _escrowPaymentAddress address payable escrow reward contract address","title":"initialize"},{"location":"architecture/contracts/#name","text":"function name () public pure returns ( string )","title":"name"},{"location":"architecture/contracts/#nft721accessprooftemplate","text":"Implementation of NFT721 Access Proof Template","title":"NFT721AccessProofTemplate"},{"location":"architecture/contracts/#nft721accessswaptemplate","text":"","title":"NFT721AccessSwapTemplate"},{"location":"architecture/contracts/#nft721accesstemplate","text":"Implementation of NFT Access Template","title":"NFT721AccessTemplate"},{"location":"architecture/contracts/#nft721salestemplate","text":"Implementation of NFT Sales Template","title":"NFT721SalesTemplate"},{"location":"architecture/contracts/#nft721saleswithaccesstemplate","text":"","title":"NFT721SalesWithAccessTemplate"},{"location":"architecture/contracts/#nftaccessprooftemplate","text":"_Implementation of NFT Access Template The NFT Access template is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing NFT holders to get access to Nevermined services. The template is a composite of 2 basic conditions: - NFT Holding Condition - Access Condition Once the agreement is created, the consumer can demonstrate is holding a NFT for a specific DID. If that's the case the Access condition can be fulfilled by the asset owner or provider and all the agreement is fulfilled. This can be used in scenarios where a data or services owner, can allow users to get access to exclusive services only when they demonstrate the are holding a specific number of NFTs of a DID. This is very useful in use cases like arts._","title":"NFTAccessProofTemplate"},{"location":"architecture/contracts/#didregistry_14","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#nftholdercondition_1","text":"contract INFTHolder nftHolderCondition","title":"nftHolderCondition"},{"location":"architecture/contracts/#accesscondition_3","text":"contract AccessProofCondition accessCondition","title":"accessCondition"},{"location":"architecture/contracts/#initialize_44","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _nftHolderConditionAddress , address _accessConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftHolderConditionAddress address lock reward condition contract address _accessConditionAddress address access condition contract address","title":"initialize"},{"location":"architecture/contracts/#nftaccessswaptemplate","text":"_Implementation of NFT Sales Template The NFT Sales template supports an scenario where a NFT owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing a NFT owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer NFT Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the transfer of the NFT from the current owner for a specific DID._","title":"NFTAccessSwapTemplate"},{"location":"architecture/contracts/#didregistry_15","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#lockpaymentcondition_3","text":"contract INFTLock lockPaymentCondition","title":"lockPaymentCondition"},{"location":"architecture/contracts/#rewardcondition_1","text":"contract INFTEscrow rewardCondition","title":"rewardCondition"},{"location":"architecture/contracts/#accesscondition_4","text":"contract AccessProofCondition accessCondition","title":"accessCondition"},{"location":"architecture/contracts/#id_1","text":"function id () public pure returns ( uint256 )","title":"id"},{"location":"architecture/contracts/#initialize_45","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockPaymentConditionAddress , address payable _escrowPaymentAddress , address _accessCondition ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _escrowPaymentAddress address payable escrow reward condition contract address _accessCondition address","title":"initialize"},{"location":"architecture/contracts/#nftaccesstemplate","text":"_Implementation of NFT Access Template The NFT Access template is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing NFT holders to get access to Nevermined services. The template is a composite of 2 basic conditions: - NFT Holding Condition - Access Condition Once the agreement is created, the consumer can demonstrate is holding a NFT for a specific DID. If that's the case the Access condition can be fulfilled by the asset owner or provider and all the agreement is fulfilled. This can be used in scenarios where a data or services owner, can allow users to get access to exclusive services only when they demonstrate the are holding a specific number of NFTs of a DID. This is very useful in use cases like arts._","title":"NFTAccessTemplate"},{"location":"architecture/contracts/#didregistry_16","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#nftholdercondition_2","text":"contract INFTHolder nftHolderCondition","title":"nftHolderCondition"},{"location":"architecture/contracts/#accesscondition_5","text":"contract INFTAccess accessCondition","title":"accessCondition"},{"location":"architecture/contracts/#initialize_46","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _nftHolderConditionAddress , address _accessConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftHolderConditionAddress address lock reward condition contract address _accessConditionAddress address access condition contract address","title":"initialize"},{"location":"architecture/contracts/#nftsalestemplate","text":"_Implementation of NFT Sales Template The NFT Sales template supports an scenario where a NFT owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing a NFT owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer NFT Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the transfer of the NFT from the current owner for a specific DID._","title":"NFTSalesTemplate"},{"location":"architecture/contracts/#didregistry_17","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#lockpaymentcondition_4","text":"contract LockPaymentCondition lockPaymentCondition","title":"lockPaymentCondition"},{"location":"architecture/contracts/#transfercondition_2","text":"contract ITransferNFT transferCondition","title":"transferCondition"},{"location":"architecture/contracts/#rewardcondition_2","text":"contract EscrowPaymentCondition rewardCondition","title":"rewardCondition"},{"location":"architecture/contracts/#id_2","text":"function id () public pure returns ( uint256 )","title":"id"},{"location":"architecture/contracts/#initialize_47","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockPaymentConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _transferConditionAddress address transfer NFT condition contract address _escrowPaymentAddress address payable escrow reward condition contract address","title":"initialize"},{"location":"architecture/contracts/#nftprice","text":"mapping ( address => mapping ( address => mapping ( address => mapping ( bytes32 => uint256 )))) nftPrice","title":"nftPrice"},{"location":"architecture/contracts/#nftsale","text":"function nftSale ( address nftAddress , bytes32 nftId , address token , uint256 amount ) external","title":"nftSale"},{"location":"architecture/contracts/#checkparamstransfer","text":"function checkParamsTransfer ( bytes [] _params , bytes32 lockPaymentConditionId , bytes32 _did ) internal view returns ( address )","title":"checkParamsTransfer"},{"location":"architecture/contracts/#checkparamsescrow","text":"function checkParamsEscrow ( bytes [] _params , bytes32 lockPaymentId , bytes32 transferId ) internal pure","title":"checkParamsEscrow"},{"location":"architecture/contracts/#createagreementfulfill","text":"function createAgreementFulfill ( bytes32 _id , bytes32 _did , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer , bytes [] _params ) external payable","title":"createAgreementFulfill"},{"location":"architecture/contracts/#nftsaleswithaccesstemplate","text":"_Implementation of NFT Sales Template The NFT Sales template supports an scenario where a NFT owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing a NFT owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer NFT Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the transfer of the NFT from the current owner for a specific DID._","title":"NFTSalesWithAccessTemplate"},{"location":"architecture/contracts/#didregistry_18","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/#lockpaymentcondition_5","text":"contract LockPaymentCondition lockPaymentCondition","title":"lockPaymentCondition"},{"location":"architecture/contracts/#transfercondition_3","text":"contract ITransferNFT transferCondition","title":"transferCondition"},{"location":"architecture/contracts/#rewardcondition_3","text":"contract EscrowPaymentCondition rewardCondition","title":"rewardCondition"},{"location":"architecture/contracts/#accesscondition_6","text":"contract AccessProofCondition accessCondition","title":"accessCondition"},{"location":"architecture/contracts/#initialize_48","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockPaymentConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress , address _accessCondition ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _transferConditionAddress address transfer NFT condition contract address _escrowPaymentAddress address payable escrow reward condition contract address _accessCondition address","title":"initialize"},{"location":"architecture/contracts/#templatestorelibrary","text":"_Implementation of the Template Store Library. Templates are blueprints for modular SEAs. When creating an Agreement, a templateId defines the condition and reward types that are instantiated in the ConditionStore._","title":"TemplateStoreLibrary"},{"location":"architecture/contracts/#templatestate","text":"enum TemplateState { Uninitialized , Proposed , Approved , Revoked }","title":"TemplateState"},{"location":"architecture/contracts/#template_1","text":"struct Template { enum TemplateStoreLibrary . TemplateState state ; address owner ; address lastUpdatedBy ; uint256 blockNumberUpdated ; }","title":"Template"},{"location":"architecture/contracts/#templatelist","text":"struct TemplateList { mapping ( address &# x3D ; & gt ; struct TemplateStoreLibrary . Template ) templates ; address [] templateIds ; }","title":"TemplateList"},{"location":"architecture/contracts/#propose","text":"function propose ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal returns ( uint256 size ) propose new template Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address Name Type Description size uint256 which is the index of the proposed template","title":"propose"},{"location":"architecture/contracts/#approve_1","text":"function approve ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal approve new template Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address","title":"approve"},{"location":"architecture/contracts/#revoke","text":"function revoke ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal revoke new template Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address approved template contract address","title":"revoke"},{"location":"architecture/contracts/#templatestoremanager_1","text":"Implementation of the Template Store Manager. Templates are blueprints for modular SEAs. When creating an Agreement, a templateId defines the condition and reward types that are instantiated in the ConditionStore. This contract manages the life cycle of the template ( Propose \u2192 Approve \u2192 Revoke ).","title":"TemplateStoreManager"},{"location":"architecture/contracts/#templatelist_1","text":"struct TemplateStoreLibrary . TemplateList templateList","title":"templateList"},{"location":"architecture/contracts/#onlyownerortemplateowner","text":"modifier onlyOwnerOrTemplateOwner ( address _id )","title":"onlyOwnerOrTemplateOwner"},{"location":"architecture/contracts/#initialize_49","text":"function initialize ( address _owner ) public initialize TemplateStoreManager Initializer Initializes Ownable. Only on contract creation. Name Type Description _owner address refers to the owner of the contract","title":"initialize"},{"location":"architecture/contracts/#proposetemplate","text":"function proposeTemplate ( address _id ) external returns ( uint256 size ) proposeTemplate proposes a new template Name Type Description _id address unique template identifier which is basically the template contract address","title":"proposeTemplate"},{"location":"architecture/contracts/#approvetemplate","text":"function approveTemplate ( address _id ) external approveTemplate approves a template Name Type Description _id address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) can approve this template.","title":"approveTemplate"},{"location":"architecture/contracts/#revoketemplate","text":"function revokeTemplate ( address _id ) external revokeTemplate revoke a template Name Type Description _id address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) or template owner can revoke this template.","title":"revokeTemplate"},{"location":"architecture/contracts/#gettemplate","text":"function getTemplate ( address _id ) external view returns ( enum TemplateStoreLibrary . TemplateState state , address owner , address lastUpdatedBy , uint256 blockNumberUpdated ) getTemplate get more information about a template Name Type Description _id address unique template identifier which is basically the template contract address. Name Type Description state enum TemplateStoreLibrary.TemplateState template status owner address template owner lastUpdatedBy address last updated by blockNumberUpdated uint256 last updated at.","title":"getTemplate"},{"location":"architecture/contracts/#gettemplatelistsize","text":"function getTemplateListSize () external view virtual returns ( uint256 size ) getTemplateListSize number of templates Name Type Description size uint256 number of templates","title":"getTemplateListSize"},{"location":"architecture/contracts/#istemplateapproved","text":"function isTemplateApproved ( address _id ) external view returns ( bool ) isTemplateApproved check whether the template is approved Name Type Description _id address unique template identifier which is basically the template contract address. Name Type Description [0] bool true if the template is approved","title":"isTemplateApproved"},{"location":"architecture/contracts/#agreementstoremanagerchangefunctionsignature","text":"","title":"AgreementStoreManagerChangeFunctionSignature"},{"location":"architecture/contracts/#createagreement_4","text":"function createAgreement ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _creator , address _sender ) public","title":"createAgreement"},{"location":"architecture/contracts/#agreementstoremanagerchangeinstorage","text":"","title":"AgreementStoreManagerChangeInStorage"},{"location":"architecture/contracts/#agreementcount","text":"uint256 agreementCount","title":"agreementCount"},{"location":"architecture/contracts/#agreementstoremanagerchangeinstorageandlogic","text":"","title":"AgreementStoreManagerChangeInStorageAndLogic"},{"location":"architecture/contracts/#agreementstoremanagerextrafunctionality","text":"","title":"AgreementStoreManagerExtraFunctionality"},{"location":"architecture/contracts/#dummyfunction","text":"function dummyFunction () public pure returns ( bool )","title":"dummyFunction"},{"location":"architecture/contracts/#agreementstoremanagerwithbug","text":"","title":"AgreementStoreManagerWithBug"},{"location":"architecture/contracts/#getdidregistryaddress_1","text":"function getDIDRegistryAddress () public pure returns ( address ) getDIDRegistryAddress utility function used by other contracts or any EOA. Name Type Description [0] address the DIDRegistry address","title":"getDIDRegistryAddress"},{"location":"architecture/contracts/#conditionstorechangefunctionsignature","text":"","title":"ConditionStoreChangeFunctionSignature"},{"location":"architecture/contracts/#createcondition_2","text":"function createCondition ( bytes32 _id , address _typeRef , address _sender ) public","title":"createCondition"},{"location":"architecture/contracts/#conditionstorechangeinstorage","text":"","title":"ConditionStoreChangeInStorage"},{"location":"architecture/contracts/#conditioncount","text":"uint256 conditionCount","title":"conditionCount"},{"location":"architecture/contracts/#conditionstorechangeinstorageandlogic","text":"","title":"ConditionStoreChangeInStorageAndLogic"},{"location":"architecture/contracts/#conditionstoreextrafunctionality","text":"","title":"ConditionStoreExtraFunctionality"},{"location":"architecture/contracts/#dummyfunction_1","text":"function dummyFunction () public pure returns ( bool )","title":"dummyFunction"},{"location":"architecture/contracts/#conditionstorewithbug","text":"","title":"ConditionStoreWithBug"},{"location":"architecture/contracts/#getconditionstate_1","text":"function getConditionState ( bytes32 _id ) public view returns ( enum ConditionStoreLibrary . ConditionState ) getConditionState Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"getConditionState"},{"location":"architecture/contracts/#didregistrychangefunctionsignature","text":"","title":"DIDRegistryChangeFunctionSignature"},{"location":"architecture/contracts/#registerattribute_1","text":"function registerAttribute ( bytes32 _didSeed , address [] _providers , bytes32 _checksum , string _url ) public","title":"registerAttribute"},{"location":"architecture/contracts/#didregistrychangeinstorage","text":"","title":"DIDRegistryChangeInStorage"},{"location":"architecture/contracts/#timeofregister","text":"mapping ( bytes32 => uint256 ) timeOfRegister","title":"timeOfRegister"},{"location":"architecture/contracts/#didregistrychangeinstorageandlogic","text":"","title":"DIDRegistryChangeInStorageAndLogic"},{"location":"architecture/contracts/#didregistryextrafunctionality","text":"","title":"DIDRegistryExtraFunctionality"},{"location":"architecture/contracts/#getnumber","text":"function getNumber () public pure returns ( uint256 )","title":"getNumber"},{"location":"architecture/contracts/#didregistrywithbug","text":"","title":"DIDRegistryWithBug"},{"location":"architecture/contracts/#registerattribute_2","text":"function registerAttribute ( bytes32 _checksum , bytes32 _didSeed , address [] _providers , string _url ) public registerAttribute is called only by DID owner. this function registers DID attributes Name Type Description _checksum bytes32 includes a one-way HASH calculated using the DDO content _didSeed bytes32 refers to decentralized identifier (a byte32 length ID) _providers address[] _url string refers to the attribute value","title":"registerAttribute"},{"location":"architecture/contracts/#ipnft","text":"","title":"IPNFT"},{"location":"architecture/contracts/#tokenurichanged","text":"event TokenURIChanged ( uint256 tokenId , string newURI )","title":"TokenURIChanged"},{"location":"architecture/contracts/#initialize_50","text":"function initialize ( string _name , string _symbol ) public","title":"initialize"},{"location":"architecture/contracts/#settokenuri","text":"function setTokenURI ( uint256 tokenId , string _tokenURI ) public","title":"setTokenURI"},{"location":"architecture/contracts/#mint_5","text":"function mint ( address to , uint256 _tokenId , string _tokenURI ) public returns ( bool )","title":"mint"},{"location":"architecture/contracts/#mintwithouttokenuri","text":"function mintWithoutTokenURI ( address to , uint256 _tokenId ) external","title":"mintWithoutTokenURI"},{"location":"architecture/contracts/#transfer_2","text":"function transfer ( address from , address to , uint256 _tokenId ) public","title":"transfer"},{"location":"architecture/contracts/#neverminedconfigchangeinstorage","text":"","title":"NeverminedConfigChangeInStorage"},{"location":"architecture/contracts/#newvariable","text":"uint256 newVariable","title":"newVariable"},{"location":"architecture/contracts/#neverminedconfigchangefunctionsignature","text":"","title":"NeverminedConfigChangeFunctionSignature"},{"location":"architecture/contracts/#setmarketplacefees_2","text":"function setMarketplaceFees ( uint256 _marketplaceFee , address _feeReceiver , uint256 _newParameter ) external virtual","title":"setMarketplaceFees"},{"location":"architecture/contracts/#neverminedconfigchangeinstorageandlogic","text":"","title":"NeverminedConfigChangeInStorageAndLogic"},{"location":"architecture/contracts/#neverminedconfigwithbug","text":"","title":"NeverminedConfigWithBug"},{"location":"architecture/contracts/#setmarketplacefees_3","text":"function setMarketplaceFees ( uint256 _marketplaceFee , address _feeReceiver ) external virtual The governor can update the Nevermined Marketplace fees Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee","title":"setMarketplaceFees"},{"location":"architecture/contracts/#templatestorechangefunctionsignature","text":"","title":"TemplateStoreChangeFunctionSignature"},{"location":"architecture/contracts/#proposetemplate_1","text":"function proposeTemplate ( address _id , address _sender ) external returns ( uint256 size )","title":"proposeTemplate"},{"location":"architecture/contracts/#templatestorechangeinstorage","text":"","title":"TemplateStoreChangeInStorage"},{"location":"architecture/contracts/#templatecount","text":"uint256 templateCount","title":"templateCount"},{"location":"architecture/contracts/#templatestorechangeinstorageandlogic","text":"","title":"TemplateStoreChangeInStorageAndLogic"},{"location":"architecture/contracts/#templatestoreextrafunctionality","text":"","title":"TemplateStoreExtraFunctionality"},{"location":"architecture/contracts/#dummyfunction_2","text":"function dummyFunction () public pure returns ( bool )","title":"dummyFunction"},{"location":"architecture/contracts/#templatestorewithbug","text":"","title":"TemplateStoreWithBug"},{"location":"architecture/contracts/#gettemplatelistsize_1","text":"function getTemplateListSize () external view returns ( uint256 size ) getTemplateListSize number of templates Name Type Description size uint256 number of templates","title":"getTemplateListSize"},{"location":"architecture/contracts/#testerc721","text":"","title":"TestERC721"},{"location":"architecture/contracts/#initialize_51","text":"function initialize () public","title":"initialize"},{"location":"architecture/contracts/#mint_6","text":"function mint ( uint256 id ) public","title":"mint"},{"location":"architecture/contracts/#didregistrylibraryproxy","text":"","title":"DIDRegistryLibraryProxy"},{"location":"architecture/contracts/#didregister_1","text":"struct DIDRegistryLibrary . DIDRegister didRegister","title":"didRegister"},{"location":"architecture/contracts/#didregisterlist_2","text":"struct DIDRegistryLibrary . DIDRegisterList didRegisterList","title":"didRegisterList"},{"location":"architecture/contracts/#areroyaltiesvalid_2","text":"function areRoyaltiesValid ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _tokenAddress ) public view returns ( bool )","title":"areRoyaltiesValid"},{"location":"architecture/contracts/#updatedidowner_1","text":"function updateDIDOwner ( bytes32 _did , address _newOwner ) public","title":"updateDIDOwner"},{"location":"architecture/contracts/#update_3","text":"function update ( bytes32 _did , bytes32 _checksum , string _url ) public","title":"update"},{"location":"architecture/contracts/#initializenftconfig_1","text":"function initializeNftConfig ( bytes32 _did , uint256 _cap , uint8 _royalties ) public","title":"initializeNftConfig"},{"location":"architecture/contracts/#initializenft721config_1","text":"function initializeNft721Config ( bytes32 _did , uint8 _royalties ) public","title":"initializeNft721Config"},{"location":"architecture/contracts/#getdidinfo","text":"function getDIDInfo ( bytes32 _did ) public view returns ( address owner , address creator , uint256 royalties )","title":"getDIDInfo"},{"location":"architecture/contracts/#epochlibraryproxy","text":"","title":"EpochLibraryProxy"},{"location":"architecture/contracts/#epoch_1","text":"struct EpochLibrary . Epoch epoch","title":"epoch"},{"location":"architecture/contracts/#epochlist_2","text":"struct EpochLibrary . EpochList epochList","title":"epochList"},{"location":"architecture/contracts/#create_5","text":"function create ( bytes32 _id , uint256 _timeLock , uint256 _timeOut ) external","title":"create"},{"location":"architecture/contracts/#hashlistlibraryproxy","text":"","title":"HashListLibraryProxy"},{"location":"architecture/contracts/#testdata","text":"struct HashListLibrary . List testData","title":"testData"},{"location":"architecture/contracts/#initialize_52","text":"function initialize ( address _owner ) public","title":"initialize"},{"location":"architecture/contracts/#hash_1","text":"function hash ( address _address ) public pure returns ( bytes32 )","title":"hash"},{"location":"architecture/contracts/#add_5","text":"function add ( bytes32 [] values ) external returns ( bool )","title":"add"},{"location":"architecture/contracts/#add_6","text":"function add ( bytes32 value ) external returns ( bool )","title":"add"},{"location":"architecture/contracts/#update_4","text":"function update ( bytes32 oldValue , bytes32 newValue ) external returns ( bool )","title":"update"},{"location":"architecture/contracts/#index_2","text":"function index ( uint256 from , uint256 to ) external returns ( bool )","title":"index"},{"location":"architecture/contracts/#has_5","text":"function has ( bytes32 value ) external view returns ( bool )","title":"has"},{"location":"architecture/contracts/#remove_2","text":"function remove ( bytes32 value ) external returns ( bool )","title":"remove"},{"location":"architecture/contracts/#get_2","text":"function get ( uint256 _index ) external view returns ( bytes32 )","title":"get"},{"location":"architecture/contracts/#size_2","text":"function size () external view returns ( uint256 )","title":"size"},{"location":"architecture/contracts/#all_2","text":"function all () external view returns ( bytes32 [])","title":"all"},{"location":"architecture/contracts/#indexof_2","text":"function indexOf ( bytes32 value ) external view returns ( uint256 )","title":"indexOf"},{"location":"architecture/contracts/#ownedby_2","text":"function ownedBy () external view returns ( address )","title":"ownedBy"},{"location":"architecture/contracts/#isindexed_2","text":"function isIndexed () external view returns ( bool )","title":"isIndexed"},{"location":"architecture/contracts/#nftbase","text":"Implementation of the Royalties EIP-2981 base contract See https://eips.ethereum.org/EIPS/eip-2981","title":"NFTBase"},{"location":"architecture/contracts/#_proxyapprovals","text":"mapping ( address => bool ) _proxyApprovals","title":"_proxyApprovals"},{"location":"architecture/contracts/#minter_role","text":"bytes32 MINTER_ROLE","title":"MINTER_ROLE"},{"location":"architecture/contracts/#royaltyinfo","text":"struct RoyaltyInfo { address receiver ; uint256 royaltyAmount ; }","title":"RoyaltyInfo"},{"location":"architecture/contracts/#nftmetadata","text":"struct NFTMetadata { string nftURI ; }","title":"NFTMetadata"},{"location":"architecture/contracts/#_royalties","text":"mapping ( uint256 => struct NFTBase . RoyaltyInfo ) _royalties","title":"_royalties"},{"location":"architecture/contracts/#_metadata","text":"mapping ( uint256 => struct NFTBase . NFTMetadata ) _metadata","title":"_metadata"},{"location":"architecture/contracts/#_expiration","text":"mapping ( address => uint256 ) _expiration","title":"_expiration"},{"location":"architecture/contracts/#proxyapproval","text":"event ProxyApproval ( address sender , address operator , bool approved ) Event for recording proxy approvals.","title":"ProxyApproval"},{"location":"architecture/contracts/#setproxyapproval","text":"function setProxyApproval ( address operator , bool approved ) public virtual","title":"setProxyApproval"},{"location":"architecture/contracts/#_setnftmetadata","text":"function _setNFTMetadata ( uint256 tokenId , string tokenURI ) internal","title":"_setNFTMetadata"},{"location":"architecture/contracts/#_settokenroyalty","text":"function _setTokenRoyalty ( uint256 tokenId , address receiver , uint256 royaltyAmount ) internal","title":"_setTokenRoyalty"},{"location":"architecture/contracts/#royaltyinfo_1","text":"function royaltyInfo ( uint256 tokenId , uint256 value ) external view returns ( address receiver , uint256 royaltyAmount ) @inheritdoc IERC2981Upgradeable","title":"royaltyInfo"},{"location":"architecture/contracts/#nftupgradeable","text":"Implementation of the basic standard multi-token. See https://eips.ethereum.org/EIPS/eip-1155","title":"NFTUpgradeable"},{"location":"architecture/contracts/#initialize_53","text":"function initialize ( string uri_ ) public See {_setURI}.","title":"initialize"},{"location":"architecture/contracts/#isapprovedforall","text":"function isApprovedForAll ( address account , address operator ) public view virtual returns ( bool ) See {IERC1155-isApprovedForAll}.","title":"isApprovedForAll"},{"location":"architecture/contracts/#mint_7","text":"function mint ( address to , uint256 id , uint256 amount , bytes data ) public","title":"mint"},{"location":"architecture/contracts/#burn_3","text":"function burn ( address to , uint256 id , uint256 amount ) public","title":"burn"},{"location":"architecture/contracts/#addminter","text":"function addMinter ( address account ) public","title":"addMinter"},{"location":"architecture/contracts/#uri","text":"function uri ( uint256 tokenId ) public view returns ( string )","title":"uri"},{"location":"architecture/contracts/#setnftmetadata","text":"function setNFTMetadata ( uint256 tokenId , string nftURI ) public Record some NFT Metadata Name Type Description tokenId uint256 the id of the asset with the royalties associated nftURI string the URI (https, ipfs, etc) to the metadata describing the NFT","title":"setNFTMetadata"},{"location":"architecture/contracts/#settokenroyalty","text":"function setTokenRoyalty ( uint256 tokenId , address receiver , uint256 royaltyAmount ) public Record the asset royalties Name Type Description tokenId uint256 the id of the asset with the royalties associated receiver address the receiver of the royalties (the original creator) royaltyAmount uint256 percentage (no decimals, between 0 and 100)","title":"setTokenRoyalty"},{"location":"architecture/contracts/#supportsinterface_2","text":"function supportsInterface ( bytes4 interfaceId ) public view virtual returns ( bool )","title":"supportsInterface"},{"location":"architecture/contracts/#nft721subscriptionupgradeable","text":"","title":"NFT721SubscriptionUpgradeable"},{"location":"architecture/contracts/#mint_8","text":"function mint ( address to , uint256 id , uint256 expirationBlock ) public","title":"mint"},{"location":"architecture/contracts/#balanceof_1","text":"function balanceOf ( address owner ) public view returns ( uint256 ) See {IERC721-balanceOf}.","title":"balanceOf"},{"location":"architecture/contracts/#nft721upgradeable","text":"Implementation of the basic standard multi-token.","title":"NFT721Upgradeable"},{"location":"architecture/contracts/#initialize_54","text":"function initialize ( string name , string symbol ) public virtual","title":"initialize"},{"location":"architecture/contracts/#initialize_55","text":"function initialize () public virtual","title":"initialize"},{"location":"architecture/contracts/#isapprovedforall_1","text":"function isApprovedForAll ( address account , address operator ) public view virtual returns ( bool ) See {IERC1155-isApprovedForAll}.","title":"isApprovedForAll"},{"location":"architecture/contracts/#addminter_1","text":"function addMinter ( address account ) public","title":"addMinter"},{"location":"architecture/contracts/#mint_9","text":"function mint ( address to , uint256 id ) public virtual","title":"mint"},{"location":"architecture/contracts/#burn_4","text":"function burn ( uint256 id ) public","title":"burn"},{"location":"architecture/contracts/#tokenuri","text":"function tokenURI ( uint256 tokenId ) public view virtual returns ( string ) See {IERC721Metadata-tokenURI}.","title":"tokenURI"},{"location":"architecture/contracts/#setnftmetadata_1","text":"function setNFTMetadata ( uint256 tokenId , string nftURI ) public Record some NFT Metadata Name Type Description tokenId uint256 the id of the asset with the royalties associated nftURI string the URI (https, ipfs, etc) to the metadata describing the NFT","title":"setNFTMetadata"},{"location":"architecture/contracts/#settokenroyalty_1","text":"function setTokenRoyalty ( uint256 tokenId , address receiver , uint256 royaltyAmount ) public Record the asset royalties Name Type Description tokenId uint256 the id of the asset with the royalties associated receiver address the receiver of the royalties (the original creator) royaltyAmount uint256 percentage (no decimals, between 0 and 100)","title":"setTokenRoyalty"},{"location":"architecture/contracts/#supportsinterface_3","text":"function supportsInterface ( bytes4 interfaceId ) public view virtual returns ( bool )","title":"supportsInterface"},{"location":"architecture/contracts/#poapupgradeable","text":"","title":"POAPUpgradeable"},{"location":"architecture/contracts/#_tokenidcounter","text":"struct CountersUpgradeable . Counter _tokenIdCounter","title":"_tokenIdCounter"},{"location":"architecture/contracts/#_tokenevent","text":"mapping ( uint256 => uint256 ) _tokenEvent","title":"_tokenEvent"},{"location":"architecture/contracts/#initialize_56","text":"function initialize () public","title":"initialize"},{"location":"architecture/contracts/#initialize_57","text":"function initialize ( string name , string symbol ) public virtual","title":"initialize"},{"location":"architecture/contracts/#mint_10","text":"function mint ( address to , string uri , uint256 eventId ) public","title":"mint"},{"location":"architecture/contracts/#mint_11","text":"function mint ( address to , uint256 id ) public","title":"mint"},{"location":"architecture/contracts/#tokenevent","text":"function tokenEvent ( uint256 tokenId ) public view returns ( uint256 )","title":"tokenEvent"},{"location":"architecture/contracts/#_beforetokentransfer_1","text":"function _beforeTokenTransfer ( address from , address to , uint256 tokenId ) internal","title":"_beforeTokenTransfer"},{"location":"architecture/contracts/#_burn","text":"function _burn ( uint256 tokenId ) internal","title":"_burn"},{"location":"architecture/contracts/#tokendetailsofowner","text":"function tokenDetailsOfOwner ( address owner ) public view returns ( uint256 [] tokenIds , uint256 [] eventIds )","title":"tokenDetailsOfOwner"},{"location":"architecture/contracts/#tokenuri_1","text":"function tokenURI ( uint256 tokenId ) public view returns ( string )","title":"tokenURI"},{"location":"architecture/contracts/#isapprovedforall_2","text":"function isApprovedForAll ( address account , address operator ) public view returns ( bool )","title":"isApprovedForAll"},{"location":"architecture/contracts/#supportsinterface_4","text":"function supportsInterface ( bytes4 interfaceId ) public view virtual returns ( bool )","title":"supportsInterface"},{"location":"architecture/contracts/ContractABIs/","text":"Contracts ABIs \u00b6 Nevermined as a digital ecosystems builder has some differences from a contracts deployment point of view compared with some other protocols. These are some main characteristics: We support different products built on Nevermined contracts running in different networks Each product will use different versions of the contracts Different products in the same network could require different versions of the contracts What defines a Nevermined deployment \u00b6 So the organization of how the applications are using the which version of the contracts in which network is defined by 3 dimensions: Version , the version of the Smart Contracts v1.3.9 , v2.0.1 , etc Network , in which network ( NETWORK_ID ) are the contracts deployed. Typically mumbai , polygon , rinkeby , mainnet , alfajores and celo but it could be others Tag Name , referring to a specific product or app using this specific release of the contracts. This is important because the same version of the contracts in the same network could be required because different configuration during the deployment of the instance. If tag name is not specified we assume is a common deployment. So Version + Network + Tag Name defines a unique Nevermined deployment or instance. How we release the ABIs? \u00b6 Because of this, the releasing and deployment process of the contracts take care of: When a new version of the contracts is tagged, the ABIs of that version are stored indicating the version. When a new version of the contracts is installed or upgraded into a non-local environment, the ABIs of that version (with the contract address included) corresponding to that network and tag name are stored in a hierarchy structure representing this unique version/network/tag Releasing new Nevermined Contracts ABIs New release of the contracts (new tag) \u00b6 A new tag of Nevermined contracts will generate the ABIs that will be uploaded using the following structure: https://artifacts.nevermined.rocks/abis/abis_<VERSION>.zip | tar.gz https://artifacts.nevermined.rocks/abis/<VERSION>/ContractNameA.json https://artifacts.nevermined.rocks/abis/<VERSION>/ContractNameB.json Deployment of the contracts in a network \u00b6 A new deployment (fresh install or upgrade) of the contracts will generate 2 different files: The contracts file keeping the name of the contract and the address where the contract is deployed. This file will be in JSON format and have the following format: { \"ContractName1\" : \"0x123\" , \"ContractName2\" : \"0x123\" } The ABIs package file including all the ABI files. The package file could be in zip and tar.gz formats. Taking all the above into account, after a deployment 2 new files are generated with the contracts addresses and abis using the following structure: https://artifacts.nevermined.rocks/deployment/<NETWORK_ID>/<TAG_NAME>/abis_<VERSION>.zip | .tar.gz https://artifacts.nevermined.rocks/deployment/<NETWORK_ID>/<TAG_NAME>/contracts_<VERSION>.json For example, for a new deployment of contracts v2.1.0 on mumbai that will be used for common environments, it will be generated the following 2 files: https://artifacts.nevermined.rocks/deployment/mumbai/common/abis_v2.1.0.zip https://artifacts.nevermined.rocks/deployment/mumbai/common/contracts_v2.1.0.json Integration \u00b6 Knowing the version, environment and the tag name, a client can get all the artifacts and addresses of the contracts that needs to use downloading the artifacts from the public repository. In addition to this, the NPM package @nevermined-io/contracts of the contracts will include the ABIs. In combination with the contracts.json, the client should be able to configure the correct address where connect just replacing the contract addresses in the ABIs. Integration of Nevermined Contracts ABIs","title":"Contracts ABIs"},{"location":"architecture/contracts/ContractABIs/#contracts-abis","text":"Nevermined as a digital ecosystems builder has some differences from a contracts deployment point of view compared with some other protocols. These are some main characteristics: We support different products built on Nevermined contracts running in different networks Each product will use different versions of the contracts Different products in the same network could require different versions of the contracts","title":"Contracts ABIs"},{"location":"architecture/contracts/ContractABIs/#what-defines-a-nevermined-deployment","text":"So the organization of how the applications are using the which version of the contracts in which network is defined by 3 dimensions: Version , the version of the Smart Contracts v1.3.9 , v2.0.1 , etc Network , in which network ( NETWORK_ID ) are the contracts deployed. Typically mumbai , polygon , rinkeby , mainnet , alfajores and celo but it could be others Tag Name , referring to a specific product or app using this specific release of the contracts. This is important because the same version of the contracts in the same network could be required because different configuration during the deployment of the instance. If tag name is not specified we assume is a common deployment. So Version + Network + Tag Name defines a unique Nevermined deployment or instance.","title":"What defines a Nevermined deployment"},{"location":"architecture/contracts/ContractABIs/#how-we-release-the-abis","text":"Because of this, the releasing and deployment process of the contracts take care of: When a new version of the contracts is tagged, the ABIs of that version are stored indicating the version. When a new version of the contracts is installed or upgraded into a non-local environment, the ABIs of that version (with the contract address included) corresponding to that network and tag name are stored in a hierarchy structure representing this unique version/network/tag Releasing new Nevermined Contracts ABIs","title":"How we release the ABIs?"},{"location":"architecture/contracts/ContractABIs/#new-release-of-the-contracts-new-tag","text":"A new tag of Nevermined contracts will generate the ABIs that will be uploaded using the following structure: https://artifacts.nevermined.rocks/abis/abis_<VERSION>.zip | tar.gz https://artifacts.nevermined.rocks/abis/<VERSION>/ContractNameA.json https://artifacts.nevermined.rocks/abis/<VERSION>/ContractNameB.json","title":"New release of the contracts (new tag)"},{"location":"architecture/contracts/ContractABIs/#deployment-of-the-contracts-in-a-network","text":"A new deployment (fresh install or upgrade) of the contracts will generate 2 different files: The contracts file keeping the name of the contract and the address where the contract is deployed. This file will be in JSON format and have the following format: { \"ContractName1\" : \"0x123\" , \"ContractName2\" : \"0x123\" } The ABIs package file including all the ABI files. The package file could be in zip and tar.gz formats. Taking all the above into account, after a deployment 2 new files are generated with the contracts addresses and abis using the following structure: https://artifacts.nevermined.rocks/deployment/<NETWORK_ID>/<TAG_NAME>/abis_<VERSION>.zip | .tar.gz https://artifacts.nevermined.rocks/deployment/<NETWORK_ID>/<TAG_NAME>/contracts_<VERSION>.json For example, for a new deployment of contracts v2.1.0 on mumbai that will be used for common environments, it will be generated the following 2 files: https://artifacts.nevermined.rocks/deployment/mumbai/common/abis_v2.1.0.zip https://artifacts.nevermined.rocks/deployment/mumbai/common/contracts_v2.1.0.json","title":"Deployment of the contracts in a network"},{"location":"architecture/contracts/ContractABIs/#integration","text":"Knowing the version, environment and the tag name, a client can get all the artifacts and addresses of the contracts that needs to use downloading the artifacts from the public repository. In addition to this, the NPM package @nevermined-io/contracts of the contracts will include the ABIs. In combination with the contracts.json, the client should be able to configure the correct address where connect just replacing the contract addresses in the ABIs. Integration of Nevermined Contracts ABIs","title":"Integration"},{"location":"architecture/contracts/Packages/","text":"Packages \u00b6 The following package describes how to package the Keeper Contracts in different formats. It is helpful to distribute the compiled smart contracts ABI's in different \"flavours\". It allows to import those ABI's from different languages enabling an easier interaction with the Keeper. Javascript (NPM) \u00b6 NPM packages are published as part of the Nevermined NPM organization . Github Actions is configured to release a new version of the nevermined-io/contracts NPM library after tagging. Versions of the library must be modified in the package.json file. { \"name\" : \"@nevermined-io/contracts\" , \"version\" : \"1.0.0\" , .. } Typically you can't overwrite NPM already published versions of the libraries. This package uses Semantic Versioning , so if you are testing with new versions, it's recommended to play with the patch numbers. If you need to build a local version of the package you need to run the following commands: yarn yarn build If you need to release a new version of the library before tagging, you need to execute the following command: npm publish --access public To do that you need to be an authorized user in the NPM Nevermined organization. Python \u00b6 Python packages are generated automatically in Pypi format: https://pypi.org/project/nevermined-contracts/ Java \u00b6 Java packages are generated automatically for JVM applications and published into Maven central: https://search.maven.org/artifact/io.keyko.nevermined/contracts","title":"Packages"},{"location":"architecture/contracts/Packages/#packages","text":"The following package describes how to package the Keeper Contracts in different formats. It is helpful to distribute the compiled smart contracts ABI's in different \"flavours\". It allows to import those ABI's from different languages enabling an easier interaction with the Keeper.","title":"Packages"},{"location":"architecture/contracts/Packages/#javascript-npm","text":"NPM packages are published as part of the Nevermined NPM organization . Github Actions is configured to release a new version of the nevermined-io/contracts NPM library after tagging. Versions of the library must be modified in the package.json file. { \"name\" : \"@nevermined-io/contracts\" , \"version\" : \"1.0.0\" , .. } Typically you can't overwrite NPM already published versions of the libraries. This package uses Semantic Versioning , so if you are testing with new versions, it's recommended to play with the patch numbers. If you need to build a local version of the package you need to run the following commands: yarn yarn build If you need to release a new version of the library before tagging, you need to execute the following command: npm publish --access public To do that you need to be an authorized user in the NPM Nevermined organization.","title":"Javascript (NPM)"},{"location":"architecture/contracts/Packages/#python","text":"Python packages are generated automatically in Pypi format: https://pypi.org/project/nevermined-contracts/","title":"Python"},{"location":"architecture/contracts/Packages/#java","text":"Java packages are generated automatically for JVM applications and published into Maven central: https://search.maven.org/artifact/io.keyko.nevermined/contracts","title":"Java"},{"location":"architecture/contracts/ReleaseProcess/","text":"Release Process \u00b6 Build a new version \u00b6 We follow the standard Nevermined release pattern: Make sure the versions are up to date: package.json , setup.py , pom.xml Create a tag: $ git tag v2.0.0 Push the tag: $ git push origin v2.0.0 Interact with networks \u00b6 Roles \u00b6 We define four roles: deployer : represented as accounts[0] upgrader : represented as accounts[1] upgraderWallet : represented as the upgrader from wallets.json ownerWallet : represented as the owner from wallets.json governorWallet : represented as the governor from wallets.json Flags \u00b6 --testnet Deploys the Dispenser, the NeverminedToken and the contracts from contracts.json --with-token Deploys the NeverminedToken and the contracts from contracts.json Nevermined Configuration \u00b6 The set of Nevermined contracts can be deployed in different networks and interact with several use cases. Each of these different scenarios could require different configurations so to facilitate that Nevermined provides an on-chain configuration mechanism allowing the governance (via DAO or similar) of a Nevermined deployment. To see all the available possibilities please see the INeverminedConfig interface. During the deployment of Nevermined all of these parameters can be specified allowing a bespoke environment configuration. This can be done via the definition of the following environment variables: NVM_MARKETPLACE_FEE . It refers to the fee charged by Nevermined for using the Service Agreements. It uses an integer number representing a 2 decimal number. It means 1450 means 14.50% fee. The value must be beteen 0 and 10000 (100%). See marketplaceFee variable. NVM_RECEIVER_FEE . It refers to the address that will receive the fee charged by Nevermined per transaction. See feeReceiver variable Deployer \u00b6 Can be any account. It is used for deploying the initial proxy contracts and the logic contracts. Upgrader \u00b6 Has to be an owner of the upgrader multi sig wallet. It is used for issuing upgrade requests against the upgrader multi sig wallet. UpgraderWallet \u00b6 One instance of the multi sig wallet, defined as upgrader . This wallet will be assigned as zos admin and is required to do upgrades. OwnerWallet \u00b6 One instance of the multi sig wallet, defined as owner . This wallet will be assigned as the owner of all the contracts. It can be used to call specific functions in the contracts ie. change the configuration. Deploy & Upgrade \u00b6 All deployment configurations are on hardhat.config.js . run yarn clean to clean the work dir. run yarn compile to compile the contracts. This step will create cache/ and deploy-cache.json used to resume the deployment in case something fails. Rinkeby (Testnet) \u00b6 Copy the wallet file for rinkeby cp wallets_rinkeby.json wallets.json run export MNEMONIC=<your rinkeby mnemonic> . You will find them in the password manager. Deploy the whole application \u00b6 Remove the deploy file related to the network in .openzeppelin/ for a clean deployment To deploy all contracts run yarn deploy:rinkeby . If the deployment fails at any point just retry the command and it will make use of the cache/ to resume the deployment This step will create a unknown-<chainId>.json . Rename this file to <tag>-<version>-<chainId>.json Deploy a single contracts \u00b6 To deploy a single contract you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:rinkeby -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser . Upgrade the whole application \u00b6 To upgrade all contracts run yarn upgrade:rinkeby Upgrade a single contract \u00b6 To upgrade a single contract run yarn upgrade:rinkeby -- NeverminedToken . For upgrading the NeverminedToken contract. Persist artifacts \u00b6 Commit all changes in artifacts/*.rinkeby.json Mumbai (PolygonTestnet) \u00b6 Copy the wallet file for mumbai cp wallets_mumbai.json wallets.json run export MNEMONIC=<your mumbai mnemonic> . You will find them in the password manager. Deploy the whole application \u00b6 To deploy all contracts run yarn deploy:mumbai Deploy a single contracts \u00b6 To deploy a single contract you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:mumbai -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser . Upgrade the whole application \u00b6 To upgrade all contracts run yarn upgrade:mumbai Upgrade a single contract \u00b6 To upgrade a single contract run yarn upgrade:mumbai -- NeverminedToken . For upgrading the NeverminedToken contract. Persist artifacts \u00b6 Commit all changes in artifacts/*.mumbai.json Kovan (Testnet) \u00b6 Copy the wallet file for kovan > cp wallets_kovan.json wallets.json run export MNEMONIC=<your kovan mnemonic> . You will find them in the password manager. run export INFURA_TOKEN=<your infura token> . You will get it from infura . Deploy the whole application \u00b6 To deploy all the contracts run yarn deploy:kovan Deploy a single contracts \u00b6 To deploy a single contracts you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:kovan -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser . Upgrade the whole application \u00b6 To upgrade all contracts run yarn upgrade:kovan Upgrade a single contract \u00b6 To upgrade a single contract run yarn upgrade:kovan -- NeverminedToken . For upgrading the NeverminedToken contract. Persist artifacts \u00b6 Commit all changes in artifacts/*.kovan.json Approve upgrades \u00b6 All upgrades of the contracts have to be approved by the upgrader wallet configured in the wallets.json file. go to https://wallet.gnosis.pm Load upgrader wallet Select an Ethereum Account that is an owner of the multi sig wallet, but not the one who issued the upgrade request. This can be done in the following ways: Connect to a local Blockchain node that holds the private key. Connect to MetaMask and select the owner account from the multi sig wallet. Connect a hardware wallet like ledger or trezor. Select the transaction you want to confirm (the upgrade script will tell you which transactions have to be approved in which wallets) Click Confirm Upload the artifacts (abis/contracts) to Contract Repository \u00b6 Once the contracts are deployed to a public network or a new contract version whose contract abis has to been uploaded, use scripts/upload_artifacts_s3.sh to upload the contracts or artifacts to repository https://artifacts-nevermined-rocks.s3.amazonaws.com . Your environment has to be configured and authorized to use aws cli to upload files to artifacts-nevermined-rocks bucketi . The script has the next variables: branch is the branch from where the workflow and artifacts will be used. asset can be abis / contracts . Use abis if you want to upload the contract ABIs that not contain deployment information. Contracts for uploading abis with deployment information to network . network refers to network name, based on filename/hardhat config. Not used if abis is selected. tag refers to deployment tag. Defaults to common. Not used if abis is selected. This workflows uses the script scripts/upload_artifacts_s3.sh that can be used using the next syntax: ./scripts/upload_artifacts_s3.sh abis ./scripts/upload_artifacts_s3.sh contracts mumbai awesome_tag Document \u00b6 Contracts documentation \u00b6 Update the contracts documentation run yarn doc:contracts Commit the changes in docs/contracts folder Trigger CI \u00b6 Commit the missing changes to the feature branch. Tag the last commit with the new version number ie. v0.2.5 Push the feature branch to GitHub. Make a pull request from the just-pushed branch to develop branch. Wait for all the tests to pass! Merge the pull request into the develop branch. Release and packages \u00b6 The release itself is done by github actions based on the tagged commit. It will deploy the following components: npm pypi maven docker The npm, pypi and maven packages contain the contract artifacts for the contracts already deployed in different networks (such as Production , Rinkeby , Mumbai , Testing , or Spree ). The docker image generated contains the contracts and script ready to be used to deploy the contracts to a network. It is used for deploying the contracts in the local network Spree in nevermined-io/tools Once the new version is tagged and released, you can edit the Releases section of GitHub with the information and changes about the new version (in the future, these will come from the changelog): Audit \u00b6 To check or document that all transactions have been approved in the multi sig wallet you can run yarn audit:rinkeby to get a list of all the current transactions and their current status. Wallet: 0x24EB26D4042a2AB576E7E39b87c3f33f276AeF92 Transaction ID: 64 Destination: 0xfA16d26e9F4fffC6e40963B281a0bB08C31ed40C Contract: EscrowAccessSecretStoreTemplate Data is `upgradeTo` call: true Confirmed from: 0x7A13E1aD23546c9b804aDFd13e9AcB184EfCAF58 Executed: false","title":"Release Process"},{"location":"architecture/contracts/ReleaseProcess/#release-process","text":"","title":"Release Process"},{"location":"architecture/contracts/ReleaseProcess/#build-a-new-version","text":"We follow the standard Nevermined release pattern: Make sure the versions are up to date: package.json , setup.py , pom.xml Create a tag: $ git tag v2.0.0 Push the tag: $ git push origin v2.0.0","title":"Build a new version"},{"location":"architecture/contracts/ReleaseProcess/#interact-with-networks","text":"","title":"Interact with networks"},{"location":"architecture/contracts/ReleaseProcess/#roles","text":"We define four roles: deployer : represented as accounts[0] upgrader : represented as accounts[1] upgraderWallet : represented as the upgrader from wallets.json ownerWallet : represented as the owner from wallets.json governorWallet : represented as the governor from wallets.json","title":"Roles"},{"location":"architecture/contracts/ReleaseProcess/#flags","text":"--testnet Deploys the Dispenser, the NeverminedToken and the contracts from contracts.json --with-token Deploys the NeverminedToken and the contracts from contracts.json","title":"Flags"},{"location":"architecture/contracts/ReleaseProcess/#nevermined-configuration","text":"The set of Nevermined contracts can be deployed in different networks and interact with several use cases. Each of these different scenarios could require different configurations so to facilitate that Nevermined provides an on-chain configuration mechanism allowing the governance (via DAO or similar) of a Nevermined deployment. To see all the available possibilities please see the INeverminedConfig interface. During the deployment of Nevermined all of these parameters can be specified allowing a bespoke environment configuration. This can be done via the definition of the following environment variables: NVM_MARKETPLACE_FEE . It refers to the fee charged by Nevermined for using the Service Agreements. It uses an integer number representing a 2 decimal number. It means 1450 means 14.50% fee. The value must be beteen 0 and 10000 (100%). See marketplaceFee variable. NVM_RECEIVER_FEE . It refers to the address that will receive the fee charged by Nevermined per transaction. See feeReceiver variable","title":"Nevermined Configuration"},{"location":"architecture/contracts/ReleaseProcess/#deployer","text":"Can be any account. It is used for deploying the initial proxy contracts and the logic contracts.","title":"Deployer"},{"location":"architecture/contracts/ReleaseProcess/#upgrader","text":"Has to be an owner of the upgrader multi sig wallet. It is used for issuing upgrade requests against the upgrader multi sig wallet.","title":"Upgrader"},{"location":"architecture/contracts/ReleaseProcess/#upgraderwallet","text":"One instance of the multi sig wallet, defined as upgrader . This wallet will be assigned as zos admin and is required to do upgrades.","title":"UpgraderWallet"},{"location":"architecture/contracts/ReleaseProcess/#ownerwallet","text":"One instance of the multi sig wallet, defined as owner . This wallet will be assigned as the owner of all the contracts. It can be used to call specific functions in the contracts ie. change the configuration.","title":"OwnerWallet"},{"location":"architecture/contracts/ReleaseProcess/#deploy-upgrade","text":"All deployment configurations are on hardhat.config.js . run yarn clean to clean the work dir. run yarn compile to compile the contracts. This step will create cache/ and deploy-cache.json used to resume the deployment in case something fails.","title":"Deploy &amp; Upgrade"},{"location":"architecture/contracts/ReleaseProcess/#rinkeby-testnet","text":"Copy the wallet file for rinkeby cp wallets_rinkeby.json wallets.json run export MNEMONIC=<your rinkeby mnemonic> . You will find them in the password manager.","title":"Rinkeby (Testnet)"},{"location":"architecture/contracts/ReleaseProcess/#deploy-the-whole-application","text":"Remove the deploy file related to the network in .openzeppelin/ for a clean deployment To deploy all contracts run yarn deploy:rinkeby . If the deployment fails at any point just retry the command and it will make use of the cache/ to resume the deployment This step will create a unknown-<chainId>.json . Rename this file to <tag>-<version>-<chainId>.json","title":"Deploy the whole application"},{"location":"architecture/contracts/ReleaseProcess/#deploy-a-single-contracts","text":"To deploy a single contract you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:rinkeby -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser .","title":"Deploy a single contracts"},{"location":"architecture/contracts/ReleaseProcess/#upgrade-the-whole-application","text":"To upgrade all contracts run yarn upgrade:rinkeby","title":"Upgrade the whole application"},{"location":"architecture/contracts/ReleaseProcess/#upgrade-a-single-contract","text":"To upgrade a single contract run yarn upgrade:rinkeby -- NeverminedToken . For upgrading the NeverminedToken contract.","title":"Upgrade a single contract"},{"location":"architecture/contracts/ReleaseProcess/#persist-artifacts","text":"Commit all changes in artifacts/*.rinkeby.json","title":"Persist artifacts"},{"location":"architecture/contracts/ReleaseProcess/#mumbai-polygontestnet","text":"Copy the wallet file for mumbai cp wallets_mumbai.json wallets.json run export MNEMONIC=<your mumbai mnemonic> . You will find them in the password manager.","title":"Mumbai (PolygonTestnet)"},{"location":"architecture/contracts/ReleaseProcess/#deploy-the-whole-application_1","text":"To deploy all contracts run yarn deploy:mumbai","title":"Deploy the whole application"},{"location":"architecture/contracts/ReleaseProcess/#deploy-a-single-contracts_1","text":"To deploy a single contract you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:mumbai -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser .","title":"Deploy a single contracts"},{"location":"architecture/contracts/ReleaseProcess/#upgrade-the-whole-application_1","text":"To upgrade all contracts run yarn upgrade:mumbai","title":"Upgrade the whole application"},{"location":"architecture/contracts/ReleaseProcess/#upgrade-a-single-contract_1","text":"To upgrade a single contract run yarn upgrade:mumbai -- NeverminedToken . For upgrading the NeverminedToken contract.","title":"Upgrade a single contract"},{"location":"architecture/contracts/ReleaseProcess/#persist-artifacts_1","text":"Commit all changes in artifacts/*.mumbai.json","title":"Persist artifacts"},{"location":"architecture/contracts/ReleaseProcess/#kovan-testnet","text":"Copy the wallet file for kovan > cp wallets_kovan.json wallets.json run export MNEMONIC=<your kovan mnemonic> . You will find them in the password manager. run export INFURA_TOKEN=<your infura token> . You will get it from infura .","title":"Kovan (Testnet)"},{"location":"architecture/contracts/ReleaseProcess/#deploy-the-whole-application_2","text":"To deploy all the contracts run yarn deploy:kovan","title":"Deploy the whole application"},{"location":"architecture/contracts/ReleaseProcess/#deploy-a-single-contracts_2","text":"To deploy a single contracts you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:kovan -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser .","title":"Deploy a single contracts"},{"location":"architecture/contracts/ReleaseProcess/#upgrade-the-whole-application_2","text":"To upgrade all contracts run yarn upgrade:kovan","title":"Upgrade the whole application"},{"location":"architecture/contracts/ReleaseProcess/#upgrade-a-single-contract_2","text":"To upgrade a single contract run yarn upgrade:kovan -- NeverminedToken . For upgrading the NeverminedToken contract.","title":"Upgrade a single contract"},{"location":"architecture/contracts/ReleaseProcess/#persist-artifacts_2","text":"Commit all changes in artifacts/*.kovan.json","title":"Persist artifacts"},{"location":"architecture/contracts/ReleaseProcess/#approve-upgrades","text":"All upgrades of the contracts have to be approved by the upgrader wallet configured in the wallets.json file. go to https://wallet.gnosis.pm Load upgrader wallet Select an Ethereum Account that is an owner of the multi sig wallet, but not the one who issued the upgrade request. This can be done in the following ways: Connect to a local Blockchain node that holds the private key. Connect to MetaMask and select the owner account from the multi sig wallet. Connect a hardware wallet like ledger or trezor. Select the transaction you want to confirm (the upgrade script will tell you which transactions have to be approved in which wallets) Click Confirm","title":"Approve upgrades"},{"location":"architecture/contracts/ReleaseProcess/#upload-the-artifacts-abiscontracts-to-contract-repository","text":"Once the contracts are deployed to a public network or a new contract version whose contract abis has to been uploaded, use scripts/upload_artifacts_s3.sh to upload the contracts or artifacts to repository https://artifacts-nevermined-rocks.s3.amazonaws.com . Your environment has to be configured and authorized to use aws cli to upload files to artifacts-nevermined-rocks bucketi . The script has the next variables: branch is the branch from where the workflow and artifacts will be used. asset can be abis / contracts . Use abis if you want to upload the contract ABIs that not contain deployment information. Contracts for uploading abis with deployment information to network . network refers to network name, based on filename/hardhat config. Not used if abis is selected. tag refers to deployment tag. Defaults to common. Not used if abis is selected. This workflows uses the script scripts/upload_artifacts_s3.sh that can be used using the next syntax: ./scripts/upload_artifacts_s3.sh abis ./scripts/upload_artifacts_s3.sh contracts mumbai awesome_tag","title":"Upload the artifacts (abis/contracts) to Contract Repository"},{"location":"architecture/contracts/ReleaseProcess/#document","text":"","title":"Document"},{"location":"architecture/contracts/ReleaseProcess/#contracts-documentation","text":"Update the contracts documentation run yarn doc:contracts Commit the changes in docs/contracts folder","title":"Contracts documentation"},{"location":"architecture/contracts/ReleaseProcess/#trigger-ci","text":"Commit the missing changes to the feature branch. Tag the last commit with the new version number ie. v0.2.5 Push the feature branch to GitHub. Make a pull request from the just-pushed branch to develop branch. Wait for all the tests to pass! Merge the pull request into the develop branch.","title":"Trigger CI"},{"location":"architecture/contracts/ReleaseProcess/#release-and-packages","text":"The release itself is done by github actions based on the tagged commit. It will deploy the following components: npm pypi maven docker The npm, pypi and maven packages contain the contract artifacts for the contracts already deployed in different networks (such as Production , Rinkeby , Mumbai , Testing , or Spree ). The docker image generated contains the contracts and script ready to be used to deploy the contracts to a network. It is used for deploying the contracts in the local network Spree in nevermined-io/tools Once the new version is tagged and released, you can edit the Releases section of GitHub with the information and changes about the new version (in the future, these will come from the changelog):","title":"Release and packages"},{"location":"architecture/contracts/ReleaseProcess/#audit","text":"To check or document that all transactions have been approved in the multi sig wallet you can run yarn audit:rinkeby to get a list of all the current transactions and their current status. Wallet: 0x24EB26D4042a2AB576E7E39b87c3f33f276AeF92 Transaction ID: 64 Destination: 0xfA16d26e9F4fffC6e40963B281a0bB08C31ed40C Contract: EscrowAccessSecretStoreTemplate Data is `upgradeTo` call: true Confirmed from: 0x7A13E1aD23546c9b804aDFd13e9AcB184EfCAF58 Executed: false","title":"Audit"},{"location":"architecture/contracts/Upgrades/","text":"Upgrade Process \u00b6 This documents explains in detail how nevermined-contracts should be deployed using zeppelinOS and how the contracts can be upgraded. The latest section describes the test procedure. Quickstart \u00b6 The first step to work with zos is to install dependencies then initialize the project. Then compile contracts and add contracts to the project. Finally push the contracts into the network and create the upgradable instances. Once the contracts are deployed they can be tested and upgraded. Also we change the proxy administrator to a MultiSignature wallet to approve upgrades. We are going to use the Nevermined Contract Tools in order to perform any future deployments/upgrades. Details \u00b6 Here we provide more details into each step of the initial deploy and the approach of upgradeability and governance. Roles \u00b6 Before going into more details about the deployment. We should differentiate between different roles in the system which govern the upgradeability in nevermined-contracts. Roles are defined as follows: deployer: represented as accounts[0] upgrader: represented as accounts[1] governor: represented as accounts[1] upgraderWallet: represented as the upgrader from wallets.json ownerWallet: represented as the owner from wallets.json governorWallet: represented as the owner from wallets.json - Deployer : Can be any account. It is used for deploying the initial proxy contracts and the logic contracts . Upgrader : Has to be an owner of the upgrader multi sig wallet. It is used for issuing upgrade requests against the upgrader multi sig wallet. - Governor : Has to have the GOVERNOR_ROLE in the contracts. It is used for issuing upgrade config requests. \u00b6 UpgraderWallet : One instance of the multi sig wallet, defined as upgrader . This wallet will be assigned as zos admin and is required to do upgrades. OwnerWallet : One instance of the multi sig wallet, defined as owner . This wallet will be assigned as the owner of all the contracts. It can be used to call specific functions in the contracts ie. change the configuration. GovernorWallet : One instance of the multi sig wallet, defined as governor . This wallet will be assigned as zos admin and is required to do config updates in a Nevermined deployment. Deploy & Upgrade \u00b6 zos does not support migrations, hence all the initial configuration should be performed with Nevermined Contract Tools . Contract constructors are ignored so the initial setup of the contract should be made in a initialize function that will be executed only once after the initial deployment. 1. Configuration \u00b6 Nevermined Contract Tools checks the contracts.json in order to detect the current contracts that are going to be deployed: [ \"ConditionStoreManager\" , \"TemplateStoreManager\" , \"AgreementStoreManager\" , \"SignCondition\" , \"HashLockCondition\" , \"LockRewardCondition\" , \"NFTHolderCondition\" , \"AccessCondition\" , \"EscrowReward\" , \"EscrowAccessSecretStoreTemplate\" , \"NFTAccessTemplate\" , \"DIDRegistry\" ] Moreover for each network, Nevermined Contract Tools needs to detect the roles and their addresses from a pre-defined wallets config file. The following configuration should be an example for wallets-<NETWORK_NAME>.json : [ { \"name\" : \"upgrader\" , \"address\" : \"0x24eb26d4042a2ab576e7e39b87c3f33f276aef92\" }, { \"name\" : \"owner\" , \"address\" : \"0xd02d68c62401472ce35ba3c7e505deae62db2b8b\" }, { \"name\" : \"governor\" , \"address\" : \"0xeeff68c62401472ce35ba3c7e505deae62db2b8b\" } ] 2. Preparation \u00b6 The following commands clean, install dependencies and compile the contracts: $ yarn clean #to clean the work dir $ yarn #install dependencies $ yarn compile #to compile the contracts 3. Deploy & Upgrade \u00b6 The following steps shows how to perform contracts deployment and upgrade on Rinkeby and Kovan networks. Nile \u00b6 Copy the wallet file for rinkeby cp wallets_rinkeby.json wallets.json run export MNEMONIC=<your staging mnemonic> . You will find them in the password manager. Deploy the whole application \u00b6 To deploy all contracts run yarn deploy:rinkeby Deploy a single contracts \u00b6 To deploy a single contract you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:rinkeby -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser . Upgrade the whole application \u00b6 To upgrade all contracts run yarn upgrade:rinkeby Upgrade a single contract \u00b6 To upgrade a single contract run yarn upgrade:rinkeby -- NeverminedToken . For upgrading the NeverminedToken contract. Persist artifacts \u00b6 Commit all changes in artifacts/*.rinkeby.json Kovan \u00b6 Copy the wallet file for kovan > cp wallets_kovan.json wallets.json run export MNEMONIC=<your kovan mnemonic> . You will find them in the password manager. run export INFURA_TOKEN=<your infura token> . You will get it from infura . Deploy the whole application \u00b6 To deploy all the contracts run yarn deploy:kovan Deploy a single contracts \u00b6 To deploy a single contracts you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:kovan -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser . Upgrade the whole application \u00b6 To upgrade all contracts run yarn upgrade:kovan Upgrade a single contract \u00b6 To upgrade a single contract run yarn upgrade:kovan -- NeverminedToken . For upgrading the NeverminedToken contract. Persist artifacts \u00b6 Commit all changes in artifacts/*.kovan.json 4. Approve Upgrade(s) \u00b6 All upgrades of the contracts have to be approved by the upgrader wallet configured in the wallets.json file. go to https://wallet.gnosis.pm Load upgrader wallet Select an Ethereum Account that is an owner of the multi sig wallet, but not the one who issued the upgrade request. This can be done in the following ways: Connect to a local Blockchain node that holds the private key. Connect to MetaMask and select the owner account from the multi sig wallet. Connect a hardware wallet like ledger or trezor. Select the transaction you want to confirm (the upgrade script will tell you which transactions have to be approved in which wallets) Click Confirm 5. Audit Contracts \u00b6 To check or document that all transactions have been approved in the multi sig wallet you can run yarn audit:rinkeby to get a list of all the current transactions and their current status. Wallet: 0x24EB26D4042a2AB576E7E39b87c3f33f276AeF92 Transaction ID: 64 Destination: 0xfA16d26e9F4fffC6e40963B281a0bB08C31ed40C Contract: EscrowAccessSecretStoreTemplate Data is `upgradeTo` call: true Confirmed from: 0x7A13E1aD23546c9b804aDFd13e9AcB184EfCAF58 Executed: false 6. Documentation \u00b6 Update the addresses in the README.md run node ./scripts/contracts/get-addresses.js <network name> It will output the current proxy addresses in the README friendly format. | AccessCondition | v0.9.0 | 0x45DE141F8Efc355F1451a102FB6225F1EDd2921d | | AgreementStoreManager | v0.9.0 | 0x62f84700b1A0ea6Bfb505aDC3c0286B7944D247C | | ConditionStoreManager | v0.9.0 | 0x39b0AA775496C5ebf26f3B81C9ed1843f09eE466 | | DIDRegistry | v0.9.0 | 0x4A0f7F763B1A7937aED21D63b2A78adc89c5Db23 | | DIDRegistryLibrary | v0.9.0 | 0x3B3504908Db36f5D5f07CD420ee2BBBbDfB674cF | | Dispenser | v0.9.0 | 0x865396b7ddc58C693db7FCAD1168E3BD95Fe3368 | .... Copy this to the README.md","title":"Upgrade Process"},{"location":"architecture/contracts/Upgrades/#upgrade-process","text":"This documents explains in detail how nevermined-contracts should be deployed using zeppelinOS and how the contracts can be upgraded. The latest section describes the test procedure.","title":"Upgrade Process"},{"location":"architecture/contracts/Upgrades/#quickstart","text":"The first step to work with zos is to install dependencies then initialize the project. Then compile contracts and add contracts to the project. Finally push the contracts into the network and create the upgradable instances. Once the contracts are deployed they can be tested and upgraded. Also we change the proxy administrator to a MultiSignature wallet to approve upgrades. We are going to use the Nevermined Contract Tools in order to perform any future deployments/upgrades.","title":"Quickstart"},{"location":"architecture/contracts/Upgrades/#details","text":"Here we provide more details into each step of the initial deploy and the approach of upgradeability and governance.","title":"Details"},{"location":"architecture/contracts/Upgrades/#roles","text":"Before going into more details about the deployment. We should differentiate between different roles in the system which govern the upgradeability in nevermined-contracts. Roles are defined as follows: deployer: represented as accounts[0] upgrader: represented as accounts[1] governor: represented as accounts[1] upgraderWallet: represented as the upgrader from wallets.json ownerWallet: represented as the owner from wallets.json governorWallet: represented as the owner from wallets.json - Deployer : Can be any account. It is used for deploying the initial proxy contracts and the logic contracts . Upgrader : Has to be an owner of the upgrader multi sig wallet. It is used for issuing upgrade requests against the upgrader multi sig wallet.","title":"Roles"},{"location":"architecture/contracts/Upgrades/#-governor-has-to-have-the-governor_role-in-the-contracts-it-is-used-for-issuing-upgrade-config-requests","text":"UpgraderWallet : One instance of the multi sig wallet, defined as upgrader . This wallet will be assigned as zos admin and is required to do upgrades. OwnerWallet : One instance of the multi sig wallet, defined as owner . This wallet will be assigned as the owner of all the contracts. It can be used to call specific functions in the contracts ie. change the configuration. GovernorWallet : One instance of the multi sig wallet, defined as governor . This wallet will be assigned as zos admin and is required to do config updates in a Nevermined deployment.","title":"- Governor: Has to have the GOVERNOR_ROLE in the contracts. It is used for issuing upgrade config requests."},{"location":"architecture/contracts/Upgrades/#deploy-upgrade","text":"zos does not support migrations, hence all the initial configuration should be performed with Nevermined Contract Tools . Contract constructors are ignored so the initial setup of the contract should be made in a initialize function that will be executed only once after the initial deployment.","title":"Deploy &amp; Upgrade"},{"location":"architecture/contracts/Upgrades/#1-configuration","text":"Nevermined Contract Tools checks the contracts.json in order to detect the current contracts that are going to be deployed: [ \"ConditionStoreManager\" , \"TemplateStoreManager\" , \"AgreementStoreManager\" , \"SignCondition\" , \"HashLockCondition\" , \"LockRewardCondition\" , \"NFTHolderCondition\" , \"AccessCondition\" , \"EscrowReward\" , \"EscrowAccessSecretStoreTemplate\" , \"NFTAccessTemplate\" , \"DIDRegistry\" ] Moreover for each network, Nevermined Contract Tools needs to detect the roles and their addresses from a pre-defined wallets config file. The following configuration should be an example for wallets-<NETWORK_NAME>.json : [ { \"name\" : \"upgrader\" , \"address\" : \"0x24eb26d4042a2ab576e7e39b87c3f33f276aef92\" }, { \"name\" : \"owner\" , \"address\" : \"0xd02d68c62401472ce35ba3c7e505deae62db2b8b\" }, { \"name\" : \"governor\" , \"address\" : \"0xeeff68c62401472ce35ba3c7e505deae62db2b8b\" } ]","title":"1. Configuration"},{"location":"architecture/contracts/Upgrades/#2-preparation","text":"The following commands clean, install dependencies and compile the contracts: $ yarn clean #to clean the work dir $ yarn #install dependencies $ yarn compile #to compile the contracts","title":"2. Preparation"},{"location":"architecture/contracts/Upgrades/#3-deploy-upgrade","text":"The following steps shows how to perform contracts deployment and upgrade on Rinkeby and Kovan networks.","title":"3. Deploy &amp; Upgrade"},{"location":"architecture/contracts/Upgrades/#nile","text":"Copy the wallet file for rinkeby cp wallets_rinkeby.json wallets.json run export MNEMONIC=<your staging mnemonic> . You will find them in the password manager.","title":"Nile"},{"location":"architecture/contracts/Upgrades/#deploy-the-whole-application","text":"To deploy all contracts run yarn deploy:rinkeby","title":"Deploy the whole application"},{"location":"architecture/contracts/Upgrades/#deploy-a-single-contracts","text":"To deploy a single contract you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:rinkeby -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser .","title":"Deploy a single contracts"},{"location":"architecture/contracts/Upgrades/#upgrade-the-whole-application","text":"To upgrade all contracts run yarn upgrade:rinkeby","title":"Upgrade the whole application"},{"location":"architecture/contracts/Upgrades/#upgrade-a-single-contract","text":"To upgrade a single contract run yarn upgrade:rinkeby -- NeverminedToken . For upgrading the NeverminedToken contract.","title":"Upgrade a single contract"},{"location":"architecture/contracts/Upgrades/#persist-artifacts","text":"Commit all changes in artifacts/*.rinkeby.json","title":"Persist artifacts"},{"location":"architecture/contracts/Upgrades/#kovan","text":"Copy the wallet file for kovan > cp wallets_kovan.json wallets.json run export MNEMONIC=<your kovan mnemonic> . You will find them in the password manager. run export INFURA_TOKEN=<your infura token> . You will get it from infura .","title":"Kovan"},{"location":"architecture/contracts/Upgrades/#deploy-the-whole-application_1","text":"To deploy all the contracts run yarn deploy:kovan","title":"Deploy the whole application"},{"location":"architecture/contracts/Upgrades/#deploy-a-single-contracts_1","text":"To deploy a single contracts you need to specify the contracts to deploy as a parameter to the deploy script: ie. yarn deploy:kovan -- NeverminedToken Dispenser will deploy NeverminedToken and Dispenser .","title":"Deploy a single contracts"},{"location":"architecture/contracts/Upgrades/#upgrade-the-whole-application_1","text":"To upgrade all contracts run yarn upgrade:kovan","title":"Upgrade the whole application"},{"location":"architecture/contracts/Upgrades/#upgrade-a-single-contract_1","text":"To upgrade a single contract run yarn upgrade:kovan -- NeverminedToken . For upgrading the NeverminedToken contract.","title":"Upgrade a single contract"},{"location":"architecture/contracts/Upgrades/#persist-artifacts_1","text":"Commit all changes in artifacts/*.kovan.json","title":"Persist artifacts"},{"location":"architecture/contracts/Upgrades/#4-approve-upgrades","text":"All upgrades of the contracts have to be approved by the upgrader wallet configured in the wallets.json file. go to https://wallet.gnosis.pm Load upgrader wallet Select an Ethereum Account that is an owner of the multi sig wallet, but not the one who issued the upgrade request. This can be done in the following ways: Connect to a local Blockchain node that holds the private key. Connect to MetaMask and select the owner account from the multi sig wallet. Connect a hardware wallet like ledger or trezor. Select the transaction you want to confirm (the upgrade script will tell you which transactions have to be approved in which wallets) Click Confirm","title":"4. Approve Upgrade(s)"},{"location":"architecture/contracts/Upgrades/#5-audit-contracts","text":"To check or document that all transactions have been approved in the multi sig wallet you can run yarn audit:rinkeby to get a list of all the current transactions and their current status. Wallet: 0x24EB26D4042a2AB576E7E39b87c3f33f276AeF92 Transaction ID: 64 Destination: 0xfA16d26e9F4fffC6e40963B281a0bB08C31ed40C Contract: EscrowAccessSecretStoreTemplate Data is `upgradeTo` call: true Confirmed from: 0x7A13E1aD23546c9b804aDFd13e9AcB184EfCAF58 Executed: false","title":"5. Audit Contracts"},{"location":"architecture/contracts/Upgrades/#6-documentation","text":"Update the addresses in the README.md run node ./scripts/contracts/get-addresses.js <network name> It will output the current proxy addresses in the README friendly format. | AccessCondition | v0.9.0 | 0x45DE141F8Efc355F1451a102FB6225F1EDd2921d | | AgreementStoreManager | v0.9.0 | 0x62f84700b1A0ea6Bfb505aDC3c0286B7944D247C | | ConditionStoreManager | v0.9.0 | 0x39b0AA775496C5ebf26f3B81C9ed1843f09eE466 | | DIDRegistry | v0.9.0 | 0x4A0f7F763B1A7937aED21D63b2A78adc89c5Db23 | | DIDRegistryLibrary | v0.9.0 | 0x3B3504908Db36f5D5f07CD420ee2BBBbDfB674cF | | Dispenser | v0.9.0 | 0x865396b7ddc58C693db7FCAD1168E3BD95Fe3368 | .... Copy this to the README.md","title":"6. Documentation"},{"location":"architecture/contracts/contracts/Common/","text":"Functions \u00b6 getCurrentBlockNumber \u00b6 function getCurrentBlockNumber ( ) external returns ( uint256 ) getCurrentBlockNumber get block number Return Values: \u00b6 Name Type Description the current block number ### isContract function isContract ( ) public returns ( bool ) isContract detect whether the address is is a contract address or externally owned account Return Values: \u00b6 Name Type Description true address if it is a contract address ### provenanceSignatureIsCorrect function provenanceSignatureIsCorrect ( address _agentId , bytes32 _hash , bytes _signature ) public returns ( bool ) Parameters: \u00b6 Name Type Description _agentId address The address of the agent _hash bytes32 bytes32 message, the hash is the signed message. What is recovered is the signer address. _signature bytes Signatures provided by the agent Return Values: \u00b6 Name Type Description true address if the signature correspond to the agent address ### calculateTotalAmount function calculateTotalAmount ( ) public returns ( uint256 ) Sum the total amount given an uint array Return Values: \u00b6 Name Type Description the uint256[] total amount","title":"Common"},{"location":"architecture/contracts/contracts/Common/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/Common/#getcurrentblocknumber","text":"function getCurrentBlockNumber ( ) external returns ( uint256 ) getCurrentBlockNumber get block number","title":"getCurrentBlockNumber"},{"location":"architecture/contracts/contracts/Common/#return-values","text":"Name Type Description the current block number ### isContract function isContract ( ) public returns ( bool ) isContract detect whether the address is is a contract address or externally owned account","title":"Return Values:"},{"location":"architecture/contracts/contracts/Common/#return-values_1","text":"Name Type Description true address if it is a contract address ### provenanceSignatureIsCorrect function provenanceSignatureIsCorrect ( address _agentId , bytes32 _hash , bytes _signature ) public returns ( bool )","title":"Return Values:"},{"location":"architecture/contracts/contracts/Common/#parameters","text":"Name Type Description _agentId address The address of the agent _hash bytes32 bytes32 message, the hash is the signed message. What is recovered is the signer address. _signature bytes Signatures provided by the agent","title":"Parameters:"},{"location":"architecture/contracts/contracts/Common/#return-values_2","text":"Name Type Description true address if the signature correspond to the agent address ### calculateTotalAmount function calculateTotalAmount ( ) public returns ( uint256 ) Sum the total amount given an uint array","title":"Return Values:"},{"location":"architecture/contracts/contracts/Common/#return-values_3","text":"Name Type Description the uint256[] total amount","title":"Return Values:"},{"location":"architecture/contracts/contracts/Dispenser/","text":"Functions \u00b6 initialize \u00b6 function initialize ( address _tokenAddress , address _owner ) external Dispenser Initializer Parameters: \u00b6 Name Type Description _tokenAddress address The deployed contract address of an ERC20 _owner address The owner of the Dispenser Runs only on initial contract creation. requestTokens \u00b6 function requestTokens ( uint256 amount ) external returns ( bool tokensTransferred ) user can request some tokens for testing Parameters: \u00b6 Name Type Description amount uint256 the amount of tokens to be requested Return Values: \u00b6 Name Type Description tokensTransferred uint256 Boolean indication of tokens are requested ### setMinPeriod function setMinPeriod ( uint256 period ) external the Owner can set the min period for token requests Parameters: \u00b6 Name Type Description period uint256 the min amount of time before next request setMaxAmount \u00b6 function setMaxAmount ( uint256 amount ) external the Owner can set the max amount for token requests Parameters: \u00b6 Name Type Description amount uint256 the max amount of tokens that can be requested setMaxMintAmount \u00b6 function setMaxMintAmount ( uint256 amount ) external the Owner can set the max amount for token requests Parameters: \u00b6 Name Type Description amount uint256 the max amount of tokens that can be requested Events \u00b6 RequestFrequencyExceeded \u00b6 event RequestFrequencyExceeded ( ) RequestLimitExceeded \u00b6 event RequestLimitExceeded ( )","title":"Dispenser"},{"location":"architecture/contracts/contracts/Dispenser/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/Dispenser/#initialize","text":"function initialize ( address _tokenAddress , address _owner ) external Dispenser Initializer","title":"initialize"},{"location":"architecture/contracts/contracts/Dispenser/#parameters","text":"Name Type Description _tokenAddress address The deployed contract address of an ERC20 _owner address The owner of the Dispenser Runs only on initial contract creation.","title":"Parameters:"},{"location":"architecture/contracts/contracts/Dispenser/#requesttokens","text":"function requestTokens ( uint256 amount ) external returns ( bool tokensTransferred ) user can request some tokens for testing","title":"requestTokens"},{"location":"architecture/contracts/contracts/Dispenser/#parameters_1","text":"Name Type Description amount uint256 the amount of tokens to be requested","title":"Parameters:"},{"location":"architecture/contracts/contracts/Dispenser/#return-values","text":"Name Type Description tokensTransferred uint256 Boolean indication of tokens are requested ### setMinPeriod function setMinPeriod ( uint256 period ) external the Owner can set the min period for token requests","title":"Return Values:"},{"location":"architecture/contracts/contracts/Dispenser/#parameters_2","text":"Name Type Description period uint256 the min amount of time before next request","title":"Parameters:"},{"location":"architecture/contracts/contracts/Dispenser/#setmaxamount","text":"function setMaxAmount ( uint256 amount ) external the Owner can set the max amount for token requests","title":"setMaxAmount"},{"location":"architecture/contracts/contracts/Dispenser/#parameters_3","text":"Name Type Description amount uint256 the max amount of tokens that can be requested","title":"Parameters:"},{"location":"architecture/contracts/contracts/Dispenser/#setmaxmintamount","text":"function setMaxMintAmount ( uint256 amount ) external the Owner can set the max amount for token requests","title":"setMaxMintAmount"},{"location":"architecture/contracts/contracts/Dispenser/#parameters_4","text":"Name Type Description amount uint256 the max amount of tokens that can be requested","title":"Parameters:"},{"location":"architecture/contracts/contracts/Dispenser/#events","text":"","title":"Events"},{"location":"architecture/contracts/contracts/Dispenser/#requestfrequencyexceeded","text":"event RequestFrequencyExceeded ( )","title":"RequestFrequencyExceeded"},{"location":"architecture/contracts/contracts/Dispenser/#requestlimitexceeded","text":"event RequestLimitExceeded ( )","title":"RequestLimitExceeded"},{"location":"architecture/contracts/contracts/HashLists/","text":"Hash lists contract is a sample list contract in which uses HashListLibrary.sol in order to store, retrieve, remove, and update bytes32 values in hash lists. This is a reference implementation for IList interface. It is used for whitelisting condition. Any entity can have its own implementation of the interface in which could be used for the same condition. Functions \u00b6 initialize \u00b6 function initialize ( address _owner ) public HashLists Initializer Parameters: \u00b6 Name Type Description _owner address The owner of the hash list Runs only upon contract creation. hash \u00b6 function hash ( address account ) public returns ( bytes32 ) hash ethereum accounts Parameters: \u00b6 Name Type Description account address Ethereum address Return Values: \u00b6 Name Type Description bytes32 address hash of the account ### add function add ( bytes32 [] values ) external returns ( bool ) put an array of elements without indexing this meant to save gas in case of large arrays Parameters: \u00b6 Name Type Description values bytes32[] is an array of elements value Return Values: \u00b6 Name Type Description true bytes32[] if values are added successfully ### add function add ( bytes32 value ) external returns ( bool ) add indexes an element then adds it to a list Parameters: \u00b6 Name Type Description value bytes32 is a bytes32 value Return Values: \u00b6 Name Type Description true bytes32 if value is added successfully ### update function update ( bytes32 oldValue , bytes32 newValue ) external returns ( bool ) update the value with a new value and maintain indices Parameters: \u00b6 Name Type Description oldValue bytes32 is an element value in a list newValue bytes32 new value Return Values: \u00b6 Name Type Description true bytes32 if value is updated successfully ### index function index ( uint256 from , uint256 to ) external returns ( bool ) index is used to map each element value to its index on the list Parameters: \u00b6 Name Type Description from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing Return Values: \u00b6 Name Type Description true uint256 if the sub list is indexed ### has function has ( bytes32 id , bytes32 value ) external returns ( bool ) has checks whether a value is exist Parameters: \u00b6 Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list Return Values: \u00b6 Name Type Description true bytes32 if the value exists ### has function has ( bytes32 value ) external returns ( bool ) has checks whether a value is exist Parameters: \u00b6 Name Type Description value bytes32 is element value in list Return Values: \u00b6 Name Type Description true bytes32 if the value exists ### remove function remove ( bytes32 value ) external returns ( bool ) remove value from a list, updates indices, and list size Parameters: \u00b6 Name Type Description value bytes32 is an element value in a list Return Values: \u00b6 Name Type Description true bytes32 if value is removed successfully ### get function get ( bytes32 id , uint256 _index ) external returns ( bytes32 ) has value by index Parameters: \u00b6 Name Type Description id bytes32 the list identifier (the hash of list owner's address) _index uint256 is where is value is stored in the list Return Values: \u00b6 Name Type Description the bytes32 value if exists ### size function size ( bytes32 id ) external returns ( uint256 ) size gets the list size Parameters: \u00b6 Name Type Description id bytes32 the list identifier (the hash of list owner's address) Return Values: \u00b6 Name Type Description total bytes32 length of the list ### all function all ( bytes32 id ) external returns ( bytes32 []) all returns all list elements Parameters: \u00b6 Name Type Description id bytes32 the list identifier (the hash of list owner's address) Return Values: \u00b6 Name Type Description all bytes32 list elements ### indexOf function indexOf ( bytes32 id , bytes32 value ) external returns ( uint256 ) indexOf gets the index of a value in a list Parameters: \u00b6 Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list Return Values: \u00b6 Name Type Description value bytes32 index in list ### ownedBy function ownedBy ( bytes32 id ) external returns ( address ) ownedBy gets the list owner Parameters: \u00b6 Name Type Description id bytes32 the list identifier (the hash of list owner's address) Return Values: \u00b6 Name Type Description list bytes32 owner ### isIndexed function isIndexed ( bytes32 id ) external returns ( bool ) isIndexed checks if the list is indexed Parameters: \u00b6 Name Type Description id bytes32 the list identifier (the hash of list owner's address) Return Values: \u00b6 Name Type Description true bytes32 if the list is indexed","title":"HashLists"},{"location":"architecture/contracts/contracts/HashLists/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/HashLists/#initialize","text":"function initialize ( address _owner ) public HashLists Initializer","title":"initialize"},{"location":"architecture/contracts/contracts/HashLists/#parameters","text":"Name Type Description _owner address The owner of the hash list Runs only upon contract creation.","title":"Parameters:"},{"location":"architecture/contracts/contracts/HashLists/#hash","text":"function hash ( address account ) public returns ( bytes32 ) hash ethereum accounts","title":"hash"},{"location":"architecture/contracts/contracts/HashLists/#parameters_1","text":"Name Type Description account address Ethereum address","title":"Parameters:"},{"location":"architecture/contracts/contracts/HashLists/#return-values","text":"Name Type Description bytes32 address hash of the account ### add function add ( bytes32 [] values ) external returns ( bool ) put an array of elements without indexing this meant to save gas in case of large arrays","title":"Return Values:"},{"location":"architecture/contracts/contracts/HashLists/#parameters_2","text":"Name Type Description values bytes32[] is an array of elements value","title":"Parameters:"},{"location":"architecture/contracts/contracts/HashLists/#return-values_1","text":"Name Type Description true bytes32[] if values are added successfully ### add function add ( bytes32 value ) external returns ( bool ) add indexes an element then adds it to a list","title":"Return Values:"},{"location":"architecture/contracts/contracts/HashLists/#parameters_3","text":"Name Type Description value bytes32 is a bytes32 value","title":"Parameters:"},{"location":"architecture/contracts/contracts/HashLists/#return-values_2","text":"Name Type Description true bytes32 if value is added successfully ### update function update ( bytes32 oldValue , bytes32 newValue ) external returns ( bool ) update the value with a new value and maintain indices","title":"Return Values:"},{"location":"architecture/contracts/contracts/HashLists/#parameters_4","text":"Name Type Description oldValue bytes32 is an element value in a list newValue bytes32 new value","title":"Parameters:"},{"location":"architecture/contracts/contracts/HashLists/#return-values_3","text":"Name Type Description true bytes32 if value is updated successfully ### index function index ( uint256 from , uint256 to ) external returns ( bool ) index is used to map each element value to its index on the list","title":"Return Values:"},{"location":"architecture/contracts/contracts/HashLists/#parameters_5","text":"Name Type Description from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing","title":"Parameters:"},{"location":"architecture/contracts/contracts/HashLists/#return-values_4","text":"Name Type Description true uint256 if the sub list is indexed ### has function has ( bytes32 id , bytes32 value ) external returns ( bool ) has checks whether a value is exist","title":"Return Values:"},{"location":"architecture/contracts/contracts/HashLists/#parameters_6","text":"Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list","title":"Parameters:"},{"location":"architecture/contracts/contracts/HashLists/#return-values_5","text":"Name Type Description true bytes32 if the value exists ### has function has ( bytes32 value ) external returns ( bool ) has checks whether a value is exist","title":"Return Values:"},{"location":"architecture/contracts/contracts/HashLists/#parameters_7","text":"Name Type Description value bytes32 is element value in list","title":"Parameters:"},{"location":"architecture/contracts/contracts/HashLists/#return-values_6","text":"Name Type Description true bytes32 if the value exists ### remove function remove ( bytes32 value ) external returns ( bool ) remove value from a list, updates indices, and list size","title":"Return Values:"},{"location":"architecture/contracts/contracts/HashLists/#parameters_8","text":"Name Type Description value bytes32 is an element value in a list","title":"Parameters:"},{"location":"architecture/contracts/contracts/HashLists/#return-values_7","text":"Name Type Description true bytes32 if value is removed successfully ### get function get ( bytes32 id , uint256 _index ) external returns ( bytes32 ) has value by index","title":"Return Values:"},{"location":"architecture/contracts/contracts/HashLists/#parameters_9","text":"Name Type Description id bytes32 the list identifier (the hash of list owner's address) _index uint256 is where is value is stored in the list","title":"Parameters:"},{"location":"architecture/contracts/contracts/HashLists/#return-values_8","text":"Name Type Description the bytes32 value if exists ### size function size ( bytes32 id ) external returns ( uint256 ) size gets the list size","title":"Return Values:"},{"location":"architecture/contracts/contracts/HashLists/#parameters_10","text":"Name Type Description id bytes32 the list identifier (the hash of list owner's address)","title":"Parameters:"},{"location":"architecture/contracts/contracts/HashLists/#return-values_9","text":"Name Type Description total bytes32 length of the list ### all function all ( bytes32 id ) external returns ( bytes32 []) all returns all list elements","title":"Return Values:"},{"location":"architecture/contracts/contracts/HashLists/#parameters_11","text":"Name Type Description id bytes32 the list identifier (the hash of list owner's address)","title":"Parameters:"},{"location":"architecture/contracts/contracts/HashLists/#return-values_10","text":"Name Type Description all bytes32 list elements ### indexOf function indexOf ( bytes32 id , bytes32 value ) external returns ( uint256 ) indexOf gets the index of a value in a list","title":"Return Values:"},{"location":"architecture/contracts/contracts/HashLists/#parameters_12","text":"Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list","title":"Parameters:"},{"location":"architecture/contracts/contracts/HashLists/#return-values_11","text":"Name Type Description value bytes32 index in list ### ownedBy function ownedBy ( bytes32 id ) external returns ( address ) ownedBy gets the list owner","title":"Return Values:"},{"location":"architecture/contracts/contracts/HashLists/#parameters_13","text":"Name Type Description id bytes32 the list identifier (the hash of list owner's address)","title":"Parameters:"},{"location":"architecture/contracts/contracts/HashLists/#return-values_12","text":"Name Type Description list bytes32 owner ### isIndexed function isIndexed ( bytes32 id ) external returns ( bool ) isIndexed checks if the list is indexed","title":"Return Values:"},{"location":"architecture/contracts/contracts/HashLists/#parameters_14","text":"Name Type Description id bytes32 the list identifier (the hash of list owner's address)","title":"Parameters:"},{"location":"architecture/contracts/contracts/HashLists/#return-values_13","text":"Name Type Description true bytes32 if the list is indexed","title":"Return Values:"},{"location":"architecture/contracts/contracts/NeverminedToken/","text":"Implementation of a Test Token. Test Token is an ERC20 token only for testing purposes Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address payable _initialMinter ) public NeverminedToken Initializer Runs only on initial contract creation. Parameters: \u00b6 Name Type Description _owner address refers to the owner of the contract _initialMinter address payable is the first token minter added _beforeTokenTransfer \u00b6 function _beforeTokenTransfer ( ) internal See {ERC20-_beforeTokenTransfer}. Requirements: minted tokens must not cause the total supply to go over the cap. mint \u00b6 function mint ( ) external returns ( bool ) Creates amount tokens and assigns them to account , increasing the total supply. Emits a {Transfer} event with from set to the zero address. Requirements: to cannot be the zero address.","title":"NeverminedToken"},{"location":"architecture/contracts/contracts/NeverminedToken/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/NeverminedToken/#initialize","text":"function initialize ( address _owner , address payable _initialMinter ) public NeverminedToken Initializer Runs only on initial contract creation.","title":"initialize"},{"location":"architecture/contracts/contracts/NeverminedToken/#parameters","text":"Name Type Description _owner address refers to the owner of the contract _initialMinter address payable is the first token minter added","title":"Parameters:"},{"location":"architecture/contracts/contracts/NeverminedToken/#_beforetokentransfer","text":"function _beforeTokenTransfer ( ) internal See {ERC20-_beforeTokenTransfer}. Requirements: minted tokens must not cause the total supply to go over the cap.","title":"_beforeTokenTransfer"},{"location":"architecture/contracts/contracts/NeverminedToken/#mint","text":"function mint ( ) external returns ( bool ) Creates amount tokens and assigns them to account , increasing the total supply. Emits a {Transfer} event with from set to the zero address. Requirements: to cannot be the zero address.","title":"mint"},{"location":"architecture/contracts/contracts/PlonkVerifier/","text":"Functions \u00b6 verifyProof \u00b6 function verifyProof ( ) public returns ( bool )","title":"PlonkVerifier"},{"location":"architecture/contracts/contracts/PlonkVerifier/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/PlonkVerifier/#verifyproof","text":"function verifyProof ( ) public returns ( bool )","title":"verifyProof"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreLibrary/","text":"Implementation of the Agreement Store Library. The agreement store library holds the business logic in which manages the life cycle of SEA agreement, each agreement is linked to the DID of an asset, template, and condition IDs. Functions \u00b6 create \u00b6 function create ( struct AgreementStoreLibrary . AgreementList _self , bytes32 _id , bytes32 _did , address _templateId , bytes32 [] _conditionIds ) internal returns ( uint256 size ) create new agreement checks whether the agreement Id exists, creates new agreement instance, including the template, conditions and DID. Parameters: \u00b6 Name Type Description _self struct AgreementStoreLibrary.AgreementList is AgreementList storage pointer _id bytes32 agreement identifier _did bytes32 asset decentralized identifier _templateId address template identifier _conditionIds bytes32[] array of condition identifiers Return Values: \u00b6 Name Type Description size struct AgreementStoreLibrary.AgreementList which is the index of the created agreement","title":"AgreementStoreLibrary"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreLibrary/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreLibrary/#create","text":"function create ( struct AgreementStoreLibrary . AgreementList _self , bytes32 _id , bytes32 _did , address _templateId , bytes32 [] _conditionIds ) internal returns ( uint256 size ) create new agreement checks whether the agreement Id exists, creates new agreement instance, including the template, conditions and DID.","title":"create"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreLibrary/#parameters","text":"Name Type Description _self struct AgreementStoreLibrary.AgreementList is AgreementList storage pointer _id bytes32 agreement identifier _did bytes32 asset decentralized identifier _templateId address template identifier _conditionIds bytes32[] array of condition identifiers","title":"Parameters:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreLibrary/#return-values","text":"Name Type Description size struct AgreementStoreLibrary.AgreementList which is the index of the created agreement","title":"Return Values:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/","text":"Implementation of the Agreement Store. The agreement store generates conditions for an agreement template. Agreement templates must to be approved in the Template Store Each agreement is linked to the DID of an asset. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _templateStoreManagerAddress , address _didRegistryAddress ) public initialize AgreementStoreManager Initializer Initializes Ownable. Only on contract creation. Parameters: \u00b6 Name Type Description _owner address refers to the owner of the contract _conditionStoreManagerAddress address is the address of the connected condition store _templateStoreManagerAddress address is the address of the connected template store _didRegistryAddress address is the address of the connected DID Registry createAgreement \u00b6 function createAgreement ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts ) public returns ( uint256 size ) Create a new agreement and associate the agreement created to the address originating the transaction. The agreement will create conditions of conditionType with conditionId. Only \"approved\" templates can access this function. Parameters: \u00b6 Name Type Description _id bytes32 is the ID of the new agreement. Must be unique. _did bytes32 is the bytes32 DID of the asset. The DID must be registered beforehand. _conditionTypes address[] is a list of addresses that point to Condition contracts. _conditionIds bytes32[] is a list of bytes32 content-addressed Condition IDs _timeLocks uint256[] is a list of uint time lock values associated to each Condition _timeOuts uint256[] is a list of uint time out values associated to each Condition Return Values: \u00b6 Name Type Description size bytes32 the size of the agreement list after the create action. ### createAgreement function createAgreement ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _creator ) public returns ( uint256 size ) Create a new agreement. The agreement will create conditions of conditionType with conditionId. Only \"approved\" templates can access this function. Parameters: \u00b6 Name Type Description _id bytes32 is the ID of the new agreement. Must be unique. _did bytes32 is the bytes32 DID of the asset. The DID must be registered beforehand. _conditionTypes address[] is a list of addresses that point to Condition contracts. _conditionIds bytes32[] is a list of bytes32 content-addressed Condition IDs _timeLocks uint256[] is a list of uint time lock values associated to each Condition _timeOuts uint256[] is a list of uint time out values associated to each Condition _creator address address of the account associated as agreement and conditions creator Return Values: \u00b6 Name Type Description size bytes32 the size of the agreement list after the create action. ### getAgreement function getAgreement ( bytes32 _id ) external returns ( bytes32 did , address didOwner , address templateId , bytes32 [] conditionIds , address lastUpdatedBy , uint256 blockNumberUpdated ) Get agreement with _id. The agreement will create conditions of conditionType with conditionId. Only \"approved\" templates can access this function. Parameters: \u00b6 Name Type Description _id bytes32 is the ID of the agreement. getAgreementDIDOwner \u00b6 function getAgreementDIDOwner ( bytes32 _id ) external returns ( address didOwner ) get the DID owner for this agreement with _id. Parameters: \u00b6 Name Type Description _id bytes32 is the ID of the agreement. Return Values: \u00b6 Name Type Description didOwner bytes32 the DID owner associated with agreement.did from the DID registry. ### isAgreementDIDOwner function isAgreementDIDOwner ( bytes32 _id , address _owner ) external returns ( bool ) check the DID owner for this agreement with _id. Parameters: \u00b6 Name Type Description _id bytes32 is the ID of the agreement. _owner address is the DID owner Return Values: \u00b6 Name Type Description the bytes32 DID owner associated with agreement.did from the DID registry. ### isAgreementDIDProvider function isAgreementDIDProvider ( bytes32 _id , address _provider ) external returns ( bool ) isAgreementDIDProvider for a given agreement Id and address check whether a DID provider is associated with this agreement Parameters: \u00b6 Name Type Description _id bytes32 is the ID of the agreement _provider address is the DID provider Return Values: \u00b6 Name Type Description true bytes32 if a DID provider is associated with the agreement ID ### getAgreementListSize function getAgreementListSize ( ) public returns ( uint256 size ) Return Values: \u00b6 Name Type Description size the length of the agreement list. ### getAgreementIdsForDID function getAgreementIdsForDID ( bytes32 _did ) public returns ( bytes32 []) Parameters: \u00b6 Name Type Description _did bytes32 is the bytes32 DID of the asset. Return Values: \u00b6 Name Type Description the bytes32 agreement IDs for a given DID ### getAgreementIdsForTemplateId function getAgreementIdsForTemplateId ( address _templateId ) public returns ( bytes32 []) Parameters: \u00b6 Name Type Description _templateId address is the address of the agreement template. Return Values: \u00b6 Name Type Description the address agreement IDs for a given DID ### getDIDRegistryAddress function getDIDRegistryAddress ( ) public returns ( address ) getDIDRegistryAddress utility function used by other contracts or any EOA. Return Values: \u00b6 Name Type Description the DIDRegistry address","title":"AgreementStoreManager"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _templateStoreManagerAddress , address _didRegistryAddress ) public initialize AgreementStoreManager Initializer Initializes Ownable. Only on contract creation.","title":"initialize"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#parameters","text":"Name Type Description _owner address refers to the owner of the contract _conditionStoreManagerAddress address is the address of the connected condition store _templateStoreManagerAddress address is the address of the connected template store _didRegistryAddress address is the address of the connected DID Registry","title":"Parameters:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#createagreement","text":"function createAgreement ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts ) public returns ( uint256 size ) Create a new agreement and associate the agreement created to the address originating the transaction. The agreement will create conditions of conditionType with conditionId. Only \"approved\" templates can access this function.","title":"createAgreement"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#parameters_1","text":"Name Type Description _id bytes32 is the ID of the new agreement. Must be unique. _did bytes32 is the bytes32 DID of the asset. The DID must be registered beforehand. _conditionTypes address[] is a list of addresses that point to Condition contracts. _conditionIds bytes32[] is a list of bytes32 content-addressed Condition IDs _timeLocks uint256[] is a list of uint time lock values associated to each Condition _timeOuts uint256[] is a list of uint time out values associated to each Condition","title":"Parameters:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#return-values","text":"Name Type Description size bytes32 the size of the agreement list after the create action. ### createAgreement function createAgreement ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _creator ) public returns ( uint256 size ) Create a new agreement. The agreement will create conditions of conditionType with conditionId. Only \"approved\" templates can access this function.","title":"Return Values:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#parameters_2","text":"Name Type Description _id bytes32 is the ID of the new agreement. Must be unique. _did bytes32 is the bytes32 DID of the asset. The DID must be registered beforehand. _conditionTypes address[] is a list of addresses that point to Condition contracts. _conditionIds bytes32[] is a list of bytes32 content-addressed Condition IDs _timeLocks uint256[] is a list of uint time lock values associated to each Condition _timeOuts uint256[] is a list of uint time out values associated to each Condition _creator address address of the account associated as agreement and conditions creator","title":"Parameters:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#return-values_1","text":"Name Type Description size bytes32 the size of the agreement list after the create action. ### getAgreement function getAgreement ( bytes32 _id ) external returns ( bytes32 did , address didOwner , address templateId , bytes32 [] conditionIds , address lastUpdatedBy , uint256 blockNumberUpdated ) Get agreement with _id. The agreement will create conditions of conditionType with conditionId. Only \"approved\" templates can access this function.","title":"Return Values:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#parameters_3","text":"Name Type Description _id bytes32 is the ID of the agreement.","title":"Parameters:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#getagreementdidowner","text":"function getAgreementDIDOwner ( bytes32 _id ) external returns ( address didOwner ) get the DID owner for this agreement with _id.","title":"getAgreementDIDOwner"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#parameters_4","text":"Name Type Description _id bytes32 is the ID of the agreement.","title":"Parameters:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#return-values_2","text":"Name Type Description didOwner bytes32 the DID owner associated with agreement.did from the DID registry. ### isAgreementDIDOwner function isAgreementDIDOwner ( bytes32 _id , address _owner ) external returns ( bool ) check the DID owner for this agreement with _id.","title":"Return Values:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#parameters_5","text":"Name Type Description _id bytes32 is the ID of the agreement. _owner address is the DID owner","title":"Parameters:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#return-values_3","text":"Name Type Description the bytes32 DID owner associated with agreement.did from the DID registry. ### isAgreementDIDProvider function isAgreementDIDProvider ( bytes32 _id , address _provider ) external returns ( bool ) isAgreementDIDProvider for a given agreement Id and address check whether a DID provider is associated with this agreement","title":"Return Values:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#parameters_6","text":"Name Type Description _id bytes32 is the ID of the agreement _provider address is the DID provider","title":"Parameters:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#return-values_4","text":"Name Type Description true bytes32 if a DID provider is associated with the agreement ID ### getAgreementListSize function getAgreementListSize ( ) public returns ( uint256 size )","title":"Return Values:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#return-values_5","text":"Name Type Description size the length of the agreement list. ### getAgreementIdsForDID function getAgreementIdsForDID ( bytes32 _did ) public returns ( bytes32 [])","title":"Return Values:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#parameters_7","text":"Name Type Description _did bytes32 is the bytes32 DID of the asset.","title":"Parameters:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#return-values_6","text":"Name Type Description the bytes32 agreement IDs for a given DID ### getAgreementIdsForTemplateId function getAgreementIdsForTemplateId ( address _templateId ) public returns ( bytes32 [])","title":"Return Values:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#parameters_8","text":"Name Type Description _templateId address is the address of the agreement template.","title":"Parameters:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#return-values_7","text":"Name Type Description the address agreement IDs for a given DID ### getDIDRegistryAddress function getDIDRegistryAddress ( ) public returns ( address ) getDIDRegistryAddress utility function used by other contracts or any EOA.","title":"Return Values:"},{"location":"architecture/contracts/contracts/agreements/AgreementStoreManager/#return-values_8","text":"Name Type Description the DIDRegistry address","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/AccessCondition/","text":"Implementation of the Access Condition Access Secret Store Condition is special condition where a client or Parity secret store can encrypt/decrypt documents based on the on-chain granted permissions. For a given DID document, and agreement ID, the owner/provider of the DID will fulfill the condition. Consequently secret store will check whether the permission is granted for the consumer in order to encrypt/decrypt the document. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address hashValues \u00b6 function hashValues ( bytes32 _documentId , address _grantee ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill access secret store condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ### grantPermission function grantPermission ( address _grantee , bytes32 _documentId ) public grantPermission is called only by DID owner or provider Parameters: \u00b6 Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys renouncePermission \u00b6 function renouncePermission ( address _grantee , bytes32 _documentId ) public renouncePermission is called only by DID owner or provider Parameters: \u00b6 Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys checkPermissions \u00b6 function checkPermissions ( address _documentId , bytes32 _grantee ) external returns ( bool permissionGranted ) checkPermissions is called by Parity secret store Parameters: \u00b6 Name Type Description _documentId address refers to the DID in which secret store will issue the decryption keys _grantee bytes32 is the address of the granted user or the DID provider Return Values: \u00b6 Name Type Description permissionGranted address true if the access was granted ## Events ### Fulfilled event Fulfilled ( )","title":"AccessCondition"},{"location":"architecture/contracts/contracts/conditions/AccessCondition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/AccessCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/AccessCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/AccessCondition/#hashvalues","text":"function hashValues ( bytes32 _documentId , address _grantee ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/AccessCondition/#parameters_1","text":"Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/AccessCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill access secret store condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/AccessCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/AccessCondition/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ### grantPermission function grantPermission ( address _grantee , bytes32 _documentId ) public grantPermission is called only by DID owner or provider","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/AccessCondition/#parameters_3","text":"Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/AccessCondition/#renouncepermission","text":"function renouncePermission ( address _grantee , bytes32 _documentId ) public renouncePermission is called only by DID owner or provider","title":"renouncePermission"},{"location":"architecture/contracts/contracts/conditions/AccessCondition/#parameters_4","text":"Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/AccessCondition/#checkpermissions","text":"function checkPermissions ( address _documentId , bytes32 _grantee ) external returns ( bool permissionGranted ) checkPermissions is called by Parity secret store","title":"checkPermissions"},{"location":"architecture/contracts/contracts/conditions/AccessCondition/#parameters_5","text":"Name Type Description _documentId address refers to the DID in which secret store will issue the decryption keys _grantee bytes32 is the address of the granted user or the DID provider","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/AccessCondition/#return-values_2","text":"Name Type Description permissionGranted address true if the access was granted ## Events ### Fulfilled event Fulfilled ( )","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/AccessProofCondition/","text":"Implementation of the Access Condition with transfer proof. The idea is that the hash of the decryption key is known before hand, and the key matching this hash is passed from data provider to the buyer using this smart contract. Using ZK proof the key is kept hidden from outsiders. For the protocol to work, both the provider and buyer need to have public keys in the babyjub curve. To initiate the deal, buyer will pass the key hash and the public keys of participants. The provider needs to pass the cipher text encrypted using MIMC (symmetric encryption). The secret key for MIMC is computed using ECDH (requires one public key and one secret key for the curve). The hash function that is used is Poseidon. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress , address _disputeManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address _disputeManagerAddress address dispute manager address hashValues \u00b6 function hashValues ( uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _origHash uint256 is the hash of the key _buyer uint256[2] buyer public key _provider uint256[2] provider public key Return Values: \u00b6 Name Type Description bytes32 uint256 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider , uint256 [ 2 ] _cipher , bytes _proof ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill key transfer The key with hash _origHash is transferred to the _buyer from _provider. Parameters: \u00b6 Name Type Description _agreementId bytes32 associated agreement _origHash uint256 is the hash of data to access _buyer uint256[2] buyer public key _provider uint256[2] provider public key _cipher uint256[2] encrypted version of the key _proof bytes SNARK proof that the cipher text can be decrypted by buyer to give the key with hash _origHash Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"AccessProofCondition"},{"location":"architecture/contracts/contracts/conditions/AccessProofCondition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/AccessProofCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress , address _disputeManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/AccessProofCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address _disputeManagerAddress address dispute manager address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/AccessProofCondition/#hashvalues","text":"function hashValues ( uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/AccessProofCondition/#parameters_1","text":"Name Type Description _origHash uint256 is the hash of the key _buyer uint256[2] buyer public key _provider uint256[2] provider public key","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/AccessProofCondition/#return-values","text":"Name Type Description bytes32 uint256 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider , uint256 [ 2 ] _cipher , bytes _proof ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill key transfer The key with hash _origHash is transferred to the _buyer from _provider.","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/AccessProofCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 associated agreement _origHash uint256 is the hash of data to access _buyer uint256[2] buyer public key _provider uint256[2] provider public key _cipher uint256[2] encrypted version of the key _proof bytes SNARK proof that the cipher text can be decrypted by buyer to give the key with hash _origHash","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/AccessProofCondition/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ComputeExecutionCondition/","text":"Implementation of the Compute Execution Condition This condition is meant to be a signal in which triggers the execution of a compute service. The compute service is fully described in the associated DID document. The provider of the compute service will send this signal to its workers by fulfilling the condition where they are listening to the fulfilled event. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address hashValues \u00b6 function hashValues ( bytes32 _did , address _computeConsumer ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _computeConsumer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill compute execution condition only the compute provider can fulfill this condition. By fulfilling this condition the compute provider will trigger the execution of the offered job/compute. The compute service is described in a DID document. Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ### wasComputeTriggered function wasComputeTriggered ( bytes32 _did , address _computeConsumer ) public returns ( bool ) wasComputeTriggered checks whether the compute is triggered or not. Parameters: \u00b6 Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the compute consumer's address Return Values: \u00b6 Name Type Description true bytes32 if the compute is triggered ## Events ### Fulfilled event Fulfilled ( )","title":"ComputeExecutionCondition"},{"location":"architecture/contracts/contracts/conditions/ComputeExecutionCondition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/ComputeExecutionCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/ComputeExecutionCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/ComputeExecutionCondition/#hashvalues","text":"function hashValues ( bytes32 _did , address _computeConsumer ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/ComputeExecutionCondition/#parameters_1","text":"Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/ComputeExecutionCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _computeConsumer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill compute execution condition only the compute provider can fulfill this condition. By fulfilling this condition the compute provider will trigger the execution of the offered job/compute. The compute service is described in a DID document.","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ComputeExecutionCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 agreement identifier _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/ComputeExecutionCondition/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ### wasComputeTriggered function wasComputeTriggered ( bytes32 _did , address _computeConsumer ) public returns ( bool ) wasComputeTriggered checks whether the compute is triggered or not.","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ComputeExecutionCondition/#parameters_3","text":"Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the compute consumer's address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/ComputeExecutionCondition/#return-values_2","text":"Name Type Description true bytes32 if the compute is triggered ## Events ### Fulfilled event Fulfilled ( )","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/Condition/","text":"Implementation of the Condition Each condition has a validation function that returns either FULFILLED, ABORTED or UNFULFILLED. When a condition is successfully solved, we call it FULFILLED. If a condition cannot be FULFILLED anymore due to a timeout or other types of counter-proofs, the condition is ABORTED. UNFULFILLED values imply that a condition has not been provably FULFILLED or ABORTED. All initialized conditions start out as UNFULFILLED. Functions \u00b6 generateId \u00b6 function generateId ( bytes32 _agreementId , bytes32 _valueHash ) public returns ( bytes32 ) generateId condition Id from the following parameters Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement ID _valueHash bytes32 hash of all the condition input values fulfill \u00b6 function fulfill ( bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) internal returns ( enum ConditionStoreLibrary . ConditionState ) fulfill set the condition state to Fulfill | Abort Parameters: \u00b6 Name Type Description _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState new condition state (Fulfill/Abort) Return Values: \u00b6 Name Type Description the bytes32 updated condition state ### abortByTimeOut function abortByTimeOut ( bytes32 _id ) external returns ( enum ConditionStoreLibrary . ConditionState ) abortByTimeOut set condition state to Aborted if the condition is timed out Parameters: \u00b6 Name Type Description _id bytes32 condition identifier Return Values: \u00b6 Name Type Description the bytes32 updated condition state","title":"Condition"},{"location":"architecture/contracts/contracts/conditions/Condition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/Condition/#generateid","text":"function generateId ( bytes32 _agreementId , bytes32 _valueHash ) public returns ( bytes32 ) generateId condition Id from the following parameters","title":"generateId"},{"location":"architecture/contracts/contracts/conditions/Condition/#parameters","text":"Name Type Description _agreementId bytes32 SEA agreement ID _valueHash bytes32 hash of all the condition input values","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/Condition/#fulfill","text":"function fulfill ( bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) internal returns ( enum ConditionStoreLibrary . ConditionState ) fulfill set the condition state to Fulfill | Abort","title":"fulfill"},{"location":"architecture/contracts/contracts/conditions/Condition/#parameters_1","text":"Name Type Description _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState new condition state (Fulfill/Abort)","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/Condition/#return-values","text":"Name Type Description the bytes32 updated condition state ### abortByTimeOut function abortByTimeOut ( bytes32 _id ) external returns ( enum ConditionStoreLibrary . ConditionState ) abortByTimeOut set condition state to Aborted if the condition is timed out","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/Condition/#parameters_2","text":"Name Type Description _id bytes32 condition identifier","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/Condition/#return-values_1","text":"Name Type Description the bytes32 updated condition state","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreLibrary/","text":"Implementation of the Condition Store Library. Condition is a key component in the service execution agreement. This library holds the logic for creating and updating condition Any Condition has only four state transitions starts with Uninitialized, Unfulfilled, Fulfilled, and Aborted. Condition state transition goes only forward from Unintialized -> Unfulfilled -> {Fulfilled || Aborted} Functions \u00b6 create \u00b6 function create ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , address _typeRef , address _creator ) internal returns ( uint256 size ) create new condition check whether the condition exists, assigns condition type, condition state, last updated by, and update at (which is the current block number) Parameters: \u00b6 Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 valid condition identifier _typeRef address condition contract address _creator address address of the condition creator Return Values: \u00b6 Name Type Description size struct ConditionStoreLibrary.ConditionList is the condition index ### updateState function updateState ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) internal updateState update the condition state check whether the condition state transition is right, assign the new state, update last updated by and updated at. Parameters: \u00b6 Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState the new state of the condition","title":"ConditionStoreLibrary"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreLibrary/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreLibrary/#create","text":"function create ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , address _typeRef , address _creator ) internal returns ( uint256 size ) create new condition check whether the condition exists, assigns condition type, condition state, last updated by, and update at (which is the current block number)","title":"create"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreLibrary/#parameters","text":"Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 valid condition identifier _typeRef address condition contract address _creator address address of the condition creator","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreLibrary/#return-values","text":"Name Type Description size struct ConditionStoreLibrary.ConditionList is the condition index ### updateState function updateState ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) internal updateState update the condition state check whether the condition state transition is right, assign the new state, update last updated by and updated at.","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreLibrary/#parameters_1","text":"Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState the new state of the condition","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/","text":"Implementation of the Condition Store Manager. Condition store manager is responsible for enforcing the the business logic behind creating/updating the condition state based on the assigned role to each party. Only specific type of contracts are allowed to call this contract, therefore there are two types of roles, create role that in which is able to create conditions. The second role is the update role, which is can update the condition state. Also, it support delegating the roles to other contract(s)/account(s). Functions \u00b6 initialize \u00b6 function initialize ( address _owner ) public initialize ConditionStoreManager Initializer Initialize Ownable. Only on contract creation, Parameters: \u00b6 Name Type Description _owner address refers to the owner of the contract getCreateRole \u00b6 function getCreateRole ( ) external returns ( address ) getCreateRole get the address of contract which has the create role Return Values: \u00b6 Name Type Description create condition role address ### delegateCreateRole function delegateCreateRole ( address delegatee ) external delegateCreateRole only owner can delegate the create condition role to a different address Parameters: \u00b6 Name Type Description delegatee address delegatee address delegateUpdateRole \u00b6 function delegateUpdateRole ( bytes32 delegatee ) external delegateUpdateRole only owner can delegate the update role to a different address for specific condition Id which has the create role Parameters: \u00b6 Name Type Description delegatee bytes32 delegatee address createCondition \u00b6 function createCondition ( bytes32 _id , address _typeRef ) external returns ( uint256 size ) createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled. Parameters: \u00b6 Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address Return Values: \u00b6 Name Type Description size bytes32 the index of the created condition ### createCondition function createCondition ( bytes32 _id , address _typeRef , address _creator ) external returns ( uint256 size ) createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled. Parameters: \u00b6 Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address _creator address address of the condition creator Return Values: \u00b6 Name Type Description size bytes32 the index of the created condition ### createCondition function createCondition ( bytes32 _id , address _typeRef , uint256 _timeLock , uint256 _timeOut , address _creator ) public returns ( uint256 size ) createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled. Parameters: \u00b6 Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address _timeLock uint256 start of the time window _timeOut uint256 end of the time window _creator address address of the condition creator Return Values: \u00b6 Name Type Description size bytes32 the index of the created condition ### updateConditionState function updateConditionState ( bytes32 _id ) external returns ( enum ConditionStoreLibrary . ConditionState ) updateConditionState only called by update role address. It enforce the condition state transition to either Fulfill or Aborted state Parameters: \u00b6 Name Type Description _id bytes32 unique condition identifier Return Values: \u00b6 Name Type Description the bytes32 current condition state ### getConditionListSize function getConditionListSize ( ) external returns ( uint256 size ) getConditionListSize Return Values: \u00b6 Name Type Description size the length of the condition list ### getCondition function getCondition ( ) external returns ( address typeRef , enum ConditionStoreLibrary . ConditionState state , uint256 timeLock , uint256 timeOut , uint256 blockNumber , address createdBy , address lastUpdatedBy , uint256 blockNumberUpdated ) getCondition Return Values: \u00b6 Name Type Description typeRef bytes32 the type reference state condition state timeLock the time lock timeOut time out blockNumber block number createdBy address lastUpdatedBy address blockNumberUpdated block number updated ### getConditionState function getConditionState ( ) external returns ( enum ConditionStoreLibrary . ConditionState ) getConditionState Return Values: \u00b6 Name Type Description condition bytes32 state ### getConditionTypeRef function getConditionTypeRef ( ) external returns ( address ) getConditionTypeRef Return Values: \u00b6 Name Type Description condition bytes32 typeRef ### getConditionCreatedBy function getConditionCreatedBy ( ) external returns ( address ) getConditionCreatedBy Return Values: \u00b6 Name Type Description condition bytes32 createdBy address ### isConditionTimeLocked function isConditionTimeLocked ( ) public returns ( bool ) isConditionTimeLocked Return Values: \u00b6 Name Type Description whether bytes32 the condition is timedLock ended ### isConditionTimedOut function isConditionTimedOut ( ) public returns ( bool ) isConditionTimedOut Return Values: \u00b6 Name Type Description whether bytes32 the condition is timed out ## Events ### ConditionCreated event ConditionCreated ( ) ConditionUpdated \u00b6 event ConditionUpdated ( )","title":"ConditionStoreManager"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#initialize","text":"function initialize ( address _owner ) public initialize ConditionStoreManager Initializer Initialize Ownable. Only on contract creation,","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#parameters","text":"Name Type Description _owner address refers to the owner of the contract","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#getcreaterole","text":"function getCreateRole ( ) external returns ( address ) getCreateRole get the address of contract which has the create role","title":"getCreateRole"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#return-values","text":"Name Type Description create condition role address ### delegateCreateRole function delegateCreateRole ( address delegatee ) external delegateCreateRole only owner can delegate the create condition role to a different address","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#parameters_1","text":"Name Type Description delegatee address delegatee address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#delegateupdaterole","text":"function delegateUpdateRole ( bytes32 delegatee ) external delegateUpdateRole only owner can delegate the update role to a different address for specific condition Id which has the create role","title":"delegateUpdateRole"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#parameters_2","text":"Name Type Description delegatee bytes32 delegatee address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#createcondition","text":"function createCondition ( bytes32 _id , address _typeRef ) external returns ( uint256 size ) createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled.","title":"createCondition"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#parameters_3","text":"Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#return-values_1","text":"Name Type Description size bytes32 the index of the created condition ### createCondition function createCondition ( bytes32 _id , address _typeRef , address _creator ) external returns ( uint256 size ) createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled.","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#parameters_4","text":"Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address _creator address address of the condition creator","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#return-values_2","text":"Name Type Description size bytes32 the index of the created condition ### createCondition function createCondition ( bytes32 _id , address _typeRef , uint256 _timeLock , uint256 _timeOut , address _creator ) public returns ( uint256 size ) createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled.","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#parameters_5","text":"Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address _timeLock uint256 start of the time window _timeOut uint256 end of the time window _creator address address of the condition creator","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#return-values_3","text":"Name Type Description size bytes32 the index of the created condition ### updateConditionState function updateConditionState ( bytes32 _id ) external returns ( enum ConditionStoreLibrary . ConditionState ) updateConditionState only called by update role address. It enforce the condition state transition to either Fulfill or Aborted state","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#parameters_6","text":"Name Type Description _id bytes32 unique condition identifier","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#return-values_4","text":"Name Type Description the bytes32 current condition state ### getConditionListSize function getConditionListSize ( ) external returns ( uint256 size ) getConditionListSize","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#return-values_5","text":"Name Type Description size the length of the condition list ### getCondition function getCondition ( ) external returns ( address typeRef , enum ConditionStoreLibrary . ConditionState state , uint256 timeLock , uint256 timeOut , uint256 blockNumber , address createdBy , address lastUpdatedBy , uint256 blockNumberUpdated ) getCondition","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#return-values_6","text":"Name Type Description typeRef bytes32 the type reference state condition state timeLock the time lock timeOut time out blockNumber block number createdBy address lastUpdatedBy address blockNumberUpdated block number updated ### getConditionState function getConditionState ( ) external returns ( enum ConditionStoreLibrary . ConditionState ) getConditionState","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#return-values_7","text":"Name Type Description condition bytes32 state ### getConditionTypeRef function getConditionTypeRef ( ) external returns ( address ) getConditionTypeRef","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#return-values_8","text":"Name Type Description condition bytes32 typeRef ### getConditionCreatedBy function getConditionCreatedBy ( ) external returns ( address ) getConditionCreatedBy","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#return-values_9","text":"Name Type Description condition bytes32 createdBy address ### isConditionTimeLocked function isConditionTimeLocked ( ) public returns ( bool ) isConditionTimeLocked","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#return-values_10","text":"Name Type Description whether bytes32 the condition is timedLock ended ### isConditionTimedOut function isConditionTimedOut ( ) public returns ( bool ) isConditionTimedOut","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#return-values_11","text":"Name Type Description whether bytes32 the condition is timed out ## Events ### ConditionCreated event ConditionCreated ( )","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ConditionStoreManager/#conditionupdated","text":"event ConditionUpdated ( )","title":"ConditionUpdated"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/","text":"Implementation of the Hash Lock Condition Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( uint256 _preimage ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _preimage uint256 refers uint value of the hash pre-image. Return Values: \u00b6 Name Type Description bytes32 uint256 hash of all these values ### hashValues function hashValues ( string _preimage ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _preimage string refers string value of the hash pre-image. Return Values: \u00b6 Name Type Description bytes32 string hash of all these values ### hashValues function hashValues ( bytes32 _preimage ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _preimage bytes32 refers bytes32 value of the hash pre-image. Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image uint value Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement identifier Return Values: \u00b6 Name Type Description condition bytes32 state ### fulfill function fulfill ( bytes32 _agreementId ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image string value Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement identifier Return Values: \u00b6 Name Type Description condition bytes32 state ### fulfill function fulfill ( bytes32 _agreementId ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image bytes32 value Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement identifier Return Values: \u00b6 Name Type Description condition bytes32 state","title":"HashLockCondition"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/#hashvalues","text":"function hashValues ( uint256 _preimage ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/#parameters_1","text":"Name Type Description _preimage uint256 refers uint value of the hash pre-image.","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/#return-values","text":"Name Type Description bytes32 uint256 hash of all these values ### hashValues function hashValues ( string _preimage ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/#parameters_2","text":"Name Type Description _preimage string refers string value of the hash pre-image.","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/#return-values_1","text":"Name Type Description bytes32 string hash of all these values ### hashValues function hashValues ( bytes32 _preimage ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/#parameters_3","text":"Name Type Description _preimage bytes32 refers bytes32 value of the hash pre-image.","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/#return-values_2","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image uint value","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/#parameters_4","text":"Name Type Description _agreementId bytes32 SEA agreement identifier","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/#return-values_3","text":"Name Type Description condition bytes32 state ### fulfill function fulfill ( bytes32 _agreementId ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image string value","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/#parameters_5","text":"Name Type Description _agreementId bytes32 SEA agreement identifier","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/#return-values_4","text":"Name Type Description condition bytes32 state ### fulfill function fulfill ( bytes32 _agreementId ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image bytes32 value","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/#parameters_6","text":"Name Type Description _agreementId bytes32 SEA agreement identifier","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/HashLockCondition/#return-values_5","text":"Name Type Description condition bytes32 state","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/IDisputeManager/","text":"Functions \u00b6 verifyProof \u00b6 function verifyProof ( ) external returns ( bool )","title":"IDisputeManager"},{"location":"architecture/contracts/contracts/conditions/IDisputeManager/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/IDisputeManager/#verifyproof","text":"function verifyProof ( ) external returns ( bool )","title":"verifyProof"},{"location":"architecture/contracts/contracts/conditions/LockPaymentCondition/","text":"Implementation of the Lock Payment Condition This condition allows to lock payment for multiple receivers taking into account the royalties to be paid to the original creators in a secondary market. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address hashValues \u00b6 function hashValues ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires valid token transfer in order to lock the amount of tokens based on the SEA Parameters: \u00b6 Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Return Values: \u00b6 Name Type Description condition bytes32 state ### _transferERC20 function _transferERC20 ( address _rewardAddress , address _tokenAddress , uint256 _amount ) internal _transferERC20 transfer ERC20 tokens Will throw if transfer fails Parameters: \u00b6 Name Type Description _rewardAddress address the address to receive the tokens _tokenAddress address the ERC20 contract address to use during the payment _amount uint256 token amount to be locked/released _transferETH \u00b6 function _transferETH ( address payable _rewardAddress , uint256 _amount ) internal _transferETH transfer ETH Parameters: \u00b6 Name Type Description _rewardAddress address payable the address to receive the ETH _amount uint256 ETH amount to be locked/released Events \u00b6 Fulfilled \u00b6 event Fulfilled ( )","title":"LockPaymentCondition"},{"location":"architecture/contracts/contracts/conditions/LockPaymentCondition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/LockPaymentCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/LockPaymentCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/LockPaymentCondition/#hashvalues","text":"function hashValues ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/LockPaymentCondition/#parameters_1","text":"Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/LockPaymentCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires valid token transfer in order to lock the amount of tokens based on the SEA","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/LockPaymentCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/LockPaymentCondition/#return-values_1","text":"Name Type Description condition bytes32 state ### _transferERC20 function _transferERC20 ( address _rewardAddress , address _tokenAddress , uint256 _amount ) internal _transferERC20 transfer ERC20 tokens Will throw if transfer fails","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/LockPaymentCondition/#parameters_3","text":"Name Type Description _rewardAddress address the address to receive the tokens _tokenAddress address the ERC20 contract address to use during the payment _amount uint256 token amount to be locked/released","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/LockPaymentCondition/#_transfereth","text":"function _transferETH ( address payable _rewardAddress , uint256 _amount ) internal _transferETH transfer ETH","title":"_transferETH"},{"location":"architecture/contracts/contracts/conditions/LockPaymentCondition/#parameters_4","text":"Name Type Description _rewardAddress address payable the address to receive the ETH _amount uint256 ETH amount to be locked/released","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/LockPaymentCondition/#events","text":"","title":"Events"},{"location":"architecture/contracts/contracts/conditions/LockPaymentCondition/#fulfilled","text":"event Fulfilled ( )","title":"Fulfilled"},{"location":"architecture/contracts/contracts/conditions/SignCondition/","text":"Implementation of the Sign Condition Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _message , address _publicKey ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _message bytes32 the message to be signed _publicKey address the public key of the signing address Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _message , address _publicKey , bytes _signature ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill validate the signed message and fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement identifier _message bytes32 the message to be signed _publicKey address the public key of the signing address _signature bytes signature of the signed message using the public key Return Values: \u00b6 Name Type Description condition bytes32 state","title":"SignCondition"},{"location":"architecture/contracts/contracts/conditions/SignCondition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/SignCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/SignCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/SignCondition/#hashvalues","text":"function hashValues ( bytes32 _message , address _publicKey ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/SignCondition/#parameters_1","text":"Name Type Description _message bytes32 the message to be signed _publicKey address the public key of the signing address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/SignCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _message , address _publicKey , bytes _signature ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill validate the signed message and fulfill the condition","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/SignCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 SEA agreement identifier _message bytes32 the message to be signed _publicKey address the public key of the signing address _signature bytes signature of the signed message using the public key","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/SignCondition/#return-values_1","text":"Name Type Description condition bytes32 state","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ThresholdCondition/","text":"Implementation of the Threshold Condition Threshold condition acts as a filter for a set of input condition(s) in which sends a signal whether to complete the flow execution or abort it. This type of conditions works as intermediary conditions where they wire SEA conditions in order to support more complex scenarios. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 [] inputConditions , uint256 threshold ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Return Values: \u00b6 Name Type Description bytes32 bytes32[] hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 [] _inputConditions , uint256 threshold ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill threshold condition the fulfill method check whether input conditions are fulfilled or not. Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted)","title":"ThresholdCondition"},{"location":"architecture/contracts/contracts/conditions/ThresholdCondition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/ThresholdCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/ThresholdCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/ThresholdCondition/#hashvalues","text":"function hashValues ( bytes32 [] inputConditions , uint256 threshold ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/ThresholdCondition/#parameters_1","text":"Name Type Description inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/ThresholdCondition/#return-values","text":"Name Type Description bytes32 bytes32[] hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 [] _inputConditions , uint256 threshold ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill threshold condition the fulfill method check whether input conditions are fulfilled or not.","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/ThresholdCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 agreement identifier _inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/ThresholdCondition/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted)","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/TransferDIDOwnershipCondition/","text":"Implementation of condition allowing to transfer the ownership between the original owner and a receiver Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address hashValues \u00b6 function hashValues ( bytes32 _did , address _receiver ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user or the DID provider Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _receiver ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer DID ownership condition only DID owner or DID provider can call this method. Fulfill method transfer full ownership permissions to to _receiver address. When true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"TransferDIDOwnershipCondition"},{"location":"architecture/contracts/contracts/conditions/TransferDIDOwnershipCondition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/TransferDIDOwnershipCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/TransferDIDOwnershipCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/TransferDIDOwnershipCondition/#hashvalues","text":"function hashValues ( bytes32 _did , address _receiver ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/TransferDIDOwnershipCondition/#parameters_1","text":"Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user or the DID provider","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/TransferDIDOwnershipCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _receiver ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer DID ownership condition only DID owner or DID provider can call this method. Fulfill method transfer full ownership permissions to to _receiver address. When true then fulfill the condition","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/TransferDIDOwnershipCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/TransferDIDOwnershipCondition/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/WhitelistingCondition/","text":"Implementation of the Whitelisting Condition Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( address _listAddress , bytes32 _item ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _listAddress address list contract address _item bytes32 item in the list Return Values: \u00b6 Name Type Description bytes32 address hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , address _listAddress , bytes32 _item ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill check whether address is whitelisted in order to fulfill the condition. This method will be called by any one in this whitelist. Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement identifier _listAddress address list contract address _item bytes32 item in the list Return Values: \u00b6 Name Type Description condition bytes32 state","title":"WhitelistingCondition"},{"location":"architecture/contracts/contracts/conditions/WhitelistingCondition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/WhitelistingCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/WhitelistingCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/WhitelistingCondition/#hashvalues","text":"function hashValues ( address _listAddress , bytes32 _item ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/WhitelistingCondition/#parameters_1","text":"Name Type Description _listAddress address list contract address _item bytes32 item in the list","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/WhitelistingCondition/#return-values","text":"Name Type Description bytes32 address hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , address _listAddress , bytes32 _item ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill check whether address is whitelisted in order to fulfill the condition. This method will be called by any one in this whitelist.","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/WhitelistingCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 SEA agreement identifier _listAddress address list contract address _item bytes32 item in the list","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/WhitelistingCondition/#return-values_1","text":"Name Type Description condition bytes32 state","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/INFTAccess/","text":"Functions \u00b6 hashValues \u00b6 function hashValues ( bytes32 _documentId , address _grantee , address _contractAddress ) external returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access conditions only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"INFTAccess"},{"location":"architecture/contracts/contracts/conditions/NFTs/INFTAccess/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/NFTs/INFTAccess/#hashvalues","text":"function hashValues ( bytes32 _documentId , address _grantee , address _contractAddress ) external returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/NFTs/INFTAccess/#parameters","text":"Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155)","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/INFTAccess/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access conditions only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/INFTAccess/#parameters_1","text":"Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155)","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/INFTAccess/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/INFTHolder/","text":"Functions \u00b6 hashValues \u00b6 function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Return Values: \u00b6 Name Type Description condition bytes32 state ## Events ### Fulfilled event Fulfilled ( )","title":"INFTHolder"},{"location":"architecture/contracts/contracts/conditions/NFTs/INFTHolder/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/NFTs/INFTHolder/#hashvalues","text":"function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/NFTs/INFTHolder/#parameters","text":"Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155)","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/INFTHolder/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/INFTHolder/#parameters_1","text":"Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155)","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/INFTHolder/#return-values_1","text":"Name Type Description condition bytes32 state ## Events ### Fulfilled event Fulfilled ( )","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/ITransferNFT/","text":"Functions \u00b6 hashValues \u00b6 function hashValues ( bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockCondition ) external returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the granted user or the DID provider _nftAmount address amount of NFTs to transfer _lockCondition uint256 lock condition identifier Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"ITransferNFT"},{"location":"architecture/contracts/contracts/conditions/NFTs/ITransferNFT/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/NFTs/ITransferNFT/#hashvalues","text":"function hashValues ( bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockCondition ) external returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/NFTs/ITransferNFT/#parameters","text":"Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the granted user or the DID provider _nftAmount address amount of NFTs to transfer _lockCondition uint256 lock condition identifier","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/ITransferNFT/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/ITransferNFT/#parameters_1","text":"Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/ITransferNFT/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFT721HolderCondition/","text":"Implementation of the Nft Holder Condition Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( ) public returns ( bytes32 ) fulfill \u00b6 function fulfill ( ) external returns ( enum ConditionStoreLibrary . ConditionState )","title":"NFT721HolderCondition"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFT721HolderCondition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFT721HolderCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFT721HolderCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFT721HolderCondition/#hashvalues","text":"function hashValues ( ) public returns ( bytes32 )","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFT721HolderCondition/#fulfill","text":"function fulfill ( ) external returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfill"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTAccessCondition/","text":"Implementation of the Access Condition specific for NFTs NFT Access Condition is special condition used to give access to a specific NFT related to a DID. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID registry address hashValues \u00b6 function hashValues ( bytes32 _documentId , address _grantee ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### hashValues function hashValues ( ) public returns ( bytes32 ) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee , address _contractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address is the contract address of the NFT implementation (ERC-1155 or ERC-721) Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ### grantPermission function grantPermission ( address _grantee , bytes32 _documentId ) public grantPermission is called only by DID owner or provider Parameters: \u00b6 Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys checkPermissions \u00b6 function checkPermissions ( address _documentId , bytes32 _grantee ) external returns ( bool permissionGranted ) checkPermissions is called to validate the permissions of user related to the NFT attached to an asset Parameters: \u00b6 Name Type Description _documentId address refers to the DID _grantee bytes32 is the address of the granted user or the DID provider Return Values: \u00b6 Name Type Description permissionGranted address true if the access was granted","title":"NFTAccessCondition"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTAccessCondition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTAccessCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTAccessCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID registry address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTAccessCondition/#hashvalues","text":"function hashValues ( bytes32 _documentId , address _grantee ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTAccessCondition/#parameters_1","text":"Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTAccessCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### hashValues function hashValues ( ) public returns ( bytes32 )","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTAccessCondition/#fulfill","text":"function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition","title":"fulfill"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTAccessCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTAccessCondition/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee , address _contractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTAccessCondition/#parameters_3","text":"Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address is the contract address of the NFT implementation (ERC-1155 or ERC-721)","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTAccessCondition/#return-values_2","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ### grantPermission function grantPermission ( address _grantee , bytes32 _documentId ) public grantPermission is called only by DID owner or provider","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTAccessCondition/#parameters_4","text":"Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTAccessCondition/#checkpermissions","text":"function checkPermissions ( address _documentId , bytes32 _grantee ) external returns ( bool permissionGranted ) checkPermissions is called to validate the permissions of user related to the NFT attached to an asset","title":"checkPermissions"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTAccessCondition/#parameters_5","text":"Name Type Description _documentId address refers to the DID _grantee bytes32 is the address of the granted user or the DID provider","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTAccessCondition/#return-values_3","text":"Name Type Description permissionGranted address true if the access was granted","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTHolderCondition/","text":"Implementation of the Nft Holder Condition Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DIDRegistry address hashValues \u00b6 function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### hashValues function hashValues ( ) public returns ( bytes32 ) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold Return Values: \u00b6 Name Type Description condition bytes32 state ### fulfill function fulfill ( ) public returns ( enum ConditionStoreLibrary . ConditionState )","title":"NFTHolderCondition"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTHolderCondition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTHolderCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTHolderCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DIDRegistry address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTHolderCondition/#hashvalues","text":"function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTHolderCondition/#parameters_1","text":"Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTHolderCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### hashValues function hashValues ( ) public returns ( bytes32 )","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTHolderCondition/#fulfill","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID","title":"fulfill"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTHolderCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTHolderCondition/#return-values_1","text":"Name Type Description condition bytes32 state ### fulfill function fulfill ( ) public returns ( enum ConditionStoreLibrary . ConditionState )","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTLockCondition/","text":"Implementation of the NFT Lock Condition Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DIDRegistry contract address hashValues \u00b6 function hashValues ( bytes32 _did , address _rewardAddress , uint256 _amount ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _rewardAddress address the final address to receive the NFTs _amount uint256 is the amount of the locked tokens Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _rewardAddress , uint256 _amount ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires valid NFT transfer in order to lock the amount of DID NFTs based on the SEA Parameters: \u00b6 Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 Asset Decentralized Identifier _rewardAddress address the contract address where the reward is locked _amount uint256 is the amount of tokens to be transferred Return Values: \u00b6 Name Type Description condition bytes32 state ### onERC1155Received function onERC1155Received ( ) external returns ( bytes4 ) onERC1155BatchReceived \u00b6 function onERC1155BatchReceived ( ) external returns ( bytes4 ) supportsInterface \u00b6 function supportsInterface ( ) external returns ( bool ) Events \u00b6 Fulfilled \u00b6 event Fulfilled ( )","title":"NFTLockCondition"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTLockCondition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTLockCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTLockCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DIDRegistry contract address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTLockCondition/#hashvalues","text":"function hashValues ( bytes32 _did , address _rewardAddress , uint256 _amount ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTLockCondition/#parameters_1","text":"Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _rewardAddress address the final address to receive the NFTs _amount uint256 is the amount of the locked tokens","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTLockCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _rewardAddress , uint256 _amount ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires valid NFT transfer in order to lock the amount of DID NFTs based on the SEA","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTLockCondition/#parameters_2","text":"Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 Asset Decentralized Identifier _rewardAddress address the contract address where the reward is locked _amount uint256 is the amount of tokens to be transferred","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTLockCondition/#return-values_1","text":"Name Type Description condition bytes32 state ### onERC1155Received function onERC1155Received ( ) external returns ( bytes4 )","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTLockCondition/#onerc1155batchreceived","text":"function onERC1155BatchReceived ( ) external returns ( bytes4 )","title":"onERC1155BatchReceived"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTLockCondition/#supportsinterface","text":"function supportsInterface ( ) external returns ( bool )","title":"supportsInterface"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTLockCondition/#events","text":"","title":"Events"},{"location":"architecture/contracts/contracts/conditions/NFTs/NFTLockCondition/#fulfilled","text":"event Fulfilled ( )","title":"Fulfilled"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFT721Condition/","text":"Implementation of condition allowing to transfer an NFT between the original owner and a receiver Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address hashValues \u00b6 function hashValues ( bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockCondition , bytes32 _contract ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the granted user or the DID provider _nftAmount address amount of NFTs to transfer _lockCondition uint256 lock condition identifier _contract bytes32 NFT contract to use Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _contract ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _contract address NFT contract to use Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted)","title":"TransferNFT721Condition"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFT721Condition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFT721Condition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFT721Condition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFT721Condition/#hashvalues","text":"function hashValues ( bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockCondition , bytes32 _contract ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFT721Condition/#parameters_1","text":"Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the granted user or the DID provider _nftAmount address amount of NFTs to transfer _lockCondition uint256 lock condition identifier _contract bytes32 NFT contract to use","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFT721Condition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _contract ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFT721Condition/#parameters_2","text":"Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _contract address NFT contract to use","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFT721Condition/#return-values_1","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted)","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFTCondition/","text":"Implementation of condition allowing to transfer an NFT between the original owner and a receiver Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress , address _nftContractAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address _nftContractAddress address Market address grantMarketRole \u00b6 function grantMarketRole ( ) public revokeMarketRole \u00b6 function revokeMarketRole ( ) public hashValues \u00b6 function hashValues ( bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockCondition ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the granted user or the DID provider _nftAmount address amount of NFTs to transfer _lockCondition uint256 lock condition identifier Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### hashValues function hashValues ( bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockCondition , bytes32 _nftContractAddress ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the granted user or the DID provider _nftAmount address amount of NFTs to transfer _lockCondition uint256 lock condition identifier _nftContractAddress bytes32 NFT contract to use Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address NFT contract to use Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ### fulfillForMarket function fulfillForMarket ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockPaymentCondition , bytes32 _nftHolder ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address in the DIDRegistry contract. When true then fulfill the condition Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount address amount of NFTs to transfer _lockPaymentCondition uint256 lock payment condition identifier _nftHolder bytes32 is the address of the account to receive the NFT Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted)","title":"TransferNFTCondition"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFTCondition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFTCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress , address _nftContractAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization.","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFTCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address _nftContractAddress address Market address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFTCondition/#grantmarketrole","text":"function grantMarketRole ( ) public","title":"grantMarketRole"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFTCondition/#revokemarketrole","text":"function revokeMarketRole ( ) public","title":"revokeMarketRole"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFTCondition/#hashvalues","text":"function hashValues ( bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockCondition ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFTCondition/#parameters_1","text":"Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the granted user or the DID provider _nftAmount address amount of NFTs to transfer _lockCondition uint256 lock condition identifier","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFTCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### hashValues function hashValues ( bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockCondition , bytes32 _nftContractAddress ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFTCondition/#parameters_2","text":"Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the granted user or the DID provider _nftAmount address amount of NFTs to transfer _lockCondition uint256 lock condition identifier _nftContractAddress bytes32 NFT contract to use","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFTCondition/#return-values_1","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( ) public returns ( enum ConditionStoreLibrary . ConditionState )","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFTCondition/#fulfill","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition","title":"fulfill"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFTCondition/#parameters_3","text":"Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address NFT contract to use","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFTCondition/#return-values_2","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ### fulfillForMarket function fulfillForMarket ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , address _nftAmount , uint256 _lockPaymentCondition , bytes32 _nftHolder ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address in the DIDRegistry contract. When true then fulfill the condition","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFTCondition/#parameters_4","text":"Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount address amount of NFTs to transfer _lockPaymentCondition uint256 lock payment condition identifier _nftHolder bytes32 is the address of the account to receive the NFT","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/NFTs/TransferNFTCondition/#return-values_3","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted)","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/rewards/EscrowPaymentCondition/","text":"Implementation of the Escrow Payment Condition The Escrow payment is reward condition in which only can release reward if lock and release conditions are fulfilled. Functions \u00b6 receive \u00b6 function receive ( ) external initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters Parameters: \u00b6 Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 _releaseCondition ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseCondition bytes32 release condition identifier Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### hashValuesLockPayment function hashValuesLockPayment ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public returns ( bytes32 ) hashValuesLockPayment generates the hash of condition inputs with the following parameters Parameters: \u00b6 Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Return Values: \u00b6 Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 _releaseCondition ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill escrow reward condition fulfill method checks whether the lock and release conditions are fulfilled in order to release/refund the reward to receiver/sender respectively. Parameters: \u00b6 Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseCondition bytes32 release condition identifier Return Values: \u00b6 Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( ) Received \u00b6 event Received ( )","title":"EscrowPaymentCondition"},{"location":"architecture/contracts/contracts/conditions/rewards/EscrowPaymentCondition/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/conditions/rewards/EscrowPaymentCondition/#receive","text":"function receive ( ) external","title":"receive"},{"location":"architecture/contracts/contracts/conditions/rewards/EscrowPaymentCondition/#initialize","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters","title":"initialize"},{"location":"architecture/contracts/contracts/conditions/rewards/EscrowPaymentCondition/#parameters","text":"Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/rewards/EscrowPaymentCondition/#hashvalues","text":"function hashValues ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 _releaseCondition ) public returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters","title":"hashValues"},{"location":"architecture/contracts/contracts/conditions/rewards/EscrowPaymentCondition/#parameters_1","text":"Name Type Description _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseCondition bytes32 release condition identifier","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/rewards/EscrowPaymentCondition/#return-values","text":"Name Type Description bytes32 bytes32 hash of all these values ### hashValuesLockPayment function hashValuesLockPayment ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public returns ( bytes32 ) hashValuesLockPayment generates the hash of condition inputs with the following parameters","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/rewards/EscrowPaymentCondition/#parameters_2","text":"Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/rewards/EscrowPaymentCondition/#return-values_1","text":"Name Type Description bytes32 bytes32 hash of all these values ### fulfill function fulfill ( bytes32 _agreementId , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 _releaseCondition ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill escrow reward condition fulfill method checks whether the lock and release conditions are fulfilled in order to release/refund the reward to receiver/sender respectively.","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/rewards/EscrowPaymentCondition/#parameters_3","text":"Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseCondition bytes32 release condition identifier","title":"Parameters:"},{"location":"architecture/contracts/contracts/conditions/rewards/EscrowPaymentCondition/#return-values_2","text":"Name Type Description condition bytes32 state (Fulfilled/Aborted) ## Events ### Fulfilled event Fulfilled ( )","title":"Return Values:"},{"location":"architecture/contracts/contracts/conditions/rewards/EscrowPaymentCondition/#received","text":"event Received ( )","title":"Received"},{"location":"architecture/contracts/contracts/conditions/rewards/Reward/","text":"Implementation of the Reward. Generic reward condition","title":"Reward"},{"location":"architecture/contracts/contracts/interfaces/IList/","text":"Functions \u00b6 has \u00b6 function has ( ) external returns ( bool ) has \u00b6 function has ( ) external returns ( bool )","title":"IList"},{"location":"architecture/contracts/contracts/interfaces/IList/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/interfaces/IList/#has","text":"function has ( ) external returns ( bool )","title":"has"},{"location":"architecture/contracts/contracts/interfaces/IList/#has_1","text":"function has ( ) external returns ( bool )","title":"has"},{"location":"architecture/contracts/contracts/interfaces/ISecretStore/","text":"Functions \u00b6 checkPermissions \u00b6 function checkPermissions ( ) external returns ( bool permissionGranted ) checkPermissions is called by Parity secret store","title":"ISecretStore"},{"location":"architecture/contracts/contracts/interfaces/ISecretStore/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/interfaces/ISecretStore/#checkpermissions","text":"function checkPermissions ( ) external returns ( bool permissionGranted ) checkPermissions is called by Parity secret store","title":"checkPermissions"},{"location":"architecture/contracts/contracts/interfaces/ISecretStorePermission/","text":"Functions \u00b6 grantPermission \u00b6 function grantPermission ( ) external grantPermission is called only by documentKeyId Owner or provider renouncePermission \u00b6 function renouncePermission ( ) external renouncePermission is called only by documentKeyId Owner or provider","title":"ISecretStorePermission"},{"location":"architecture/contracts/contracts/interfaces/ISecretStorePermission/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/interfaces/ISecretStorePermission/#grantpermission","text":"function grantPermission ( ) external grantPermission is called only by documentKeyId Owner or provider","title":"grantPermission"},{"location":"architecture/contracts/contracts/interfaces/ISecretStorePermission/#renouncepermission","text":"function renouncePermission ( ) external renouncePermission is called only by documentKeyId Owner or provider","title":"renouncePermission"},{"location":"architecture/contracts/contracts/libraries/EpochLibrary/","text":"Implementation of Epoch Library. For an arbitrary Epoch, this library manages the life cycle of an Epoch. Usually this library is used for handling the time window between conditions in an agreement. Functions \u00b6 create \u00b6 function create ( struct EpochLibrary . EpochList _self , bytes32 _timeLock , uint256 _timeOut ) internal create creates new Epoch Parameters: \u00b6 Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _timeLock bytes32 value in block count (can not fulfill before) _timeOut uint256 value in block count (can not fulfill after) isTimedOut \u00b6 function isTimedOut ( struct EpochLibrary . EpochList _self ) external returns ( bool ) isTimedOut means you cannot fulfill after Parameters: \u00b6 Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer Return Values: \u00b6 Name Type Description true struct EpochLibrary.EpochList if the current block number is gt timeOut ### isTimeLocked function isTimeLocked ( struct EpochLibrary . EpochList _self ) external returns ( bool ) isTimeLocked means you cannot fulfill before Parameters: \u00b6 Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer Return Values: \u00b6 Name Type Description true struct EpochLibrary.EpochList if the current block number is gt timeLock ### getEpochTimeOut function getEpochTimeOut ( struct EpochLibrary . Epoch _self ) public returns ( uint256 ) getEpochTimeOut Parameters: \u00b6 Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer getEpochTimeLock \u00b6 function getEpochTimeLock ( struct EpochLibrary . Epoch _self ) public returns ( uint256 ) getEpochTimeLock Parameters: \u00b6 Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer","title":"EpochLibrary"},{"location":"architecture/contracts/contracts/libraries/EpochLibrary/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/libraries/EpochLibrary/#create","text":"function create ( struct EpochLibrary . EpochList _self , bytes32 _timeLock , uint256 _timeOut ) internal create creates new Epoch","title":"create"},{"location":"architecture/contracts/contracts/libraries/EpochLibrary/#parameters","text":"Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _timeLock bytes32 value in block count (can not fulfill before) _timeOut uint256 value in block count (can not fulfill after)","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/EpochLibrary/#istimedout","text":"function isTimedOut ( struct EpochLibrary . EpochList _self ) external returns ( bool ) isTimedOut means you cannot fulfill after","title":"isTimedOut"},{"location":"architecture/contracts/contracts/libraries/EpochLibrary/#parameters_1","text":"Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/EpochLibrary/#return-values","text":"Name Type Description true struct EpochLibrary.EpochList if the current block number is gt timeOut ### isTimeLocked function isTimeLocked ( struct EpochLibrary . EpochList _self ) external returns ( bool ) isTimeLocked means you cannot fulfill before","title":"Return Values:"},{"location":"architecture/contracts/contracts/libraries/EpochLibrary/#parameters_2","text":"Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/EpochLibrary/#return-values_1","text":"Name Type Description true struct EpochLibrary.EpochList if the current block number is gt timeLock ### getEpochTimeOut function getEpochTimeOut ( struct EpochLibrary . Epoch _self ) public returns ( uint256 ) getEpochTimeOut","title":"Return Values:"},{"location":"architecture/contracts/contracts/libraries/EpochLibrary/#parameters_3","text":"Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/EpochLibrary/#getepochtimelock","text":"function getEpochTimeLock ( struct EpochLibrary . Epoch _self ) public returns ( uint256 ) getEpochTimeLock","title":"getEpochTimeLock"},{"location":"architecture/contracts/contracts/libraries/EpochLibrary/#parameters_4","text":"Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/","text":"Implementation of the basic functionality of list of hash values. This library allows other contracts to build and maintain lists and also preserves the privacy of the data by accepting only hashed content (bytes32 based data type) Functions \u00b6 add \u00b6 function add ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) add index an element then add it to a list Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is a bytes32 value Return Values: \u00b6 Name Type Description true struct HashListLibrary.List if value is added successfully ### add function add ( struct HashListLibrary . List _self , bytes32 [] values ) public returns ( bool ) put an array of elements without indexing this meant to save gas in case of large arrays Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage values bytes32[] is an array of elements value Return Values: \u00b6 Name Type Description true struct HashListLibrary.List if values are added successfully ### update function update ( struct HashListLibrary . List _self , bytes32 oldValue , bytes32 newValue ) public returns ( bool ) update the value with a new value and maintain indices Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage oldValue bytes32 is an element value in a list newValue bytes32 new value Return Values: \u00b6 Name Type Description true struct HashListLibrary.List if value is updated successfully ### remove function remove ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) remove value from a list, updates indices, and list size Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is an element value in a list Return Values: \u00b6 Name Type Description true struct HashListLibrary.List if value is removed successfully ### get function get ( struct HashListLibrary . List _self , uint256 index ) public returns ( bytes32 ) has value by index Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage index uint256 is where is value is stored in the list Return Values: \u00b6 Name Type Description the struct HashListLibrary.List value if exists ### index function index ( struct HashListLibrary . List _self , uint256 from , uint256 to ) public returns ( bool ) index is used to map each element value to its index on the list Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing Return Values: \u00b6 Name Type Description true struct HashListLibrary.List if the sub list is indexed ### setOwner function setOwner ( ) public setOwner set list owner param _owner owner address indexOf \u00b6 function indexOf ( struct HashListLibrary . List _self , bytes32 value ) public returns ( uint256 ) indexOf gets the index of a value in a list Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list Return Values: \u00b6 Name Type Description value struct HashListLibrary.List index in list ### isIndexed function isIndexed ( struct HashListLibrary . List _self ) public returns ( bool ) isIndexed checks if the list is indexed Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Return Values: \u00b6 Name Type Description true struct HashListLibrary.List if the list is indexed ### all function all ( struct HashListLibrary . List _self ) public returns ( bytes32 []) all returns all list elements Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Return Values: \u00b6 Name Type Description all struct HashListLibrary.List list elements ### has function has ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) size returns the list size Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list Return Values: \u00b6 Name Type Description true struct HashListLibrary.List if the value exists ### size function size ( struct HashListLibrary . List _self ) public returns ( uint256 ) size gets the list size Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Return Values: \u00b6 Name Type Description total struct HashListLibrary.List length of the list ### ownedBy function ownedBy ( struct HashListLibrary . List _self ) public returns ( address ) ownedBy gets the list owner Parameters: \u00b6 Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Return Values: \u00b6 Name Type Description list struct HashListLibrary.List owner","title":"HashListLibrary"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#add","text":"function add ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) add index an element then add it to a list","title":"add"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#parameters","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is a bytes32 value","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#return-values","text":"Name Type Description true struct HashListLibrary.List if value is added successfully ### add function add ( struct HashListLibrary . List _self , bytes32 [] values ) public returns ( bool ) put an array of elements without indexing this meant to save gas in case of large arrays","title":"Return Values:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#parameters_1","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage values bytes32[] is an array of elements value","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#return-values_1","text":"Name Type Description true struct HashListLibrary.List if values are added successfully ### update function update ( struct HashListLibrary . List _self , bytes32 oldValue , bytes32 newValue ) public returns ( bool ) update the value with a new value and maintain indices","title":"Return Values:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#parameters_2","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage oldValue bytes32 is an element value in a list newValue bytes32 new value","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#return-values_2","text":"Name Type Description true struct HashListLibrary.List if value is updated successfully ### remove function remove ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) remove value from a list, updates indices, and list size","title":"Return Values:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#parameters_3","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is an element value in a list","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#return-values_3","text":"Name Type Description true struct HashListLibrary.List if value is removed successfully ### get function get ( struct HashListLibrary . List _self , uint256 index ) public returns ( bytes32 ) has value by index","title":"Return Values:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#parameters_4","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage index uint256 is where is value is stored in the list","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#return-values_4","text":"Name Type Description the struct HashListLibrary.List value if exists ### index function index ( struct HashListLibrary . List _self , uint256 from , uint256 to ) public returns ( bool ) index is used to map each element value to its index on the list","title":"Return Values:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#parameters_5","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#return-values_5","text":"Name Type Description true struct HashListLibrary.List if the sub list is indexed ### setOwner function setOwner ( ) public setOwner set list owner param _owner owner address","title":"Return Values:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#indexof","text":"function indexOf ( struct HashListLibrary . List _self , bytes32 value ) public returns ( uint256 ) indexOf gets the index of a value in a list","title":"indexOf"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#parameters_6","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#return-values_6","text":"Name Type Description value struct HashListLibrary.List index in list ### isIndexed function isIndexed ( struct HashListLibrary . List _self ) public returns ( bool ) isIndexed checks if the list is indexed","title":"Return Values:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#parameters_7","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#return-values_7","text":"Name Type Description true struct HashListLibrary.List if the list is indexed ### all function all ( struct HashListLibrary . List _self ) public returns ( bytes32 []) all returns all list elements","title":"Return Values:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#parameters_8","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#return-values_8","text":"Name Type Description all struct HashListLibrary.List list elements ### has function has ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) size returns the list size","title":"Return Values:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#parameters_9","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#return-values_9","text":"Name Type Description true struct HashListLibrary.List if the value exists ### size function size ( struct HashListLibrary . List _self ) public returns ( uint256 ) size gets the list size","title":"Return Values:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#parameters_10","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#return-values_10","text":"Name Type Description total struct HashListLibrary.List length of the list ### ownedBy function ownedBy ( struct HashListLibrary . List _self ) public returns ( address ) ownedBy gets the list owner","title":"Return Values:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#parameters_11","text":"Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage","title":"Parameters:"},{"location":"architecture/contracts/contracts/libraries/HashListLibrary/#return-values_11","text":"Name Type Description list struct HashListLibrary.List owner","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/","text":"Implementation of the DID Registry. Functions \u00b6 initialize \u00b6 function initialize ( address _owner ) public DIDRegistry Initializer Initialize Ownable. Only on contract creation. Parameters: \u00b6 Name Type Description _owner address refers to the owner of the contract. setManager \u00b6 function setManager ( ) external Sets the manager role. Should be the TransferCondition contract address registerAttribute \u00b6 function registerAttribute ( bytes32 _didSeed , bytes32 _checksum , address [] _url ) public returns ( uint256 size ) Register DID attributes. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Parameters: \u00b6 Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _url address[] refers to the attribute value, limited to 2048 bytes. Return Values: \u00b6 Name Type Description size bytes32 refers to the size of the registry after the register action. ### registerDID function registerDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , bytes32 _providers , string _activityId , _attributes ) public returns ( uint256 size ) Register DID attributes. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Parameters: \u00b6 Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). The final DID will be calculated with the creator address using the hashDID function _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _providers bytes32 list of DID providers addresses _activityId string refers to activity _attributes refers to the provenance attributes Return Values: \u00b6 Name Type Description size bytes32 refers to the size of the registry after the register action. ### hashDID function hashDID ( bytes32 _didSeed , address _creator ) public returns ( bytes32 ) It generates a DID using as seed a bytes32 and the address of the DID creator Parameters: \u00b6 Name Type Description _didSeed bytes32 refers to DID Seed used as base to generate the final DID _creator address address of the creator of the DID Return Values: \u00b6 Name Type Description the bytes32 new DID created ### areRoyaltiesValid function areRoyaltiesValid ( bytes32 _did , uint256 [] _amounts , address [] _receivers ) public returns ( bool ) areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards Return Values: \u00b6 Name Type Description true bytes32 if the rewards distribution respect the original creator royalties ### wasGeneratedBy function wasGeneratedBy ( ) internal returns ( bool ) used \u00b6 function used ( ) public returns ( bool success ) wasDerivedFrom \u00b6 function wasDerivedFrom ( ) public returns ( bool success ) wasAssociatedWith \u00b6 function wasAssociatedWith ( ) public returns ( bool success ) actedOnBehalf \u00b6 function actedOnBehalf ( bytes32 _provId , bytes32 _did , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes _signatureDelegate , string _attributes ) public returns ( bool success ) Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId & _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId) Parameters: \u00b6 Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes Return Values: \u00b6 Name Type Description success bytes32 true if the action was properly registered ### addDIDProvider function addDIDProvider ( bytes32 _did , address _provider ) external addDIDProvider add new DID provider. it adds new DID provider to the providers list. A provider is any entity that can serve the registered asset Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address. removeDIDProvider \u00b6 function removeDIDProvider ( bytes32 _did , address _provider ) external removeDIDProvider delete an existing DID provider. Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address. addDIDProvenanceDelegate \u00b6 function addDIDProvenanceDelegate ( bytes32 _did , address _delegate ) public addDIDProvenanceDelegate add new DID provenance delegate. it adds new DID provenance delegate to the delegates list. A delegate is any entity that interact with the provenance entries of one DID Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegates's address. removeDIDProvenanceDelegate \u00b6 function removeDIDProvenanceDelegate ( bytes32 _did , address _delegate ) external removeDIDProvenanceDelegate delete an existing DID delegate. Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address. transferDIDOwnership \u00b6 function transferDIDOwnership ( bytes32 _did , address _newOwner ) external transferDIDOwnership transfer DID ownership Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _newOwner address new owner address transferDIDOwnershipManaged \u00b6 function transferDIDOwnershipManaged ( address _did , bytes32 _newOwner ) external transferDIDOwnershipManaged transfer DID ownership Parameters: \u00b6 Name Type Description _did address refers to decentralized identifier (a bytes32 length ID) _newOwner bytes32 new owner address _transferDIDOwnership \u00b6 function _transferDIDOwnership ( ) internal grantPermission \u00b6 function grantPermission ( bytes32 _did , address _grantee ) external grantPermission grants access permission to grantee Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address revokePermission \u00b6 function revokePermission ( bytes32 _did , address _grantee ) external revokePermission revokes access permission from grantee Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address getPermission \u00b6 function getPermission ( bytes32 _did , address _grantee ) external returns ( bool ) getPermission gets access permission of a grantee Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address Return Values: \u00b6 Name Type Description true bytes32 if grantee has access permission to a DID ### isDIDProvider function isDIDProvider ( bytes32 _did , address _provider ) public returns ( bool ) isDIDProvider check whether a given DID provider exists Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address. getDIDRegister \u00b6 function getDIDRegister ( bytes32 _did ) public returns ( address owner , bytes32 lastChecksum , string url , address lastUpdatedBy , uint256 blockNumberUpdated , address [] providers , uint256 nftSupply , uint256 mintCap , uint256 royalties ) Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Return Values: \u00b6 Name Type Description owner bytes32 the did owner lastChecksum url lastUpdatedBy blockNumberUpdated getBlockNumberUpdated \u00b6 function getBlockNumberUpdated ( bytes32 _did ) public returns ( uint256 blockNumberUpdated ) Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Return Values: \u00b6 Name Type Description blockNumberUpdated bytes32 last modified (update) block number of a DID. ### getDIDOwner function getDIDOwner ( bytes32 _did ) public returns ( address didOwner ) Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Return Values: \u00b6 Name Type Description didOwner bytes32 the address of the DID owner. ### getDIDRegistrySize function getDIDRegistrySize ( ) public returns ( uint256 size ) Return Values: \u00b6 Name Type Description size the length of the DID registry. ### getDIDRegisterIds function getDIDRegisterIds ( ) public returns ( bytes32 []) Return Values: \u00b6 Name Type Description the list of items in the DID registry. ### _grantPermission function _grantPermission ( bytes32 _did , address _grantee ) internal _grantPermission grants access permission to grantee Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address _revokePermission \u00b6 function _revokePermission ( bytes32 _did , address _grantee ) internal _revokePermission revokes access permission from grantee Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address _getPermission \u00b6 function _getPermission ( bytes32 _did , address _grantee ) internal returns ( bool ) _getPermission gets access permission of a grantee Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address Return Values: \u00b6 Name Type Description true bytes32 if grantee has access permission to a DID ### getProvenanceEntry function getProvenanceEntry ( bytes32 _provId ) public returns ( bytes32 did , bytes32 relatedDid , address agentId , bytes32 activityId , address agentInvolvedId , uint8 method , address createdBy , uint256 blockNumberUpdated , bytes signature ) Fetch the complete provenance entry attributes Parameters: \u00b6 Name Type Description _provId bytes32 refers to the provenance identifier Return Values: \u00b6 Name Type Description did bytes32 relatedDid activityId agentInvolvedId createdBy blockNumberUpdated signature isDIDOwner \u00b6 function isDIDOwner ( address _address , bytes32 _did ) public returns ( bool ) isDIDOwner check whether a given address is owner for a DID Parameters: \u00b6 Name Type Description _address address user address. _did bytes32 refers to decentralized identifier (a bytes32 length ID). isOwnerProviderOrDelegate \u00b6 function isOwnerProviderOrDelegate ( bytes32 _did ) public returns ( bool ) isOwnerProviderOrDelegate check whether msg.sender is owner, provider or delegate for a DID given Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Return Values: \u00b6 Name Type Description boolean bytes32 true if yes ### isProvenanceDelegate function isProvenanceDelegate ( bytes32 _did , address _delegate ) public returns ( bool ) isProvenanceDelegate check whether a given DID delegate exists Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address. Return Values: \u00b6 Name Type Description boolean bytes32 true if yes ### getProvenanceOwner function getProvenanceOwner ( bytes32 _did ) public returns ( address provenanceOwner ) Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Return Values: \u00b6 Name Type Description provenanceOwner bytes32 the address of the Provenance owner. ## Events ### DIDAttributeRegistered event DIDAttributeRegistered ( ) DID Events DIDProviderRemoved \u00b6 event DIDProviderRemoved ( ) DIDProviderAdded \u00b6 event DIDProviderAdded ( ) DIDOwnershipTransferred \u00b6 event DIDOwnershipTransferred ( ) DIDPermissionGranted \u00b6 event DIDPermissionGranted ( ) DIDPermissionRevoked \u00b6 event DIDPermissionRevoked ( ) DIDProvenanceDelegateRemoved \u00b6 event DIDProvenanceDelegateRemoved ( ) DIDProvenanceDelegateAdded \u00b6 event DIDProvenanceDelegateAdded ( )","title":"DIDFactory"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#initialize","text":"function initialize ( address _owner ) public DIDRegistry Initializer Initialize Ownable. Only on contract creation.","title":"initialize"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters","text":"Name Type Description _owner address refers to the owner of the contract.","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#setmanager","text":"function setManager ( ) external Sets the manager role. Should be the TransferCondition contract address","title":"setManager"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#registerattribute","text":"function registerAttribute ( bytes32 _didSeed , bytes32 _checksum , address [] _url ) public returns ( uint256 size ) Register DID attributes. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info.","title":"registerAttribute"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_1","text":"Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _url address[] refers to the attribute value, limited to 2048 bytes.","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#return-values","text":"Name Type Description size bytes32 refers to the size of the registry after the register action. ### registerDID function registerDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , bytes32 _providers , string _activityId , _attributes ) public returns ( uint256 size ) Register DID attributes. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info.","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_2","text":"Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). The final DID will be calculated with the creator address using the hashDID function _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _providers bytes32 list of DID providers addresses _activityId string refers to activity _attributes refers to the provenance attributes","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#return-values_1","text":"Name Type Description size bytes32 refers to the size of the registry after the register action. ### hashDID function hashDID ( bytes32 _didSeed , address _creator ) public returns ( bytes32 ) It generates a DID using as seed a bytes32 and the address of the DID creator","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_3","text":"Name Type Description _didSeed bytes32 refers to DID Seed used as base to generate the final DID _creator address address of the creator of the DID","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#return-values_2","text":"Name Type Description the bytes32 new DID created ### areRoyaltiesValid function areRoyaltiesValid ( bytes32 _did , uint256 [] _amounts , address [] _receivers ) public returns ( bool ) areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_4","text":"Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#return-values_3","text":"Name Type Description true bytes32 if the rewards distribution respect the original creator royalties ### wasGeneratedBy function wasGeneratedBy ( ) internal returns ( bool )","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#used","text":"function used ( ) public returns ( bool success )","title":"used"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#wasderivedfrom","text":"function wasDerivedFrom ( ) public returns ( bool success )","title":"wasDerivedFrom"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#wasassociatedwith","text":"function wasAssociatedWith ( ) public returns ( bool success )","title":"wasAssociatedWith"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#actedonbehalf","text":"function actedOnBehalf ( bytes32 _provId , bytes32 _did , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes _signatureDelegate , string _attributes ) public returns ( bool success ) Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId & _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId)","title":"actedOnBehalf"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_5","text":"Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#return-values_4","text":"Name Type Description success bytes32 true if the action was properly registered ### addDIDProvider function addDIDProvider ( bytes32 _did , address _provider ) external addDIDProvider add new DID provider. it adds new DID provider to the providers list. A provider is any entity that can serve the registered asset","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_6","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address.","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#removedidprovider","text":"function removeDIDProvider ( bytes32 _did , address _provider ) external removeDIDProvider delete an existing DID provider.","title":"removeDIDProvider"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_7","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address.","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#adddidprovenancedelegate","text":"function addDIDProvenanceDelegate ( bytes32 _did , address _delegate ) public addDIDProvenanceDelegate add new DID provenance delegate. it adds new DID provenance delegate to the delegates list. A delegate is any entity that interact with the provenance entries of one DID","title":"addDIDProvenanceDelegate"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_8","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegates's address.","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#removedidprovenancedelegate","text":"function removeDIDProvenanceDelegate ( bytes32 _did , address _delegate ) external removeDIDProvenanceDelegate delete an existing DID delegate.","title":"removeDIDProvenanceDelegate"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_9","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address.","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#transferdidownership","text":"function transferDIDOwnership ( bytes32 _did , address _newOwner ) external transferDIDOwnership transfer DID ownership","title":"transferDIDOwnership"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_10","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _newOwner address new owner address","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#transferdidownershipmanaged","text":"function transferDIDOwnershipManaged ( address _did , bytes32 _newOwner ) external transferDIDOwnershipManaged transfer DID ownership","title":"transferDIDOwnershipManaged"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_11","text":"Name Type Description _did address refers to decentralized identifier (a bytes32 length ID) _newOwner bytes32 new owner address","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#_transferdidownership","text":"function _transferDIDOwnership ( ) internal","title":"_transferDIDOwnership"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#grantpermission","text":"function grantPermission ( bytes32 _did , address _grantee ) external grantPermission grants access permission to grantee","title":"grantPermission"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_12","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#revokepermission","text":"function revokePermission ( bytes32 _did , address _grantee ) external revokePermission revokes access permission from grantee","title":"revokePermission"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_13","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#getpermission","text":"function getPermission ( bytes32 _did , address _grantee ) external returns ( bool ) getPermission gets access permission of a grantee","title":"getPermission"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_14","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#return-values_5","text":"Name Type Description true bytes32 if grantee has access permission to a DID ### isDIDProvider function isDIDProvider ( bytes32 _did , address _provider ) public returns ( bool ) isDIDProvider check whether a given DID provider exists","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_15","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address.","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#getdidregister","text":"function getDIDRegister ( bytes32 _did ) public returns ( address owner , bytes32 lastChecksum , string url , address lastUpdatedBy , uint256 blockNumberUpdated , address [] providers , uint256 nftSupply , uint256 mintCap , uint256 royalties )","title":"getDIDRegister"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_16","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID).","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#return-values_6","text":"Name Type Description owner bytes32 the did owner lastChecksum url lastUpdatedBy blockNumberUpdated","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#getblocknumberupdated","text":"function getBlockNumberUpdated ( bytes32 _did ) public returns ( uint256 blockNumberUpdated )","title":"getBlockNumberUpdated"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_17","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID).","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#return-values_7","text":"Name Type Description blockNumberUpdated bytes32 last modified (update) block number of a DID. ### getDIDOwner function getDIDOwner ( bytes32 _did ) public returns ( address didOwner )","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_18","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID).","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#return-values_8","text":"Name Type Description didOwner bytes32 the address of the DID owner. ### getDIDRegistrySize function getDIDRegistrySize ( ) public returns ( uint256 size )","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#return-values_9","text":"Name Type Description size the length of the DID registry. ### getDIDRegisterIds function getDIDRegisterIds ( ) public returns ( bytes32 [])","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#return-values_10","text":"Name Type Description the list of items in the DID registry. ### _grantPermission function _grantPermission ( bytes32 _did , address _grantee ) internal _grantPermission grants access permission to grantee","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_19","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#_revokepermission","text":"function _revokePermission ( bytes32 _did , address _grantee ) internal _revokePermission revokes access permission from grantee","title":"_revokePermission"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_20","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#_getpermission","text":"function _getPermission ( bytes32 _did , address _grantee ) internal returns ( bool ) _getPermission gets access permission of a grantee","title":"_getPermission"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_21","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#return-values_11","text":"Name Type Description true bytes32 if grantee has access permission to a DID ### getProvenanceEntry function getProvenanceEntry ( bytes32 _provId ) public returns ( bytes32 did , bytes32 relatedDid , address agentId , bytes32 activityId , address agentInvolvedId , uint8 method , address createdBy , uint256 blockNumberUpdated , bytes signature ) Fetch the complete provenance entry attributes","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_22","text":"Name Type Description _provId bytes32 refers to the provenance identifier","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#return-values_12","text":"Name Type Description did bytes32 relatedDid activityId agentInvolvedId createdBy blockNumberUpdated signature","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#isdidowner","text":"function isDIDOwner ( address _address , bytes32 _did ) public returns ( bool ) isDIDOwner check whether a given address is owner for a DID","title":"isDIDOwner"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_23","text":"Name Type Description _address address user address. _did bytes32 refers to decentralized identifier (a bytes32 length ID).","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#isownerproviderordelegate","text":"function isOwnerProviderOrDelegate ( bytes32 _did ) public returns ( bool ) isOwnerProviderOrDelegate check whether msg.sender is owner, provider or delegate for a DID given","title":"isOwnerProviderOrDelegate"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_24","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID).","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#return-values_13","text":"Name Type Description boolean bytes32 true if yes ### isProvenanceDelegate function isProvenanceDelegate ( bytes32 _did , address _delegate ) public returns ( bool ) isProvenanceDelegate check whether a given DID delegate exists","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_25","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address.","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#return-values_14","text":"Name Type Description boolean bytes32 true if yes ### getProvenanceOwner function getProvenanceOwner ( bytes32 _did ) public returns ( address provenanceOwner )","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#parameters_26","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID).","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#return-values_15","text":"Name Type Description provenanceOwner bytes32 the address of the Provenance owner. ## Events ### DIDAttributeRegistered event DIDAttributeRegistered ( ) DID Events","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#didproviderremoved","text":"event DIDProviderRemoved ( )","title":"DIDProviderRemoved"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#didprovideradded","text":"event DIDProviderAdded ( )","title":"DIDProviderAdded"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#didownershiptransferred","text":"event DIDOwnershipTransferred ( )","title":"DIDOwnershipTransferred"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#didpermissiongranted","text":"event DIDPermissionGranted ( )","title":"DIDPermissionGranted"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#didpermissionrevoked","text":"event DIDPermissionRevoked ( )","title":"DIDPermissionRevoked"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#didprovenancedelegateremoved","text":"event DIDProvenanceDelegateRemoved ( )","title":"DIDProvenanceDelegateRemoved"},{"location":"architecture/contracts/contracts/registry/DIDFactory/#didprovenancedelegateadded","text":"event DIDProvenanceDelegateAdded ( )","title":"DIDProvenanceDelegateAdded"},{"location":"architecture/contracts/contracts/registry/DIDRegistry/","text":"Implementation of a Mintable DID Registry. Functions \u00b6 initialize \u00b6 function initialize ( address _owner ) public DIDRegistry Initializer Initialize Ownable. Only on contract creation. Parameters: \u00b6 Name Type Description _owner address refers to the owner of the contract. registerMintableDID \u00b6 function registerMintableDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , uint256 _cap , uint8 _royalties , bytes32 _activityId , string _attributes ) public returns ( uint256 size ) Register a Mintable DID. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Parameters: \u00b6 Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Return Values: \u00b6 Name Type Description size bytes32 refers to the size of the registry after the register action. ### enableAndMintDidNft function enableAndMintDidNft ( bytes32 _did , uint256 _cap , uint8 _royalties , bool _preMint ) public returns ( bool success ) enableDidNft creates the initial setup of NFTs minting and royalties distribution. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _preMint bool if is true mint directly the amount capped tokens and lock in the _lockAddress mint \u00b6 function mint ( bytes32 _did , uint256 _amount ) public Mints a NFT associated to the DID Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both Only the DID owner can mint NFTs associated to the DID Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to mint burn \u00b6 function burn ( bytes32 _did , uint256 _amount ) public Burns NFTs associated to the DID Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both Only the DID owner can burn NFTs associated to the DID Parameters: \u00b6 Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to burn","title":"DIDRegistry"},{"location":"architecture/contracts/contracts/registry/DIDRegistry/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/registry/DIDRegistry/#initialize","text":"function initialize ( address _owner ) public DIDRegistry Initializer Initialize Ownable. Only on contract creation.","title":"initialize"},{"location":"architecture/contracts/contracts/registry/DIDRegistry/#parameters","text":"Name Type Description _owner address refers to the owner of the contract.","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDRegistry/#registermintabledid","text":"function registerMintableDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , uint256 _cap , uint8 _royalties , bytes32 _activityId , string _attributes ) public returns ( uint256 size ) Register a Mintable DID. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info.","title":"registerMintableDID"},{"location":"architecture/contracts/contracts/registry/DIDRegistry/#parameters_1","text":"Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _activityId bytes32 refers to activity _attributes string refers to the provenance attributes","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDRegistry/#return-values","text":"Name Type Description size bytes32 refers to the size of the registry after the register action. ### enableAndMintDidNft function enableAndMintDidNft ( bytes32 _did , uint256 _cap , uint8 _royalties , bool _preMint ) public returns ( bool success ) enableDidNft creates the initial setup of NFTs minting and royalties distribution. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDRegistry/#parameters_2","text":"Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _preMint bool if is true mint directly the amount capped tokens and lock in the _lockAddress","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDRegistry/#mint","text":"function mint ( bytes32 _did , uint256 _amount ) public Mints a NFT associated to the DID Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both Only the DID owner can mint NFTs associated to the DID","title":"mint"},{"location":"architecture/contracts/contracts/registry/DIDRegistry/#parameters_3","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to mint","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDRegistry/#burn","text":"function burn ( bytes32 _did , uint256 _amount ) public Burns NFTs associated to the DID Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both Only the DID owner can burn NFTs associated to the DID","title":"burn"},{"location":"architecture/contracts/contracts/registry/DIDRegistry/#parameters_4","text":"Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to burn","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/","text":"All function calls are currently implemented without side effects Functions \u00b6 update \u00b6 function update ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , bytes32 _checksum , string _url ) external returns ( uint256 size ) update the DID store access modifiers and storage pointer should be implemented in DIDRegistry Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _checksum bytes32 includes a one-way HASH calculated using the DDO content _url string includes the url resolving to the DID Document (DDO) initializeNftConfig \u00b6 function initializeNftConfig ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint256 _cap , uint8 _royalties ) internal initializeNftConfig creates the initial setup of NFTs minting and royalties distribution. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market The royalties in secondary market for the creator should be between 0% >= x < 100% areRoyaltiesValid \u00b6 function areRoyaltiesValid ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint256 [] _amounts , address [] _receivers ) internal returns ( bool ) areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards Return Values: \u00b6 Name Type Description true struct DIDRegistryLibrary.DIDRegisterList if the rewards distribution respect the original creator royalties ### addProvider function addProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address provider ) internal addProvider add provider to DID registry update the DID registry providers list by adding a new provider Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) provider address the provider's address removeProvider \u00b6 function removeProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _provider ) internal returns ( bool ) removeProvider remove provider from DID registry update the DID registry providers list by removing an existing provider Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address updateDIDOwner \u00b6 function updateDIDOwner ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _newOwner ) internal updateDIDOwner transfer DID ownership to a new owner Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _newOwner address the new DID owner address isProvider \u00b6 function isProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _provider ) public returns ( bool ) isProvider check whether DID provider exists Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address Return Values: \u00b6 Name Type Description true struct DIDRegistryLibrary.DIDRegisterList if the provider already exists ### addDelegate function addDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address delegate ) internal addDelegate add delegate to DID registry update the DID registry delegates list by adding a new delegate Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) delegate address the delegate's address removeDelegate \u00b6 function removeDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _delegate ) internal returns ( bool ) removeDelegate remove delegate from DID registry update the DID registry delegates list by removing an existing delegate Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address isDelegate \u00b6 function isDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _delegate ) public returns ( bool ) isDelegate check whether DID delegate exists Parameters: \u00b6 Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address Return Values: \u00b6 Name Type Description true struct DIDRegistryLibrary.DIDRegisterList if the delegate already exists","title":"DIDRegistryLibrary"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#update","text":"function update ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , bytes32 _checksum , string _url ) external returns ( uint256 size ) update the DID store access modifiers and storage pointer should be implemented in DIDRegistry","title":"update"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#parameters","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _checksum bytes32 includes a one-way HASH calculated using the DDO content _url string includes the url resolving to the DID Document (DDO)","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#initializenftconfig","text":"function initializeNftConfig ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint256 _cap , uint8 _royalties ) internal initializeNftConfig creates the initial setup of NFTs minting and royalties distribution. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration","title":"initializeNftConfig"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#parameters_1","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market The royalties in secondary market for the creator should be between 0% >= x < 100%","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#areroyaltiesvalid","text":"function areRoyaltiesValid ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint256 [] _amounts , address [] _receivers ) internal returns ( bool ) areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly","title":"areRoyaltiesValid"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#parameters_2","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#return-values","text":"Name Type Description true struct DIDRegistryLibrary.DIDRegisterList if the rewards distribution respect the original creator royalties ### addProvider function addProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address provider ) internal addProvider add provider to DID registry update the DID registry providers list by adding a new provider","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#parameters_3","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) provider address the provider's address","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#removeprovider","text":"function removeProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _provider ) internal returns ( bool ) removeProvider remove provider from DID registry update the DID registry providers list by removing an existing provider","title":"removeProvider"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#parameters_4","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#updatedidowner","text":"function updateDIDOwner ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _newOwner ) internal updateDIDOwner transfer DID ownership to a new owner","title":"updateDIDOwner"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#parameters_5","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _newOwner address the new DID owner address","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#isprovider","text":"function isProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _provider ) public returns ( bool ) isProvider check whether DID provider exists","title":"isProvider"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#parameters_6","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#return-values_1","text":"Name Type Description true struct DIDRegistryLibrary.DIDRegisterList if the provider already exists ### addDelegate function addDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address delegate ) internal addDelegate add delegate to DID registry update the DID registry delegates list by adding a new delegate","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#parameters_7","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) delegate address the delegate's address","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#removedelegate","text":"function removeDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _delegate ) internal returns ( bool ) removeDelegate remove delegate from DID registry update the DID registry delegates list by removing an existing delegate","title":"removeDelegate"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#parameters_8","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#isdelegate","text":"function isDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _delegate ) public returns ( bool ) isDelegate check whether DID delegate exists","title":"isDelegate"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#parameters_9","text":"Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/DIDRegistryLibrary/#return-values_2","text":"Name Type Description true struct DIDRegistryLibrary.DIDRegisterList if the delegate already exists","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/","text":"All function calls are currently implemented without side effects Functions \u00b6 __ProvenanceRegistry_init \u00b6 function __ProvenanceRegistry_init ( ) internal __ProvenanceRegistry_init_unchained \u00b6 function __ProvenanceRegistry_init_unchained ( ) internal createProvenanceEntry \u00b6 function createProvenanceEntry ( bytes32 _provId , bytes32 _did , bytes32 _relatedDid , address _agentId , bytes32 _activityId , address _agentInvolvedId , enum ProvenanceRegistry . ProvenanceMethod _method , address _createdBy , bytes _signatureDelegate ) internal returns ( bool ) create an event in the Provenance store access modifiers and storage pointer should be implemented in ProvenanceRegistry Parameters: \u00b6 Name Type Description _provId bytes32 refers to provenance event identifier _did bytes32 refers to decentralized identifier (a byte32 length ID) _relatedDid bytes32 refers to decentralized identifier (a byte32 length ID) of a related entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _agentInvolvedId address refers to address of the agent involved with the provenance record _method enum ProvenanceRegistry.ProvenanceMethod refers to the W3C Provenance method _createdBy address refers to address of the agent triggering the activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _wasGeneratedBy \u00b6 function _wasGeneratedBy ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal returns ( bool ) Implements the W3C PROV Generation action Parameters: \u00b6 Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Return Values: \u00b6 Name Type Description the bytes32 number of the new provenance size ### _used function _used ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , bytes _signatureUsing , string _attributes ) internal returns ( bool success ) Implements the W3C PROV Usage action Parameters: \u00b6 Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _signatureUsing bytes refers to the digital signature provided by the agent using the _did _attributes string refers to the provenance attributes Return Values: \u00b6 Name Type Description success bytes32 true if the action was properly registered ### _wasDerivedFrom function _wasDerivedFrom ( bytes32 _provId , bytes32 _newEntityDid , bytes32 _usedEntityDid , address _agentId , bytes32 _activityId , string _attributes ) internal returns ( bool success ) Implements the W3C PROV Derivation action Parameters: \u00b6 Name Type Description _provId bytes32 unique identifier referring to the provenance entry _newEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _usedEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity used to derive the new did _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Return Values: \u00b6 Name Type Description success bytes32 true if the action was properly registered ### _wasAssociatedWith function _wasAssociatedWith ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal returns ( bool success ) Implements the W3C PROV Association action Parameters: \u00b6 Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Return Values: \u00b6 Name Type Description success bytes32 true if the action was properly registered ### _actedOnBehalf function _actedOnBehalf ( bytes32 _provId , bytes32 _did , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes _signatureDelegate , string _attributes ) internal returns ( bool success ) Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId & _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId) Parameters: \u00b6 Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes Return Values: \u00b6 Name Type Description success bytes32 true if the action was properly registered ## Events ### ProvenanceAttributeRegistered event ProvenanceAttributeRegistered ( ) Provenance Events WasGeneratedBy \u00b6 event WasGeneratedBy ( ) Used \u00b6 event Used ( ) WasDerivedFrom \u00b6 event WasDerivedFrom ( ) WasAssociatedWith \u00b6 event WasAssociatedWith ( ) ActedOnBehalf \u00b6 event ActedOnBehalf ( )","title":"ProvenanceRegistry"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#__provenanceregistry_init","text":"function __ProvenanceRegistry_init ( ) internal","title":"__ProvenanceRegistry_init"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#__provenanceregistry_init_unchained","text":"function __ProvenanceRegistry_init_unchained ( ) internal","title":"__ProvenanceRegistry_init_unchained"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#createprovenanceentry","text":"function createProvenanceEntry ( bytes32 _provId , bytes32 _did , bytes32 _relatedDid , address _agentId , bytes32 _activityId , address _agentInvolvedId , enum ProvenanceRegistry . ProvenanceMethod _method , address _createdBy , bytes _signatureDelegate ) internal returns ( bool ) create an event in the Provenance store access modifiers and storage pointer should be implemented in ProvenanceRegistry","title":"createProvenanceEntry"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#parameters","text":"Name Type Description _provId bytes32 refers to provenance event identifier _did bytes32 refers to decentralized identifier (a byte32 length ID) _relatedDid bytes32 refers to decentralized identifier (a byte32 length ID) of a related entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _agentInvolvedId address refers to address of the agent involved with the provenance record _method enum ProvenanceRegistry.ProvenanceMethod refers to the W3C Provenance method _createdBy address refers to address of the agent triggering the activity _signatureDelegate bytes refers to the digital signature provided by the did delegate.","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#_wasgeneratedby","text":"function _wasGeneratedBy ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal returns ( bool ) Implements the W3C PROV Generation action","title":"_wasGeneratedBy"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#parameters_1","text":"Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#return-values","text":"Name Type Description the bytes32 number of the new provenance size ### _used function _used ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , bytes _signatureUsing , string _attributes ) internal returns ( bool success ) Implements the W3C PROV Usage action","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#parameters_2","text":"Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _signatureUsing bytes refers to the digital signature provided by the agent using the _did _attributes string refers to the provenance attributes","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#return-values_1","text":"Name Type Description success bytes32 true if the action was properly registered ### _wasDerivedFrom function _wasDerivedFrom ( bytes32 _provId , bytes32 _newEntityDid , bytes32 _usedEntityDid , address _agentId , bytes32 _activityId , string _attributes ) internal returns ( bool success ) Implements the W3C PROV Derivation action","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#parameters_3","text":"Name Type Description _provId bytes32 unique identifier referring to the provenance entry _newEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _usedEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity used to derive the new did _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#return-values_2","text":"Name Type Description success bytes32 true if the action was properly registered ### _wasAssociatedWith function _wasAssociatedWith ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal returns ( bool success ) Implements the W3C PROV Association action","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#parameters_4","text":"Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#return-values_3","text":"Name Type Description success bytes32 true if the action was properly registered ### _actedOnBehalf function _actedOnBehalf ( bytes32 _provId , bytes32 _did , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes _signatureDelegate , string _attributes ) internal returns ( bool success ) Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId & _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId)","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#parameters_5","text":"Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes","title":"Parameters:"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#return-values_4","text":"Name Type Description success bytes32 true if the action was properly registered ## Events ### ProvenanceAttributeRegistered event ProvenanceAttributeRegistered ( ) Provenance Events","title":"Return Values:"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#wasgeneratedby","text":"event WasGeneratedBy ( )","title":"WasGeneratedBy"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#used","text":"event Used ( )","title":"Used"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#wasderivedfrom","text":"event WasDerivedFrom ( )","title":"WasDerivedFrom"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#wasassociatedwith","text":"event WasAssociatedWith ( )","title":"WasAssociatedWith"},{"location":"architecture/contracts/contracts/registry/ProvenanceRegistry/#actedonbehalf","text":"event ActedOnBehalf ( )","title":"ActedOnBehalf"},{"location":"architecture/contracts/contracts/templates/AccessProofTemplate/","text":"Implementation of Access Agreement Template Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _accessConditionAddress , address _lockConditionAddress , address payable _escrowConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address","title":"AccessProofTemplate"},{"location":"architecture/contracts/contracts/templates/AccessProofTemplate/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/templates/AccessProofTemplate/#initialize","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _accessConditionAddress , address _lockConditionAddress , address payable _escrowConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions.","title":"initialize"},{"location":"architecture/contracts/contracts/templates/AccessProofTemplate/#parameters","text":"Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/AccessTemplate/","text":"Implementation of Access Agreement Template Access template is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an on-chain SEA. The template is a composite of three basic conditions. Once the agreement is created, the consumer will lock an amount of tokens (as listed in the DID document - off-chain metadata) to the the lock reward contract which in turn will fire an event. ON the other hand the provider is listening to all the emitted events, the provider will catch the event and grant permissions to the consumer through secret store contract, the consumer now is able to download the data set by asking the off-chain component of secret store to decrypt the DID and encrypt it using the consumer's public key. Then the secret store will provide an on-chain proof that the consumer had access to the data set. Finally, the provider can call the escrow reward condition in order to release the payment. Every condition has a time window (time lock and time out). This implies that if the provider didn't grant the access to the consumer through secret store within this time window, the consumer can ask for refund. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _accessConditionAddress , address _lockConditionAddress , address payable _escrowConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address","title":"AccessTemplate"},{"location":"architecture/contracts/contracts/templates/AccessTemplate/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/templates/AccessTemplate/#initialize","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _accessConditionAddress , address _lockConditionAddress , address payable _escrowConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions.","title":"initialize"},{"location":"architecture/contracts/contracts/templates/AccessTemplate/#parameters","text":"Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/AgreementTemplate/","text":"Implementation of Agreement Template Agreement template is a reference template where it has the ability to create agreements from whitelisted template Functions \u00b6 createAgreement \u00b6 function createAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts ) public returns ( uint256 size ) createAgreement create new agreement Parameters: \u00b6 Name Type Description _id bytes32 agreement unique identifier _did bytes32 refers to decentralized identifier (a bytes32 length ID). _conditionIds bytes32[] list of condition identifiers _timeLocks uint256[] list of time locks, each time lock will be assigned to the same condition that has the same index _timeOuts uint256[] list of time outs, each time out will be assigned to the same condition that has the same index Return Values: \u00b6 Name Type Description size bytes32 the index of the created agreement ### getConditionTypes function getConditionTypes ( ) public returns ( address []) getConditionTypes gets the conditions addresses list for the current template returns list of condition contracts addresses Return Values: \u00b6 Name Type Description list of conditions contract addresses","title":"AgreementTemplate"},{"location":"architecture/contracts/contracts/templates/AgreementTemplate/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/templates/AgreementTemplate/#createagreement","text":"function createAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts ) public returns ( uint256 size ) createAgreement create new agreement","title":"createAgreement"},{"location":"architecture/contracts/contracts/templates/AgreementTemplate/#parameters","text":"Name Type Description _id bytes32 agreement unique identifier _did bytes32 refers to decentralized identifier (a bytes32 length ID). _conditionIds bytes32[] list of condition identifiers _timeLocks uint256[] list of time locks, each time lock will be assigned to the same condition that has the same index _timeOuts uint256[] list of time outs, each time out will be assigned to the same condition that has the same index","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/AgreementTemplate/#return-values","text":"Name Type Description size bytes32 the index of the created agreement ### getConditionTypes function getConditionTypes ( ) public returns ( address []) getConditionTypes gets the conditions addresses list for the current template returns list of condition contracts addresses","title":"Return Values:"},{"location":"architecture/contracts/contracts/templates/AgreementTemplate/#return-values_1","text":"Name Type Description list of conditions contract addresses","title":"Return Values:"},{"location":"architecture/contracts/contracts/templates/BaseEscrowTemplate/","text":"Functions \u00b6 createAgreement \u00b6 function createAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer ) public returns ( uint256 size ) createAgreement creates agreements through agreement template this function initializes the agreement by setting the DID, conditions ID, timeouts, time locks and the consumer address. The DID provider/owner is automatically detected by the DID Registry Parameters: \u00b6 Name Type Description _id bytes32 SEA agreement unique identifier _did bytes32 Decentralized Identifier (DID) _conditionIds bytes32[] conditions ID associated with the condition types _timeLocks uint256[] the starting point of the time window ,time lock is in block number not seconds _timeOuts uint256[] the ending point of the time window ,time lock is in block number not seconds _accessConsumer address consumer address Return Values: \u00b6 Name Type Description size bytes32 the agreement index ### getAgreementData function getAgreementData ( bytes32 _id ) external returns ( address accessConsumer , address accessProvider ) getAgreementData return the agreement Data Parameters: \u00b6 Name Type Description _id bytes32 SEA agreement unique identifier Return Values: \u00b6 Name Type Description accessConsumer bytes32 the agreement consumer accessProvider the provider addresses ## Events ### AgreementCreated event AgreementCreated ( )","title":"BaseEscrowTemplate"},{"location":"architecture/contracts/contracts/templates/BaseEscrowTemplate/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/templates/BaseEscrowTemplate/#createagreement","text":"function createAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer ) public returns ( uint256 size ) createAgreement creates agreements through agreement template this function initializes the agreement by setting the DID, conditions ID, timeouts, time locks and the consumer address. The DID provider/owner is automatically detected by the DID Registry","title":"createAgreement"},{"location":"architecture/contracts/contracts/templates/BaseEscrowTemplate/#parameters","text":"Name Type Description _id bytes32 SEA agreement unique identifier _did bytes32 Decentralized Identifier (DID) _conditionIds bytes32[] conditions ID associated with the condition types _timeLocks uint256[] the starting point of the time window ,time lock is in block number not seconds _timeOuts uint256[] the ending point of the time window ,time lock is in block number not seconds _accessConsumer address consumer address","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/BaseEscrowTemplate/#return-values","text":"Name Type Description size bytes32 the agreement index ### getAgreementData function getAgreementData ( bytes32 _id ) external returns ( address accessConsumer , address accessProvider ) getAgreementData return the agreement Data","title":"Return Values:"},{"location":"architecture/contracts/contracts/templates/BaseEscrowTemplate/#parameters_1","text":"Name Type Description _id bytes32 SEA agreement unique identifier","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/BaseEscrowTemplate/#return-values_1","text":"Name Type Description accessConsumer bytes32 the agreement consumer accessProvider the provider addresses ## Events ### AgreementCreated event AgreementCreated ( )","title":"Return Values:"},{"location":"architecture/contracts/contracts/templates/DIDSalesTemplate/","text":"Implementation of DID Sales Template The DID Sales template supports an scenario where an Asset owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing an Asset owner to get transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer DID Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the ownership transfer of an asset from the current owner for a specific DID. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockConditionAddress address lock reward condition contract address _transferConditionAddress address transfer ownership condition contract address _escrowPaymentAddress address payable escrow reward condition contract address","title":"DIDSalesTemplate"},{"location":"architecture/contracts/contracts/templates/DIDSalesTemplate/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/templates/DIDSalesTemplate/#initialize","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions.","title":"initialize"},{"location":"architecture/contracts/contracts/templates/DIDSalesTemplate/#parameters","text":"Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockConditionAddress address lock reward condition contract address _transferConditionAddress address transfer ownership condition contract address _escrowPaymentAddress address payable escrow reward condition contract address","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/DynamicAccessTemplate/","text":"Implementation of Agreement Template This is a dynamic template that allows to setup flexible conditions depending on the use case. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address addTemplateCondition \u00b6 function addTemplateCondition ( address _conditionAddress ) external returns ( uint256 length ) addTemplateCondition adds a new condition to the template Parameters: \u00b6 Name Type Description _conditionAddress address condition contract address Return Values: \u00b6 Name Type Description length address conditionTypes array size ### removeLastTemplateCondition function removeLastTemplateCondition ( ) external returns ( address []) removeLastTemplateCondition removes last condition added to the template Return Values: \u00b6 Name Type Description conditionTypes existing in the array","title":"DynamicAccessTemplate"},{"location":"architecture/contracts/contracts/templates/DynamicAccessTemplate/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/templates/DynamicAccessTemplate/#initialize","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions.","title":"initialize"},{"location":"architecture/contracts/contracts/templates/DynamicAccessTemplate/#parameters","text":"Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/DynamicAccessTemplate/#addtemplatecondition","text":"function addTemplateCondition ( address _conditionAddress ) external returns ( uint256 length ) addTemplateCondition adds a new condition to the template","title":"addTemplateCondition"},{"location":"architecture/contracts/contracts/templates/DynamicAccessTemplate/#parameters_1","text":"Name Type Description _conditionAddress address condition contract address","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/DynamicAccessTemplate/#return-values","text":"Name Type Description length address conditionTypes array size ### removeLastTemplateCondition function removeLastTemplateCondition ( ) external returns ( address []) removeLastTemplateCondition removes last condition added to the template","title":"Return Values:"},{"location":"architecture/contracts/contracts/templates/DynamicAccessTemplate/#return-values_1","text":"Name Type Description conditionTypes existing in the array","title":"Return Values:"},{"location":"architecture/contracts/contracts/templates/EscrowComputeExecutionTemplate/","text":"Implementation of a Compute Execution Agreement Template EscrowComputeExecutionTemplate is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an on-chain SEA. The template is a composite of three basic conditions. Once the agreement is created, the consumer will lock an amount of tokens (as listed in the DID document - off-chain metadata) to the the lock reward contract which in turn will fire an event. ON the other hand the provider is listening to all the emitted events, the provider will catch the event and grant permissions to trigger a computation granting the execution via the ComputeExecutionCondition contract. The consumer now is able to trigger that computation by asking the off-chain gateway to start the execution of a compute workflow. Finally, the provider can call the escrow reward condition in order to release the payment. Every condition has a time window (time lock and time out). This implies that if the provider didn't grant the execution to the consumer within this time window, the consumer can ask for refund. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _computeExecutionConditionAddress , address _lockPaymentConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including service executor condition, lock reward and escrow reward conditions. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _computeExecutionConditionAddress address service executor condition contract address _lockPaymentConditionAddress address lock reward condition contract address _escrowPaymentAddress address payable escrow reward contract address","title":"EscrowComputeExecutionTemplate"},{"location":"architecture/contracts/contracts/templates/EscrowComputeExecutionTemplate/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/templates/EscrowComputeExecutionTemplate/#initialize","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _computeExecutionConditionAddress , address _lockPaymentConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including service executor condition, lock reward and escrow reward conditions.","title":"initialize"},{"location":"architecture/contracts/contracts/templates/EscrowComputeExecutionTemplate/#parameters","text":"Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _computeExecutionConditionAddress address service executor condition contract address _lockPaymentConditionAddress address lock reward condition contract address _escrowPaymentAddress address payable escrow reward contract address","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/NFTAccessTemplate/","text":"Implementation of NFT Access Template The NFT Access template is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing NFT holders to get access to Nevermined services. The template is a composite of 2 basic conditions: - NFT Holding Condition - Access Condition Once the agreement is created, the consumer can demonstrate is holding a NFT for a specific DID. If that's the case the Access condition can be fulfilled by the asset owner or provider and all the agreement is fulfilled. This can be used in scenarios where a data or services owner, can allow users to get access to exclusive services only when they demonstrate the are holding a specific number of NFTs of a DID. This is very useful in use cases like arts. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _nftHolderConditionAddress , address _accessConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftHolderConditionAddress address lock reward condition contract address _accessConditionAddress address access condition contract address","title":"NFTAccessTemplate"},{"location":"architecture/contracts/contracts/templates/NFTAccessTemplate/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/templates/NFTAccessTemplate/#initialize","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _nftHolderConditionAddress , address _accessConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions.","title":"initialize"},{"location":"architecture/contracts/contracts/templates/NFTAccessTemplate/#parameters","text":"Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftHolderConditionAddress address lock reward condition contract address _accessConditionAddress address access condition contract address","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/NFTSalesTemplate/","text":"Implementation of NFT Sales Template The NFT Sales template supports an scenario where a NFT owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing a NFT owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer NFT Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the transfer of the NFT from the current owner for a specific DID. Functions \u00b6 initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockPaymentConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Parameters: \u00b6 Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _transferConditionAddress address transfer NFT condition contract address _escrowPaymentAddress address payable escrow reward condition contract address","title":"NFTSalesTemplate"},{"location":"architecture/contracts/contracts/templates/NFTSalesTemplate/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/templates/NFTSalesTemplate/#initialize","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockPaymentConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions.","title":"initialize"},{"location":"architecture/contracts/contracts/templates/NFTSalesTemplate/#parameters","text":"Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _transferConditionAddress address transfer NFT condition contract address _escrowPaymentAddress address payable escrow reward condition contract address","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/TemplateStoreLibrary/","text":"Implementation of the Template Store Library. Templates are blueprints for modular SEAs. When creating an Agreement, a templateId defines the condition and reward types that are instantiated in the ConditionStore. Functions \u00b6 propose \u00b6 function propose ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal returns ( uint256 size ) propose new template Parameters: \u00b6 Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address Return Values: \u00b6 Name Type Description size struct TemplateStoreLibrary.TemplateList which is the index of the proposed template ### approve function approve ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal approve new template Parameters: \u00b6 Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address revoke \u00b6 function revoke ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal revoke new template Parameters: \u00b6 Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address approved template contract address","title":"TemplateStoreLibrary"},{"location":"architecture/contracts/contracts/templates/TemplateStoreLibrary/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/templates/TemplateStoreLibrary/#propose","text":"function propose ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal returns ( uint256 size ) propose new template","title":"propose"},{"location":"architecture/contracts/contracts/templates/TemplateStoreLibrary/#parameters","text":"Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/TemplateStoreLibrary/#return-values","text":"Name Type Description size struct TemplateStoreLibrary.TemplateList which is the index of the proposed template ### approve function approve ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal approve new template","title":"Return Values:"},{"location":"architecture/contracts/contracts/templates/TemplateStoreLibrary/#parameters_1","text":"Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/TemplateStoreLibrary/#revoke","text":"function revoke ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal revoke new template","title":"revoke"},{"location":"architecture/contracts/contracts/templates/TemplateStoreLibrary/#parameters_2","text":"Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address approved template contract address","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/TemplateStoreManager/","text":"Implementation of the Template Store Manager. Templates are blueprints for modular SEAs. When creating an Agreement, a templateId defines the condition and reward types that are instantiated in the ConditionStore. This contract manages the life cycle of the template ( Propose \u2192 Approve \u2192 Revoke ). Functions \u00b6 initialize \u00b6 function initialize ( address _owner ) public initialize TemplateStoreManager Initializer Initializes Ownable. Only on contract creation. Parameters: \u00b6 Name Type Description _owner address refers to the owner of the contract proposeTemplate \u00b6 function proposeTemplate ( address _id ) external returns ( uint256 size ) proposeTemplate proposes a new template Parameters: \u00b6 Name Type Description _id address unique template identifier which is basically the template contract address approveTemplate \u00b6 function approveTemplate ( address _id ) external approveTemplate approves a template Parameters: \u00b6 Name Type Description _id address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) can approve this template. revokeTemplate \u00b6 function revokeTemplate ( address _id ) external revokeTemplate revoke a template Parameters: \u00b6 Name Type Description _id address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) or template owner can revoke this template. getTemplate \u00b6 function getTemplate ( address _id ) external returns ( enum TemplateStoreLibrary . TemplateState state , address owner , address lastUpdatedBy , uint256 blockNumberUpdated ) getTemplate get more information about a template Parameters: \u00b6 Name Type Description _id address unique template identifier which is basically the template contract address. Return Values: \u00b6 Name Type Description state address template status owner template owner lastUpdatedBy last updated by blockNumberUpdated last updated at. ### getTemplateListSize function getTemplateListSize ( ) external returns ( uint256 size ) getTemplateListSize number of templates Return Values: \u00b6 Name Type Description size number of templates ### isTemplateApproved function isTemplateApproved ( address _id ) external returns ( bool ) isTemplateApproved check whether the template is approved Parameters: \u00b6 Name Type Description _id address unique template identifier which is basically the template contract address. Return Values: \u00b6 Name Type Description true address if the template is approved","title":"TemplateStoreManager"},{"location":"architecture/contracts/contracts/templates/TemplateStoreManager/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/templates/TemplateStoreManager/#initialize","text":"function initialize ( address _owner ) public initialize TemplateStoreManager Initializer Initializes Ownable. Only on contract creation.","title":"initialize"},{"location":"architecture/contracts/contracts/templates/TemplateStoreManager/#parameters","text":"Name Type Description _owner address refers to the owner of the contract","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/TemplateStoreManager/#proposetemplate","text":"function proposeTemplate ( address _id ) external returns ( uint256 size ) proposeTemplate proposes a new template","title":"proposeTemplate"},{"location":"architecture/contracts/contracts/templates/TemplateStoreManager/#parameters_1","text":"Name Type Description _id address unique template identifier which is basically the template contract address","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/TemplateStoreManager/#approvetemplate","text":"function approveTemplate ( address _id ) external approveTemplate approves a template","title":"approveTemplate"},{"location":"architecture/contracts/contracts/templates/TemplateStoreManager/#parameters_2","text":"Name Type Description _id address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) can approve this template.","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/TemplateStoreManager/#revoketemplate","text":"function revokeTemplate ( address _id ) external revokeTemplate revoke a template","title":"revokeTemplate"},{"location":"architecture/contracts/contracts/templates/TemplateStoreManager/#parameters_3","text":"Name Type Description _id address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) or template owner can revoke this template.","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/TemplateStoreManager/#gettemplate","text":"function getTemplate ( address _id ) external returns ( enum TemplateStoreLibrary . TemplateState state , address owner , address lastUpdatedBy , uint256 blockNumberUpdated ) getTemplate get more information about a template","title":"getTemplate"},{"location":"architecture/contracts/contracts/templates/TemplateStoreManager/#parameters_4","text":"Name Type Description _id address unique template identifier which is basically the template contract address.","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/TemplateStoreManager/#return-values","text":"Name Type Description state address template status owner template owner lastUpdatedBy last updated by blockNumberUpdated last updated at. ### getTemplateListSize function getTemplateListSize ( ) external returns ( uint256 size ) getTemplateListSize number of templates","title":"Return Values:"},{"location":"architecture/contracts/contracts/templates/TemplateStoreManager/#return-values_1","text":"Name Type Description size number of templates ### isTemplateApproved function isTemplateApproved ( address _id ) external returns ( bool ) isTemplateApproved check whether the template is approved","title":"Return Values:"},{"location":"architecture/contracts/contracts/templates/TemplateStoreManager/#parameters_5","text":"Name Type Description _id address unique template identifier which is basically the template contract address.","title":"Parameters:"},{"location":"architecture/contracts/contracts/templates/TemplateStoreManager/#return-values_2","text":"Name Type Description true address if the template is approved","title":"Return Values:"},{"location":"architecture/contracts/contracts/test/IPNFT/","text":"Functions \u00b6 initialize \u00b6 function initialize ( ) public setTokenURI \u00b6 function setTokenURI ( ) public mint \u00b6 function mint ( ) public returns ( bool ) mintWithoutTokenURI \u00b6 function mintWithoutTokenURI ( ) external transfer \u00b6 function transfer ( ) public Events \u00b6 TokenURIChanged \u00b6 event TokenURIChanged ( )","title":"IPNFT"},{"location":"architecture/contracts/contracts/test/IPNFT/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/IPNFT/#initialize","text":"function initialize ( ) public","title":"initialize"},{"location":"architecture/contracts/contracts/test/IPNFT/#settokenuri","text":"function setTokenURI ( ) public","title":"setTokenURI"},{"location":"architecture/contracts/contracts/test/IPNFT/#mint","text":"function mint ( ) public returns ( bool )","title":"mint"},{"location":"architecture/contracts/contracts/test/IPNFT/#mintwithouttokenuri","text":"function mintWithoutTokenURI ( ) external","title":"mintWithoutTokenURI"},{"location":"architecture/contracts/contracts/test/IPNFT/#transfer","text":"function transfer ( ) public","title":"transfer"},{"location":"architecture/contracts/contracts/test/IPNFT/#events","text":"","title":"Events"},{"location":"architecture/contracts/contracts/test/IPNFT/#tokenurichanged","text":"event TokenURIChanged ( )","title":"TokenURIChanged"},{"location":"architecture/contracts/contracts/test/TestDisputeManager/","text":"Functions \u00b6 accepted \u00b6 function accepted ( ) public returns ( bool ) setAccepted \u00b6 function setAccepted ( ) public","title":"TestDisputeManager"},{"location":"architecture/contracts/contracts/test/TestDisputeManager/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/TestDisputeManager/#accepted","text":"function accepted ( ) public returns ( bool )","title":"accepted"},{"location":"architecture/contracts/contracts/test/TestDisputeManager/#setaccepted","text":"function setAccepted ( ) public","title":"setAccepted"},{"location":"architecture/contracts/contracts/test/TestERC721/","text":"Functions \u00b6 initialize \u00b6 function initialize ( ) public mint \u00b6 function mint ( ) public","title":"TestERC721"},{"location":"architecture/contracts/contracts/test/TestERC721/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/TestERC721/#initialize","text":"function initialize ( ) public","title":"initialize"},{"location":"architecture/contracts/contracts/test/TestERC721/#mint","text":"function mint ( ) public","title":"mint"},{"location":"architecture/contracts/contracts/test/AgreementStoreManager/AgreementStoreManagerChangeFunctionSignature/","text":"Functions \u00b6 createAgreement \u00b6 function createAgreement ( ) public returns ( uint256 size )","title":"AgreementStoreManagerChangeFunctionSignature"},{"location":"architecture/contracts/contracts/test/AgreementStoreManager/AgreementStoreManagerChangeFunctionSignature/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/AgreementStoreManager/AgreementStoreManagerChangeFunctionSignature/#createagreement","text":"function createAgreement ( ) public returns ( uint256 size )","title":"createAgreement"},{"location":"architecture/contracts/contracts/test/AgreementStoreManager/AgreementStoreManagerChangeInStorage/","text":"","title":"AgreementStoreManagerChangeInStorage"},{"location":"architecture/contracts/contracts/test/AgreementStoreManager/AgreementStoreManagerChangeInStorageAndLogic/","text":"","title":"AgreementStoreManagerChangeInStorageAndLogic"},{"location":"architecture/contracts/contracts/test/AgreementStoreManager/AgreementStoreManagerExtraFunctionality/","text":"Functions \u00b6 dummyFunction \u00b6 function dummyFunction ( ) public returns ( bool )","title":"AgreementStoreManagerExtraFunctionality"},{"location":"architecture/contracts/contracts/test/AgreementStoreManager/AgreementStoreManagerExtraFunctionality/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/AgreementStoreManager/AgreementStoreManagerExtraFunctionality/#dummyfunction","text":"function dummyFunction ( ) public returns ( bool )","title":"dummyFunction"},{"location":"architecture/contracts/contracts/test/AgreementStoreManager/AgreementStoreManagerWithBug/","text":"Functions \u00b6 getAgreementListSize \u00b6 function getAgreementListSize ( ) public returns ( uint256 size )","title":"AgreementStoreManagerWithBug"},{"location":"architecture/contracts/contracts/test/AgreementStoreManager/AgreementStoreManagerWithBug/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/AgreementStoreManager/AgreementStoreManagerWithBug/#getagreementlistsize","text":"function getAgreementListSize ( ) public returns ( uint256 size )","title":"getAgreementListSize"},{"location":"architecture/contracts/contracts/test/ConditionStoreManager/ConditionStoreChangeFunctionSignature/","text":"Functions \u00b6 createCondition \u00b6 function createCondition ( ) public returns ( uint256 size )","title":"ConditionStoreChangeFunctionSignature"},{"location":"architecture/contracts/contracts/test/ConditionStoreManager/ConditionStoreChangeFunctionSignature/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/ConditionStoreManager/ConditionStoreChangeFunctionSignature/#createcondition","text":"function createCondition ( ) public returns ( uint256 size )","title":"createCondition"},{"location":"architecture/contracts/contracts/test/ConditionStoreManager/ConditionStoreChangeInStorage/","text":"","title":"ConditionStoreChangeInStorage"},{"location":"architecture/contracts/contracts/test/ConditionStoreManager/ConditionStoreChangeInStorageAndLogic/","text":"","title":"ConditionStoreChangeInStorageAndLogic"},{"location":"architecture/contracts/contracts/test/ConditionStoreManager/ConditionStoreExtraFunctionality/","text":"Functions \u00b6 dummyFunction \u00b6 function dummyFunction ( ) public returns ( bool )","title":"ConditionStoreExtraFunctionality"},{"location":"architecture/contracts/contracts/test/ConditionStoreManager/ConditionStoreExtraFunctionality/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/ConditionStoreManager/ConditionStoreExtraFunctionality/#dummyfunction","text":"function dummyFunction ( ) public returns ( bool )","title":"dummyFunction"},{"location":"architecture/contracts/contracts/test/ConditionStoreManager/ConditionStoreWithBug/","text":"Functions \u00b6 getConditionState \u00b6 function getConditionState ( ) public returns ( enum ConditionStoreLibrary . ConditionState )","title":"ConditionStoreWithBug"},{"location":"architecture/contracts/contracts/test/ConditionStoreManager/ConditionStoreWithBug/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/ConditionStoreManager/ConditionStoreWithBug/#getconditionstate","text":"function getConditionState ( ) public returns ( enum ConditionStoreLibrary . ConditionState )","title":"getConditionState"},{"location":"architecture/contracts/contracts/test/DIDRegistry/DIDRegistryChangeFunctionSignature/","text":"Functions \u00b6 registerAttribute \u00b6 function registerAttribute ( ) public returns ( uint256 size )","title":"DIDRegistryChangeFunctionSignature"},{"location":"architecture/contracts/contracts/test/DIDRegistry/DIDRegistryChangeFunctionSignature/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/DIDRegistry/DIDRegistryChangeFunctionSignature/#registerattribute","text":"function registerAttribute ( ) public returns ( uint256 size )","title":"registerAttribute"},{"location":"architecture/contracts/contracts/test/DIDRegistry/DIDRegistryChangeInStorage/","text":"","title":"DIDRegistryChangeInStorage"},{"location":"architecture/contracts/contracts/test/DIDRegistry/DIDRegistryChangeInStorageAndLogic/","text":"","title":"DIDRegistryChangeInStorageAndLogic"},{"location":"architecture/contracts/contracts/test/DIDRegistry/DIDRegistryExtraFunctionality/","text":"Functions \u00b6 getNumber \u00b6 function getNumber ( ) public returns ( uint256 )","title":"DIDRegistryExtraFunctionality"},{"location":"architecture/contracts/contracts/test/DIDRegistry/DIDRegistryExtraFunctionality/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/DIDRegistry/DIDRegistryExtraFunctionality/#getnumber","text":"function getNumber ( ) public returns ( uint256 )","title":"getNumber"},{"location":"architecture/contracts/contracts/test/DIDRegistry/DIDRegistryWithBug/","text":"Functions \u00b6 registerAttribute \u00b6 function registerAttribute ( bytes32 _didSeed , bytes32 _checksum , address [] _url ) public returns ( uint256 size ) registerAttribute is called only by DID owner. this function registers DID attributes Parameters: \u00b6 Name Type Description _didSeed bytes32 refers to decentralized identifier (a byte32 length ID) _checksum bytes32 includes a one-way HASH calculated using the DDO content _url address[] refers to the attribute value","title":"DIDRegistryWithBug"},{"location":"architecture/contracts/contracts/test/DIDRegistry/DIDRegistryWithBug/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/DIDRegistry/DIDRegistryWithBug/#registerattribute","text":"function registerAttribute ( bytes32 _didSeed , bytes32 _checksum , address [] _url ) public returns ( uint256 size ) registerAttribute is called only by DID owner. this function registers DID attributes","title":"registerAttribute"},{"location":"architecture/contracts/contracts/test/DIDRegistry/DIDRegistryWithBug/#parameters","text":"Name Type Description _didSeed bytes32 refers to decentralized identifier (a byte32 length ID) _checksum bytes32 includes a one-way HASH calculated using the DDO content _url address[] refers to the attribute value","title":"Parameters:"},{"location":"architecture/contracts/contracts/test/TemplateStoreManager/TemplateStoreChangeFunctionSignature/","text":"Functions \u00b6 proposeTemplate \u00b6 function proposeTemplate ( ) external returns ( uint256 size )","title":"TemplateStoreChangeFunctionSignature"},{"location":"architecture/contracts/contracts/test/TemplateStoreManager/TemplateStoreChangeFunctionSignature/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/TemplateStoreManager/TemplateStoreChangeFunctionSignature/#proposetemplate","text":"function proposeTemplate ( ) external returns ( uint256 size )","title":"proposeTemplate"},{"location":"architecture/contracts/contracts/test/TemplateStoreManager/TemplateStoreChangeInStorage/","text":"","title":"TemplateStoreChangeInStorage"},{"location":"architecture/contracts/contracts/test/TemplateStoreManager/TemplateStoreChangeInStorageAndLogic/","text":"","title":"TemplateStoreChangeInStorageAndLogic"},{"location":"architecture/contracts/contracts/test/TemplateStoreManager/TemplateStoreExtraFunctionality/","text":"Functions \u00b6 dummyFunction \u00b6 function dummyFunction ( ) public returns ( bool )","title":"TemplateStoreExtraFunctionality"},{"location":"architecture/contracts/contracts/test/TemplateStoreManager/TemplateStoreExtraFunctionality/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/TemplateStoreManager/TemplateStoreExtraFunctionality/#dummyfunction","text":"function dummyFunction ( ) public returns ( bool )","title":"dummyFunction"},{"location":"architecture/contracts/contracts/test/TemplateStoreManager/TemplateStoreWithBug/","text":"Functions \u00b6 getTemplateListSize \u00b6 function getTemplateListSize ( ) external returns ( uint256 size )","title":"TemplateStoreWithBug"},{"location":"architecture/contracts/contracts/test/TemplateStoreManager/TemplateStoreWithBug/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/TemplateStoreManager/TemplateStoreWithBug/#gettemplatelistsize","text":"function getTemplateListSize ( ) external returns ( uint256 size )","title":"getTemplateListSize"},{"location":"architecture/contracts/contracts/test/libraries/DIDRegistryLibraryProxy/","text":"Functions \u00b6 areRoyaltiesValid \u00b6 function areRoyaltiesValid ( ) public returns ( bool ) updateDIDOwner \u00b6 function updateDIDOwner ( ) public update \u00b6 function update ( ) public returns ( uint256 size ) initializeNftConfig \u00b6 function initializeNftConfig ( ) public getDIDInfo \u00b6 function getDIDInfo ( ) public returns ( address owner , address creator , uint256 royalties )","title":"DIDRegistryLibraryProxy"},{"location":"architecture/contracts/contracts/test/libraries/DIDRegistryLibraryProxy/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/libraries/DIDRegistryLibraryProxy/#areroyaltiesvalid","text":"function areRoyaltiesValid ( ) public returns ( bool )","title":"areRoyaltiesValid"},{"location":"architecture/contracts/contracts/test/libraries/DIDRegistryLibraryProxy/#updatedidowner","text":"function updateDIDOwner ( ) public","title":"updateDIDOwner"},{"location":"architecture/contracts/contracts/test/libraries/DIDRegistryLibraryProxy/#update","text":"function update ( ) public returns ( uint256 size )","title":"update"},{"location":"architecture/contracts/contracts/test/libraries/DIDRegistryLibraryProxy/#initializenftconfig","text":"function initializeNftConfig ( ) public","title":"initializeNftConfig"},{"location":"architecture/contracts/contracts/test/libraries/DIDRegistryLibraryProxy/#getdidinfo","text":"function getDIDInfo ( ) public returns ( address owner , address creator , uint256 royalties )","title":"getDIDInfo"},{"location":"architecture/contracts/contracts/test/libraries/EpochLibraryProxy/","text":"Functions \u00b6 create \u00b6 function create ( ) external","title":"EpochLibraryProxy"},{"location":"architecture/contracts/contracts/test/libraries/EpochLibraryProxy/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/libraries/EpochLibraryProxy/#create","text":"function create ( ) external","title":"create"},{"location":"architecture/contracts/contracts/test/libraries/HashListLibraryProxy/","text":"Functions \u00b6 initialize \u00b6 function initialize ( ) public hash \u00b6 function hash ( ) public returns ( bytes32 ) add \u00b6 function add ( ) external returns ( bool ) add \u00b6 function add ( ) external returns ( bool ) update \u00b6 function update ( ) external returns ( bool ) index \u00b6 function index ( ) external returns ( bool ) has \u00b6 function has ( ) external returns ( bool ) remove \u00b6 function remove ( ) external returns ( bool ) get \u00b6 function get ( ) external returns ( bytes32 ) size \u00b6 function size ( ) external returns ( uint256 ) all \u00b6 function all ( ) external returns ( bytes32 []) indexOf \u00b6 function indexOf ( ) external returns ( uint256 ) ownedBy \u00b6 function ownedBy ( ) external returns ( address ) isIndexed \u00b6 function isIndexed ( ) external returns ( bool )","title":"HashListLibraryProxy"},{"location":"architecture/contracts/contracts/test/libraries/HashListLibraryProxy/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/test/libraries/HashListLibraryProxy/#initialize","text":"function initialize ( ) public","title":"initialize"},{"location":"architecture/contracts/contracts/test/libraries/HashListLibraryProxy/#hash","text":"function hash ( ) public returns ( bytes32 )","title":"hash"},{"location":"architecture/contracts/contracts/test/libraries/HashListLibraryProxy/#add","text":"function add ( ) external returns ( bool )","title":"add"},{"location":"architecture/contracts/contracts/test/libraries/HashListLibraryProxy/#add_1","text":"function add ( ) external returns ( bool )","title":"add"},{"location":"architecture/contracts/contracts/test/libraries/HashListLibraryProxy/#update","text":"function update ( ) external returns ( bool )","title":"update"},{"location":"architecture/contracts/contracts/test/libraries/HashListLibraryProxy/#index","text":"function index ( ) external returns ( bool )","title":"index"},{"location":"architecture/contracts/contracts/test/libraries/HashListLibraryProxy/#has","text":"function has ( ) external returns ( bool )","title":"has"},{"location":"architecture/contracts/contracts/test/libraries/HashListLibraryProxy/#remove","text":"function remove ( ) external returns ( bool )","title":"remove"},{"location":"architecture/contracts/contracts/test/libraries/HashListLibraryProxy/#get","text":"function get ( ) external returns ( bytes32 )","title":"get"},{"location":"architecture/contracts/contracts/test/libraries/HashListLibraryProxy/#size","text":"function size ( ) external returns ( uint256 )","title":"size"},{"location":"architecture/contracts/contracts/test/libraries/HashListLibraryProxy/#all","text":"function all ( ) external returns ( bytes32 [])","title":"all"},{"location":"architecture/contracts/contracts/test/libraries/HashListLibraryProxy/#indexof","text":"function indexOf ( ) external returns ( uint256 )","title":"indexOf"},{"location":"architecture/contracts/contracts/test/libraries/HashListLibraryProxy/#ownedby","text":"function ownedBy ( ) external returns ( address )","title":"ownedBy"},{"location":"architecture/contracts/contracts/test/libraries/HashListLibraryProxy/#isindexed","text":"function isIndexed ( ) external returns ( bool )","title":"isIndexed"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/","text":"Implementation of the basic standard multi-token. See https://eips.ethereum.org/EIPS/eip-1155 Originally based on code by Enjin: https://github.com/enjin/erc-1155 Available since v3.1. Functions \u00b6 __NFTUpgradeable_init \u00b6 function __NFTUpgradeable_init ( ) internal See {_setURI}. __ERC1155_init_unchained \u00b6 function __ERC1155_init_unchained ( ) internal uri \u00b6 function uri ( ) external returns ( string ) See {IERC1155MetadataURI-uri}. This implementation returns the same URI for all token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the \\{id\\} substring with the actual token type ID. burn \u00b6 function burn ( ) public burnBatch \u00b6 function burnBatch ( ) public balanceOf \u00b6 function balanceOf ( ) public returns ( uint256 ) See {IERC1155-balanceOf}. Requirements: account cannot be the zero address. balanceOf \u00b6 function balanceOf ( ) external returns ( uint256 ) Returns the amount of tokens of token type id owned by account . Requirements: account cannot be the zero address. balanceOfBatch \u00b6 function balanceOfBatch ( ) public returns ( uint256 []) See {IERC1155-balanceOfBatch}. Requirements: accounts and ids must have the same length. setApprovalForAll \u00b6 function setApprovalForAll ( ) public See {IERC1155-setApprovalForAll}. setProxyApproval \u00b6 function setProxyApproval ( ) public isApprovedForAll \u00b6 function isApprovedForAll ( ) public returns ( bool ) See {IERC1155-isApprovedForAll}. isHolder \u00b6 function isHolder ( ) public returns ( bool ) safeTransferFrom \u00b6 function safeTransferFrom ( ) public See {IERC1155-safeTransferFrom}. safeBatchTransferFrom \u00b6 function safeBatchTransferFrom ( ) public See {IERC1155-safeBatchTransferFrom}. _mint \u00b6 function _mint ( ) internal Creates amount tokens of token type id , and assigns them to account . Emits a {TransferSingle} event. Requirements: account cannot be the zero address. If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value. _mintBatch \u00b6 function _mintBatch ( ) internal xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}. Requirements: ids and amounts must have the same length. If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value. _burn \u00b6 function _burn ( ) internal Destroys amount tokens of token type id from account Requirements: account cannot be the zero address. account must have at least amount tokens of token type id . _burnBatch \u00b6 function _burnBatch ( ) internal xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}. Requirements: ids and amounts must have the same length. _beforeTokenTransfer \u00b6 function _beforeTokenTransfer ( ) internal Hook that is called before any token transfer. This includes minting and burning, as well as batched variants. The same hook is called on both single and batched variants. For single transfers, the length of the id and amount arrays will be 1. Calling conditions (for each id and amount pair): When from and to are both non-zero, amount of from 's tokens of token type id will be transferred to to . When from is zero, amount tokens of token type id will be minted for to . when to is zero, amount of from 's tokens of token type id will be burned. from and to are never both zero. ids and amounts have the same, non-zero length. To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks]. Events \u00b6 ProxyApproval \u00b6 event ProxyApproval ( ) Event for recording proxy approvals.","title":"NFTUpgradeable"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#functions","text":"","title":"Functions"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#__nftupgradeable_init","text":"function __NFTUpgradeable_init ( ) internal See {_setURI}.","title":"__NFTUpgradeable_init"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#__erc1155_init_unchained","text":"function __ERC1155_init_unchained ( ) internal","title":"__ERC1155_init_unchained"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#uri","text":"function uri ( ) external returns ( string ) See {IERC1155MetadataURI-uri}. This implementation returns the same URI for all token types. It relies on the token type ID substitution mechanism https://eips.ethereum.org/EIPS/eip-1155#metadata[defined in the EIP]. Clients calling this function must replace the \\{id\\} substring with the actual token type ID.","title":"uri"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#burn","text":"function burn ( ) public","title":"burn"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#burnbatch","text":"function burnBatch ( ) public","title":"burnBatch"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#balanceof","text":"function balanceOf ( ) public returns ( uint256 ) See {IERC1155-balanceOf}. Requirements: account cannot be the zero address.","title":"balanceOf"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#balanceof_1","text":"function balanceOf ( ) external returns ( uint256 ) Returns the amount of tokens of token type id owned by account . Requirements: account cannot be the zero address.","title":"balanceOf"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#balanceofbatch","text":"function balanceOfBatch ( ) public returns ( uint256 []) See {IERC1155-balanceOfBatch}. Requirements: accounts and ids must have the same length.","title":"balanceOfBatch"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#setapprovalforall","text":"function setApprovalForAll ( ) public See {IERC1155-setApprovalForAll}.","title":"setApprovalForAll"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#setproxyapproval","text":"function setProxyApproval ( ) public","title":"setProxyApproval"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#isapprovedforall","text":"function isApprovedForAll ( ) public returns ( bool ) See {IERC1155-isApprovedForAll}.","title":"isApprovedForAll"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#isholder","text":"function isHolder ( ) public returns ( bool )","title":"isHolder"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#safetransferfrom","text":"function safeTransferFrom ( ) public See {IERC1155-safeTransferFrom}.","title":"safeTransferFrom"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#safebatchtransferfrom","text":"function safeBatchTransferFrom ( ) public See {IERC1155-safeBatchTransferFrom}.","title":"safeBatchTransferFrom"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#_mint","text":"function _mint ( ) internal Creates amount tokens of token type id , and assigns them to account . Emits a {TransferSingle} event. Requirements: account cannot be the zero address. If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value.","title":"_mint"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#_mintbatch","text":"function _mintBatch ( ) internal xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_mint}. Requirements: ids and amounts must have the same length. If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.","title":"_mintBatch"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#_burn","text":"function _burn ( ) internal Destroys amount tokens of token type id from account Requirements: account cannot be the zero address. account must have at least amount tokens of token type id .","title":"_burn"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#_burnbatch","text":"function _burnBatch ( ) internal xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {_burn}. Requirements: ids and amounts must have the same length.","title":"_burnBatch"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#_beforetokentransfer","text":"function _beforeTokenTransfer ( ) internal Hook that is called before any token transfer. This includes minting and burning, as well as batched variants. The same hook is called on both single and batched variants. For single transfers, the length of the id and amount arrays will be 1. Calling conditions (for each id and amount pair): When from and to are both non-zero, amount of from 's tokens of token type id will be transferred to to . When from is zero, amount tokens of token type id will be minted for to . when to is zero, amount of from 's tokens of token type id will be burned. from and to are never both zero. ids and amounts have the same, non-zero length. To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].","title":"_beforeTokenTransfer"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#events","text":"","title":"Events"},{"location":"architecture/contracts/contracts/token/erc1155/NFTUpgradeable/#proxyapproval","text":"event ProxyApproval ( ) Event for recording proxy approvals.","title":"ProxyApproval"},{"location":"architecture/contracts/generated/solidity-api/","text":"Solidity API \u00b6 TestDisputeManager \u00b6 accept \u00b6 mapping ( bytes32 => bool ) accept accepted \u00b6 function accepted ( address provider , address buyer , bytes32 orig , bytes32 crypted ) public view returns ( bool ) setAccepted \u00b6 function setAccepted ( bytes32 orig , bytes32 crypted , address provider , address buyer ) public Common \u00b6 getCurrentBlockNumber \u00b6 function getCurrentBlockNumber () external view returns ( uint256 ) getCurrentBlockNumber get block number Name Type Description [0] uint256 the current block number isContract \u00b6 function isContract ( address addr ) public view returns ( bool ) isContract detect whether the address is is a contract address or externally owned account Name Type Description [0] bool true if it is a contract address provenanceSignatureIsCorrect \u00b6 function provenanceSignatureIsCorrect ( address _agentId , bytes32 _hash , bytes _signature ) public pure returns ( bool ) Name Type Description _agentId address The address of the agent _hash bytes32 bytes32 message, the hash is the signed message. What is recovered is the signer address. _signature bytes Signatures provided by the agent Name Type Description [0] bool true if the signature correspond to the agent address calculateTotalAmount \u00b6 function calculateTotalAmount ( uint256 [] _amounts ) public pure returns ( uint256 ) Sum the total amount given an uint array Name Type Description [0] uint256 the total amount addressToBytes32 \u00b6 function addressToBytes32 ( address _addr ) public pure returns ( bytes32 ) bytes32ToAddress \u00b6 function bytes32ToAddress ( bytes32 _b32 ) public pure returns ( address ) Dispenser \u00b6 tokenRequests \u00b6 mapping ( address => uint256 ) tokenRequests totalMintAmount \u00b6 uint256 totalMintAmount maxAmount \u00b6 uint256 maxAmount maxMintAmount \u00b6 uint256 maxMintAmount minPeriod \u00b6 uint256 minPeriod scale \u00b6 uint256 scale token \u00b6 contract NeverminedToken token RequestFrequencyExceeded \u00b6 event RequestFrequencyExceeded ( address requester , uint256 minPeriod ) RequestLimitExceeded \u00b6 event RequestLimitExceeded ( address requester , uint256 amount , uint256 maxAmount ) isValidAddress \u00b6 modifier isValidAddress ( address _address ) initialize \u00b6 function initialize ( address _tokenAddress , address _owner ) external Dispenser Initializer Name Type Description _tokenAddress address The deployed contract address of an ERC20 _owner address The owner of the Dispenser Runs only on initial contract creation. requestTokens \u00b6 function requestTokens ( uint256 amount ) external returns ( bool tokensTransferred ) user can request some tokens for testing Name Type Description amount uint256 the amount of tokens to be requested Name Type Description tokensTransferred bool Boolean indication of tokens are requested setMinPeriod \u00b6 function setMinPeriod ( uint256 period ) external the Owner can set the min period for token requests Name Type Description period uint256 the min amount of time before next request setMaxAmount \u00b6 function setMaxAmount ( uint256 amount ) external the Owner can set the max amount for token requests Name Type Description amount uint256 the max amount of tokens that can be requested setMaxMintAmount \u00b6 function setMaxMintAmount ( uint256 amount ) external the Owner can set the max amount for token requests Name Type Description amount uint256 the max amount of tokens that can be requested HashLists \u00b6 Hash lists contract is a sample list contract in which uses HashListLibrary.sol in order to store, retrieve, remove, and update bytes32 values in hash lists. This is a reference implementation for IList interface. It is used for whitelisting condition. Any entity can have its own implementation of the interface in which could be used for the same condition. lists \u00b6 mapping ( bytes32 => struct HashListLibrary . List ) lists initialize \u00b6 function initialize ( address _owner ) public HashLists Initializer Name Type Description _owner address The owner of the hash list Runs only upon contract creation. hash \u00b6 function hash ( address account ) public pure returns ( bytes32 ) hash ethereum accounts Name Type Description account address Ethereum address Name Type Description [0] bytes32 bytes32 hash of the account add \u00b6 function add ( bytes32 [] values ) external returns ( bool ) put an array of elements without indexing this meant to save gas in case of large arrays Name Type Description values bytes32[] is an array of elements value Name Type Description [0] bool true if values are added successfully add \u00b6 function add ( bytes32 value ) external returns ( bool ) add indexes an element then adds it to a list Name Type Description value bytes32 is a bytes32 value Name Type Description [0] bool true if value is added successfully update \u00b6 function update ( bytes32 oldValue , bytes32 newValue ) external returns ( bool ) update the value with a new value and maintain indices Name Type Description oldValue bytes32 is an element value in a list newValue bytes32 new value Name Type Description [0] bool true if value is updated successfully index \u00b6 function index ( uint256 from , uint256 to ) external returns ( bool ) index is used to map each element value to its index on the list Name Type Description from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing Name Type Description [0] bool true if the sub list is indexed has \u00b6 function has ( bytes32 id , bytes32 value ) external view returns ( bool ) has checks whether a value is exist Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list Name Type Description [0] bool true if the value exists has \u00b6 function has ( bytes32 value ) external view returns ( bool ) has checks whether a value is exist Name Type Description value bytes32 is element value in list Name Type Description [0] bool true if the value exists remove \u00b6 function remove ( bytes32 value ) external returns ( bool ) remove value from a list, updates indices, and list size Name Type Description value bytes32 is an element value in a list Name Type Description [0] bool true if value is removed successfully get \u00b6 function get ( bytes32 id , uint256 _index ) external view returns ( bytes32 ) has value by index Name Type Description id bytes32 the list identifier (the hash of list owner's address) _index uint256 is where is value is stored in the list Name Type Description [0] bytes32 the value if exists size \u00b6 function size ( bytes32 id ) external view returns ( uint256 ) size gets the list size Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] uint256 total length of the list all \u00b6 function all ( bytes32 id ) external view returns ( bytes32 []) all returns all list elements Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] bytes32[] all list elements indexOf \u00b6 function indexOf ( bytes32 id , bytes32 value ) external view returns ( uint256 ) indexOf gets the index of a value in a list Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list Name Type Description [0] uint256 value index in list ownedBy \u00b6 function ownedBy ( bytes32 id ) external view returns ( address ) ownedBy gets the list owner Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] address list owner isIndexed \u00b6 function isIndexed ( bytes32 id ) external view returns ( bool ) isIndexed checks if the list is indexed Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] bool true if the list is indexed NeverminedToken \u00b6 Implementation of a Test Token. Test Token is an ERC20 token only for testing purposes initialize \u00b6 function initialize ( address _owner , address payable _initialMinter ) public NeverminedToken Initializer Runs only on initial contract creation. Name Type Description _owner address refers to the owner of the contract _initialMinter address payable is the first token minter added _beforeTokenTransfer \u00b6 function _beforeTokenTransfer ( address from , address to , uint256 amount ) internal _See {ERC20-_beforeTokenTransfer}. Requirements: minted tokens must not cause the total supply to go over the cap._ mint \u00b6 function mint ( address account , uint256 amount ) external returns ( bool ) _Creates amount tokens and assigns them to account , increasing the total supply. Emits a {Transfer} event with from set to the zero address. Requirements: to cannot be the zero address._ AgreementStoreLibrary \u00b6 Implementation of the Agreement Store Library. The agreement store library holds the business logic in which manages the life cycle of SEA agreement, each agreement is linked to the DID of an asset, template, and condition IDs. Agreement \u00b6 struct Agreement { bytes32 did ; address templateId ; bytes32 [] conditionIds ; address lastUpdatedBy ; uint256 blockNumberUpdated ; } AgreementList \u00b6 struct AgreementList { mapping ( bytes32 &# x3D ; & gt ; struct AgreementStoreLibrary . Agreement ) agreements ; mapping ( bytes32 &# x3D ; & gt ; bytes32 []) didToAgreementIds ; mapping ( address &# x3D ; & gt ; bytes32 []) templateIdToAgreementIds ; bytes32 [] agreementIds ; } create \u00b6 function create ( struct AgreementStoreLibrary . AgreementList _self , bytes32 _id , bytes32 , address _templateId , bytes32 []) internal create new agreement checks whether the agreement Id exists, creates new agreement instance, including the template, conditions and DID. Name Type Description _self struct AgreementStoreLibrary.AgreementList is AgreementList storage pointer _id bytes32 agreement identifier bytes32 _templateId address template identifier bytes32[] Template \u00b6 getConditionTypes \u00b6 function getConditionTypes () external view returns ( address []) AgreementStoreManager \u00b6 _Implementation of the Agreement Store. The agreement store generates conditions for an agreement template. Agreement templates must to be approved in the Template Store Each agreement is linked to the DID of an asset._ PROXY_ROLE \u00b6 bytes32 PROXY_ROLE grantProxyRole \u00b6 function grantProxyRole ( address _address ) public revokeProxyRole \u00b6 function revokeProxyRole ( address _address ) public agreementList \u00b6 struct AgreementStoreLibrary . AgreementList agreementList state storage for the agreements conditionStoreManager \u00b6 contract ConditionStoreManager conditionStoreManager templateStoreManager \u00b6 contract TemplateStoreManager templateStoreManager didRegistry \u00b6 contract DIDRegistry didRegistry initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _templateStoreManagerAddress , address _didRegistryAddress ) public initialize AgreementStoreManager Initializer Initializes Ownable. Only on contract creation. Name Type Description _owner address refers to the owner of the contract _conditionStoreManagerAddress address is the address of the connected condition store _templateStoreManagerAddress address is the address of the connected template store _didRegistryAddress address is the address of the connected DID Registry fullConditionId \u00b6 function fullConditionId ( bytes32 _agreementId , address _condType , bytes32 _valueHash ) public pure returns ( bytes32 ) agreementId \u00b6 function agreementId ( bytes32 _agreementId , address _creator ) public pure returns ( bytes32 ) createAgreement \u00b6 function createAgreement ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts ) public Create a new agreement. The agreement will create conditions of conditionType with conditionId. Only \"approved\" templates can access this function. Name Type Description _id bytes32 is the ID of the new agreement. Must be unique. _did bytes32 is the bytes32 DID of the asset. The DID must be registered beforehand. _conditionTypes address[] is a list of addresses that point to Condition contracts. _conditionIds bytes32[] is a list of bytes32 content-addressed Condition IDs _timeLocks uint256[] is a list of uint time lock values associated to each Condition _timeOuts uint256[] is a list of uint time out values associated to each Condition CreateAgreementArgs \u00b6 struct CreateAgreementArgs { bytes32 _id ; bytes32 _did ; address [] _conditionTypes ; bytes32 [] _conditionIds ; uint256 [] _timeLocks ; uint256 [] _timeOuts ; address _creator ; uint256 _idx ; address payable _rewardAddress ; address _tokenAddress ; uint256 [] _amounts ; address [] _receivers ; } createAgreementAndPay \u00b6 function createAgreementAndPay ( struct AgreementStoreManager . CreateAgreementArgs args ) public payable createAgreementAndFulfill \u00b6 function createAgreementAndFulfill ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address [] _account , uint256 [] _idx , bytes [] params ) public payable getAgreementTemplate \u00b6 function getAgreementTemplate ( bytes32 _id ) external view returns ( address ) getDIDRegistryAddress \u00b6 function getDIDRegistryAddress () public view virtual returns ( address ) getDIDRegistryAddress utility function used by other contracts or any EOA. Name Type Description [0] address the DIDRegistry address AccessCondition \u00b6 _Implementation of the Access Condition Access Secret Store Condition is special condition where a client or Parity secret store can encrypt/decrypt documents based on the on-chain granted permissions. For a given DID document, and agreement ID, the owner/provider of the DID will fulfill the condition. Consequently secret store will check whether the permission is granted for the consumer in order to encrypt/decrypt the document._ CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE DocumentPermission \u00b6 struct DocumentPermission { bytes32 agreementIdDeprecated ; mapping ( address &# x3D ; & gt ; bool ) permission ; } documentPermissions \u00b6 mapping ( bytes32 => struct AccessCondition . DocumentPermission ) documentPermissions agreementStoreManager \u00b6 contract AgreementStoreManager agreementStoreManager didRegistry \u00b6 contract DIDRegistry didRegistry Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _documentId , address _grantee , bytes32 _conditionId ) onlyDIDOwnerOrProvider \u00b6 modifier onlyDIDOwnerOrProvider ( bytes32 _documentId ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address reinitialize \u00b6 function reinitialize () external Should be called when the contract has been upgraded. hashValues \u00b6 function hashValues ( bytes32 _documentId , address _grantee ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill access secret store condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) grantPermission \u00b6 function grantPermission ( address _grantee , bytes32 _documentId ) public grantPermission is called only by DID owner or provider Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys renouncePermission \u00b6 function renouncePermission ( address _grantee , bytes32 _documentId ) public renouncePermission is called only by DID owner or provider Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys checkPermissions \u00b6 function checkPermissions ( address _grantee , bytes32 _documentId ) external view returns ( bool permissionGranted ) checkPermissions is called by Parity secret store Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys Name Type Description permissionGranted bool true if the access was granted IDisputeManager \u00b6 verifyProof \u00b6 function verifyProof ( bytes proof , uint256 [] pubSignals ) external view returns ( bool ) AccessProofCondition \u00b6 Implementation of the Access Condition with transfer proof. The idea is that the hash of the decryption key is known before hand, and the key matching this hash is passed from data provider to the buyer using this smart contract. Using ZK proof the key is kept hidden from outsiders. For the protocol to work, both the provider and buyer need to have public keys in the babyjub curve. To initiate the deal, buyer will pass the key hash and the public keys of participants. The provider needs to pass the cipher text encrypted using MIMC (symmetric encryption). The secret key for MIMC is computed using ECDH (requires one public key and one secret key for the curve). The hash function that is used is Poseidon. CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE agreementStoreManager \u00b6 contract AgreementStoreManager agreementStoreManager disputeManager \u00b6 contract IDisputeManager disputeManager Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider , uint256 [ 2 ] _cipher , bytes _proof , bytes32 _conditionId ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress , address _disputeManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address _disputeManagerAddress address dispute manager address changeDisputeManager \u00b6 function changeDisputeManager ( address _disputeManagerAddress ) external hashValues \u00b6 function hashValues ( uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _origHash uint256 is the hash of the key _buyer uint256[2] buyer public key _provider uint256[2] provider public key Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider , uint256 [ 2 ] _cipher , bytes _proof ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill key transfer The key with hash _origHash is transferred to the _buyer from _provider. Name Type Description _agreementId bytes32 associated agreement _origHash uint256 is the hash of data to access _buyer uint256[2] buyer public key _provider uint256[2] provider public key _cipher uint256[2] encrypted version of the key _proof bytes SNARK proof that the cipher text can be decrypted by buyer to give the key with hash _origHash Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) ComputeExecutionCondition \u00b6 Implementation of the Compute Execution Condition This condition is meant to be a signal in which triggers the execution of a compute service. The compute service is fully described in the associated DID document. The provider of the compute service will send this signal to its workers by fulfilling the condition where they are listening to the fulfilled event. CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE computeExecutionStatus \u00b6 mapping ( bytes32 => mapping ( address => bool )) computeExecutionStatus agreementStoreManager \u00b6 contract AgreementStoreManager agreementStoreManager Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _computeConsumer , bytes32 _conditionId ) onlyDIDOwnerOrProvider \u00b6 modifier onlyDIDOwnerOrProvider ( bytes32 _did ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address hashValues \u00b6 function hashValues ( bytes32 _did , address _computeConsumer ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _computeConsumer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill compute execution condition only the compute provider can fulfill this condition. By fulfilling this condition the compute provider will trigger the execution of the offered job/compute. The compute service is described in a DID document. Name Type Description _agreementId bytes32 agreement identifier _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) wasComputeTriggered \u00b6 function wasComputeTriggered ( bytes32 _did , address _computeConsumer ) public view returns ( bool ) wasComputeTriggered checks whether the compute is triggered or not. Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the compute consumer's address Name Type Description [0] bool true if the compute is triggered Condition \u00b6 _Implementation of the Condition Each condition has a validation function that returns either FULFILLED, ABORTED or UNFULFILLED. When a condition is successfully solved, we call it FULFILLED. If a condition cannot be FULFILLED anymore due to a timeout or other types of counter-proofs, the condition is ABORTED. UNFULFILLED values imply that a condition has not been provably FULFILLED or ABORTED. All initialized conditions start out as UNFULFILLED._ conditionStoreManager \u00b6 contract ConditionStoreManager conditionStoreManager generateId \u00b6 function generateId ( bytes32 _agreementId , bytes32 _valueHash ) public view returns ( bytes32 ) generateId condition Id from the following parameters Name Type Description _agreementId bytes32 SEA agreement ID _valueHash bytes32 hash of all the condition input values fulfill \u00b6 function fulfill ( bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) internal returns ( enum ConditionStoreLibrary . ConditionState ) fulfill set the condition state to Fulfill | Abort Name Type Description _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState new condition state (Fulfill/Abort) Name Type Description [0] enum ConditionStoreLibrary.ConditionState the updated condition state abortByTimeOut \u00b6 function abortByTimeOut ( bytes32 _id ) external returns ( enum ConditionStoreLibrary . ConditionState ) abortByTimeOut set condition state to Aborted if the condition is timed out Name Type Description _id bytes32 condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState the updated condition state ConditionStoreLibrary \u00b6 _Implementation of the Condition Store Library. Condition is a key component in the service execution agreement. This library holds the logic for creating and updating condition Any Condition has only four state transitions starts with Uninitialized, Unfulfilled, Fulfilled, and Aborted. Condition state transition goes only forward from Unintialized -> Unfulfilled -> {Fulfilled || Aborted}_ ConditionState \u00b6 enum ConditionState { Uninitialized , Unfulfilled , Fulfilled , Aborted } Condition \u00b6 struct Condition { address typeRef ; enum ConditionStoreLibrary . ConditionState state ; address createdBy ; address lastUpdatedBy ; uint256 blockNumberUpdated ; } ConditionList \u00b6 struct ConditionList { mapping ( bytes32 &# x3D ; & gt ; struct ConditionStoreLibrary . Condition ) conditions ; mapping ( bytes32 &# x3D ; & gt ; mapping ( bytes32 &# x3D ; & gt ; bytes32 )) map ; bytes32 [] conditionIds ; } create \u00b6 function create ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , address _typeRef ) internal create new condition check whether the condition exists, assigns condition type, condition state, last updated by, and update at (which is the current block number) Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 valid condition identifier _typeRef address condition contract address updateState \u00b6 function updateState ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) internal updateState update the condition state check whether the condition state transition is right, assign the new state, update last updated by and updated at. Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState the new state of the condition updateKeyValue \u00b6 function updateKeyValue ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , bytes32 _key , bytes32 _value ) internal ConditionStoreManager \u00b6 _Implementation of the Condition Store Manager. Condition store manager is responsible for enforcing the the business logic behind creating/updating the condition state based on the assigned role to each party. Only specific type of contracts are allowed to call this contract, therefore there are two types of roles, create role that in which is able to create conditions. The second role is the update role, which is can update the condition state. Also, it support delegating the roles to other contract(s)/account(s)._ PROXY_ROLE \u00b6 bytes32 PROXY_ROLE RoleType \u00b6 enum RoleType { Create , Update } createRole \u00b6 address createRole conditionList \u00b6 struct ConditionStoreLibrary . ConditionList conditionList epochList \u00b6 struct EpochLibrary . EpochList epochList nvmConfigAddress \u00b6 address nvmConfigAddress ConditionCreated \u00b6 event ConditionCreated ( bytes32 _id , address _typeRef , address _who ) ConditionUpdated \u00b6 event ConditionUpdated ( bytes32 _id , address _typeRef , enum ConditionStoreLibrary . ConditionState _state , address _who ) onlyCreateRole \u00b6 modifier onlyCreateRole () onlyUpdateRole \u00b6 modifier onlyUpdateRole ( bytes32 _id ) onlyValidType \u00b6 modifier onlyValidType ( address typeRef ) initialize \u00b6 function initialize ( address _creator , address _owner , address _nvmConfigAddress ) public initialize ConditionStoreManager Initializer Initialize Ownable. Only on contract creation, Name Type Description _creator address refers to the creator of the contract _owner address refers to the owner of the contract _nvmConfigAddress address refers to the contract address of NeverminedConfig getCreateRole \u00b6 function getCreateRole () external view returns ( address ) getCreateRole get the address of contract which has the create role Name Type Description [0] address create condition role address getNvmConfigAddress \u00b6 function getNvmConfigAddress () external view returns ( address ) getNvmConfigAddress get the address of the NeverminedConfig contract Name Type Description [0] address NeverminedConfig contract address setNvmConfigAddress \u00b6 function setNvmConfigAddress ( address _addr ) external delegateCreateRole \u00b6 function delegateCreateRole ( address delegatee ) external delegateCreateRole only owner can delegate the create condition role to a different address Name Type Description delegatee address delegatee address delegateUpdateRole \u00b6 function delegateUpdateRole ( bytes32 _id , address delegatee ) external delegateUpdateRole only owner can delegate the update role to a different address for specific condition Id which has the create role Name Type Description _id bytes32 delegatee address delegatee address grantProxyRole \u00b6 function grantProxyRole ( address _address ) public revokeProxyRole \u00b6 function revokeProxyRole ( address _address ) public createCondition \u00b6 function createCondition ( bytes32 _id , address _typeRef ) external createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled. Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address createCondition2 \u00b6 function createCondition2 ( bytes32 _id , address _typeRef ) external createCondition \u00b6 function createCondition ( bytes32 _id , address _typeRef , uint256 _timeLock , uint256 _timeOut ) public createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled. Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address _timeLock uint256 start of the time window _timeOut uint256 end of the time window updateConditionState \u00b6 function updateConditionState ( bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) external returns ( enum ConditionStoreLibrary . ConditionState ) updateConditionState only called by update role address. It enforce the condition state transition to either Fulfill or Aborted state Name Type Description _id bytes32 unique condition identifier _newState enum ConditionStoreLibrary.ConditionState Name Type Description [0] enum ConditionStoreLibrary.ConditionState the current condition state updateConditionMapping \u00b6 function updateConditionMapping ( bytes32 _id , bytes32 _key , bytes32 _value ) external updateConditionMappingProxy \u00b6 function updateConditionMappingProxy ( bytes32 _id , bytes32 _key , bytes32 _value ) external getCondition \u00b6 function getCondition ( bytes32 _id ) external view returns ( address typeRef , enum ConditionStoreLibrary . ConditionState state , uint256 timeLock , uint256 timeOut , uint256 blockNumber ) getCondition Name Type Description typeRef address the type reference state enum ConditionStoreLibrary.ConditionState condition state timeLock uint256 the time lock timeOut uint256 time out blockNumber uint256 block number getConditionState \u00b6 function getConditionState ( bytes32 _id ) external view virtual returns ( enum ConditionStoreLibrary . ConditionState ) getConditionState Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state getConditionTypeRef \u00b6 function getConditionTypeRef ( bytes32 _id ) external view virtual returns ( address ) getConditionTypeRef Name Type Description [0] address condition typeRef getMappingValue \u00b6 function getMappingValue ( bytes32 _id , bytes32 _key ) external view virtual returns ( bytes32 ) getConditionState Name Type Description [0] bytes32 condition state isConditionTimeLocked \u00b6 function isConditionTimeLocked ( bytes32 _id ) public view returns ( bool ) isConditionTimeLocked Name Type Description [0] bool whether the condition is timedLock ended isConditionTimedOut \u00b6 function isConditionTimedOut ( bytes32 _id ) public view returns ( bool ) isConditionTimedOut Name Type Description [0] bool whether the condition is timed out HashLockCondition \u00b6 Implementation of the Hash Lock Condition CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( uint256 _preimage ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _preimage uint256 refers uint value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values hashValues \u00b6 function hashValues ( string _preimage ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _preimage string refers string value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values hashValues \u00b6 function hashValues ( bytes32 _preimage ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _preimage bytes32 refers bytes32 value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , uint256 _preimage ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image uint value Name Type Description _agreementId bytes32 SEA agreement identifier _preimage uint256 Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state fulfill \u00b6 function fulfill ( bytes32 _agreementId , string _preimage ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image string value Name Type Description _agreementId bytes32 SEA agreement identifier _preimage string Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _preimage ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image bytes32 value Name Type Description _agreementId bytes32 SEA agreement identifier _preimage bytes32 Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state _fulfill \u00b6 function _fulfill ( bytes32 _generatedId ) private returns ( enum ConditionStoreLibrary . ConditionState ) _fulfill calls super fulfil method Name Type Description _generatedId bytes32 SEA agreement identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state ICondition \u00b6 fulfillProxy \u00b6 function fulfillProxy ( address _account , bytes32 _agreementId , bytes params ) external payable ILockPayment \u00b6 Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId , address _rewardAddress , address _tokenAddress , address [] _receivers , uint256 [] _amounts ) hashValues \u00b6 function hashValues ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires valid token transfer in order to lock the amount of tokens based on the SEA Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state LockPaymentCondition \u00b6 Implementation of the Lock Payment Condition This condition allows to lock payment for multiple receivers taking into account the royalties to be paid to the original creators in a secondary market. didRegistry \u00b6 contract DIDRegistry didRegistry nvmConfig \u00b6 contract INVMConfig nvmConfig CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE KEY_ASSET_RECEIVER \u00b6 bytes32 KEY_ASSET_RECEIVER PROXY_ROLE \u00b6 bytes32 PROXY_ROLE ALLOWED_EXTERNAL_CONTRACT_ROLE \u00b6 bytes32 ALLOWED_EXTERNAL_CONTRACT_ROLE grantProxyRole \u00b6 function grantProxyRole ( address _address ) public revokeProxyRole \u00b6 function revokeProxyRole ( address _address ) public grantExternalContractRole \u00b6 function grantExternalContractRole ( address _address ) public revokeExternalContractRole \u00b6 function revokeExternalContractRole ( address _address ) public initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address reinitialize \u00b6 function reinitialize () external Should be called when the contract has been upgraded. hashValues \u00b6 function hashValues ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires valid token transfer in order to lock the amount of tokens based on the SEA Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state fulfillExternal \u00b6 function fulfillExternal ( bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _externalContract , bytes32 _remoteId , uint256 [] _amounts , address [] _receivers ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) fulfill lock condition using the funds locked in an external contract (auction, bonding curve, lottery, etc) Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _externalContract address the address of the contract with the lock funds are locked _remoteId bytes32 the id used to identify into the external contract _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state encodeParams \u00b6 function encodeParams ( bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external pure returns ( bytes ) fulfillInternal \u00b6 function fulfillInternal ( address _account , bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) internal returns ( enum ConditionStoreLibrary . ConditionState ) fulfillProxy \u00b6 function fulfillProxy ( address _account , bytes32 _agreementId , bytes params ) external payable _transferERC20Proxy \u00b6 function _transferERC20Proxy ( address _senderAddress , address _rewardAddress , address _tokenAddress , uint256 _amount ) internal _transferERC20Proxy transfer ERC20 tokens Will throw if transfer fails Name Type Description _senderAddress address the address to send the tokens from _rewardAddress address the address to receive the tokens _tokenAddress address the ERC20 contract address to use during the payment _amount uint256 token amount to be locked/released _transferETH \u00b6 function _transferETH ( address payable _rewardAddress , uint256 _amount ) internal _transferETH transfer ETH Name Type Description _rewardAddress address payable the address to receive the ETH _amount uint256 ETH amount to be locked/released allowedExternalContract \u00b6 modifier allowedExternalContract ( address _externalContractAddress ) areMarketplaceFeesIncluded \u00b6 function areMarketplaceFeesIncluded ( uint256 [] _amounts , address [] _receivers ) internal view returns ( bool ) DistributeNFTCollateralCondition \u00b6 Implementation of a condition allowing to transfer a NFT to an account or another depending on the final state of a lock condition CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE aaveCreditVault \u00b6 contract AaveCreditVault aaveCreditVault _lockConditionAddress \u00b6 address _lockConditionAddress Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _receiver , bytes32 _conditionId , address _contract ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _lockNFTConditionAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _lockNFTConditionAddress address Lock NFT Condition address hashValues \u00b6 function hashValues ( bytes32 _did , address _vaultAddress , address _nftContractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _vaultAddress address The contract address of the vault _nftContractAddress address NFT contract to use Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _nftContractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _vaultAddress address The contract address of the vault _nftContractAddress address NFT contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) INFTAccess \u00b6 Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _documentId , address _grantee , bytes32 _conditionId ) hashValues \u00b6 function hashValues ( bytes32 _documentId , address _grantee , address _contractAddress ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access conditions only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) INFTHolder \u00b6 Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _address , bytes32 _conditionId , uint256 _amount ) hashValues \u00b6 function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state INFTLock \u00b6 Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _lockAddress , bytes32 _conditionId , uint256 _amount , address _receiver , address _nftContractAddress ) hashValues \u00b6 function hashValues ( bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the NFTs locked _nftContractAddress address Is the address of the NFT (ERC-721, ERC-1155) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values hashValuesMarked \u00b6 function hashValuesMarked ( bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) external pure returns ( bytes32 ) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) fulfillMarked \u00b6 function fulfillMarked ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) ITransferNFT \u00b6 Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _receiver , uint256 _amount , bytes32 _conditionId , address _contract ) hashValues \u00b6 function hashValues ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockCondition , address _contract , bool _transfer ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _contract address _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _contract , bool _transfer ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _contract address _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) getNFTDefaultAddress \u00b6 function getNFTDefaultAddress () external view returns ( address ) returns if the default NFT contract address The default NFT contract address was given to the Transfer Condition during the contract initialization Name Type Description [0] address the NFT contract address used by default in the transfer condition NFT721HolderCondition \u00b6 Implementation of the Nft Holder Condition CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state NFT721LockCondition \u00b6 Implementation of the NFT Lock Condition for ERC-721 based NFTs CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values hashValuesMarked \u00b6 function hashValuesMarked ( bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) public pure returns ( bytes32 ) fulfillMarked \u00b6 function fulfillMarked ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method lock a NFT into the _lockAddress . Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens (1) _receiver address _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) onERC721Received \u00b6 function onERC721Received ( address , address , uint256 , bytes ) public virtual returns ( bytes4 ) Always returns IERC721Receiver.onERC721Received.selector . NFTAccessCondition \u00b6 _Implementation of the Access Condition specific for NFTs NFT Access Condition is special condition used to give access to a specific NFT related to a DID._ CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE DocumentPermission \u00b6 struct DocumentPermission { bytes32 agreementIdDeprecated ; mapping ( address &# x3D ; & gt ; bool ) permission ; } nftPermissions \u00b6 mapping ( bytes32 => struct NFTAccessCondition . DocumentPermission ) nftPermissions didRegistry \u00b6 contract DIDRegistry didRegistry onlyDIDOwnerOrProvider \u00b6 modifier onlyDIDOwnerOrProvider ( bytes32 _documentId ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID registry address hashValues \u00b6 function hashValues ( bytes32 _documentId , address _grantee ) public view returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values hashValues \u00b6 function hashValues ( bytes32 _documentId , address _grantee , address _contractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee , address _contractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address is the contract address of the NFT implementation (ERC-1155 or ERC-721) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) grantPermission \u00b6 function grantPermission ( address _grantee , bytes32 _documentId ) public grantPermission is called only by DID owner or provider Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys checkPermissions \u00b6 function checkPermissions ( address _grantee , bytes32 _documentId ) external view returns ( bool permissionGranted ) checkPermissions is called to validate the permissions of user related to the NFT attached to an asset Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID Name Type Description permissionGranted bool true if the access was granted NFTHolderCondition \u00b6 Implementation of the Nft Holder Condition erc1155 \u00b6 contract ERC1155BurnableUpgradeable erc1155 CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _ercAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _ercAddress address Nevermined ERC-1155 address hashValues \u00b6 function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount ) public view returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder Name Type Description [0] bytes32 bytes32 hash of all these values hashValues \u00b6 function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state NFTLockCondition \u00b6 Implementation of the NFT Lock Condition erc1155 \u00b6 contract IERC1155Upgradeable erc1155 CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE ERC1155_ACCEPTED \u00b6 bytes4 ERC1155_ACCEPTED ERC1155_BATCH_ACCEPTED \u00b6 bytes4 ERC1155_BATCH_ACCEPTED initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _ercAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _ercAddress address Nevermined ERC-1155 address hashValues \u00b6 function hashValues ( bytes32 _did , address _lockAddress , uint256 _amount ) public view returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens Name Type Description [0] bytes32 bytes32 hash of all these values hashValues \u00b6 function hashValues ( bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-1155) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values hashValuesMarked \u00b6 function hashValuesMarked ( bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) public pure returns ( bytes32 ) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _nft ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfillMarked \u00b6 function fulfillMarked ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _receiver address _nftContractAddress address Is the address of the NFT (ERC-1155) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) onERC1155Received \u00b6 function onERC1155Received ( address , address , uint256 , uint256 , bytes ) external pure returns ( bytes4 ) onERC1155BatchReceived \u00b6 function onERC1155BatchReceived ( address , address , uint256 [], uint256 [], bytes ) external pure returns ( bytes4 ) supportsInterface \u00b6 function supportsInterface ( bytes4 interfaceId ) external pure returns ( bool ) _Returns true if this contract implements the interface defined by interfaceId . See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas._ TransferNFT721Condition \u00b6 Implementation of condition allowing to transfer an NFT between the original owner and a receiver CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE MARKET_ROLE \u00b6 bytes32 MARKET_ROLE erc721 \u00b6 contract NFT721Upgradeable erc721 _lockConditionAddress \u00b6 address _lockConditionAddress PROXY_ROLE \u00b6 bytes32 PROXY_ROLE didRegistry \u00b6 contract DIDRegistry didRegistry grantProxyRole \u00b6 function grantProxyRole ( address _address ) public revokeProxyRole \u00b6 function revokeProxyRole ( address _address ) public initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress , address _ercAddress , address _lockNFTConditionAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address _ercAddress address Nevermined ERC-721 address _lockNFTConditionAddress address getNFTDefaultAddress \u00b6 function getNFTDefaultAddress () external view returns ( address ) returns if the default NFT contract address The default NFT contract address was given to the Transfer Condition during the contract initialization Name Type Description [0] address the NFT contract address used by default in the transfer condition hashValues \u00b6 function hashValues ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockCondition , address _contract , bool _transfer ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _contract address NFT contract to use _transfer bool Name Type Description [0] bytes32 bytes32 hash of all these values encodeParams \u00b6 function encodeParams ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) external pure returns ( bytes ) Encodes/serialize all the parameters received Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address the NFT contract to use _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] bytes the encoded parameters fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _contract , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _contract address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) fulfillProxy \u00b6 function fulfillProxy ( address _account , bytes32 _agreementId , bytes _params ) external payable fulfill the transfer NFT condition by a proxy Fulfill method transfer a certain amount of NFTs Name Type Description _account address NFT Holder _agreementId bytes32 agreement identifier _params bytes encoded parameters fulfillInternal \u00b6 function fulfillInternal ( address _account , bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _contract , bool _transfer , uint256 _expirationBlock ) internal returns ( enum ConditionStoreLibrary . ConditionState ) fulfillForDelegate \u00b6 function fulfillForDelegate ( bytes32 _agreementId , bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address in the DIDRegistry contract. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) fulfillForDelegate \u00b6 function fulfillForDelegate ( bytes32 _agreementId , bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , bool _transfer , address _nftContractAddress , uint256 _expirationBlock ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address in the DIDRegistry contract. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _transfer bool if yes it does a transfer if false it mints the NFT _nftContractAddress address the address of the ERC-721 NFT contract _expirationBlock uint256 in which block the nft expires, if 0 it doesn't expire Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) TransferNFTCondition \u00b6 Implementation of condition allowing to transfer an NFT between the original owner and a receiver CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE MARKET_ROLE \u00b6 bytes32 MARKET_ROLE erc1155 \u00b6 contract NFTUpgradeable erc1155 didRegistry \u00b6 contract DIDRegistry didRegistry PROXY_ROLE \u00b6 bytes32 PROXY_ROLE grantProxyRole \u00b6 function grantProxyRole ( address _address ) public revokeProxyRole \u00b6 function revokeProxyRole ( address _address ) public initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress , address _ercAddress , address _nftContractAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address _ercAddress address Nevermined ERC-1155 address _nftContractAddress address Market address grantMarketRole \u00b6 function grantMarketRole ( address _nftContractAddress ) public revokeMarketRole \u00b6 function revokeMarketRole ( address _nftContractAddress ) public getNFTDefaultAddress \u00b6 function getNFTDefaultAddress () external view returns ( address ) returns if the default NFT contract address The default NFT contract address was given to the Transfer Condition during the contract initialization Name Type Description [0] address the NFT contract address used by default in the transfer condition hashValues \u00b6 function hashValues ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockCondition ) public view returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values hashValues \u00b6 function hashValues ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockCondition , address _nftContractAddress , bool _transfer ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _nftContractAddress address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition ) public returns ( enum ConditionStoreLibrary . ConditionState ) encodeParams \u00b6 function encodeParams ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) external pure returns ( bytes ) Encodes/serialize all the parameters received Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address the NFT contract to use _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] bytes the encoded parameters fulfillProxy \u00b6 function fulfillProxy ( address _account , bytes32 _agreementId , bytes _params ) external payable fulfill the transfer NFT condition by a proxy Fulfill method transfer a certain amount of NFTs Name Type Description _account address NFT Holder _agreementId bytes32 agreement identifier _params bytes encoded parameters fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) fulfillInternal \u00b6 function fulfillInternal ( address _account , bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) internal returns ( enum ConditionStoreLibrary . ConditionState ) fulfillForDelegate \u00b6 function fulfillForDelegate ( bytes32 _agreementId , bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address in the DIDRegistry contract. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) fulfillForDelegate \u00b6 function fulfillForDelegate ( bytes32 _agreementId , bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address in the DIDRegistry contract. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address the address of the ERC-721 NFT contract _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) SignCondition \u00b6 Implementation of the Sign Condition CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _message , address _publicKey ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _message bytes32 the message to be signed _publicKey address the public key of the signing address Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _message , address _publicKey , bytes _signature ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill validate the signed message and fulfill the condition Name Type Description _agreementId bytes32 SEA agreement identifier _message bytes32 the message to be signed _publicKey address the public key of the signing address _signature bytes signature of the signed message using the public key Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state ThresholdCondition \u00b6 _Implementation of the Threshold Condition Threshold condition acts as a filter for a set of input condition(s) in which sends a signal whether to complete the flow execution or abort it. This type of conditions works as intermediary conditions where they wire SEA conditions in order to support more complex scenarios._ CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 [] inputConditions , uint256 threshold ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 [] _inputConditions , uint256 threshold ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill threshold condition the fulfill method check whether input conditions are fulfilled or not. Name Type Description _agreementId bytes32 agreement identifier _inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) canFulfill \u00b6 function canFulfill ( bytes32 [] _inputConditions , uint256 threshold ) private view returns ( bool _fulfill ) canFulfill check if condition can be fulfilled Name Type Description _inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description _fulfill bool true if can fulfill TransferDIDOwnershipCondition \u00b6 Implementation of condition allowing to transfer the ownership between the original owner and a receiver CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE didRegistry \u00b6 contract DIDRegistry didRegistry Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _receiver , bytes32 _conditionId ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address hashValues \u00b6 function hashValues ( bytes32 _did , address _receiver ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _receiver ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer DID ownership condition only DID owner or DID provider can call this method. Fulfill method transfer full ownership permissions to to _receiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) WhitelistingCondition \u00b6 Implementation of the Whitelisting Condition CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( address _listAddress , bytes32 _item ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _listAddress address list contract address _item bytes32 item in the list Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , address _listAddress , bytes32 _item ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill check whether address is whitelisted in order to fulfill the condition. This method will be called by any one in this whitelist. Name Type Description _agreementId bytes32 SEA agreement identifier _listAddress address list contract address _item bytes32 item in the list Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state AaveBorrowCondition \u00b6 Implementation of the Aave Borrow Credit Condition aaveCreditVault \u00b6 contract AaveCreditVault aaveCreditVault CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , address _vaultAddress , address _assetToBorrow , uint256 _amount , uint256 _interestRateMode ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToBorrow address the address of the asset to borrow (i.e DAI) _amount uint256 the amount of the ERC-20 the assets to borrow (i.e 50 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _assetToBorrow , uint256 _amount , uint256 _interestRateMode ) external returns ( enum ConditionStoreLibrary . ConditionState ) It allows the borrower to borrow the asset deposited by the lender Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToBorrow address the address of the asset to borrow (i.e DAI) _amount uint256 the amount of the ERC-20 the assets to borrow (i.e 50 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good) AaveCollateralDepositCondition \u00b6 Implementation of the Aave Collateral Deposit Condition This condition allows a Lender to deposit the collateral that into account the royalties to be paid to the original creators in a secondary market. aaveCreditVault \u00b6 contract AaveCreditVault aaveCreditVault CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , address _vaultAddress , address _collateralAsset , uint256 _collateralAmount , address _delegatedAsset , uint256 _delegatedAmount , uint256 _interestRateMode ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the ERC-20 that will be used as collateral (i.e WETH) _collateralAmount uint256 the amount of the ERC-20 that will be used as collateral (i.e 10 WETH) _delegatedAsset address the address of the ERC-20 that will be delegated to the borrower (i.e DAI) _delegatedAmount uint256 the amount of the ERC-20 that will be delegated to the borrower (i.e 500 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _collateralAsset , uint256 _collateralAmount , address _delegatedAsset , uint256 _delegatedAmount , uint256 _interestRateMode ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) It fulfills the condition if the collateral can be deposited into the vault Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the ERC-20 that will be used as collateral (i.e WETH) _collateralAmount uint256 the amount of the ERC-20 that will be used as collateral (i.e 10 WETH) _delegatedAsset address the address of the ERC-20 that will be delegated to the borrower (i.e DAI) _delegatedAmount uint256 the amount of the ERC-20 that will be delegated to the borrower (i.e 500 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good) AaveCollateralWithdrawCondition \u00b6 Implementation of the Collateral Withdraw Condition This condition allows to credit delegator withdraw the collateral and fees after the agreement expiration aaveCreditVault \u00b6 contract AaveCreditVault aaveCreditVault CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , address _vaultAddress , address _collateralAsset ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the asset used as collateral (i.e DAI) Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _collateralAsset ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) It allows the borrower to repay the loan Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the asset used as collateral (i.e DAI) Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good) AaveCreditVault \u00b6 lendingPool \u00b6 contract ILendingPool lendingPool dataProvider \u00b6 contract IProtocolDataProvider dataProvider weth \u00b6 contract IWETHGateway weth addressProvider \u00b6 contract ILendingPoolAddressesProvider addressProvider priceOracle \u00b6 contract IPriceOracleGetter priceOracle borrowedAsset \u00b6 address borrowedAsset borrowedAmount \u00b6 uint256 borrowedAmount nvmFee \u00b6 uint256 nvmFee agreementFee \u00b6 uint256 agreementFee FEE_BASE \u00b6 uint256 FEE_BASE treasuryAddress \u00b6 address treasuryAddress borrower \u00b6 address borrower lender \u00b6 address lender repayConditionId \u00b6 bytes32 repayConditionId nftId \u00b6 uint256 nftId nftAddress \u00b6 address nftAddress BORROWER_ROLE \u00b6 bytes32 BORROWER_ROLE LENDER_ROLE \u00b6 bytes32 LENDER_ROLE CONDITION_ROLE \u00b6 bytes32 CONDITION_ROLE initialize \u00b6 function initialize ( address _lendingPool , address _dataProvider , address _weth , uint256 _nvmFee , uint256 _agreementFee , address _treasuryAddress , address _borrower , address _lender , address [] _conditions ) public Vault constructor, creates a unique vault for each agreement Name Type Description _lendingPool address Aave lending pool address _dataProvider address Aave data provider address _weth address WETH address _nvmFee uint256 Nevermined fee that will apply to this agreeement _agreementFee uint256 Agreement fee that lender will receive on agreement maturity _treasuryAddress address Address of nevermined contract to store fees _borrower address _lender address _conditions address[] isLender \u00b6 function isLender ( address _address ) public view returns ( bool ) isBorrower \u00b6 function isBorrower ( address _address ) public view returns ( bool ) deposit \u00b6 function deposit ( address _collateralAsset , uint256 _amount ) public payable Deposit function. Receives the funds from the delegator and deposits the funds in the Aave contracts Name Type Description _collateralAsset address collateral asset that will be deposit on Aave _amount uint256 Amount of collateral to deposit approveBorrower \u00b6 function approveBorrower ( address _borrower , uint256 _amount , address _asset , uint256 _interestRateMode ) public Appproves delegatee to borrow funds from Aave on behalf of delegator Name Type Description _borrower address delegatee that will borrow the funds _amount uint256 Amount of funds to delegate _asset address Asset to delegate the borrow _interestRateMode uint256 interest rate type stable 1, variable 2 delegatedAmount \u00b6 function delegatedAmount ( address _borrower , address _asset , uint256 _interestRateMode ) public view returns ( uint256 ) Return the actual delegated amount for the borrower in the specific asset Name Type Description _borrower address The borrower of the funds (i.e. delgatee) _asset address The asset they are allowed to borrow _interestRateMode uint256 interest rate type stable 1, variable 2 borrow \u00b6 function borrow ( address _assetToBorrow , uint256 _amount , address _delgatee , uint256 _interestRateMode ) public Borrower can call this function to borrow the delegated funds Name Type Description _assetToBorrow address The asset they are allowed to borrow _amount uint256 Amount to borrow _delgatee address Address where the funds will be transfered _interestRateMode uint256 interest rate type stable 1, variable 2 repay \u00b6 function repay ( address _asset , uint256 _interestRateMode , bytes32 _repayConditionId ) public Repay an uncollaterised loan Name Type Description _asset address The asset to be repaid _interestRateMode uint256 interest rate type stable 1, variable 2 _repayConditionId bytes32 identifier of the condition id working as lock for other vault methods setRepayConditionId \u00b6 function setRepayConditionId ( bytes32 _repayConditionId ) public getBorrowedAmount \u00b6 function getBorrowedAmount () public view returns ( uint256 ) Returns the borrowed amount from the delegatee on this agreement getAssetPrice \u00b6 function getAssetPrice ( address _asset ) public view returns ( uint256 ) Returns the priceof the asset in the Aave oracles Name Type Description _asset address The asset to get the actual price getCreditAssetDebt \u00b6 function getCreditAssetDebt () public view returns ( uint256 ) Returns the total debt of the credit in the Aave protocol expressed in token units getActualCreditDebt \u00b6 function getActualCreditDebt () public view returns ( uint256 ) Returns the total debt of the credit in the Aave protocol expressed in ETH units getTotalActualDebt \u00b6 function getTotalActualDebt () public view returns ( uint256 ) Returns the total actual debt of the agreement credit + fees in token units withdrawCollateral \u00b6 function withdrawCollateral ( address _asset , address _delegator ) public Withdraw all of a collateral as the underlying asset, if no outstanding loans delegated Name Type Description _asset address The underlying asset to withdraw _delegator address Delegator address that deposited the collateral transferNFT \u00b6 function transferNFT ( uint256 _tokenId , address _receiver ) public Transfer a NFT (ERC-721) locked into the vault to a receiver address Name Type Description _tokenId uint256 the token id _receiver address the receiver adddress _transferERC20 \u00b6 function _transferERC20 ( address _collateralAsset , uint256 _amount ) internal Transfers the ERC20 token deposited to the Aave contracts Name Type Description _collateralAsset address collateral asset that will be deposit on Aave _amount uint256 Amount of collateral to deposit onERC721Received \u00b6 function onERC721Received ( address , address , uint256 _tokenId , bytes ) public virtual returns ( bytes4 ) Handle the receipt of an NFT _The ERC721 smart contract calls this function on the recipient after a {IERC721-safeTransferFrom}. This function MUST return the function selector, otherwise the caller will revert the transaction. Note: the ERC721 contract address is always the message sender. (param not used): operator The address which called safeTransferFrom function (param not used): from The address which previously owned the token_ Name Type Description address address _tokenId uint256 The NFT identifier which is being transferred (param not used): data Additional data with no specified format bytes Name Type Description [0] bytes4 bytes4 bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")) AaveRepayCondition \u00b6 Implementation of the Aave Repay Condition This condition allows to a borrower to repay a credit as part of a credit template aaveCreditVault \u00b6 contract AaveCreditVault aaveCreditVault CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId ) initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , address _vaultAddress , address _assetToRepay , uint256 _amountToRepay , uint256 _interestRateMode ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToRepay address the address of the asset to repay (i.e DAI) _amountToRepay uint256 Amount to repay _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _assetToRepay , uint256 _amountToRepay , uint256 _interestRateMode ) external returns ( enum ConditionStoreLibrary . ConditionState ) It allows the borrower to repay the loan Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToRepay address the address of the asset to repay (i.e DAI) _amountToRepay uint256 Amount to repay _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good) EscrowPaymentCondition \u00b6 _Implementation of the Escrow Payment Condition The Escrow payment is reward condition in which only can release reward if lock and release conditions are fulfilled._ CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE USED_PAYMENT_ID \u00b6 bytes32 USED_PAYMENT_ID Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , address _tokenAddress , address [] _receivers , bytes32 _conditionId , uint256 [] _amounts ) Received \u00b6 event Received ( address _from , uint256 _value ) receive \u00b6 receive () external payable initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValuesMulti \u00b6 function hashValuesMulti ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values encodeParams \u00b6 function encodeParams ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public pure returns ( bytes ) hashValues \u00b6 function hashValues ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 _releaseCondition ) public pure returns ( bytes32 ) hashValuesLockPayment \u00b6 function hashValuesLockPayment ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public pure returns ( bytes32 ) hashValuesLockPayment generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values fulfillMulti \u00b6 function fulfillMulti ( bytes32 _agreementId , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill escrow reward condition fulfill method checks whether the lock and release conditions are fulfilled in order to release/refund the reward to receiver/sender respectively. Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) Args \u00b6 struct Args { bytes32 _agreementId ; bytes32 _did ; uint256 [] _amounts ; address [] _receivers ; address _returnAddress ; address _lockPaymentAddress ; address _tokenAddress ; bytes32 _lockCondition ; bytes32 [] _releaseConditions ; } fulfillKludge \u00b6 function fulfillKludge ( struct EscrowPaymentCondition . Args a ) internal returns ( enum ConditionStoreLibrary . ConditionState ) fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 _releaseCondition ) external returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfillERC20 \u00b6 function _transferAndFulfillERC20 ( bytes32 _id , address _tokenAddress , address [] _receivers , uint256 [] _amounts ) private returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfill transfer ERC20 tokens and fulfill the condition Name Type Description _id bytes32 condition identifier _tokenAddress address the ERC20 contract address to use during the payment _receivers address[] receiver's address _amounts uint256[] token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) _transferAndFulfillETH \u00b6 function _transferAndFulfillETH ( bytes32 _id , address [] _receivers , uint256 [] _amounts ) private returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfill transfer ETH and fulfill the condition Name Type Description _id bytes32 condition identifier _receivers address[] receiver's address _amounts uint256[] token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) INFTEscrow \u00b6 Common interface for ERC-721 and ERC-1155 Fulfilled \u00b6 event Fulfilled ( bytes32 _agreementId , address _tokenAddress , bytes32 _did , address _receivers , bytes32 _conditionId , uint256 _amounts ) NFT721EscrowPaymentCondition \u00b6 _Implementation of the Escrow Payment Condition The Escrow payment is reward condition in which only can release reward if lock and release conditions are fulfilled._ CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE Received \u00b6 event Received ( address _from , uint256 _value ) receive \u00b6 receive () external payable initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , uint256 _amounts , address _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 asset decentralized identifier _amounts uint256 token amounts to be locked/released _receivers address receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values hashValuesLockPayment \u00b6 function hashValuesLockPayment ( bytes32 _did , address _lockAddress , address _nftContractAddress , uint256 _amount , address _receiver ) public pure returns ( bytes32 ) hashValuesLockPayment generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _lockAddress address the contract address where the reward is locked _nftContractAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amount uint256 token amounts to be locked/released _receiver address receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , uint256 _amount , address _receiver , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill escrow reward condition fulfill method checks whether the lock and release conditions are fulfilled in order to release/refund the reward to receiver/sender respectively. Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amount uint256 token amounts to be locked/released _receiver address receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) Args \u00b6 struct Args { bytes32 _agreementId ; bytes32 _did ; uint256 _amount ; address _receiver ; address _returnAddress ; address _lockPaymentAddress ; address _tokenAddress ; bytes32 _lockCondition ; bytes32 [] _releaseConditions ; } fulfillKludge \u00b6 function fulfillKludge ( struct NFT721EscrowPaymentCondition . Args a ) internal returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfillNFT \u00b6 function _transferAndFulfillNFT ( bytes32 _agreementId , bytes32 _id , bytes32 _did , address _tokenAddress , address _receiver , uint256 _amount ) private returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfill transfer ERC20 tokens and fulfill the condition Name Type Description _agreementId bytes32 _id bytes32 condition identifier _did bytes32 _tokenAddress address the ERC20 contract address to use during the payment _receiver address receiver's address _amount uint256 token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) onERC721Received \u00b6 function onERC721Received ( address , address , uint256 , bytes ) public virtual returns ( bytes4 ) NFTEscrowPaymentCondition \u00b6 _Implementation of the Escrow Payment Condition The Escrow payment is reward condition in which only can release reward if lock and release conditions are fulfilled._ CONDITION_TYPE \u00b6 bytes32 CONDITION_TYPE LOCK_CONDITION_TYPE \u00b6 bytes32 LOCK_CONDITION_TYPE Received \u00b6 event Received ( address _from , uint256 _value ) receive \u00b6 receive () external payable initialize \u00b6 function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address hashValues \u00b6 function hashValues ( bytes32 _did , uint256 _amounts , address _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 asset decentralized identifier _amounts uint256 token amounts to be locked/released _receivers address receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values hashValuesLockPayment \u00b6 function hashValuesLockPayment ( bytes32 _did , address _lockAddress , address _nftContractAddress , uint256 _amount , address _receiver ) public pure returns ( bytes32 ) hashValuesLockPayment generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _lockAddress address the contract address where the reward is locked _nftContractAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amount uint256 token amounts to be locked/released _receiver address receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values fulfill \u00b6 function fulfill ( bytes32 _agreementId , bytes32 _did , uint256 _amount , address _receiver , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill escrow reward condition fulfill method checks whether the lock and release conditions are fulfilled in order to release/refund the reward to receiver/sender respectively. Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amount uint256 token amounts to be locked/released _receiver address receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) Args \u00b6 struct Args { bytes32 _agreementId ; bytes32 _did ; uint256 _amount ; address _receiver ; address _returnAddress ; address _lockPaymentAddress ; address _tokenAddress ; bytes32 _lockCondition ; bytes32 [] _releaseConditions ; } fulfillKludge \u00b6 function fulfillKludge ( struct NFTEscrowPaymentCondition . Args a ) internal returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfillNFT \u00b6 function _transferAndFulfillNFT ( bytes32 _agreementId , bytes32 _id , bytes32 _did , address _tokenAddress , address _receiver , uint256 _amount ) private returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfill transfer ERC20 tokens and fulfill the condition Name Type Description _agreementId bytes32 _id bytes32 condition identifier _did bytes32 _tokenAddress address the ERC20 contract address to use during the payment _receiver address receiver's address _amount uint256 token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted) ERC1155_ACCEPTED \u00b6 bytes4 ERC1155_ACCEPTED ERC1155_BATCH_ACCEPTED \u00b6 bytes4 ERC1155_BATCH_ACCEPTED onERC1155Received \u00b6 function onERC1155Received ( address , address , uint256 , uint256 , bytes ) external pure returns ( bytes4 ) onERC1155BatchReceived \u00b6 function onERC1155BatchReceived ( address , address , uint256 [], uint256 [], bytes ) external pure returns ( bytes4 ) supportsInterface \u00b6 function supportsInterface ( bytes4 interfaceId ) external pure returns ( bool ) _Returns true if this contract implements the interface defined by interfaceId . See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas._ Reward \u00b6 _Implementation of the Reward. Generic reward condition_ INVMConfig \u00b6 GOVERNOR_ROLE \u00b6 bytes32 GOVERNOR_ROLE NeverminedConfigChange \u00b6 event NeverminedConfigChange ( address _whoChanged , bytes32 _parameter ) Event that is emitted when a parameter is changed Name Type Description _whoChanged address the address of the governor changing the parameter _parameter bytes32 the hash of the name of the parameter changed initialize \u00b6 function initialize ( address _owner , address _governor ) external virtual Used to initialize the contract during delegator constructor Name Type Description _owner address The owner of the contract _governor address The address to be granted with the GOVERNOR_ROLE setMarketplaceFees \u00b6 function setMarketplaceFees ( uint256 _marketplaceFee , address _feeReceiver ) external virtual The governor can update the Nevermined Marketplace fees Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee isGovernor \u00b6 function isGovernor ( address _address ) external view virtual returns ( bool ) Indicates if an address is a having the GOVERNOR role Name Type Description _address address The address to validate Name Type Description [0] bool true if is a governor getMarketplaceFee \u00b6 function getMarketplaceFee () external view virtual returns ( uint256 ) Returns the marketplace fee Name Type Description [0] uint256 the marketplace fee getFeeReceiver \u00b6 function getFeeReceiver () external view virtual returns ( address ) Returns the receiver address of the marketplace fee Name Type Description [0] address the receiver address NeverminedConfig \u00b6 marketplaceFee \u00b6 uint256 marketplaceFee feeReceiver \u00b6 address feeReceiver initialize \u00b6 function initialize ( address _owner , address _governor ) public Used to initialize the contract during delegator constructor Name Type Description _owner address The owner of the contract _governor address The address to be granted with the GOVERNOR_ROLE setMarketplaceFees \u00b6 function setMarketplaceFees ( uint256 _marketplaceFee , address _feeReceiver ) external virtual The governor can update the Nevermined Marketplace fees Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee setGovernor \u00b6 function setGovernor ( address _address ) external isGovernor \u00b6 function isGovernor ( address _address ) external view returns ( bool ) Indicates if an address is a having the GOVERNOR role Name Type Description _address address The address to validate Name Type Description [0] bool true if is a governor getMarketplaceFee \u00b6 function getMarketplaceFee () external view returns ( uint256 ) Returns the marketplace fee Name Type Description [0] uint256 the marketplace fee getFeeReceiver \u00b6 function getFeeReceiver () external view returns ( address ) Returns the receiver address of the marketplace fee Name Type Description [0] address the receiver address onlyGovernor \u00b6 modifier onlyGovernor ( address _address ) IERC20 \u00b6 totalSupply \u00b6 function totalSupply () external view returns ( uint256 ) Returns the amount of tokens in existence. balanceOf \u00b6 function balanceOf ( address account ) external view returns ( uint256 ) Returns the amount of tokens owned by account . transfer \u00b6 function transfer ( address recipient , uint256 amount ) external returns ( bool ) _Moves amount tokens from the caller's account to recipient . Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event._ allowance \u00b6 function allowance ( address owner , address spender ) external view returns ( uint256 ) _Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called._ approve \u00b6 function approve ( address spender , uint256 amount ) external returns ( bool ) _Sets amount as the allowance of spender over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event._ transferFrom \u00b6 function transferFrom ( address sender , address recipient , uint256 amount ) external returns ( bool ) _Moves amount tokens from sender to recipient using the allowance mechanism. amount is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event._ Transfer \u00b6 event Transfer ( address from , address to , uint256 value ) _Emitted when value tokens are moved from one account ( from ) to another ( to ). Note that value may be zero._ Approval \u00b6 event Approval ( address owner , address spender , uint256 value ) Emitted when the allowance of a spender for an owner is set by a call to {approve}. value is the new allowance. IPriceOracleGetter \u00b6 Interface for the Aave price oracle. getAssetPrice \u00b6 function getAssetPrice ( address asset ) external view returns ( uint256 ) returns the asset price in ETH Name Type Description asset address the address of the asset Name Type Description [0] uint256 the ETH price of the asset IProtocolDataProvider \u00b6 TokenData \u00b6 struct TokenData { string symbol ; address tokenAddress ; } ADDRESSES_PROVIDER \u00b6 function ADDRESSES_PROVIDER () external view returns ( contract ILendingPoolAddressesProvider ) getAllReservesTokens \u00b6 function getAllReservesTokens () external view returns ( struct IProtocolDataProvider . TokenData []) getAllATokens \u00b6 function getAllATokens () external view returns ( struct IProtocolDataProvider . TokenData []) getReserveConfigurationData \u00b6 function getReserveConfigurationData ( address asset ) external view returns ( uint256 decimals , uint256 ltv , uint256 liquidationThreshold , uint256 liquidationBonus , uint256 reserveFactor , bool usageAsCollateralEnabled , bool borrowingEnabled , bool stableBorrowRateEnabled , bool isActive , bool isFrozen ) getReserveData \u00b6 function getReserveData ( address asset ) external view returns ( uint256 availableLiquidity , uint256 totalStableDebt , uint256 totalVariableDebt , uint256 liquidityRate , uint256 variableBorrowRate , uint256 stableBorrowRate , uint256 averageStableBorrowRate , uint256 liquidityIndex , uint256 variableBorrowIndex , uint40 lastUpdateTimestamp ) getUserReserveData \u00b6 function getUserReserveData ( address asset , address user ) external view returns ( uint256 currentATokenBalance , uint256 currentStableDebt , uint256 currentVariableDebt , uint256 principalStableDebt , uint256 scaledVariableDebt , uint256 stableBorrowRate , uint256 liquidityRate , uint40 stableRateLastUpdated , bool usageAsCollateralEnabled ) getReserveTokensAddresses \u00b6 function getReserveTokensAddresses ( address asset ) external view returns ( address aTokenAddress , address stableDebtTokenAddress , address variableDebtTokenAddress ) ILendingPoolAddressesProvider \u00b6 MarketIdSet \u00b6 event MarketIdSet ( string newMarketId ) LendingPoolUpdated \u00b6 event LendingPoolUpdated ( address newAddress ) ConfigurationAdminUpdated \u00b6 event ConfigurationAdminUpdated ( address newAddress ) EmergencyAdminUpdated \u00b6 event EmergencyAdminUpdated ( address newAddress ) LendingPoolConfiguratorUpdated \u00b6 event LendingPoolConfiguratorUpdated ( address newAddress ) LendingPoolCollateralManagerUpdated \u00b6 event LendingPoolCollateralManagerUpdated ( address newAddress ) PriceOracleUpdated \u00b6 event PriceOracleUpdated ( address newAddress ) LendingRateOracleUpdated \u00b6 event LendingRateOracleUpdated ( address newAddress ) ProxyCreated \u00b6 event ProxyCreated ( bytes32 id , address newAddress ) AddressSet \u00b6 event AddressSet ( bytes32 id , address newAddress , bool hasProxy ) getMarketId \u00b6 function getMarketId () external view returns ( string ) setMarketId \u00b6 function setMarketId ( string marketId ) external setAddress \u00b6 function setAddress ( bytes32 id , address newAddress ) external setAddressAsProxy \u00b6 function setAddressAsProxy ( bytes32 id , address impl ) external getAddress \u00b6 function getAddress ( bytes32 id ) external view returns ( address ) getLendingPool \u00b6 function getLendingPool () external view returns ( address ) setLendingPoolImpl \u00b6 function setLendingPoolImpl ( address pool ) external getLendingPoolConfigurator \u00b6 function getLendingPoolConfigurator () external view returns ( address ) setLendingPoolConfiguratorImpl \u00b6 function setLendingPoolConfiguratorImpl ( address configurator ) external getLendingPoolCollateralManager \u00b6 function getLendingPoolCollateralManager () external view returns ( address ) setLendingPoolCollateralManager \u00b6 function setLendingPoolCollateralManager ( address manager ) external getPoolAdmin \u00b6 function getPoolAdmin () external view returns ( address ) setPoolAdmin \u00b6 function setPoolAdmin ( address admin ) external getEmergencyAdmin \u00b6 function getEmergencyAdmin () external view returns ( address ) setEmergencyAdmin \u00b6 function setEmergencyAdmin ( address admin ) external getPriceOracle \u00b6 function getPriceOracle () external view returns ( address ) setPriceOracle \u00b6 function setPriceOracle ( address priceOracle ) external getLendingRateOracle \u00b6 function getLendingRateOracle () external view returns ( address ) setLendingRateOracle \u00b6 function setLendingRateOracle ( address lendingRateOracle ) external ILendingPool \u00b6 Deposit \u00b6 event Deposit ( address reserve , address user , address onBehalfOf , uint256 amount , uint16 referral ) Emitted on deposit() Name Type Description reserve address The address of the underlying asset of the reserve user address The address initiating the deposit onBehalfOf address The beneficiary of the deposit, receiving the aTokens amount uint256 The amount deposited referral uint16 The referral code used Withdraw \u00b6 event Withdraw ( address reserve , address user , address to , uint256 amount ) Emitted on withdraw() Name Type Description reserve address The address of the underlyng asset being withdrawn user address The address initiating the withdrawal, owner of aTokens to address Address that will receive the underlying amount uint256 The amount to be withdrawn Borrow \u00b6 event Borrow ( address reserve , address user , address onBehalfOf , uint256 amount , uint256 borrowRateMode , uint256 borrowRate , uint16 referral ) Emitted on borrow() and flashLoan() when debt needs to be opened Name Type Description reserve address The address of the underlying asset being borrowed user address The address of the user initiating the borrow(), receiving the funds on borrow() or just initiator of the transaction on flashLoan() onBehalfOf address The address that will be getting the debt amount uint256 The amount borrowed out borrowRateMode uint256 The rate mode: 1 for Stable, 2 for Variable borrowRate uint256 The numeric rate at which the user has borrowed referral uint16 The referral code used Repay \u00b6 event Repay ( address reserve , address user , address repayer , uint256 amount ) Emitted on repay() Name Type Description reserve address The address of the underlying asset of the reserve user address The beneficiary of the repayment, getting his debt reduced repayer address The address of the user initiating the repay(), providing the funds amount uint256 The amount repaid Swap \u00b6 event Swap ( address reserve , address user , uint256 rateMode ) Emitted on swapBorrowRateMode() Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user swapping his rate mode rateMode uint256 The rate mode that the user wants to swap to ReserveUsedAsCollateralEnabled \u00b6 event ReserveUsedAsCollateralEnabled ( address reserve , address user ) Emitted on setUserUseReserveAsCollateral() Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user enabling the usage as collateral ReserveUsedAsCollateralDisabled \u00b6 event ReserveUsedAsCollateralDisabled ( address reserve , address user ) Emitted on setUserUseReserveAsCollateral() Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user enabling the usage as collateral RebalanceStableBorrowRate \u00b6 event RebalanceStableBorrowRate ( address reserve , address user ) Emitted on rebalanceStableBorrowRate() Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user for which the rebalance has been executed FlashLoan \u00b6 event FlashLoan ( address target , address initiator , address asset , uint256 amount , uint256 premium , uint16 referralCode ) Emitted on flashLoan() Name Type Description target address The address of the flash loan receiver contract initiator address The address initiating the flash loan asset address The address of the asset being flash borrowed amount uint256 The amount flash borrowed premium uint256 The fee flash borrowed referralCode uint16 The referral code used Paused \u00b6 event Paused () Emitted when the pause is triggered. Unpaused \u00b6 event Unpaused () Emitted when the pause is lifted. LiquidationCall \u00b6 event LiquidationCall ( address collateralAsset , address debtAsset , address user , uint256 debtToCover , uint256 liquidatedCollateralAmount , address liquidator , bool receiveAToken ) Emitted when a borrower is liquidated. This event is emitted by the LendingPool via LendingPoolCollateral manager using a DELEGATECALL This allows to have the events in the generated ABI for LendingPool. Name Type Description collateralAsset address The address of the underlying asset used as collateral, to receive as result of the liquidation debtAsset address The address of the underlying borrowed asset to be repaid with the liquidation user address The address of the borrower getting liquidated debtToCover uint256 The debt amount of borrowed asset the liquidator wants to cover liquidatedCollateralAmount uint256 The amount of collateral received by the liiquidator liquidator address The address of the liquidator receiveAToken bool true if the liquidators wants to receive the collateral aTokens, false if he wants to receive the underlying collateral asset directly ReserveDataUpdated \u00b6 event ReserveDataUpdated ( address reserve , uint256 liquidityRate , uint256 stableBorrowRate , uint256 variableBorrowRate , uint256 liquidityIndex , uint256 variableBorrowIndex ) Emitted when the state of a reserve is updated. NOTE: This event is actually declared in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal, the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it gets added to the LendingPool ABI Name Type Description reserve address The address of the underlying asset of the reserve liquidityRate uint256 The new liquidity rate stableBorrowRate uint256 The new stable borrow rate variableBorrowRate uint256 The new variable borrow rate liquidityIndex uint256 The new liquidity index variableBorrowIndex uint256 The new variable borrow index deposit \u00b6 function deposit ( address asset , uint256 amount , address onBehalfOf , uint16 referralCode ) external Deposits an amount of underlying asset into the reserve, receiving in return overlying aTokens. - E.g. User deposits 100 USDC and gets in return 100 aUSDC Name Type Description asset address The address of the underlying asset to deposit amount uint256 The amount to be deposited onBehalfOf address The address that will receive the aTokens, same as msg.sender if the user wants to receive them on his own wallet, or a different address if the beneficiary of aTokens is a different wallet referralCode uint16 Code used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-man withdraw \u00b6 function withdraw ( address asset , uint256 amount , address to ) external returns ( uint256 ) Withdraws an amount of underlying asset from the reserve, burning the equivalent aTokens owned E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC Name Type Description asset address The address of the underlying asset to withdraw amount uint256 The underlying amount to be withdrawn - Send the value type(uint256).max in order to withdraw the whole aToken balance to address Address that will receive the underlying, same as msg.sender if the user wants to receive it on his own wallet, or a different address if the beneficiary is a different wallet Name Type Description [0] uint256 The final amount withdrawn borrow \u00b6 function borrow ( address asset , uint256 amount , uint256 interestRateMode , uint16 referralCode , address onBehalfOf ) external Allows users to borrow a specific amount of the reserve underlying asset, provided that the borrower already deposited enough collateral, or he was given enough allowance by a credit delegator on the corresponding debt token (StableDebtToken or VariableDebtToken) - E.g. User borrows 100 USDC passing as onBehalfOf his own address, receiving the 100 USDC in his wallet and 100 stable/variable debt tokens, depending on the interestRateMode Name Type Description asset address The address of the underlying asset to borrow amount uint256 The amount to be borrowed interestRateMode uint256 The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable referralCode uint16 Code used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-man onBehalfOf address Address of the user who will receive the debt. Should be the address of the borrower itself calling the function if he wants to borrow against his own collateral, or the address of the credit delegator if he has been given credit delegation allowance repay \u00b6 function repay ( address asset , uint256 amount , uint256 rateMode , address onBehalfOf ) external returns ( uint256 ) Repays a borrowed amount on a specific reserve, burning the equivalent debt tokens owned - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the onBehalfOf address Name Type Description asset address The address of the borrowed underlying asset previously borrowed amount uint256 The amount to repay - Send the value type(uint256).max in order to repay the whole debt for asset on the specific debtMode rateMode uint256 The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable onBehalfOf address Address of the user who will get his debt reduced/removed. Should be the address of the user calling the function if he wants to reduce/remove his own debt, or the address of any other other borrower whose debt should be removed Name Type Description [0] uint256 The final amount repaid swapBorrowRateMode \u00b6 function swapBorrowRateMode ( address asset , uint256 rateMode ) external Allows a borrower to swap his debt between stable and variable mode, or viceversa Name Type Description asset address The address of the underlying asset borrowed rateMode uint256 The rate mode that the user wants to swap to rebalanceStableBorrowRate \u00b6 function rebalanceStableBorrowRate ( address asset , address user ) external Rebalances the stable interest rate of a user to the current stable rate defined on the reserve. - Users can be rebalanced if the following conditions are satisfied: 1. Usage ratio is above 95% 2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been borrowed at a stable rate and depositors are not earning enough Name Type Description asset address The address of the underlying asset borrowed user address The address of the user to be rebalanced setUserUseReserveAsCollateral \u00b6 function setUserUseReserveAsCollateral ( address asset , bool useAsCollateral ) external Allows depositors to enable/disable a specific deposited asset as collateral Name Type Description asset address The address of the underlying asset deposited useAsCollateral bool true if the user wants to use the deposit as collateral, false otherwise liquidationCall \u00b6 function liquidationCall ( address collateralAsset , address debtAsset , address user , uint256 debtToCover , bool receiveAToken ) external Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1 - The caller (liquidator) covers debtToCover amount of debt of the user getting liquidated, and receives a proportionally amount of the collateralAsset plus a bonus to cover market risk Name Type Description collateralAsset address The address of the underlying asset used as collateral, to receive as result of the liquidation debtAsset address The address of the underlying borrowed asset to be repaid with the liquidation user address The address of the borrower getting liquidated debtToCover uint256 The debt amount of borrowed asset the liquidator wants to cover receiveAToken bool true if the liquidators wants to receive the collateral aTokens, false if he wants to receive the underlying collateral asset directly flashLoan \u00b6 function flashLoan ( address receiverAddress , address [] assets , uint256 [] amounts , uint256 [] modes , address onBehalfOf , bytes params , uint16 referralCode ) external Allows smartcontracts to access the liquidity of the pool within one transaction, as long as the amount taken plus a fee is returned. IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration. For further details please visit https://developers.aave.com Name Type Description receiverAddress address The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface assets address[] The addresses of the assets being flash-borrowed amounts uint256[] The amounts amounts being flash-borrowed modes uint256[] Types of the debt to open if the flash loan is not returned: 0 -> Don't open any debt, just revert if funds can't be transferred from the receiver 1 -> Open debt at stable rate for the value of the amount flash-borrowed to the onBehalfOf address 2 -> Open debt at variable rate for the value of the amount flash-borrowed to the onBehalfOf address onBehalfOf address The address that will receive the debt in the case of using on modes 1 or 2 params bytes Variadic packed params to pass to the receiver as extra information referralCode uint16 Code used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-man getUserAccountData \u00b6 function getUserAccountData ( address user ) external view returns ( uint256 totalCollateralETH , uint256 totalDebtETH , uint256 availableBorrowsETH , uint256 currentLiquidationThreshold , uint256 ltv , uint256 healthFactor ) Returns the user account data across all the reserves Name Type Description user address The address of the user Name Type Description totalCollateralETH uint256 the total collateral in ETH of the user totalDebtETH uint256 the total debt in ETH of the user availableBorrowsETH uint256 the borrowing power left of the user currentLiquidationThreshold uint256 the liquidation threshold of the user ltv uint256 the loan to value of the user healthFactor uint256 the current health factor of the user initReserve \u00b6 function initReserve ( address reserve , address aTokenAddress , address stableDebtAddress , address variableDebtAddress , address interestRateStrategyAddress ) external setReserveInterestRateStrategyAddress \u00b6 function setReserveInterestRateStrategyAddress ( address reserve , address rateStrategyAddress ) external setConfiguration \u00b6 function setConfiguration ( address reserve , uint256 configuration ) external getConfiguration \u00b6 function getConfiguration ( address asset ) external view returns ( struct DataTypes . ReserveConfigurationMap ) Returns the configuration of the reserve Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] struct DataTypes.ReserveConfigurationMap The configuration of the reserve getUserConfiguration \u00b6 function getUserConfiguration ( address user ) external view returns ( struct DataTypes . UserConfigurationMap ) Returns the configuration of the user across all the reserves Name Type Description user address The user address Name Type Description [0] struct DataTypes.UserConfigurationMap The configuration of the user getReserveNormalizedIncome \u00b6 function getReserveNormalizedIncome ( address asset ) external view returns ( uint256 ) Returns the normalized income normalized income of the reserve Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] uint256 The reserve's normalized income getReserveNormalizedVariableDebt \u00b6 function getReserveNormalizedVariableDebt ( address asset ) external view returns ( uint256 ) Returns the normalized variable debt per unit of asset Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] uint256 The reserve normalized variable debt getReserveData \u00b6 function getReserveData ( address asset ) external view returns ( struct DataTypes . ReserveData ) Returns the state and configuration of the reserve Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] struct DataTypes.ReserveData The state of the reserve finalizeTransfer \u00b6 function finalizeTransfer ( address asset , address from , address to , uint256 amount , uint256 balanceFromAfter , uint256 balanceToBefore ) external getReservesList \u00b6 function getReservesList () external view returns ( address []) getAddressesProvider \u00b6 function getAddressesProvider () external view returns ( contract ILendingPoolAddressesProvider ) setPause \u00b6 function setPause ( bool val ) external paused \u00b6 function paused () external view returns ( bool ) IStableDebtToken \u00b6 Mint \u00b6 event Mint ( address user , address onBehalfOf , uint256 amount , uint256 currentBalance , uint256 balanceIncrease , uint256 newRate , uint256 avgStableRate , uint256 newTotalSupply ) Emitted when new stable debt is minted Name Type Description user address The address of the user who triggered the minting onBehalfOf address The recipient of stable debt tokens amount uint256 The amount minted currentBalance uint256 The current balance of the user balanceIncrease uint256 The increase in balance since the last action of the user newRate uint256 The rate of the debt after the minting avgStableRate uint256 The new average stable rate after the minting newTotalSupply uint256 The new total supply of the stable debt token after the action Burn \u00b6 event Burn ( address user , uint256 amount , uint256 currentBalance , uint256 balanceIncrease , uint256 avgStableRate , uint256 newTotalSupply ) Emitted when new stable debt is burned Name Type Description user address The address of the user amount uint256 The amount being burned currentBalance uint256 The current balance of the user balanceIncrease uint256 The the increase in balance since the last action of the user avgStableRate uint256 The new average stable rate after the burning newTotalSupply uint256 The new total supply of the stable debt token after the action approveDelegation \u00b6 function approveDelegation ( address delegatee , uint256 amount ) external delegates borrowing power to a user on the specific debt token Name Type Description delegatee address the address receiving the delegated borrowing power amount uint256 the maximum amount being delegated. Delegation will still respect the liquidation constraints (even if delegated, a delegatee cannot force a delegator HF to go below 1) borrowAllowance \u00b6 function borrowAllowance ( address fromUser , address toUser ) external view returns ( uint256 ) returns the borrow allowance of the user Name Type Description fromUser address The user to giving allowance toUser address The user to give allowance to Name Type Description [0] uint256 the current allowance of toUser mint \u00b6 function mint ( address user , address onBehalfOf , uint256 amount , uint256 rate ) external returns ( bool ) Mints debt token to the onBehalfOf address. - The resulting rate is the weighted average between the rate of the new debt and the rate of the previous debt Name Type Description user address The address receiving the borrowed underlying, being the delegatee in case of credit delegate, or same as onBehalfOf otherwise onBehalfOf address The address receiving the debt tokens amount uint256 The amount of debt tokens to mint rate uint256 The rate of the debt being minted burn \u00b6 function burn ( address user , uint256 amount ) external Burns debt of user - The resulting rate is the weighted average between the rate of the new debt and the rate of the previous debt Name Type Description user address The address of the user getting his debt burned amount uint256 The amount of debt tokens getting burned getAverageStableRate \u00b6 function getAverageStableRate () external view returns ( uint256 ) Returns the average rate of all the stable rate loans. Name Type Description [0] uint256 The average stable rate getUserStableRate \u00b6 function getUserStableRate ( address user ) external view returns ( uint256 ) Returns the stable rate of the user debt Name Type Description [0] uint256 The stable rate of the user getUserLastUpdated \u00b6 function getUserLastUpdated ( address user ) external view returns ( uint40 ) Returns the timestamp of the last update of the user Name Type Description [0] uint40 The timestamp getSupplyData \u00b6 function getSupplyData () external view returns ( uint256 , uint256 , uint256 , uint40 ) Returns the principal, the total supply and the average stable rate getTotalSupplyLastUpdated \u00b6 function getTotalSupplyLastUpdated () external view returns ( uint40 ) Returns the timestamp of the last update of the total supply Name Type Description [0] uint40 The timestamp getTotalSupplyAndAvgRate \u00b6 function getTotalSupplyAndAvgRate () external view returns ( uint256 , uint256 ) Returns the total supply and the average stable rate principalBalanceOf \u00b6 function principalBalanceOf ( address user ) external view returns ( uint256 ) Returns the principal debt balance of the user Name Type Description [0] uint256 The debt balance of the user since the last burn/mint action IDynamicPricing \u00b6 DynamicPricingState \u00b6 enum DynamicPricingState { NotStarted , Finished , InProgress , Aborted } getPricingType \u00b6 function getPricingType () external view returns ( bytes32 ) getPrice \u00b6 function getPrice ( bytes32 did ) external view returns ( uint256 ) getTokenAddress \u00b6 function getTokenAddress ( bytes32 did ) external view returns ( address ) getStatus \u00b6 function getStatus ( bytes32 did ) external view returns ( enum IDynamicPricing . DynamicPricingState , uint256 , address ) canBePurchased \u00b6 function canBePurchased ( bytes32 did ) external view returns ( bool ) withdraw \u00b6 function withdraw ( bytes32 did , address withdrawAddress ) external returns ( bool ) IList \u00b6 has \u00b6 function has ( bytes32 value ) external view returns ( bool ) has \u00b6 function has ( bytes32 value , bytes32 id ) external view returns ( bool ) IRoyaltyScheme \u00b6 check \u00b6 function check ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _tokenAddress ) external view returns ( bool ) check that royalties are correct Name Type Description _did bytes32 compute royalties for this DID _amounts uint256[] amounts in payment _receivers address[] receivers of payments _tokenAddress address payment token. zero address means native token (ether) ISecretStore \u00b6 checkPermissions \u00b6 function checkPermissions ( address user , bytes32 documentKeyId ) external view returns ( bool permissionGranted ) checkPermissions is called by Parity secret store ISecretStorePermission \u00b6 grantPermission \u00b6 function grantPermission ( address user , bytes32 documentKeyId ) external grantPermission is called only by documentKeyId Owner or provider renouncePermission \u00b6 function renouncePermission ( address user , bytes32 documentKeyId ) external renouncePermission is called only by documentKeyId Owner or provider IWETHGateway \u00b6 depositETH \u00b6 function depositETH ( address lendingPool , address onBehalfOf , uint16 referralCode ) external payable withdrawETH \u00b6 function withdrawETH ( address lendingPool , uint256 amount , address to ) external repayETH \u00b6 function repayETH ( address lendingPool , uint256 amount , uint256 rateMode , address onBehalfOf ) external payable borrowETH \u00b6 function borrowETH ( address lendingPool , uint256 amount , uint256 interesRateMode , uint16 referralCode ) external DataTypes \u00b6 ReserveData \u00b6 struct ReserveData { struct DataTypes . ReserveConfigurationMap configuration ; uint128 liquidityIndex ; uint128 variableBorrowIndex ; uint128 currentLiquidityRate ; uint128 currentVariableBorrowRate ; uint128 currentStableBorrowRate ; uint40 lastUpdateTimestamp ; address aTokenAddress ; address stableDebtTokenAddress ; address variableDebtTokenAddress ; address interestRateStrategyAddress ; uint8 id ; } ReserveConfigurationMap \u00b6 struct ReserveConfigurationMap { uint256 data ; } UserConfigurationMap \u00b6 struct UserConfigurationMap { uint256 data ; } InterestRateMode \u00b6 enum InterestRateMode { NONE , STABLE , VARIABLE } SafeMath \u00b6 add \u00b6 function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the addition of two unsigned integers, reverting on overflow. Counterpart to Solidity's + operator. Requirements: - Addition cannot overflow._ sub \u00b6 function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the subtraction of two unsigned integers, reverting on overflow (when the result is negative). Counterpart to Solidity's - operator. Requirements: - Subtraction cannot overflow._ sub \u00b6 function sub ( uint256 a , uint256 b , string errorMessage ) internal pure returns ( uint256 ) _Returns the subtraction of two unsigned integers, reverting with custom message on overflow (when the result is negative). Counterpart to Solidity's - operator. Requirements: - Subtraction cannot overflow._ mul \u00b6 function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the multiplication of two unsigned integers, reverting on overflow. Counterpart to Solidity's * operator. Requirements: - Multiplication cannot overflow._ div \u00b6 function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the integer division of two unsigned integers. Reverts on division by zero. The result is rounded towards zero. Counterpart to Solidity's / operator. Note: this function uses a revert opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas). Requirements: - The divisor cannot be zero._ div \u00b6 function div ( uint256 a , uint256 b , string errorMessage ) internal pure returns ( uint256 ) _Returns the integer division of two unsigned integers. Reverts with custom message on division by zero. The result is rounded towards zero. Counterpart to Solidity's / operator. Note: this function uses a revert opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas). Requirements: - The divisor cannot be zero._ mod \u00b6 function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), Reverts when dividing by zero. Counterpart to Solidity's % operator. This function uses a revert opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas). Requirements: - The divisor cannot be zero._ mod \u00b6 function mod ( uint256 a , uint256 b , string errorMessage ) internal pure returns ( uint256 ) _Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), Reverts with custom message when dividing by zero. Counterpart to Solidity's % operator. This function uses a revert opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas). Requirements: - The divisor cannot be zero._ Address \u00b6 isContract \u00b6 function isContract ( address account ) internal view returns ( bool ) _Returns true if account is a contract. [IMPORTANT] \u00b6 It is unsafe to assume that an address for which this function returns false is an externally-owned account (EOA) and not a contract. Among others, isContract will return false for the following types of addresses: an externally-owned account a contract in construction an address where a contract will be created an address where a contract lived, but was destroyed ====_ sendValue \u00b6 function sendValue ( address payable recipient , uint256 amount ) internal _Replacement for Solidity's transfer : sends amount wei to recipient , forwarding all available gas and reverting on errors. https://eips.ethereum.org/EIPS/eip-1884[EIP1884 ] increases the gas cost of certain opcodes, possibly making contracts go over the 2300 gas limit imposed by transfer , making them unable to receive funds via transfer . {sendValue} removes this limitation. https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. IMPORTANT: because control is transferred to recipient , care must be taken to not create reentrancy vulnerabilities. Consider using {ReentrancyGuard} or the https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern]._ SafeERC20 \u00b6 Wrappers around ERC20 operations that throw on failure (when the token contract returns false). Tokens that return no value (and instead revert or throw on failure) are also supported, non-reverting calls are assumed to be successful. To use this library you can add a using SafeERC20 for IERC20; statement to your contract, which allows you to call the safe operations as token.safeTransfer(...) , etc. safeTransfer \u00b6 function safeTransfer ( contract IERC20 token , address to , uint256 value ) internal safeTransferFrom \u00b6 function safeTransferFrom ( contract IERC20 token , address from , address to , uint256 value ) internal safeApprove \u00b6 function safeApprove ( contract IERC20 token , address spender , uint256 value ) internal callOptionalReturn \u00b6 function callOptionalReturn ( contract IERC20 token , bytes data ) private CloneFactory \u00b6 createClone \u00b6 function createClone ( address target ) internal returns ( address result ) isClone \u00b6 function isClone ( address target , address query ) internal view returns ( bool result ) EpochLibrary \u00b6 Implementation of Epoch Library. For an arbitrary Epoch, this library manages the life cycle of an Epoch. Usually this library is used for handling the time window between conditions in an agreement. Epoch \u00b6 struct Epoch { uint256 timeLock ; uint256 timeOut ; uint256 blockNumber ; } EpochList \u00b6 struct EpochList { mapping ( bytes32 &# x3D ; & gt ; struct EpochLibrary . Epoch ) epochs ; bytes32 [] epochIds ; } create \u00b6 function create ( struct EpochLibrary . EpochList _self , bytes32 _id , uint256 _timeLock , uint256 _timeOut ) internal create creates new Epoch Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 _timeLock uint256 value in block count (can not fulfill before) _timeOut uint256 value in block count (can not fulfill after) isTimedOut \u00b6 function isTimedOut ( struct EpochLibrary . EpochList _self , bytes32 _id ) external view returns ( bool ) isTimedOut means you cannot fulfill after Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 Name Type Description [0] bool true if the current block number is gt timeOut isTimeLocked \u00b6 function isTimeLocked ( struct EpochLibrary . EpochList _self , bytes32 _id ) external view returns ( bool ) isTimeLocked means you cannot fulfill before Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 Name Type Description [0] bool true if the current block number is gt timeLock getEpochTimeOut \u00b6 function getEpochTimeOut ( struct EpochLibrary . Epoch _self ) public view returns ( uint256 ) getEpochTimeOut Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer getEpochTimeLock \u00b6 function getEpochTimeLock ( struct EpochLibrary . Epoch _self ) public view returns ( uint256 ) getEpochTimeLock Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer HashListLibrary \u00b6 Implementation of the basic functionality of list of hash values. This library allows other contracts to build and maintain lists and also preserves the privacy of the data by accepting only hashed content (bytes32 based data type) List \u00b6 struct List { address _owner ; bytes32 [] values ; mapping ( bytes32 &# x3D ; & gt ; uint256 ) indices ; } onlyListOwner \u00b6 modifier onlyListOwner ( struct HashListLibrary . List _self ) add \u00b6 function add ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) add index an element then add it to a list Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is a bytes32 value Name Type Description [0] bool true if value is added successfully add \u00b6 function add ( struct HashListLibrary . List _self , bytes32 [] values ) public returns ( bool ) put an array of elements without indexing this meant to save gas in case of large arrays Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage values bytes32[] is an array of elements value Name Type Description [0] bool true if values are added successfully update \u00b6 function update ( struct HashListLibrary . List _self , bytes32 oldValue , bytes32 newValue ) public returns ( bool ) update the value with a new value and maintain indices Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage oldValue bytes32 is an element value in a list newValue bytes32 new value Name Type Description [0] bool true if value is updated successfully remove \u00b6 function remove ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) remove value from a list, updates indices, and list size Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is an element value in a list Name Type Description [0] bool true if value is removed successfully get \u00b6 function get ( struct HashListLibrary . List _self , uint256 __index ) public view returns ( bytes32 ) has value by index Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage __index uint256 is where is value is stored in the list Name Type Description [0] bytes32 the value if exists index \u00b6 function index ( struct HashListLibrary . List _self , uint256 from , uint256 to ) public returns ( bool ) index is used to map each element value to its index on the list Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing Name Type Description [0] bool true if the sub list is indexed setOwner \u00b6 function setOwner ( struct HashListLibrary . List _self , address _owner ) public setOwner set list owner param _owner owner address indexOf \u00b6 function indexOf ( struct HashListLibrary . List _self , bytes32 value ) public view returns ( uint256 ) indexOf gets the index of a value in a list Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list Name Type Description [0] uint256 value index in list isIndexed \u00b6 function isIndexed ( struct HashListLibrary . List _self ) public view returns ( bool ) isIndexed checks if the list is indexed Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] bool true if the list is indexed all \u00b6 function all ( struct HashListLibrary . List _self ) public view returns ( bytes32 []) all returns all list elements Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] bytes32[] all list elements has \u00b6 function has ( struct HashListLibrary . List _self , bytes32 value ) public view returns ( bool ) size returns the list size Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list Name Type Description [0] bool true if the value exists size \u00b6 function size ( struct HashListLibrary . List _self ) public view returns ( uint256 ) size gets the list size Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] uint256 total length of the list ownedBy \u00b6 function ownedBy ( struct HashListLibrary . List _self ) public view returns ( address ) ownedBy gets the list owner Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] address list owner _index \u00b6 function _index ( struct HashListLibrary . List _self , uint256 from , uint256 to ) private returns ( bool ) __index assign index to the list elements_ Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage from uint256 is the starting index id to uint256 is the ending index id AbstractAuction \u00b6 AUCTION_MANAGER_ROLE \u00b6 bytes32 AUCTION_MANAGER_ROLE NVM_AGREEMENT_ROLE \u00b6 bytes32 NVM_AGREEMENT_ROLE Auction \u00b6 struct Auction { bytes32 did ; enum IDynamicPricing . DynamicPricingState state ; address creator ; uint256 blockNumberCreated ; uint256 floor ; uint256 starts ; uint256 ends ; uint256 price ; address tokenAddress ; address whoCanClaim ; string hash ; } auctions \u00b6 mapping ( bytes32 => struct AbstractAuction . Auction ) auctions auctionBids \u00b6 mapping ( bytes32 => mapping ( address => uint256 )) auctionBids AuctionCreated \u00b6 event AuctionCreated ( bytes32 auctionId , bytes32 did , address creator , uint256 blockNumberCreated , uint256 floor , uint256 starts , uint256 ends , address tokenAddress ) AuctionChangedState \u00b6 event AuctionChangedState ( bytes32 auctionId , address who , enum IDynamicPricing . DynamicPricingState previousState , enum IDynamicPricing . DynamicPricingState newState ) AuctionBidReceived \u00b6 event AuctionBidReceived ( bytes32 auctionId , address bidder , address tokenAddress , uint256 amount ) AuctionWithdrawal \u00b6 event AuctionWithdrawal ( bytes32 auctionId , address receiver , address tokenAddress , uint256 amount ) receive \u00b6 receive () external payable abortAuction \u00b6 function abortAuction ( bytes32 _auctionId ) external virtual withdraw \u00b6 function withdraw ( bytes32 _auctionId , address _withdrawAddress ) external virtual returns ( bool ) getPricingType \u00b6 function getPricingType () external pure virtual returns ( bytes32 ) getPrice \u00b6 function getPrice ( bytes32 _auctionId ) external view returns ( uint256 ) getTokenAddress \u00b6 function getTokenAddress ( bytes32 _auctionId ) external view returns ( address ) getStatus \u00b6 function getStatus ( bytes32 _auctionId ) external view returns ( enum IDynamicPricing . DynamicPricingState state , uint256 price , address whoCanClaim ) canBePurchased \u00b6 function canBePurchased ( bytes32 _auctionId ) external view virtual returns ( bool ) addNVMAgreementRole \u00b6 function addNVMAgreementRole ( address account ) public onlyCreator \u00b6 modifier onlyCreator ( bytes32 _auctionId ) onlyCreatorOrAdmin \u00b6 modifier onlyCreatorOrAdmin ( bytes32 _auctionId ) onlyNotCreator \u00b6 modifier onlyNotCreator ( bytes32 _auctionId ) onlyAfterStart \u00b6 modifier onlyAfterStart ( bytes32 _auctionId ) onlyBeforeStarts \u00b6 modifier onlyBeforeStarts ( bytes32 _auctionId ) onlyBeforeEnd \u00b6 modifier onlyBeforeEnd ( bytes32 _auctionId ) onlyNotAbortedOrFinished \u00b6 modifier onlyNotAbortedOrFinished ( bytes32 _auctionId ) onlyAbortedOrFinished \u00b6 modifier onlyAbortedOrFinished ( bytes32 _auctionId ) onlyNotAborted \u00b6 modifier onlyNotAborted ( bytes32 _auctionId ) onlyFinishedOrAborted \u00b6 modifier onlyFinishedOrAborted ( bytes32 _auctionId ) DutchAuction \u00b6 initialize \u00b6 function initialize ( address _owner ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address create \u00b6 function create ( bytes32 _auctionId , bytes32 _did , uint256 _startPrice , uint256 _starts , uint256 _ends , address _tokenAddress , string _hash ) external virtual It creates a new Auction given some setup parameters Name Type Description _auctionId bytes32 unique auction identifier _did bytes32 reference to the asset part of the auction _startPrice uint256 start price (and max) for the auction _starts uint256 block number when the auction starts _ends uint256 block number of when the auction ends _tokenAddress address token address to use for the auction. If address(0) means native token _hash string ipfs hash referring to the auction metadata placeNativeTokenBid \u00b6 function placeNativeTokenBid ( bytes32 _auctionId ) external payable virtual placeERC20Bid \u00b6 function placeERC20Bid ( bytes32 _auctionId , uint256 _bidAmount ) external virtual withdraw \u00b6 function withdraw ( bytes32 _auctionId , address _withdrawAddress ) external virtual returns ( bool ) getPricingType \u00b6 function getPricingType () external pure returns ( bytes32 ) EnglishAuction \u00b6 initialize \u00b6 function initialize ( address _owner ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address create \u00b6 function create ( bytes32 _auctionId , bytes32 _did , uint256 _floor , uint256 _starts , uint256 _ends , address _tokenAddress , string _hash ) external virtual It creates a new Auction given some setup parameters Name Type Description _auctionId bytes32 unique auction identifier _did bytes32 reference to the asset part of the auction _floor uint256 floor price _starts uint256 block number when the auction starts _ends uint256 block number of when the auction ends _tokenAddress address token address to use for the auction. If address(0) means native token _hash string ipfs hash referring to the auction metadata placeNativeTokenBid \u00b6 function placeNativeTokenBid ( bytes32 _auctionId ) external payable virtual placeERC20Bid \u00b6 function placeERC20Bid ( bytes32 _auctionId , uint256 _bidAmount ) external virtual getPricingType \u00b6 function getPricingType () external pure returns ( bytes32 ) DIDFactory \u00b6 Implementation of the DID Registry. didRegisterList \u00b6 struct DIDRegistryLibrary . DIDRegisterList didRegisterList state storage for the DID registry didPermissions \u00b6 mapping ( bytes32 => mapping ( address => bool )) didPermissions manager \u00b6 address manager onlyDIDOwner \u00b6 modifier onlyDIDOwner ( bytes32 _did ) onlyManager \u00b6 modifier onlyManager () onlyOwnerProviderOrDelegated \u00b6 modifier onlyOwnerProviderOrDelegated ( bytes32 _did ) onlyValidAttributes \u00b6 modifier onlyValidAttributes ( string _attributes ) nftIsInitialized \u00b6 modifier nftIsInitialized ( bytes32 _did ) nft721IsInitialized \u00b6 modifier nft721IsInitialized ( bytes32 _did ) DIDAttributeRegistered \u00b6 event DIDAttributeRegistered ( bytes32 _did , address _owner , bytes32 _checksum , string _value , address _lastUpdatedBy , uint256 _blockNumberUpdated ) DID Events DIDProviderRemoved \u00b6 event DIDProviderRemoved ( bytes32 _did , address _provider , bool state ) DIDProviderAdded \u00b6 event DIDProviderAdded ( bytes32 _did , address _provider ) DIDOwnershipTransferred \u00b6 event DIDOwnershipTransferred ( bytes32 _did , address _previousOwner , address _newOwner ) DIDPermissionGranted \u00b6 event DIDPermissionGranted ( bytes32 _did , address _owner , address _grantee ) DIDPermissionRevoked \u00b6 event DIDPermissionRevoked ( bytes32 _did , address _owner , address _grantee ) DIDProvenanceDelegateRemoved \u00b6 event DIDProvenanceDelegateRemoved ( bytes32 _did , address _delegate , bool state ) DIDProvenanceDelegateAdded \u00b6 event DIDProvenanceDelegateAdded ( bytes32 _did , address _delegate ) setManager \u00b6 function setManager ( address _addr ) external Sets the manager role. Should be the TransferCondition contract address registerAttribute \u00b6 function registerAttribute ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url ) public virtual Register DID attributes. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] _url string refers to the attribute value, limited to 2048 bytes. registerDID \u00b6 function registerDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , bytes32 _activityId , string _attributes ) public virtual Register DID attributes. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). The final DID will be calculated with the creator address using the hashDID function _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _activityId bytes32 refers to activity _attributes string refers to the provenance attributes hashDID \u00b6 function hashDID ( bytes32 _didSeed , address _creator ) public pure returns ( bytes32 ) It generates a DID using as seed a bytes32 and the address of the DID creator Name Type Description _didSeed bytes32 refers to DID Seed used as base to generate the final DID _creator address address of the creator of the DID Name Type Description [0] bytes32 the new DID created areRoyaltiesValid \u00b6 function areRoyaltiesValid ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _tokenAddress ) public view returns ( bool ) areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards _tokenAddress address Name Type Description [0] bool true if the rewards distribution respect the original creator royalties wasGeneratedBy \u00b6 function wasGeneratedBy ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal returns ( bool ) used \u00b6 function used ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , bytes _signatureUsing , string _attributes ) public returns ( bool success ) wasDerivedFrom \u00b6 function wasDerivedFrom ( bytes32 _provId , bytes32 _newEntityDid , bytes32 _usedEntityDid , address _agentId , bytes32 _activityId , string _attributes ) public returns ( bool success ) wasAssociatedWith \u00b6 function wasAssociatedWith ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) public returns ( bool success ) actedOnBehalf \u00b6 function actedOnBehalf ( bytes32 _provId , bytes32 _did , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes _signatureDelegate , string _attributes ) public returns ( bool success ) Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId & _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId) Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered addDIDProvider \u00b6 function addDIDProvider ( bytes32 _did , address _provider ) external addDIDProvider add new DID provider. it adds new DID provider to the providers list. A provider is any entity that can serve the registered asset Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address. removeDIDProvider \u00b6 function removeDIDProvider ( bytes32 _did , address _provider ) external removeDIDProvider delete an existing DID provider. Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address. addDIDProvenanceDelegate \u00b6 function addDIDProvenanceDelegate ( bytes32 _did , address _delegate ) public addDIDProvenanceDelegate add new DID provenance delegate. it adds new DID provenance delegate to the delegates list. A delegate is any entity that interact with the provenance entries of one DID Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegates's address. removeDIDProvenanceDelegate \u00b6 function removeDIDProvenanceDelegate ( bytes32 _did , address _delegate ) external removeDIDProvenanceDelegate delete an existing DID delegate. Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address. transferDIDOwnership \u00b6 function transferDIDOwnership ( bytes32 _did , address _newOwner ) external transferDIDOwnership transfer DID ownership Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _newOwner address new owner address transferDIDOwnershipManaged \u00b6 function transferDIDOwnershipManaged ( address _sender , bytes32 _did , address _newOwner ) external transferDIDOwnershipManaged transfer DID ownership Name Type Description _sender address _did bytes32 refers to decentralized identifier (a bytes32 length ID) _newOwner address new owner address _transferDIDOwnership \u00b6 function _transferDIDOwnership ( address _sender , bytes32 _did , address _newOwner ) internal grantPermission \u00b6 function grantPermission ( bytes32 _did , address _grantee ) external grantPermission grants access permission to grantee Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address revokePermission \u00b6 function revokePermission ( bytes32 _did , address _grantee ) external revokePermission revokes access permission from grantee Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address getPermission \u00b6 function getPermission ( bytes32 _did , address _grantee ) external view returns ( bool ) getPermission gets access permission of a grantee Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address Name Type Description [0] bool true if grantee has access permission to a DID isDIDProvider \u00b6 function isDIDProvider ( bytes32 _did , address _provider ) public view returns ( bool ) isDIDProvider check whether a given DID provider exists Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address. isDIDProviderOrOwner \u00b6 function isDIDProviderOrOwner ( bytes32 _did , address _provider ) public view returns ( bool ) getDIDRegister \u00b6 function getDIDRegister ( bytes32 _did ) public view returns ( address owner , bytes32 lastChecksum , string url , address lastUpdatedBy , uint256 blockNumberUpdated , address [] providers , uint256 nftSupply , uint256 mintCap , uint256 royalties ) Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description owner address the did owner lastChecksum bytes32 last checksum url string URL to the DID metadata lastUpdatedBy address who was the last updating the DID blockNumberUpdated uint256 In which block was the DID updated providers address[] the list of providers nftSupply uint256 the supply of nfts mintCap uint256 the maximum number of nfts that can be minted royalties uint256 the royalties amount getDIDSupply \u00b6 function getDIDSupply ( bytes32 _did ) public view returns ( uint256 nftSupply , uint256 mintCap ) getBlockNumberUpdated \u00b6 function getBlockNumberUpdated ( bytes32 _did ) public view returns ( uint256 blockNumberUpdated ) Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description blockNumberUpdated uint256 last modified (update) block number of a DID. getDIDOwner \u00b6 function getDIDOwner ( bytes32 _did ) public view returns ( address didOwner ) Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description didOwner address the address of the DID owner. getDIDRoyaltyRecipient \u00b6 function getDIDRoyaltyRecipient ( bytes32 _did ) public view returns ( address ) getDIDRoyaltyScheme \u00b6 function getDIDRoyaltyScheme ( bytes32 _did ) public view returns ( address ) getDIDCreator \u00b6 function getDIDCreator ( bytes32 _did ) public view returns ( address ) _grantPermission \u00b6 function _grantPermission ( bytes32 _did , address _grantee ) internal __grantPermission grants access permission to grantee_ Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address _revokePermission \u00b6 function _revokePermission ( bytes32 _did , address _grantee ) internal __revokePermission revokes access permission from grantee_ Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address _getPermission \u00b6 function _getPermission ( bytes32 _did , address _grantee ) internal view returns ( bool ) __getPermission gets access permission of a grantee_ Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address Name Type Description [0] bool true if grantee has access permission to a DID getProvenanceEntry \u00b6 function getProvenanceEntry ( bytes32 _provId ) public view returns ( bytes32 did , bytes32 relatedDid , address agentId , bytes32 activityId , address agentInvolvedId , uint8 method , address createdBy , uint256 blockNumberUpdated , bytes signature ) Fetch the complete provenance entry attributes Name Type Description _provId bytes32 refers to the provenance identifier Name Type Description did bytes32 to what DID refers this entry relatedDid bytes32 DID related with the entry agentId address the agent identifier activityId bytes32 referring to the id of the activity agentInvolvedId address agent involved with the action method uint8 the w3c provenance method createdBy address who is creating this entry blockNumberUpdated uint256 in which block was updated signature bytes digital signature isDIDOwner \u00b6 function isDIDOwner ( address _address , bytes32 _did ) public view returns ( bool ) isDIDOwner check whether a given address is owner for a DID Name Type Description _address address user address. _did bytes32 refers to decentralized identifier (a bytes32 length ID). isOwnerProviderOrDelegate \u00b6 function isOwnerProviderOrDelegate ( bytes32 _did ) public view returns ( bool ) isOwnerProviderOrDelegate check whether msg.sender is owner, provider or delegate for a DID given Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description [0] bool boolean true if yes isProvenanceDelegate \u00b6 function isProvenanceDelegate ( bytes32 _did , address _delegate ) public view returns ( bool ) isProvenanceDelegate check whether a given DID delegate exists Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address. Name Type Description [0] bool boolean true if yes getProvenanceOwner \u00b6 function getProvenanceOwner ( bytes32 _did ) public view returns ( address provenanceOwner ) Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description provenanceOwner address the address of the Provenance owner. DIDRegistry \u00b6 Implementation of a Mintable DID Registry. erc1155 \u00b6 contract NFTUpgradeable erc1155 erc721 \u00b6 contract NFT721Upgradeable erc721 royaltiesCheckers \u00b6 mapping ( address => bool ) royaltiesCheckers initialize \u00b6 function initialize ( address _owner , address _erc1155 , address _erc721 ) public DIDRegistry Initializer Initialize Ownable. Only on contract creation. Name Type Description _owner address refers to the owner of the contract. _erc1155 address _erc721 address registerRoyaltiesChecker \u00b6 function registerRoyaltiesChecker ( address _addr ) public DIDRoyaltiesAdded \u00b6 event DIDRoyaltiesAdded ( bytes32 did , address addr ) DIDRoyaltyRecipientChanged \u00b6 event DIDRoyaltyRecipientChanged ( bytes32 did , address addr ) setDIDRoyalties \u00b6 function setDIDRoyalties ( bytes32 _did , address _royalties ) public setDIDRoyaltyRecipient \u00b6 function setDIDRoyaltyRecipient ( bytes32 _did , address _recipient ) public registerMintableDID \u00b6 function registerMintableDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , uint256 _cap , uint8 _royalties , bool _mint , bytes32 _activityId , string _nftMetadata ) public Register a Mintable DID using NFTs based in the ERC-1155 standard. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if true it mints the ERC-1155 NFTs attached to the asset _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata registerMintableDID721 \u00b6 function registerMintableDID721 ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , uint8 _royalties , bool _mint , bytes32 _activityId , string _nftMetadata ) public Register a Mintable DID using NFTs based in the ERC-721 standard. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if true it mints the ERC-1155 NFTs attached to the asset _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata registerMintableDID \u00b6 function registerMintableDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , uint256 _cap , uint8 _royalties , bytes32 _activityId , string _nftMetadata ) public Register a Mintable DID. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata enableAndMintDidNft \u00b6 function enableAndMintDidNft ( bytes32 _did , uint256 _cap , uint8 _royalties , bool _mint , string _nftMetadata ) public returns ( bool success ) enableDidNft creates the initial setup of NFTs minting and royalties distribution for ERC-1155 NFTs. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if is true mint directly the amount capped tokens and lock in the _lockAddress _nftMetadata string refers to the url providing the NFT Metadata enableAndMintDidNft721 \u00b6 function enableAndMintDidNft721 ( bytes32 _did , uint8 _royalties , bool _mint , string _nftMetadata ) public returns ( bool success ) enableAndMintDidNft721 creates the initial setup of NFTs minting and royalties distribution for ERC-721 NFTs. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if is true mint directly the amount capped tokens and lock in the _lockAddress _nftMetadata string refers to the url providing the NFT Metadata mint \u00b6 function mint ( bytes32 _did , uint256 _amount , address _receiver ) public Mints a NFT associated to the DID Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both Only the DID owner can mint NFTs associated to the DID Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to mint _receiver address the address that will receive the new nfts minted mint \u00b6 function mint ( bytes32 _did , uint256 _amount ) public mint721 \u00b6 function mint721 ( bytes32 _did , address _receiver ) public Mints a ERC-721 NFT associated to the DID Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _receiver address the address that will receive the new nfts minted mint721 \u00b6 function mint721 ( bytes32 _did ) public burn \u00b6 function burn ( bytes32 _did , uint256 _amount ) public Burns NFTs associated to the DID Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both Only the DID owner can burn NFTs associated to the DID Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to burn burn721 \u00b6 function burn721 ( bytes32 _did ) public DIDRegistryLibrary \u00b6 All function calls are currently implemented without side effects DIDRegister \u00b6 struct DIDRegister { address owner ; uint8 royalties ; bool nftInitialized ; bool nft721Initialized ; address creator ; bytes32 lastChecksum ; string url ; address lastUpdatedBy ; uint256 blockNumberUpdated ; address [] providers ; address [] delegates ; uint256 nftSupply ; uint256 mintCap ; address royaltyRecipient ; contract IRoyaltyScheme royaltyScheme ; } DIDRegisterList \u00b6 struct DIDRegisterList { mapping ( bytes32 &# x3D ; & gt ; struct DIDRegistryLibrary . DIDRegister ) didRegisters ; bytes32 [] didRegisterIds ; } update \u00b6 function update ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , bytes32 _checksum , string _url ) external update the DID store access modifiers and storage pointer should be implemented in DIDRegistry Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _checksum bytes32 includes a one-way HASH calculated using the DDO content _url string includes the url resolving to the DID Document (DDO) initializeNftConfig \u00b6 function initializeNftConfig ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint256 _cap , uint8 _royalties ) internal initializeNftConfig creates the initial setup of NFTs minting and royalties distribution. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market The royalties in secondary market for the creator should be between 0% >= x < 100% initializeNft721Config \u00b6 function initializeNft721Config ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint8 _royalties ) internal areRoyaltiesValid \u00b6 function areRoyaltiesValid ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _tokenAddress ) internal view returns ( bool ) areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards _tokenAddress address Name Type Description [0] bool true if the rewards distribution respect the original creator royalties addProvider \u00b6 function addProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address provider ) internal addProvider add provider to DID registry update the DID registry providers list by adding a new provider Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) provider address the provider's address removeProvider \u00b6 function removeProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _provider ) internal returns ( bool ) removeProvider remove provider from DID registry update the DID registry providers list by removing an existing provider Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address updateDIDOwner \u00b6 function updateDIDOwner ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _newOwner ) internal updateDIDOwner transfer DID ownership to a new owner Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _newOwner address the new DID owner address isProvider \u00b6 function isProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _provider ) public view returns ( bool ) isProvider check whether DID provider exists Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address Name Type Description [0] bool true if the provider already exists getProviderIndex \u00b6 function getProviderIndex ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address provider ) private view returns ( int256 ) getProviderIndex get the index of a provider Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) provider address the provider's address Name Type Description [0] int256 the index if the provider exists otherwise return -1 addDelegate \u00b6 function addDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address delegate ) internal addDelegate add delegate to DID registry update the DID registry delegates list by adding a new delegate Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) delegate address the delegate's address removeDelegate \u00b6 function removeDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _delegate ) internal returns ( bool ) removeDelegate remove delegate from DID registry update the DID registry delegates list by removing an existing delegate Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address isDelegate \u00b6 function isDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _delegate ) public view returns ( bool ) isDelegate check whether DID delegate exists Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address Name Type Description [0] bool true if the delegate already exists getDelegateIndex \u00b6 function getDelegateIndex ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address delegate ) private view returns ( int256 ) getDelegateIndex get the index of a delegate Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) delegate address the delegate's address Name Type Description [0] int256 the index if the delegate exists otherwise return -1 ProvenanceRegistry \u00b6 All function calls are currently implemented without side effects __ProvenanceRegistry_init \u00b6 function __ProvenanceRegistry_init () internal __ProvenanceRegistry_init_unchained \u00b6 function __ProvenanceRegistry_init_unchained () internal Provenance \u00b6 struct Provenance { bytes32 did ; bytes32 relatedDid ; address agentId ; bytes32 activityId ; address agentInvolvedId ; uint8 method ; address createdBy ; uint256 blockNumberUpdated ; bytes signature ; } ProvenanceRegistryList \u00b6 struct ProvenanceRegistryList { mapping ( bytes32 &# x3D ; & gt ; struct ProvenanceRegistry . Provenance ) list ; } provenanceRegistry \u00b6 struct ProvenanceRegistry . ProvenanceRegistryList provenanceRegistry ProvenanceMethod \u00b6 enum ProvenanceMethod { ENTITY , ACTIVITY , WAS_GENERATED_BY , USED , WAS_INFORMED_BY , WAS_STARTED_BY , WAS_ENDED_BY , WAS_INVALIDATED_BY , WAS_DERIVED_FROM , AGENT , WAS_ATTRIBUTED_TO , WAS_ASSOCIATED_WITH , ACTED_ON_BEHALF } ProvenanceAttributeRegistered \u00b6 event ProvenanceAttributeRegistered ( bytes32 provId , bytes32 _did , address _agentId , bytes32 _activityId , bytes32 _relatedDid , address _agentInvolvedId , enum ProvenanceRegistry . ProvenanceMethod _method , string _attributes , uint256 _blockNumberUpdated ) Provenance Events WasGeneratedBy \u00b6 event WasGeneratedBy ( bytes32 _did , address _agentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated ) Used \u00b6 event Used ( bytes32 _did , address _agentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated ) WasDerivedFrom \u00b6 event WasDerivedFrom ( bytes32 _newEntityDid , bytes32 _usedEntityDid , address _agentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated ) WasAssociatedWith \u00b6 event WasAssociatedWith ( bytes32 _entityDid , address _agentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated ) ActedOnBehalf \u00b6 event ActedOnBehalf ( bytes32 _entityDid , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated ) createProvenanceEntry \u00b6 function createProvenanceEntry ( bytes32 _provId , bytes32 _did , bytes32 _relatedDid , address _agentId , bytes32 _activityId , address _agentInvolvedId , enum ProvenanceRegistry . ProvenanceMethod _method , address _createdBy , bytes _signatureDelegate , string _attributes ) internal returns ( bool ) create an event in the Provenance store access modifiers and storage pointer should be implemented in ProvenanceRegistry Name Type Description _provId bytes32 refers to provenance event identifier _did bytes32 refers to decentralized identifier (a byte32 length ID) _relatedDid bytes32 refers to decentralized identifier (a byte32 length ID) of a related entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _agentInvolvedId address refers to address of the agent involved with the provenance record _method enum ProvenanceRegistry.ProvenanceMethod refers to the W3C Provenance method _createdBy address refers to address of the agent triggering the activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string _wasGeneratedBy \u00b6 function _wasGeneratedBy ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal virtual returns ( bool ) Implements the W3C PROV Generation action Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description [0] bool the number of the new provenance size _used \u00b6 function _used ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , bytes _signatureUsing , string _attributes ) internal virtual returns ( bool success ) Implements the W3C PROV Usage action Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _signatureUsing bytes refers to the digital signature provided by the agent using the _did _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered _wasDerivedFrom \u00b6 function _wasDerivedFrom ( bytes32 _provId , bytes32 _newEntityDid , bytes32 _usedEntityDid , address _agentId , bytes32 _activityId , string _attributes ) internal virtual returns ( bool success ) Implements the W3C PROV Derivation action Name Type Description _provId bytes32 unique identifier referring to the provenance entry _newEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _usedEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity used to derive the new did _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered _wasAssociatedWith \u00b6 function _wasAssociatedWith ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal virtual returns ( bool success ) Implements the W3C PROV Association action Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered _actedOnBehalf \u00b6 function _actedOnBehalf ( bytes32 _provId , bytes32 _did , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes _signatureDelegate , string _attributes ) internal virtual returns ( bool success ) Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId & _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId) Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered CurveRoyalties \u00b6 registry \u00b6 contract DIDRegistry registry DENOMINATOR \u00b6 uint256 DENOMINATOR royalties \u00b6 mapping ( bytes32 => uint256 ) royalties initialize \u00b6 function initialize ( address _registry ) public royaltyCurve \u00b6 function royaltyCurve ( uint256 num , uint256 max , uint256 rate ) public pure virtual returns ( uint256 ) setRoyalty \u00b6 function setRoyalty ( bytes32 _did , uint256 _royalty ) public Set royalties for a DID Can only be called by creator of the DID Name Type Description _did bytes32 DID for which the royalties are set _royalty uint256 Royalty, the actual royalty will be _royalty / 10000 percent check \u00b6 function check ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _token ) external view returns ( bool ) RewardsDistributor \u00b6 used \u00b6 mapping ( bytes32 => bool ) used receivers \u00b6 mapping ( bytes32 => address []) receivers registry \u00b6 contract DIDRegistry registry conditionStoreManager \u00b6 contract ConditionStoreManager conditionStoreManager escrow \u00b6 address escrow initialize \u00b6 function initialize ( address _registry , address _conditionStoreManager , address _escrow ) public setReceivers \u00b6 function setReceivers ( bytes32 _did , address [] _addr ) public set receivers for did Name Type Description _did bytes32 DID _addr address[] list of receivers claimReward \u00b6 function claimReward ( bytes32 _agreementId , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public distribute rewards associated with an escrow condition as paramemeters, it just gets the same parameters as fulfill for escrow condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier StandardRoyalties \u00b6 registry \u00b6 contract DIDRegistry registry DENOMINATOR \u00b6 uint256 DENOMINATOR royalties \u00b6 mapping ( bytes32 => uint256 ) royalties initialize \u00b6 function initialize ( address _registry ) public setRoyalty \u00b6 function setRoyalty ( bytes32 _did , uint256 _royalty ) public Set royalties for a DID Can only be called by creator of the DID Name Type Description _did bytes32 DID for which the royalties are set _royalty uint256 Royalty, the actual royalty will be _royalty / 10000 percent check \u00b6 function check ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address ) external view returns ( bool ) AaveCreditTemplate \u00b6 Implementation of the Aaven Credit Agreement Template 0. Initialize the agreement 1. LockNFT - Delegatee locks the NFT 2. AaveCollateralDeposit - Delegator deposits the collateral into Aave. And approves the delegation flow 3. AaveBorrowCondition - The Delegatee claim the credit amount from Aave 4. AaveRepayCondition. Options: 4.a Fulfilled state - The Delegatee pay back the loan (including fee) into Aave and gets back the NFT 4.b Aborted state - The Delegatee doesn't pay the loan in time so the Delegator gets the NFT. The Delegator pays the loan to Aave 5. TransferNFT. Options: 5.a if AaveRepayCondition was fulfilled, it will allow transfer back to the Delegatee or Borrower 5.b if AaveRepayCondition was aborted, it will allow transfer the NFT to the Delegator or Lender didRegistry \u00b6 contract DIDRegistry didRegistry nftLockCondition \u00b6 contract INFTLock nftLockCondition depositCondition \u00b6 contract AaveCollateralDepositCondition depositCondition borrowCondition \u00b6 contract AaveBorrowCondition borrowCondition repayCondition \u00b6 contract AaveRepayCondition repayCondition transferCondition \u00b6 contract DistributeNFTCollateralCondition transferCondition withdrawCondition \u00b6 contract AaveCollateralWithdrawCondition withdrawCondition vaultAddress \u00b6 mapping ( bytes32 => address ) vaultAddress nvmFee \u00b6 uint256 nvmFee vaultLibrary \u00b6 address vaultLibrary VaultCreated \u00b6 event VaultCreated ( address _vaultAddress , address _creator , address _lender , address _borrower ) initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _nftLockConditionAddress , address _depositConditionAddress , address _borrowConditionAddress , address _repayConditionAddress , address _withdrawCollateralAddress , address _transferConditionAddress , address _vaultLibrary ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftLockConditionAddress address NFT Lock Condition contract address _depositConditionAddress address Aave collateral deposit Condition address _borrowConditionAddress address Aave borrow deposit Condition address _repayConditionAddress address Aave repay credit Condition address _withdrawCollateralAddress address _transferConditionAddress address NFT Transfer Condition address _vaultLibrary address createVaultAgreement \u00b6 function createVaultAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _vaultAddress ) public createAgreement \u00b6 function createAgreement ( bytes32 _id , address _lendingPool , address _dataProvider , address _weth , uint256 _agreementFee , address _treasuryAddress , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _lender ) public deployVault \u00b6 function deployVault ( address _lendingPool , address _dataProvider , address _weth , uint256 _agreementFee , address _treasuryAddress , address _borrower , address _lender ) public returns ( address ) getVaultForAgreement \u00b6 function getVaultForAgreement ( bytes32 _agreementId ) public view returns ( address ) updateNVMFee \u00b6 function updateNVMFee ( uint256 _newFee ) public Updates the nevermined fee for this type of agreement Name Type Description _newFee uint256 New nevermined fee expressed in basis points changeCreditVaultLibrary \u00b6 function changeCreditVaultLibrary ( address _vaultLibrary ) public AccessProofTemplate \u00b6 Implementation of Access Agreement Template didRegistry \u00b6 contract DIDRegistry didRegistry accessCondition \u00b6 contract AccessProofCondition accessCondition lockCondition \u00b6 contract LockPaymentCondition lockCondition escrowReward \u00b6 contract EscrowPaymentCondition escrowReward initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _accessConditionAddress , address _lockConditionAddress , address payable _escrowConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address AccessTemplate \u00b6 _Implementation of Access Agreement Template Access template is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an on-chain SEA. The template is a composite of three basic conditions. Once the agreement is created, the consumer will lock an amount of tokens (as listed in the DID document - off-chain metadata) to the the lock reward contract which in turn will fire an event. ON the other hand the provider is listening to all the emitted events, the provider will catch the event and grant permissions to the consumer through secret store contract, the consumer now is able to download the data set by asking the off-chain component of secret store to decrypt the DID and encrypt it using the consumer's public key. Then the secret store will provide an on-chain proof that the consumer had access to the data set. Finally, the provider can call the escrow reward condition in order to release the payment. Every condition has a time window (time lock and time out). This implies that if the provider didn't grant the access to the consumer through secret store within this time window, the consumer can ask for refund._ didRegistry \u00b6 contract DIDRegistry didRegistry accessCondition \u00b6 contract AccessCondition accessCondition lockCondition \u00b6 contract LockPaymentCondition lockCondition escrowReward \u00b6 contract EscrowPaymentCondition escrowReward initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _accessConditionAddress , address _lockConditionAddress , address payable _escrowConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address AgreementTemplate \u00b6 _Implementation of Agreement Template Agreement template is a reference template where it has the ability to create agreements from whitelisted template_ conditionTypes \u00b6 address [] conditionTypes agreementStoreManager \u00b6 contract AgreementStoreManager agreementStoreManager createAgreement \u00b6 function createAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts ) public createAgreement create new agreement Name Type Description _id bytes32 agreement unique identifier _did bytes32 refers to decentralized identifier (a bytes32 length ID). _conditionIds bytes32[] list of condition identifiers _timeLocks uint256[] list of time locks, each time lock will be assigned to the same condition that has the same index _timeOuts uint256[] list of time outs, each time out will be assigned to the same condition that has the same index createAgreementAndPay \u00b6 function createAgreementAndPay ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , uint256 _idx , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public payable createAgreementAndFulfill \u00b6 function createAgreementAndFulfill ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , uint256 [] _indices , address [] _accounts , bytes [] _params ) internal getConditionTypes \u00b6 function getConditionTypes () public view returns ( address []) getConditionTypes gets the conditions addresses list for the current template returns list of condition contracts addresses Name Type Description [0] address[] list of conditions contract addresses BaseEscrowTemplate \u00b6 agreementData \u00b6 struct BaseEscrowTemplate . AgreementData agreementData AgreementCreated \u00b6 event AgreementCreated ( bytes32 _agreementId , bytes32 _did , address _accessConsumer , address _accessProvider , uint256 [] _timeLocks , uint256 [] _timeOuts , bytes32 [] _conditionIdSeeds , bytes32 [] _conditionIds , bytes32 _idSeed , address _creator ) AgreementDataModel \u00b6 struct AgreementDataModel { address accessConsumer ; address accessProvider ; bytes32 did ; } AgreementData \u00b6 struct AgreementData { mapping ( bytes32 &# x3D ; & gt ; struct BaseEscrowTemplate . AgreementDataModel ) agreementDataItems ; bytes32 [] agreementIds ; } createAgreement \u00b6 function createAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer ) public createAgreement creates agreements through agreement template this function initializes the agreement by setting the DID, conditions ID, timeouts, time locks and the consumer address. The DID provider/owner is automatically detected by the DID Registry Name Type Description _id bytes32 SEA agreement unique identifier _did bytes32 Decentralized Identifier (DID) _conditionIds bytes32[] conditions ID associated with the condition types _timeLocks uint256[] the starting point of the time window ,time lock is in block number not seconds _timeOuts uint256[] the ending point of the time window ,time lock is in block number not seconds _accessConsumer address consumer address createAgreementAndPayEscrow \u00b6 function createAgreementAndPayEscrow ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer , uint256 _idx , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public payable createAgreementAndFulfill \u00b6 function createAgreementAndFulfill ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer , uint256 [] _indices , address [] _accounts , bytes [] _params ) internal _makeIds \u00b6 function _makeIds ( bytes32 _idSeed , bytes32 [] _conditionIds ) internal view returns ( bytes32 []) _initAgreement \u00b6 function _initAgreement ( bytes32 _idSeed , bytes32 _did , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer , bytes32 [] _conditionIds ) internal getAgreementData \u00b6 function getAgreementData ( bytes32 _id ) external view returns ( address accessConsumer , address accessProvider ) getAgreementData return the agreement Data Name Type Description _id bytes32 SEA agreement unique identifier Name Type Description accessConsumer address the agreement consumer accessProvider address the provider addresses DIDSalesTemplate \u00b6 _Implementation of DID Sales Template The DID Sales template supports an scenario where an Asset owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing an Asset owner to get transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer DID Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the ownership transfer of an asset from the current owner for a specific DID._ didRegistry \u00b6 contract DIDRegistry didRegistry lockPaymentCondition \u00b6 contract LockPaymentCondition lockPaymentCondition transferCondition \u00b6 contract TransferDIDOwnershipCondition transferCondition rewardCondition \u00b6 contract EscrowPaymentCondition rewardCondition id \u00b6 function id () public pure returns ( uint256 ) initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockConditionAddress address lock reward condition contract address _transferConditionAddress address transfer ownership condition contract address _escrowPaymentAddress address payable escrow reward condition contract address DynamicAccessTemplate \u00b6 Implementation of Agreement Template This is a dynamic template that allows to setup flexible conditions depending on the use case. didRegistry \u00b6 contract DIDRegistry didRegistry templateConfig \u00b6 struct DynamicAccessTemplate . TemplateConditions templateConfig TemplateConditions \u00b6 struct TemplateConditions { mapping ( address &# x3D ; & gt ; contract Condition ) templateConditions ; } initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address addTemplateCondition \u00b6 function addTemplateCondition ( address _conditionAddress ) external returns ( uint256 length ) addTemplateCondition adds a new condition to the template Name Type Description _conditionAddress address condition contract address Name Type Description length uint256 conditionTypes array size removeLastTemplateCondition \u00b6 function removeLastTemplateCondition () external returns ( address []) removeLastTemplateCondition removes last condition added to the template Name Type Description [0] address[] conditionTypes existing in the array EscrowComputeExecutionTemplate \u00b6 _Implementation of a Compute Execution Agreement Template EscrowComputeExecutionTemplate is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an on-chain SEA. The template is a composite of three basic conditions. Once the agreement is created, the consumer will lock an amount of tokens (as listed in the DID document - off-chain metadata) to the the lock reward contract which in turn will fire an event. ON the other hand the provider is listening to all the emitted events, the provider will catch the event and grant permissions to trigger a computation granting the execution via the ComputeExecutionCondition contract. The consumer now is able to trigger that computation by asking the off-chain gateway to start the execution of a compute workflow. Finally, the provider can call the escrow reward condition in order to release the payment. Every condition has a time window (time lock and time out). This implies that if the provider didn't grant the execution to the consumer within this time window, the consumer can ask for refund._ didRegistry \u00b6 contract DIDRegistry didRegistry computeExecutionCondition \u00b6 contract ComputeExecutionCondition computeExecutionCondition lockPaymentCondition \u00b6 contract LockPaymentCondition lockPaymentCondition escrowPayment \u00b6 contract EscrowPaymentCondition escrowPayment initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _computeExecutionConditionAddress , address _lockPaymentConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including service executor condition, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _computeExecutionConditionAddress address service executor condition contract address _lockPaymentConditionAddress address lock reward condition contract address _escrowPaymentAddress address payable escrow reward contract address name \u00b6 function name () public pure returns ( string ) NFT721AccessProofTemplate \u00b6 Implementation of NFT721 Access Proof Template NFT721AccessSwapTemplate \u00b6 NFT721AccessTemplate \u00b6 Implementation of NFT Access Template NFT721SalesTemplate \u00b6 Implementation of NFT Sales Template NFT721SalesWithAccessTemplate \u00b6 NFTAccessProofTemplate \u00b6 _Implementation of NFT Access Template The NFT Access template is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing NFT holders to get access to Nevermined services. The template is a composite of 2 basic conditions: - NFT Holding Condition - Access Condition Once the agreement is created, the consumer can demonstrate is holding a NFT for a specific DID. If that's the case the Access condition can be fulfilled by the asset owner or provider and all the agreement is fulfilled. This can be used in scenarios where a data or services owner, can allow users to get access to exclusive services only when they demonstrate the are holding a specific number of NFTs of a DID. This is very useful in use cases like arts._ didRegistry \u00b6 contract DIDRegistry didRegistry nftHolderCondition \u00b6 contract INFTHolder nftHolderCondition accessCondition \u00b6 contract AccessProofCondition accessCondition initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _nftHolderConditionAddress , address _accessConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftHolderConditionAddress address lock reward condition contract address _accessConditionAddress address access condition contract address NFTAccessSwapTemplate \u00b6 _Implementation of NFT Sales Template The NFT Sales template supports an scenario where a NFT owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing a NFT owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer NFT Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the transfer of the NFT from the current owner for a specific DID._ didRegistry \u00b6 contract DIDRegistry didRegistry lockPaymentCondition \u00b6 contract INFTLock lockPaymentCondition rewardCondition \u00b6 contract INFTEscrow rewardCondition accessCondition \u00b6 contract AccessProofCondition accessCondition id \u00b6 function id () public pure returns ( uint256 ) initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockPaymentConditionAddress , address payable _escrowPaymentAddress , address _accessCondition ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _escrowPaymentAddress address payable escrow reward condition contract address _accessCondition address NFTAccessTemplate \u00b6 _Implementation of NFT Access Template The NFT Access template is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing NFT holders to get access to Nevermined services. The template is a composite of 2 basic conditions: - NFT Holding Condition - Access Condition Once the agreement is created, the consumer can demonstrate is holding a NFT for a specific DID. If that's the case the Access condition can be fulfilled by the asset owner or provider and all the agreement is fulfilled. This can be used in scenarios where a data or services owner, can allow users to get access to exclusive services only when they demonstrate the are holding a specific number of NFTs of a DID. This is very useful in use cases like arts._ didRegistry \u00b6 contract DIDRegistry didRegistry nftHolderCondition \u00b6 contract INFTHolder nftHolderCondition accessCondition \u00b6 contract INFTAccess accessCondition initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _nftHolderConditionAddress , address _accessConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftHolderConditionAddress address lock reward condition contract address _accessConditionAddress address access condition contract address NFTSalesTemplate \u00b6 _Implementation of NFT Sales Template The NFT Sales template supports an scenario where a NFT owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing a NFT owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer NFT Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the transfer of the NFT from the current owner for a specific DID._ didRegistry \u00b6 contract DIDRegistry didRegistry lockPaymentCondition \u00b6 contract LockPaymentCondition lockPaymentCondition transferCondition \u00b6 contract ITransferNFT transferCondition rewardCondition \u00b6 contract EscrowPaymentCondition rewardCondition id \u00b6 function id () public pure returns ( uint256 ) initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockPaymentConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _transferConditionAddress address transfer NFT condition contract address _escrowPaymentAddress address payable escrow reward condition contract address nftPrice \u00b6 mapping ( address => mapping ( address => mapping ( address => mapping ( bytes32 => uint256 )))) nftPrice nftSale \u00b6 function nftSale ( address nftAddress , bytes32 nftId , address token , uint256 amount ) external checkParamsTransfer \u00b6 function checkParamsTransfer ( bytes [] _params , bytes32 lockPaymentConditionId , bytes32 _did ) internal view returns ( address ) checkParamsEscrow \u00b6 function checkParamsEscrow ( bytes [] _params , bytes32 lockPaymentId , bytes32 transferId ) internal pure createAgreementFulfill \u00b6 function createAgreementFulfill ( bytes32 _id , bytes32 _did , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer , bytes [] _params ) external payable NFTSalesWithAccessTemplate \u00b6 _Implementation of NFT Sales Template The NFT Sales template supports an scenario where a NFT owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing a NFT owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer NFT Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the transfer of the NFT from the current owner for a specific DID._ didRegistry \u00b6 contract DIDRegistry didRegistry lockPaymentCondition \u00b6 contract LockPaymentCondition lockPaymentCondition transferCondition \u00b6 contract ITransferNFT transferCondition rewardCondition \u00b6 contract EscrowPaymentCondition rewardCondition accessCondition \u00b6 contract AccessProofCondition accessCondition initialize \u00b6 function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockPaymentConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress , address _accessCondition ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _transferConditionAddress address transfer NFT condition contract address _escrowPaymentAddress address payable escrow reward condition contract address _accessCondition address TemplateStoreLibrary \u00b6 _Implementation of the Template Store Library. Templates are blueprints for modular SEAs. When creating an Agreement, a templateId defines the condition and reward types that are instantiated in the ConditionStore._ TemplateState \u00b6 enum TemplateState { Uninitialized , Proposed , Approved , Revoked } Template \u00b6 struct Template { enum TemplateStoreLibrary . TemplateState state ; address owner ; address lastUpdatedBy ; uint256 blockNumberUpdated ; } TemplateList \u00b6 struct TemplateList { mapping ( address &# x3D ; & gt ; struct TemplateStoreLibrary . Template ) templates ; address [] templateIds ; } propose \u00b6 function propose ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal returns ( uint256 size ) propose new template Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address Name Type Description size uint256 which is the index of the proposed template approve \u00b6 function approve ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal approve new template Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address revoke \u00b6 function revoke ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal revoke new template Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address approved template contract address TemplateStoreManager \u00b6 Implementation of the Template Store Manager. Templates are blueprints for modular SEAs. When creating an Agreement, a templateId defines the condition and reward types that are instantiated in the ConditionStore. This contract manages the life cycle of the template ( Propose \u2192 Approve \u2192 Revoke ). templateList \u00b6 struct TemplateStoreLibrary . TemplateList templateList onlyOwnerOrTemplateOwner \u00b6 modifier onlyOwnerOrTemplateOwner ( address _id ) initialize \u00b6 function initialize ( address _owner ) public initialize TemplateStoreManager Initializer Initializes Ownable. Only on contract creation. Name Type Description _owner address refers to the owner of the contract proposeTemplate \u00b6 function proposeTemplate ( address _id ) external returns ( uint256 size ) proposeTemplate proposes a new template Name Type Description _id address unique template identifier which is basically the template contract address approveTemplate \u00b6 function approveTemplate ( address _id ) external approveTemplate approves a template Name Type Description _id address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) can approve this template. revokeTemplate \u00b6 function revokeTemplate ( address _id ) external revokeTemplate revoke a template Name Type Description _id address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) or template owner can revoke this template. getTemplate \u00b6 function getTemplate ( address _id ) external view returns ( enum TemplateStoreLibrary . TemplateState state , address owner , address lastUpdatedBy , uint256 blockNumberUpdated ) getTemplate get more information about a template Name Type Description _id address unique template identifier which is basically the template contract address. Name Type Description state enum TemplateStoreLibrary.TemplateState template status owner address template owner lastUpdatedBy address last updated by blockNumberUpdated uint256 last updated at. getTemplateListSize \u00b6 function getTemplateListSize () external view virtual returns ( uint256 size ) getTemplateListSize number of templates Name Type Description size uint256 number of templates isTemplateApproved \u00b6 function isTemplateApproved ( address _id ) external view returns ( bool ) isTemplateApproved check whether the template is approved Name Type Description _id address unique template identifier which is basically the template contract address. Name Type Description [0] bool true if the template is approved AgreementStoreManagerChangeFunctionSignature \u00b6 createAgreement \u00b6 function createAgreement ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _creator , address _sender ) public AgreementStoreManagerChangeInStorage \u00b6 agreementCount \u00b6 uint256 agreementCount AgreementStoreManagerChangeInStorageAndLogic \u00b6 AgreementStoreManagerExtraFunctionality \u00b6 dummyFunction \u00b6 function dummyFunction () public pure returns ( bool ) AgreementStoreManagerWithBug \u00b6 getDIDRegistryAddress \u00b6 function getDIDRegistryAddress () public pure returns ( address ) getDIDRegistryAddress utility function used by other contracts or any EOA. Name Type Description [0] address the DIDRegistry address ConditionStoreChangeFunctionSignature \u00b6 createCondition \u00b6 function createCondition ( bytes32 _id , address _typeRef , address _sender ) public ConditionStoreChangeInStorage \u00b6 conditionCount \u00b6 uint256 conditionCount ConditionStoreChangeInStorageAndLogic \u00b6 ConditionStoreExtraFunctionality \u00b6 dummyFunction \u00b6 function dummyFunction () public pure returns ( bool ) ConditionStoreWithBug \u00b6 getConditionState \u00b6 function getConditionState ( bytes32 _id ) public view returns ( enum ConditionStoreLibrary . ConditionState ) getConditionState Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state DIDRegistryChangeFunctionSignature \u00b6 registerAttribute \u00b6 function registerAttribute ( bytes32 _didSeed , address [] _providers , bytes32 _checksum , string _url ) public DIDRegistryChangeInStorage \u00b6 timeOfRegister \u00b6 mapping ( bytes32 => uint256 ) timeOfRegister DIDRegistryChangeInStorageAndLogic \u00b6 DIDRegistryExtraFunctionality \u00b6 getNumber \u00b6 function getNumber () public pure returns ( uint256 ) DIDRegistryWithBug \u00b6 registerAttribute \u00b6 function registerAttribute ( bytes32 _checksum , bytes32 _didSeed , address [] _providers , string _url ) public registerAttribute is called only by DID owner. this function registers DID attributes Name Type Description _checksum bytes32 includes a one-way HASH calculated using the DDO content _didSeed bytes32 refers to decentralized identifier (a byte32 length ID) _providers address[] _url string refers to the attribute value IPNFT \u00b6 TokenURIChanged \u00b6 event TokenURIChanged ( uint256 tokenId , string newURI ) initialize \u00b6 function initialize ( string _name , string _symbol ) public setTokenURI \u00b6 function setTokenURI ( uint256 tokenId , string _tokenURI ) public mint \u00b6 function mint ( address to , uint256 _tokenId , string _tokenURI ) public returns ( bool ) mintWithoutTokenURI \u00b6 function mintWithoutTokenURI ( address to , uint256 _tokenId ) external transfer \u00b6 function transfer ( address from , address to , uint256 _tokenId ) public NeverminedConfigChangeInStorage \u00b6 newVariable \u00b6 uint256 newVariable NeverminedConfigChangeFunctionSignature \u00b6 setMarketplaceFees \u00b6 function setMarketplaceFees ( uint256 _marketplaceFee , address _feeReceiver , uint256 _newParameter ) external virtual NeverminedConfigChangeInStorageAndLogic \u00b6 NeverminedConfigWithBug \u00b6 setMarketplaceFees \u00b6 function setMarketplaceFees ( uint256 _marketplaceFee , address _feeReceiver ) external virtual The governor can update the Nevermined Marketplace fees Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee TemplateStoreChangeFunctionSignature \u00b6 proposeTemplate \u00b6 function proposeTemplate ( address _id , address _sender ) external returns ( uint256 size ) TemplateStoreChangeInStorage \u00b6 templateCount \u00b6 uint256 templateCount TemplateStoreChangeInStorageAndLogic \u00b6 TemplateStoreExtraFunctionality \u00b6 dummyFunction \u00b6 function dummyFunction () public pure returns ( bool ) TemplateStoreWithBug \u00b6 getTemplateListSize \u00b6 function getTemplateListSize () external view returns ( uint256 size ) getTemplateListSize number of templates Name Type Description size uint256 number of templates TestERC721 \u00b6 initialize \u00b6 function initialize () public mint \u00b6 function mint ( uint256 id ) public DIDRegistryLibraryProxy \u00b6 didRegister \u00b6 struct DIDRegistryLibrary . DIDRegister didRegister didRegisterList \u00b6 struct DIDRegistryLibrary . DIDRegisterList didRegisterList areRoyaltiesValid \u00b6 function areRoyaltiesValid ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _tokenAddress ) public view returns ( bool ) updateDIDOwner \u00b6 function updateDIDOwner ( bytes32 _did , address _newOwner ) public update \u00b6 function update ( bytes32 _did , bytes32 _checksum , string _url ) public initializeNftConfig \u00b6 function initializeNftConfig ( bytes32 _did , uint256 _cap , uint8 _royalties ) public initializeNft721Config \u00b6 function initializeNft721Config ( bytes32 _did , uint8 _royalties ) public getDIDInfo \u00b6 function getDIDInfo ( bytes32 _did ) public view returns ( address owner , address creator , uint256 royalties ) EpochLibraryProxy \u00b6 epoch \u00b6 struct EpochLibrary . Epoch epoch epochList \u00b6 struct EpochLibrary . EpochList epochList create \u00b6 function create ( bytes32 _id , uint256 _timeLock , uint256 _timeOut ) external HashListLibraryProxy \u00b6 testData \u00b6 struct HashListLibrary . List testData initialize \u00b6 function initialize ( address _owner ) public hash \u00b6 function hash ( address _address ) public pure returns ( bytes32 ) add \u00b6 function add ( bytes32 [] values ) external returns ( bool ) add \u00b6 function add ( bytes32 value ) external returns ( bool ) update \u00b6 function update ( bytes32 oldValue , bytes32 newValue ) external returns ( bool ) index \u00b6 function index ( uint256 from , uint256 to ) external returns ( bool ) has \u00b6 function has ( bytes32 value ) external view returns ( bool ) remove \u00b6 function remove ( bytes32 value ) external returns ( bool ) get \u00b6 function get ( uint256 _index ) external view returns ( bytes32 ) size \u00b6 function size () external view returns ( uint256 ) all \u00b6 function all () external view returns ( bytes32 []) indexOf \u00b6 function indexOf ( bytes32 value ) external view returns ( uint256 ) ownedBy \u00b6 function ownedBy () external view returns ( address ) isIndexed \u00b6 function isIndexed () external view returns ( bool ) NFTBase \u00b6 Implementation of the Royalties EIP-2981 base contract See https://eips.ethereum.org/EIPS/eip-2981 _proxyApprovals \u00b6 mapping ( address => bool ) _proxyApprovals MINTER_ROLE \u00b6 bytes32 MINTER_ROLE RoyaltyInfo \u00b6 struct RoyaltyInfo { address receiver ; uint256 royaltyAmount ; } NFTMetadata \u00b6 struct NFTMetadata { string nftURI ; } _royalties \u00b6 mapping ( uint256 => struct NFTBase . RoyaltyInfo ) _royalties _metadata \u00b6 mapping ( uint256 => struct NFTBase . NFTMetadata ) _metadata _expiration \u00b6 mapping ( address => uint256 ) _expiration ProxyApproval \u00b6 event ProxyApproval ( address sender , address operator , bool approved ) Event for recording proxy approvals. setProxyApproval \u00b6 function setProxyApproval ( address operator , bool approved ) public virtual _setNFTMetadata \u00b6 function _setNFTMetadata ( uint256 tokenId , string tokenURI ) internal _setTokenRoyalty \u00b6 function _setTokenRoyalty ( uint256 tokenId , address receiver , uint256 royaltyAmount ) internal royaltyInfo \u00b6 function royaltyInfo ( uint256 tokenId , uint256 value ) external view returns ( address receiver , uint256 royaltyAmount ) @inheritdoc IERC2981Upgradeable NFTUpgradeable \u00b6 Implementation of the basic standard multi-token. See https://eips.ethereum.org/EIPS/eip-1155 initialize \u00b6 function initialize ( string uri_ ) public See {_setURI}. isApprovedForAll \u00b6 function isApprovedForAll ( address account , address operator ) public view virtual returns ( bool ) See {IERC1155-isApprovedForAll}. mint \u00b6 function mint ( address to , uint256 id , uint256 amount , bytes data ) public burn \u00b6 function burn ( address to , uint256 id , uint256 amount ) public addMinter \u00b6 function addMinter ( address account ) public uri \u00b6 function uri ( uint256 tokenId ) public view returns ( string ) setNFTMetadata \u00b6 function setNFTMetadata ( uint256 tokenId , string nftURI ) public Record some NFT Metadata Name Type Description tokenId uint256 the id of the asset with the royalties associated nftURI string the URI (https, ipfs, etc) to the metadata describing the NFT setTokenRoyalty \u00b6 function setTokenRoyalty ( uint256 tokenId , address receiver , uint256 royaltyAmount ) public Record the asset royalties Name Type Description tokenId uint256 the id of the asset with the royalties associated receiver address the receiver of the royalties (the original creator) royaltyAmount uint256 percentage (no decimals, between 0 and 100) supportsInterface \u00b6 function supportsInterface ( bytes4 interfaceId ) public view virtual returns ( bool ) NFT721SubscriptionUpgradeable \u00b6 mint \u00b6 function mint ( address to , uint256 id , uint256 expirationBlock ) public _This mint function allows to define when the NFT expires. The minter should calculate this block number depending on the network velocity TransferNFT721Condition needs to have the MINTER_ROLE _ balanceOf \u00b6 function balanceOf ( address owner ) public view returns ( uint256 ) See {IERC721-balanceOf}. NFT721Upgradeable \u00b6 Implementation of the basic standard multi-token. initialize \u00b6 function initialize ( string name , string symbol ) public virtual initialize \u00b6 function initialize () public virtual isApprovedForAll \u00b6 function isApprovedForAll ( address account , address operator ) public view virtual returns ( bool ) See {IERC1155-isApprovedForAll}. addMinter \u00b6 function addMinter ( address account ) public mint \u00b6 function mint ( address to , uint256 id ) public virtual burn \u00b6 function burn ( uint256 id ) public tokenURI \u00b6 function tokenURI ( uint256 tokenId ) public view virtual returns ( string ) See {IERC721Metadata-tokenURI}. setNFTMetadata \u00b6 function setNFTMetadata ( uint256 tokenId , string nftURI ) public Record some NFT Metadata Name Type Description tokenId uint256 the id of the asset with the royalties associated nftURI string the URI (https, ipfs, etc) to the metadata describing the NFT setTokenRoyalty \u00b6 function setTokenRoyalty ( uint256 tokenId , address receiver , uint256 royaltyAmount ) public Record the asset royalties Name Type Description tokenId uint256 the id of the asset with the royalties associated receiver address the receiver of the royalties (the original creator) royaltyAmount uint256 percentage (no decimals, between 0 and 100) supportsInterface \u00b6 function supportsInterface ( bytes4 interfaceId ) public view virtual returns ( bool ) POAPUpgradeable \u00b6 _tokenIdCounter \u00b6 struct CountersUpgradeable . Counter _tokenIdCounter _tokenEvent \u00b6 mapping ( uint256 => uint256 ) _tokenEvent initialize \u00b6 function initialize () public initialize \u00b6 function initialize ( string name , string symbol ) public virtual mint \u00b6 function mint ( address to , string uri , uint256 eventId ) public mint \u00b6 function mint ( address to , uint256 id ) public tokenEvent \u00b6 function tokenEvent ( uint256 tokenId ) public view returns ( uint256 ) _beforeTokenTransfer \u00b6 function _beforeTokenTransfer ( address from , address to , uint256 tokenId ) internal _burn \u00b6 function _burn ( uint256 tokenId ) internal tokenDetailsOfOwner \u00b6 function tokenDetailsOfOwner ( address owner ) public view returns ( uint256 [] tokenIds , uint256 [] eventIds ) tokenURI \u00b6 function tokenURI ( uint256 tokenId ) public view returns ( string ) isApprovedForAll \u00b6 function isApprovedForAll ( address account , address operator ) public view returns ( bool ) supportsInterface \u00b6 function supportsInterface ( bytes4 interfaceId ) public view virtual returns ( bool ) PlonkVerifier \u00b6 n \u00b6 uint32 n nPublic \u00b6 uint16 nPublic nLagrange \u00b6 uint16 nLagrange Qmx \u00b6 uint256 Qmx Qmy \u00b6 uint256 Qmy Qlx \u00b6 uint256 Qlx Qly \u00b6 uint256 Qly Qrx \u00b6 uint256 Qrx Qry \u00b6 uint256 Qry Qox \u00b6 uint256 Qox Qoy \u00b6 uint256 Qoy Qcx \u00b6 uint256 Qcx Qcy \u00b6 uint256 Qcy S1x \u00b6 uint256 S1x S1y \u00b6 uint256 S1y S2x \u00b6 uint256 S2x S2y \u00b6 uint256 S2y S3x \u00b6 uint256 S3x S3y \u00b6 uint256 S3y k1 \u00b6 uint256 k1 k2 \u00b6 uint256 k2 X2x1 \u00b6 uint256 X2x1 X2x2 \u00b6 uint256 X2x2 X2y1 \u00b6 uint256 X2y1 X2y2 \u00b6 uint256 X2y2 q \u00b6 uint256 q qf \u00b6 uint256 qf w1 \u00b6 uint256 w1 G1x \u00b6 uint256 G1x G1y \u00b6 uint256 G1y G2x1 \u00b6 uint256 G2x1 G2x2 \u00b6 uint256 G2x2 G2y1 \u00b6 uint256 G2y1 G2y2 \u00b6 uint256 G2y2 pA \u00b6 uint16 pA pB \u00b6 uint16 pB pC \u00b6 uint16 pC pZ \u00b6 uint16 pZ pT1 \u00b6 uint16 pT1 pT2 \u00b6 uint16 pT2 pT3 \u00b6 uint16 pT3 pWxi \u00b6 uint16 pWxi pWxiw \u00b6 uint16 pWxiw pEval_a \u00b6 uint16 pEval_a pEval_b \u00b6 uint16 pEval_b pEval_c \u00b6 uint16 pEval_c pEval_s1 \u00b6 uint16 pEval_s1 pEval_s2 \u00b6 uint16 pEval_s2 pEval_zw \u00b6 uint16 pEval_zw pEval_r \u00b6 uint16 pEval_r pAlpha \u00b6 uint16 pAlpha pBeta \u00b6 uint16 pBeta pGamma \u00b6 uint16 pGamma pXi \u00b6 uint16 pXi pXin \u00b6 uint16 pXin pBetaXi \u00b6 uint16 pBetaXi pV1 \u00b6 uint16 pV1 pV2 \u00b6 uint16 pV2 pV3 \u00b6 uint16 pV3 pV4 \u00b6 uint16 pV4 pV5 \u00b6 uint16 pV5 pV6 \u00b6 uint16 pV6 pU \u00b6 uint16 pU pPl \u00b6 uint16 pPl pEval_t \u00b6 uint16 pEval_t pA1 \u00b6 uint16 pA1 pB1 \u00b6 uint16 pB1 pZh \u00b6 uint16 pZh pZhInv \u00b6 uint16 pZhInv pEval_l1 \u00b6 uint16 pEval_l1 pEval_l2 \u00b6 uint16 pEval_l2 pEval_l3 \u00b6 uint16 pEval_l3 pEval_l4 \u00b6 uint16 pEval_l4 pEval_l5 \u00b6 uint16 pEval_l5 pEval_l6 \u00b6 uint16 pEval_l6 pEval_l7 \u00b6 uint16 pEval_l7 lastMem \u00b6 uint16 lastMem verifyProof \u00b6 function verifyProof ( bytes proof , uint256 [] pubSignals ) public view returns ( bool )","title":"Solidity API"},{"location":"architecture/contracts/generated/solidity-api/#solidity-api","text":"","title":"Solidity API"},{"location":"architecture/contracts/generated/solidity-api/#testdisputemanager","text":"","title":"TestDisputeManager"},{"location":"architecture/contracts/generated/solidity-api/#accept","text":"mapping ( bytes32 => bool ) accept","title":"accept"},{"location":"architecture/contracts/generated/solidity-api/#accepted","text":"function accepted ( address provider , address buyer , bytes32 orig , bytes32 crypted ) public view returns ( bool )","title":"accepted"},{"location":"architecture/contracts/generated/solidity-api/#setaccepted","text":"function setAccepted ( bytes32 orig , bytes32 crypted , address provider , address buyer ) public","title":"setAccepted"},{"location":"architecture/contracts/generated/solidity-api/#common","text":"","title":"Common"},{"location":"architecture/contracts/generated/solidity-api/#getcurrentblocknumber","text":"function getCurrentBlockNumber () external view returns ( uint256 ) getCurrentBlockNumber get block number Name Type Description [0] uint256 the current block number","title":"getCurrentBlockNumber"},{"location":"architecture/contracts/generated/solidity-api/#iscontract","text":"function isContract ( address addr ) public view returns ( bool ) isContract detect whether the address is is a contract address or externally owned account Name Type Description [0] bool true if it is a contract address","title":"isContract"},{"location":"architecture/contracts/generated/solidity-api/#provenancesignatureiscorrect","text":"function provenanceSignatureIsCorrect ( address _agentId , bytes32 _hash , bytes _signature ) public pure returns ( bool ) Name Type Description _agentId address The address of the agent _hash bytes32 bytes32 message, the hash is the signed message. What is recovered is the signer address. _signature bytes Signatures provided by the agent Name Type Description [0] bool true if the signature correspond to the agent address","title":"provenanceSignatureIsCorrect"},{"location":"architecture/contracts/generated/solidity-api/#calculatetotalamount","text":"function calculateTotalAmount ( uint256 [] _amounts ) public pure returns ( uint256 ) Sum the total amount given an uint array Name Type Description [0] uint256 the total amount","title":"calculateTotalAmount"},{"location":"architecture/contracts/generated/solidity-api/#addresstobytes32","text":"function addressToBytes32 ( address _addr ) public pure returns ( bytes32 )","title":"addressToBytes32"},{"location":"architecture/contracts/generated/solidity-api/#bytes32toaddress","text":"function bytes32ToAddress ( bytes32 _b32 ) public pure returns ( address )","title":"bytes32ToAddress"},{"location":"architecture/contracts/generated/solidity-api/#dispenser","text":"","title":"Dispenser"},{"location":"architecture/contracts/generated/solidity-api/#tokenrequests","text":"mapping ( address => uint256 ) tokenRequests","title":"tokenRequests"},{"location":"architecture/contracts/generated/solidity-api/#totalmintamount","text":"uint256 totalMintAmount","title":"totalMintAmount"},{"location":"architecture/contracts/generated/solidity-api/#maxamount","text":"uint256 maxAmount","title":"maxAmount"},{"location":"architecture/contracts/generated/solidity-api/#maxmintamount","text":"uint256 maxMintAmount","title":"maxMintAmount"},{"location":"architecture/contracts/generated/solidity-api/#minperiod","text":"uint256 minPeriod","title":"minPeriod"},{"location":"architecture/contracts/generated/solidity-api/#scale","text":"uint256 scale","title":"scale"},{"location":"architecture/contracts/generated/solidity-api/#token","text":"contract NeverminedToken token","title":"token"},{"location":"architecture/contracts/generated/solidity-api/#requestfrequencyexceeded","text":"event RequestFrequencyExceeded ( address requester , uint256 minPeriod )","title":"RequestFrequencyExceeded"},{"location":"architecture/contracts/generated/solidity-api/#requestlimitexceeded","text":"event RequestLimitExceeded ( address requester , uint256 amount , uint256 maxAmount )","title":"RequestLimitExceeded"},{"location":"architecture/contracts/generated/solidity-api/#isvalidaddress","text":"modifier isValidAddress ( address _address )","title":"isValidAddress"},{"location":"architecture/contracts/generated/solidity-api/#initialize","text":"function initialize ( address _tokenAddress , address _owner ) external Dispenser Initializer Name Type Description _tokenAddress address The deployed contract address of an ERC20 _owner address The owner of the Dispenser Runs only on initial contract creation.","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#requesttokens","text":"function requestTokens ( uint256 amount ) external returns ( bool tokensTransferred ) user can request some tokens for testing Name Type Description amount uint256 the amount of tokens to be requested Name Type Description tokensTransferred bool Boolean indication of tokens are requested","title":"requestTokens"},{"location":"architecture/contracts/generated/solidity-api/#setminperiod","text":"function setMinPeriod ( uint256 period ) external the Owner can set the min period for token requests Name Type Description period uint256 the min amount of time before next request","title":"setMinPeriod"},{"location":"architecture/contracts/generated/solidity-api/#setmaxamount","text":"function setMaxAmount ( uint256 amount ) external the Owner can set the max amount for token requests Name Type Description amount uint256 the max amount of tokens that can be requested","title":"setMaxAmount"},{"location":"architecture/contracts/generated/solidity-api/#setmaxmintamount","text":"function setMaxMintAmount ( uint256 amount ) external the Owner can set the max amount for token requests Name Type Description amount uint256 the max amount of tokens that can be requested","title":"setMaxMintAmount"},{"location":"architecture/contracts/generated/solidity-api/#hashlists","text":"Hash lists contract is a sample list contract in which uses HashListLibrary.sol in order to store, retrieve, remove, and update bytes32 values in hash lists. This is a reference implementation for IList interface. It is used for whitelisting condition. Any entity can have its own implementation of the interface in which could be used for the same condition.","title":"HashLists"},{"location":"architecture/contracts/generated/solidity-api/#lists","text":"mapping ( bytes32 => struct HashListLibrary . List ) lists","title":"lists"},{"location":"architecture/contracts/generated/solidity-api/#initialize_1","text":"function initialize ( address _owner ) public HashLists Initializer Name Type Description _owner address The owner of the hash list Runs only upon contract creation.","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hash","text":"function hash ( address account ) public pure returns ( bytes32 ) hash ethereum accounts Name Type Description account address Ethereum address Name Type Description [0] bytes32 bytes32 hash of the account","title":"hash"},{"location":"architecture/contracts/generated/solidity-api/#add","text":"function add ( bytes32 [] values ) external returns ( bool ) put an array of elements without indexing this meant to save gas in case of large arrays Name Type Description values bytes32[] is an array of elements value Name Type Description [0] bool true if values are added successfully","title":"add"},{"location":"architecture/contracts/generated/solidity-api/#add_1","text":"function add ( bytes32 value ) external returns ( bool ) add indexes an element then adds it to a list Name Type Description value bytes32 is a bytes32 value Name Type Description [0] bool true if value is added successfully","title":"add"},{"location":"architecture/contracts/generated/solidity-api/#update","text":"function update ( bytes32 oldValue , bytes32 newValue ) external returns ( bool ) update the value with a new value and maintain indices Name Type Description oldValue bytes32 is an element value in a list newValue bytes32 new value Name Type Description [0] bool true if value is updated successfully","title":"update"},{"location":"architecture/contracts/generated/solidity-api/#index","text":"function index ( uint256 from , uint256 to ) external returns ( bool ) index is used to map each element value to its index on the list Name Type Description from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing Name Type Description [0] bool true if the sub list is indexed","title":"index"},{"location":"architecture/contracts/generated/solidity-api/#has","text":"function has ( bytes32 id , bytes32 value ) external view returns ( bool ) has checks whether a value is exist Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list Name Type Description [0] bool true if the value exists","title":"has"},{"location":"architecture/contracts/generated/solidity-api/#has_1","text":"function has ( bytes32 value ) external view returns ( bool ) has checks whether a value is exist Name Type Description value bytes32 is element value in list Name Type Description [0] bool true if the value exists","title":"has"},{"location":"architecture/contracts/generated/solidity-api/#remove","text":"function remove ( bytes32 value ) external returns ( bool ) remove value from a list, updates indices, and list size Name Type Description value bytes32 is an element value in a list Name Type Description [0] bool true if value is removed successfully","title":"remove"},{"location":"architecture/contracts/generated/solidity-api/#get","text":"function get ( bytes32 id , uint256 _index ) external view returns ( bytes32 ) has value by index Name Type Description id bytes32 the list identifier (the hash of list owner's address) _index uint256 is where is value is stored in the list Name Type Description [0] bytes32 the value if exists","title":"get"},{"location":"architecture/contracts/generated/solidity-api/#size","text":"function size ( bytes32 id ) external view returns ( uint256 ) size gets the list size Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] uint256 total length of the list","title":"size"},{"location":"architecture/contracts/generated/solidity-api/#all","text":"function all ( bytes32 id ) external view returns ( bytes32 []) all returns all list elements Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] bytes32[] all list elements","title":"all"},{"location":"architecture/contracts/generated/solidity-api/#indexof","text":"function indexOf ( bytes32 id , bytes32 value ) external view returns ( uint256 ) indexOf gets the index of a value in a list Name Type Description id bytes32 the list identifier (the hash of list owner's address) value bytes32 is element value in list Name Type Description [0] uint256 value index in list","title":"indexOf"},{"location":"architecture/contracts/generated/solidity-api/#ownedby","text":"function ownedBy ( bytes32 id ) external view returns ( address ) ownedBy gets the list owner Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] address list owner","title":"ownedBy"},{"location":"architecture/contracts/generated/solidity-api/#isindexed","text":"function isIndexed ( bytes32 id ) external view returns ( bool ) isIndexed checks if the list is indexed Name Type Description id bytes32 the list identifier (the hash of list owner's address) Name Type Description [0] bool true if the list is indexed","title":"isIndexed"},{"location":"architecture/contracts/generated/solidity-api/#neverminedtoken","text":"Implementation of a Test Token. Test Token is an ERC20 token only for testing purposes","title":"NeverminedToken"},{"location":"architecture/contracts/generated/solidity-api/#initialize_2","text":"function initialize ( address _owner , address payable _initialMinter ) public NeverminedToken Initializer Runs only on initial contract creation. Name Type Description _owner address refers to the owner of the contract _initialMinter address payable is the first token minter added","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#_beforetokentransfer","text":"function _beforeTokenTransfer ( address from , address to , uint256 amount ) internal _See {ERC20-_beforeTokenTransfer}. Requirements: minted tokens must not cause the total supply to go over the cap._","title":"_beforeTokenTransfer"},{"location":"architecture/contracts/generated/solidity-api/#mint","text":"function mint ( address account , uint256 amount ) external returns ( bool ) _Creates amount tokens and assigns them to account , increasing the total supply. Emits a {Transfer} event with from set to the zero address. Requirements: to cannot be the zero address._","title":"mint"},{"location":"architecture/contracts/generated/solidity-api/#agreementstorelibrary","text":"Implementation of the Agreement Store Library. The agreement store library holds the business logic in which manages the life cycle of SEA agreement, each agreement is linked to the DID of an asset, template, and condition IDs.","title":"AgreementStoreLibrary"},{"location":"architecture/contracts/generated/solidity-api/#agreement","text":"struct Agreement { bytes32 did ; address templateId ; bytes32 [] conditionIds ; address lastUpdatedBy ; uint256 blockNumberUpdated ; }","title":"Agreement"},{"location":"architecture/contracts/generated/solidity-api/#agreementlist","text":"struct AgreementList { mapping ( bytes32 &# x3D ; & gt ; struct AgreementStoreLibrary . Agreement ) agreements ; mapping ( bytes32 &# x3D ; & gt ; bytes32 []) didToAgreementIds ; mapping ( address &# x3D ; & gt ; bytes32 []) templateIdToAgreementIds ; bytes32 [] agreementIds ; }","title":"AgreementList"},{"location":"architecture/contracts/generated/solidity-api/#create","text":"function create ( struct AgreementStoreLibrary . AgreementList _self , bytes32 _id , bytes32 , address _templateId , bytes32 []) internal create new agreement checks whether the agreement Id exists, creates new agreement instance, including the template, conditions and DID. Name Type Description _self struct AgreementStoreLibrary.AgreementList is AgreementList storage pointer _id bytes32 agreement identifier bytes32 _templateId address template identifier bytes32[]","title":"create"},{"location":"architecture/contracts/generated/solidity-api/#template","text":"","title":"Template"},{"location":"architecture/contracts/generated/solidity-api/#getconditiontypes","text":"function getConditionTypes () external view returns ( address [])","title":"getConditionTypes"},{"location":"architecture/contracts/generated/solidity-api/#agreementstoremanager","text":"_Implementation of the Agreement Store. The agreement store generates conditions for an agreement template. Agreement templates must to be approved in the Template Store Each agreement is linked to the DID of an asset._","title":"AgreementStoreManager"},{"location":"architecture/contracts/generated/solidity-api/#proxy_role","text":"bytes32 PROXY_ROLE","title":"PROXY_ROLE"},{"location":"architecture/contracts/generated/solidity-api/#grantproxyrole","text":"function grantProxyRole ( address _address ) public","title":"grantProxyRole"},{"location":"architecture/contracts/generated/solidity-api/#revokeproxyrole","text":"function revokeProxyRole ( address _address ) public","title":"revokeProxyRole"},{"location":"architecture/contracts/generated/solidity-api/#agreementlist_1","text":"struct AgreementStoreLibrary . AgreementList agreementList state storage for the agreements","title":"agreementList"},{"location":"architecture/contracts/generated/solidity-api/#conditionstoremanager","text":"contract ConditionStoreManager conditionStoreManager","title":"conditionStoreManager"},{"location":"architecture/contracts/generated/solidity-api/#templatestoremanager","text":"contract TemplateStoreManager templateStoreManager","title":"templateStoreManager"},{"location":"architecture/contracts/generated/solidity-api/#didregistry","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#initialize_3","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _templateStoreManagerAddress , address _didRegistryAddress ) public initialize AgreementStoreManager Initializer Initializes Ownable. Only on contract creation. Name Type Description _owner address refers to the owner of the contract _conditionStoreManagerAddress address is the address of the connected condition store _templateStoreManagerAddress address is the address of the connected template store _didRegistryAddress address is the address of the connected DID Registry","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#fullconditionid","text":"function fullConditionId ( bytes32 _agreementId , address _condType , bytes32 _valueHash ) public pure returns ( bytes32 )","title":"fullConditionId"},{"location":"architecture/contracts/generated/solidity-api/#agreementid","text":"function agreementId ( bytes32 _agreementId , address _creator ) public pure returns ( bytes32 )","title":"agreementId"},{"location":"architecture/contracts/generated/solidity-api/#createagreement","text":"function createAgreement ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts ) public Create a new agreement. The agreement will create conditions of conditionType with conditionId. Only \"approved\" templates can access this function. Name Type Description _id bytes32 is the ID of the new agreement. Must be unique. _did bytes32 is the bytes32 DID of the asset. The DID must be registered beforehand. _conditionTypes address[] is a list of addresses that point to Condition contracts. _conditionIds bytes32[] is a list of bytes32 content-addressed Condition IDs _timeLocks uint256[] is a list of uint time lock values associated to each Condition _timeOuts uint256[] is a list of uint time out values associated to each Condition","title":"createAgreement"},{"location":"architecture/contracts/generated/solidity-api/#createagreementargs","text":"struct CreateAgreementArgs { bytes32 _id ; bytes32 _did ; address [] _conditionTypes ; bytes32 [] _conditionIds ; uint256 [] _timeLocks ; uint256 [] _timeOuts ; address _creator ; uint256 _idx ; address payable _rewardAddress ; address _tokenAddress ; uint256 [] _amounts ; address [] _receivers ; }","title":"CreateAgreementArgs"},{"location":"architecture/contracts/generated/solidity-api/#createagreementandpay","text":"function createAgreementAndPay ( struct AgreementStoreManager . CreateAgreementArgs args ) public payable","title":"createAgreementAndPay"},{"location":"architecture/contracts/generated/solidity-api/#createagreementandfulfill","text":"function createAgreementAndFulfill ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address [] _account , uint256 [] _idx , bytes [] params ) public payable","title":"createAgreementAndFulfill"},{"location":"architecture/contracts/generated/solidity-api/#getagreementtemplate","text":"function getAgreementTemplate ( bytes32 _id ) external view returns ( address )","title":"getAgreementTemplate"},{"location":"architecture/contracts/generated/solidity-api/#getdidregistryaddress","text":"function getDIDRegistryAddress () public view virtual returns ( address ) getDIDRegistryAddress utility function used by other contracts or any EOA. Name Type Description [0] address the DIDRegistry address","title":"getDIDRegistryAddress"},{"location":"architecture/contracts/generated/solidity-api/#accesscondition","text":"_Implementation of the Access Condition Access Secret Store Condition is special condition where a client or Parity secret store can encrypt/decrypt documents based on the on-chain granted permissions. For a given DID document, and agreement ID, the owner/provider of the DID will fulfill the condition. Consequently secret store will check whether the permission is granted for the consumer in order to encrypt/decrypt the document._","title":"AccessCondition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#documentpermission","text":"struct DocumentPermission { bytes32 agreementIdDeprecated ; mapping ( address &# x3D ; & gt ; bool ) permission ; }","title":"DocumentPermission"},{"location":"architecture/contracts/generated/solidity-api/#documentpermissions","text":"mapping ( bytes32 => struct AccessCondition . DocumentPermission ) documentPermissions","title":"documentPermissions"},{"location":"architecture/contracts/generated/solidity-api/#agreementstoremanager_1","text":"contract AgreementStoreManager agreementStoreManager","title":"agreementStoreManager"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_1","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#fulfilled","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _documentId , address _grantee , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/generated/solidity-api/#onlydidownerorprovider","text":"modifier onlyDIDOwnerOrProvider ( bytes32 _documentId )","title":"onlyDIDOwnerOrProvider"},{"location":"architecture/contracts/generated/solidity-api/#initialize_4","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#reinitialize","text":"function reinitialize () external Should be called when the contract has been upgraded.","title":"reinitialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues","text":"function hashValues ( bytes32 _documentId , address _grantee ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill","text":"function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill access secret store condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#grantpermission","text":"function grantPermission ( address _grantee , bytes32 _documentId ) public grantPermission is called only by DID owner or provider Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys","title":"grantPermission"},{"location":"architecture/contracts/generated/solidity-api/#renouncepermission","text":"function renouncePermission ( address _grantee , bytes32 _documentId ) public renouncePermission is called only by DID owner or provider Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys","title":"renouncePermission"},{"location":"architecture/contracts/generated/solidity-api/#checkpermissions","text":"function checkPermissions ( address _grantee , bytes32 _documentId ) external view returns ( bool permissionGranted ) checkPermissions is called by Parity secret store Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys Name Type Description permissionGranted bool true if the access was granted","title":"checkPermissions"},{"location":"architecture/contracts/generated/solidity-api/#idisputemanager","text":"","title":"IDisputeManager"},{"location":"architecture/contracts/generated/solidity-api/#verifyproof","text":"function verifyProof ( bytes proof , uint256 [] pubSignals ) external view returns ( bool )","title":"verifyProof"},{"location":"architecture/contracts/generated/solidity-api/#accessproofcondition","text":"Implementation of the Access Condition with transfer proof. The idea is that the hash of the decryption key is known before hand, and the key matching this hash is passed from data provider to the buyer using this smart contract. Using ZK proof the key is kept hidden from outsiders. For the protocol to work, both the provider and buyer need to have public keys in the babyjub curve. To initiate the deal, buyer will pass the key hash and the public keys of participants. The provider needs to pass the cipher text encrypted using MIMC (symmetric encryption). The secret key for MIMC is computed using ECDH (requires one public key and one secret key for the curve). The hash function that is used is Poseidon.","title":"AccessProofCondition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_1","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#agreementstoremanager_2","text":"contract AgreementStoreManager agreementStoreManager","title":"agreementStoreManager"},{"location":"architecture/contracts/generated/solidity-api/#disputemanager","text":"contract IDisputeManager disputeManager","title":"disputeManager"},{"location":"architecture/contracts/generated/solidity-api/#fulfilled_1","text":"event Fulfilled ( bytes32 _agreementId , uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider , uint256 [ 2 ] _cipher , bytes _proof , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/generated/solidity-api/#initialize_5","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress , address _disputeManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address _disputeManagerAddress address dispute manager address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#changedisputemanager","text":"function changeDisputeManager ( address _disputeManagerAddress ) external","title":"changeDisputeManager"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_1","text":"function hashValues ( uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _origHash uint256 is the hash of the key _buyer uint256[2] buyer public key _provider uint256[2] provider public key Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_1","text":"function fulfill ( bytes32 _agreementId , uint256 _origHash , uint256 [ 2 ] _buyer , uint256 [ 2 ] _provider , uint256 [ 2 ] _cipher , bytes _proof ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill key transfer The key with hash _origHash is transferred to the _buyer from _provider. Name Type Description _agreementId bytes32 associated agreement _origHash uint256 is the hash of data to access _buyer uint256[2] buyer public key _provider uint256[2] provider public key _cipher uint256[2] encrypted version of the key _proof bytes SNARK proof that the cipher text can be decrypted by buyer to give the key with hash _origHash Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#computeexecutioncondition","text":"Implementation of the Compute Execution Condition This condition is meant to be a signal in which triggers the execution of a compute service. The compute service is fully described in the associated DID document. The provider of the compute service will send this signal to its workers by fulfilling the condition where they are listening to the fulfilled event.","title":"ComputeExecutionCondition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_2","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#computeexecutionstatus","text":"mapping ( bytes32 => mapping ( address => bool )) computeExecutionStatus","title":"computeExecutionStatus"},{"location":"architecture/contracts/generated/solidity-api/#agreementstoremanager_3","text":"contract AgreementStoreManager agreementStoreManager","title":"agreementStoreManager"},{"location":"architecture/contracts/generated/solidity-api/#fulfilled_2","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _computeConsumer , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/generated/solidity-api/#onlydidownerorprovider_1","text":"modifier onlyDIDOwnerOrProvider ( bytes32 _did )","title":"onlyDIDOwnerOrProvider"},{"location":"architecture/contracts/generated/solidity-api/#initialize_6","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _agreementStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _agreementStoreManagerAddress address agreement store manager address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_2","text":"function hashValues ( bytes32 _did , address _computeConsumer ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_2","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _computeConsumer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill compute execution condition only the compute provider can fulfill this condition. By fulfilling this condition the compute provider will trigger the execution of the offered job/compute. The compute service is described in a DID document. Name Type Description _agreementId bytes32 agreement identifier _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the consumer's address Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#wascomputetriggered","text":"function wasComputeTriggered ( bytes32 _did , address _computeConsumer ) public view returns ( bool ) wasComputeTriggered checks whether the compute is triggered or not. Name Type Description _did bytes32 Decentralized Identifier (unique compute/asset resolver) describes the compute service _computeConsumer address is the compute consumer's address Name Type Description [0] bool true if the compute is triggered","title":"wasComputeTriggered"},{"location":"architecture/contracts/generated/solidity-api/#condition","text":"_Implementation of the Condition Each condition has a validation function that returns either FULFILLED, ABORTED or UNFULFILLED. When a condition is successfully solved, we call it FULFILLED. If a condition cannot be FULFILLED anymore due to a timeout or other types of counter-proofs, the condition is ABORTED. UNFULFILLED values imply that a condition has not been provably FULFILLED or ABORTED. All initialized conditions start out as UNFULFILLED._","title":"Condition"},{"location":"architecture/contracts/generated/solidity-api/#conditionstoremanager_1","text":"contract ConditionStoreManager conditionStoreManager","title":"conditionStoreManager"},{"location":"architecture/contracts/generated/solidity-api/#generateid","text":"function generateId ( bytes32 _agreementId , bytes32 _valueHash ) public view returns ( bytes32 ) generateId condition Id from the following parameters Name Type Description _agreementId bytes32 SEA agreement ID _valueHash bytes32 hash of all the condition input values","title":"generateId"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_3","text":"function fulfill ( bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) internal returns ( enum ConditionStoreLibrary . ConditionState ) fulfill set the condition state to Fulfill | Abort Name Type Description _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState new condition state (Fulfill/Abort) Name Type Description [0] enum ConditionStoreLibrary.ConditionState the updated condition state","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#abortbytimeout","text":"function abortByTimeOut ( bytes32 _id ) external returns ( enum ConditionStoreLibrary . ConditionState ) abortByTimeOut set condition state to Aborted if the condition is timed out Name Type Description _id bytes32 condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState the updated condition state","title":"abortByTimeOut"},{"location":"architecture/contracts/generated/solidity-api/#conditionstorelibrary","text":"_Implementation of the Condition Store Library. Condition is a key component in the service execution agreement. This library holds the logic for creating and updating condition Any Condition has only four state transitions starts with Uninitialized, Unfulfilled, Fulfilled, and Aborted. Condition state transition goes only forward from Unintialized -> Unfulfilled -> {Fulfilled || Aborted}_","title":"ConditionStoreLibrary"},{"location":"architecture/contracts/generated/solidity-api/#conditionstate","text":"enum ConditionState { Uninitialized , Unfulfilled , Fulfilled , Aborted }","title":"ConditionState"},{"location":"architecture/contracts/generated/solidity-api/#condition_1","text":"struct Condition { address typeRef ; enum ConditionStoreLibrary . ConditionState state ; address createdBy ; address lastUpdatedBy ; uint256 blockNumberUpdated ; }","title":"Condition"},{"location":"architecture/contracts/generated/solidity-api/#conditionlist","text":"struct ConditionList { mapping ( bytes32 &# x3D ; & gt ; struct ConditionStoreLibrary . Condition ) conditions ; mapping ( bytes32 &# x3D ; & gt ; mapping ( bytes32 &# x3D ; & gt ; bytes32 )) map ; bytes32 [] conditionIds ; }","title":"ConditionList"},{"location":"architecture/contracts/generated/solidity-api/#create_1","text":"function create ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , address _typeRef ) internal create new condition check whether the condition exists, assigns condition type, condition state, last updated by, and update at (which is the current block number) Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 valid condition identifier _typeRef address condition contract address","title":"create"},{"location":"architecture/contracts/generated/solidity-api/#updatestate","text":"function updateState ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) internal updateState update the condition state check whether the condition state transition is right, assign the new state, update last updated by and updated at. Name Type Description _self struct ConditionStoreLibrary.ConditionList is the ConditionList storage pointer _id bytes32 condition identifier _newState enum ConditionStoreLibrary.ConditionState the new state of the condition","title":"updateState"},{"location":"architecture/contracts/generated/solidity-api/#updatekeyvalue","text":"function updateKeyValue ( struct ConditionStoreLibrary . ConditionList _self , bytes32 _id , bytes32 _key , bytes32 _value ) internal","title":"updateKeyValue"},{"location":"architecture/contracts/generated/solidity-api/#conditionstoremanager_2","text":"_Implementation of the Condition Store Manager. Condition store manager is responsible for enforcing the the business logic behind creating/updating the condition state based on the assigned role to each party. Only specific type of contracts are allowed to call this contract, therefore there are two types of roles, create role that in which is able to create conditions. The second role is the update role, which is can update the condition state. Also, it support delegating the roles to other contract(s)/account(s)._","title":"ConditionStoreManager"},{"location":"architecture/contracts/generated/solidity-api/#proxy_role_1","text":"bytes32 PROXY_ROLE","title":"PROXY_ROLE"},{"location":"architecture/contracts/generated/solidity-api/#roletype","text":"enum RoleType { Create , Update }","title":"RoleType"},{"location":"architecture/contracts/generated/solidity-api/#createrole","text":"address createRole","title":"createRole"},{"location":"architecture/contracts/generated/solidity-api/#conditionlist_1","text":"struct ConditionStoreLibrary . ConditionList conditionList","title":"conditionList"},{"location":"architecture/contracts/generated/solidity-api/#epochlist","text":"struct EpochLibrary . EpochList epochList","title":"epochList"},{"location":"architecture/contracts/generated/solidity-api/#nvmconfigaddress","text":"address nvmConfigAddress","title":"nvmConfigAddress"},{"location":"architecture/contracts/generated/solidity-api/#conditioncreated","text":"event ConditionCreated ( bytes32 _id , address _typeRef , address _who )","title":"ConditionCreated"},{"location":"architecture/contracts/generated/solidity-api/#conditionupdated","text":"event ConditionUpdated ( bytes32 _id , address _typeRef , enum ConditionStoreLibrary . ConditionState _state , address _who )","title":"ConditionUpdated"},{"location":"architecture/contracts/generated/solidity-api/#onlycreaterole","text":"modifier onlyCreateRole ()","title":"onlyCreateRole"},{"location":"architecture/contracts/generated/solidity-api/#onlyupdaterole","text":"modifier onlyUpdateRole ( bytes32 _id )","title":"onlyUpdateRole"},{"location":"architecture/contracts/generated/solidity-api/#onlyvalidtype","text":"modifier onlyValidType ( address typeRef )","title":"onlyValidType"},{"location":"architecture/contracts/generated/solidity-api/#initialize_7","text":"function initialize ( address _creator , address _owner , address _nvmConfigAddress ) public initialize ConditionStoreManager Initializer Initialize Ownable. Only on contract creation, Name Type Description _creator address refers to the creator of the contract _owner address refers to the owner of the contract _nvmConfigAddress address refers to the contract address of NeverminedConfig","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#getcreaterole","text":"function getCreateRole () external view returns ( address ) getCreateRole get the address of contract which has the create role Name Type Description [0] address create condition role address","title":"getCreateRole"},{"location":"architecture/contracts/generated/solidity-api/#getnvmconfigaddress","text":"function getNvmConfigAddress () external view returns ( address ) getNvmConfigAddress get the address of the NeverminedConfig contract Name Type Description [0] address NeverminedConfig contract address","title":"getNvmConfigAddress"},{"location":"architecture/contracts/generated/solidity-api/#setnvmconfigaddress","text":"function setNvmConfigAddress ( address _addr ) external","title":"setNvmConfigAddress"},{"location":"architecture/contracts/generated/solidity-api/#delegatecreaterole","text":"function delegateCreateRole ( address delegatee ) external delegateCreateRole only owner can delegate the create condition role to a different address Name Type Description delegatee address delegatee address","title":"delegateCreateRole"},{"location":"architecture/contracts/generated/solidity-api/#delegateupdaterole","text":"function delegateUpdateRole ( bytes32 _id , address delegatee ) external delegateUpdateRole only owner can delegate the update role to a different address for specific condition Id which has the create role Name Type Description _id bytes32 delegatee address delegatee address","title":"delegateUpdateRole"},{"location":"architecture/contracts/generated/solidity-api/#grantproxyrole_1","text":"function grantProxyRole ( address _address ) public","title":"grantProxyRole"},{"location":"architecture/contracts/generated/solidity-api/#revokeproxyrole_1","text":"function revokeProxyRole ( address _address ) public","title":"revokeProxyRole"},{"location":"architecture/contracts/generated/solidity-api/#createcondition","text":"function createCondition ( bytes32 _id , address _typeRef ) external createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled. Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address","title":"createCondition"},{"location":"architecture/contracts/generated/solidity-api/#createcondition2","text":"function createCondition2 ( bytes32 _id , address _typeRef ) external","title":"createCondition2"},{"location":"architecture/contracts/generated/solidity-api/#createcondition_1","text":"function createCondition ( bytes32 _id , address _typeRef , uint256 _timeLock , uint256 _timeOut ) public createCondition only called by create role address the condition should use a valid condition contract address, valid time lock and timeout. Moreover, it enforce the condition state transition from Uninitialized to Unfulfilled. Name Type Description _id bytes32 unique condition identifier _typeRef address condition contract address _timeLock uint256 start of the time window _timeOut uint256 end of the time window","title":"createCondition"},{"location":"architecture/contracts/generated/solidity-api/#updateconditionstate","text":"function updateConditionState ( bytes32 _id , enum ConditionStoreLibrary . ConditionState _newState ) external returns ( enum ConditionStoreLibrary . ConditionState ) updateConditionState only called by update role address. It enforce the condition state transition to either Fulfill or Aborted state Name Type Description _id bytes32 unique condition identifier _newState enum ConditionStoreLibrary.ConditionState Name Type Description [0] enum ConditionStoreLibrary.ConditionState the current condition state","title":"updateConditionState"},{"location":"architecture/contracts/generated/solidity-api/#updateconditionmapping","text":"function updateConditionMapping ( bytes32 _id , bytes32 _key , bytes32 _value ) external","title":"updateConditionMapping"},{"location":"architecture/contracts/generated/solidity-api/#updateconditionmappingproxy","text":"function updateConditionMappingProxy ( bytes32 _id , bytes32 _key , bytes32 _value ) external","title":"updateConditionMappingProxy"},{"location":"architecture/contracts/generated/solidity-api/#getcondition","text":"function getCondition ( bytes32 _id ) external view returns ( address typeRef , enum ConditionStoreLibrary . ConditionState state , uint256 timeLock , uint256 timeOut , uint256 blockNumber ) getCondition Name Type Description typeRef address the type reference state enum ConditionStoreLibrary.ConditionState condition state timeLock uint256 the time lock timeOut uint256 time out blockNumber uint256 block number","title":"getCondition"},{"location":"architecture/contracts/generated/solidity-api/#getconditionstate","text":"function getConditionState ( bytes32 _id ) external view virtual returns ( enum ConditionStoreLibrary . ConditionState ) getConditionState Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"getConditionState"},{"location":"architecture/contracts/generated/solidity-api/#getconditiontyperef","text":"function getConditionTypeRef ( bytes32 _id ) external view virtual returns ( address ) getConditionTypeRef Name Type Description [0] address condition typeRef","title":"getConditionTypeRef"},{"location":"architecture/contracts/generated/solidity-api/#getmappingvalue","text":"function getMappingValue ( bytes32 _id , bytes32 _key ) external view virtual returns ( bytes32 ) getConditionState Name Type Description [0] bytes32 condition state","title":"getMappingValue"},{"location":"architecture/contracts/generated/solidity-api/#isconditiontimelocked","text":"function isConditionTimeLocked ( bytes32 _id ) public view returns ( bool ) isConditionTimeLocked Name Type Description [0] bool whether the condition is timedLock ended","title":"isConditionTimeLocked"},{"location":"architecture/contracts/generated/solidity-api/#isconditiontimedout","text":"function isConditionTimedOut ( bytes32 _id ) public view returns ( bool ) isConditionTimedOut Name Type Description [0] bool whether the condition is timed out","title":"isConditionTimedOut"},{"location":"architecture/contracts/generated/solidity-api/#hashlockcondition","text":"Implementation of the Hash Lock Condition","title":"HashLockCondition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_3","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#initialize_8","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_3","text":"function hashValues ( uint256 _preimage ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _preimage uint256 refers uint value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_4","text":"function hashValues ( string _preimage ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _preimage string refers string value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_5","text":"function hashValues ( bytes32 _preimage ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _preimage bytes32 refers bytes32 value of the hash pre-image. Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_4","text":"function fulfill ( bytes32 _agreementId , uint256 _preimage ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image uint value Name Type Description _agreementId bytes32 SEA agreement identifier _preimage uint256 Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_5","text":"function fulfill ( bytes32 _agreementId , string _preimage ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image string value Name Type Description _agreementId bytes32 SEA agreement identifier _preimage string Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_6","text":"function fulfill ( bytes32 _agreementId , bytes32 _preimage ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the condition by calling check the the hash and the pre-image bytes32 value Name Type Description _agreementId bytes32 SEA agreement identifier _preimage bytes32 Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#_fulfill","text":"function _fulfill ( bytes32 _generatedId ) private returns ( enum ConditionStoreLibrary . ConditionState ) _fulfill calls super fulfil method Name Type Description _generatedId bytes32 SEA agreement identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"_fulfill"},{"location":"architecture/contracts/generated/solidity-api/#icondition","text":"","title":"ICondition"},{"location":"architecture/contracts/generated/solidity-api/#fulfillproxy","text":"function fulfillProxy ( address _account , bytes32 _agreementId , bytes params ) external payable","title":"fulfillProxy"},{"location":"architecture/contracts/generated/solidity-api/#ilockpayment","text":"","title":"ILockPayment"},{"location":"architecture/contracts/generated/solidity-api/#fulfilled_3","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId , address _rewardAddress , address _tokenAddress , address [] _receivers , uint256 [] _amounts )","title":"Fulfilled"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_6","text":"function hashValues ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_7","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires valid token transfer in order to lock the amount of tokens based on the SEA Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#lockpaymentcondition","text":"Implementation of the Lock Payment Condition This condition allows to lock payment for multiple receivers taking into account the royalties to be paid to the original creators in a secondary market.","title":"LockPaymentCondition"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_2","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#nvmconfig","text":"contract INVMConfig nvmConfig","title":"nvmConfig"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_4","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#key_asset_receiver","text":"bytes32 KEY_ASSET_RECEIVER","title":"KEY_ASSET_RECEIVER"},{"location":"architecture/contracts/generated/solidity-api/#proxy_role_2","text":"bytes32 PROXY_ROLE","title":"PROXY_ROLE"},{"location":"architecture/contracts/generated/solidity-api/#allowed_external_contract_role","text":"bytes32 ALLOWED_EXTERNAL_CONTRACT_ROLE","title":"ALLOWED_EXTERNAL_CONTRACT_ROLE"},{"location":"architecture/contracts/generated/solidity-api/#grantproxyrole_2","text":"function grantProxyRole ( address _address ) public","title":"grantProxyRole"},{"location":"architecture/contracts/generated/solidity-api/#revokeproxyrole_2","text":"function revokeProxyRole ( address _address ) public","title":"revokeProxyRole"},{"location":"architecture/contracts/generated/solidity-api/#grantexternalcontractrole","text":"function grantExternalContractRole ( address _address ) public","title":"grantExternalContractRole"},{"location":"architecture/contracts/generated/solidity-api/#revokeexternalcontractrole","text":"function revokeExternalContractRole ( address _address ) public","title":"revokeExternalContractRole"},{"location":"architecture/contracts/generated/solidity-api/#initialize_9","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#reinitialize_1","text":"function reinitialize () external Should be called when the contract has been upgraded.","title":"reinitialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_7","text":"function hashValues ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_8","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires valid token transfer in order to lock the amount of tokens based on the SEA Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#fulfillexternal","text":"function fulfillExternal ( bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _externalContract , bytes32 _remoteId , uint256 [] _amounts , address [] _receivers ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) fulfill lock condition using the funds locked in an external contract (auction, bonding curve, lottery, etc) Name Type Description _agreementId bytes32 the agreement identifier _did bytes32 the asset decentralized identifier _rewardAddress address payable the contract address where the reward is locked _externalContract address the address of the contract with the lock funds are locked _remoteId bytes32 the id used to identify into the external contract _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfillExternal"},{"location":"architecture/contracts/generated/solidity-api/#encodeparams","text":"function encodeParams ( bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) external pure returns ( bytes )","title":"encodeParams"},{"location":"architecture/contracts/generated/solidity-api/#fulfillinternal","text":"function fulfillInternal ( address _account , bytes32 _agreementId , bytes32 _did , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) internal returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfillInternal"},{"location":"architecture/contracts/generated/solidity-api/#fulfillproxy_1","text":"function fulfillProxy ( address _account , bytes32 _agreementId , bytes params ) external payable","title":"fulfillProxy"},{"location":"architecture/contracts/generated/solidity-api/#_transfererc20proxy","text":"function _transferERC20Proxy ( address _senderAddress , address _rewardAddress , address _tokenAddress , uint256 _amount ) internal _transferERC20Proxy transfer ERC20 tokens Will throw if transfer fails Name Type Description _senderAddress address the address to send the tokens from _rewardAddress address the address to receive the tokens _tokenAddress address the ERC20 contract address to use during the payment _amount uint256 token amount to be locked/released","title":"_transferERC20Proxy"},{"location":"architecture/contracts/generated/solidity-api/#_transfereth","text":"function _transferETH ( address payable _rewardAddress , uint256 _amount ) internal _transferETH transfer ETH Name Type Description _rewardAddress address payable the address to receive the ETH _amount uint256 ETH amount to be locked/released","title":"_transferETH"},{"location":"architecture/contracts/generated/solidity-api/#allowedexternalcontract","text":"modifier allowedExternalContract ( address _externalContractAddress )","title":"allowedExternalContract"},{"location":"architecture/contracts/generated/solidity-api/#aremarketplacefeesincluded","text":"function areMarketplaceFeesIncluded ( uint256 [] _amounts , address [] _receivers ) internal view returns ( bool )","title":"areMarketplaceFeesIncluded"},{"location":"architecture/contracts/generated/solidity-api/#distributenftcollateralcondition","text":"Implementation of a condition allowing to transfer a NFT to an account or another depending on the final state of a lock condition","title":"DistributeNFTCollateralCondition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_5","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#aavecreditvault","text":"contract AaveCreditVault aaveCreditVault","title":"aaveCreditVault"},{"location":"architecture/contracts/generated/solidity-api/#_lockconditionaddress","text":"address _lockConditionAddress","title":"_lockConditionAddress"},{"location":"architecture/contracts/generated/solidity-api/#fulfilled_4","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _receiver , bytes32 _conditionId , address _contract )","title":"Fulfilled"},{"location":"architecture/contracts/generated/solidity-api/#initialize_10","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _lockNFTConditionAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _lockNFTConditionAddress address Lock NFT Condition address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_8","text":"function hashValues ( bytes32 _did , address _vaultAddress , address _nftContractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _vaultAddress address The contract address of the vault _nftContractAddress address NFT contract to use Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_9","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _nftContractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _vaultAddress address The contract address of the vault _nftContractAddress address NFT contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#inftaccess","text":"","title":"INFTAccess"},{"location":"architecture/contracts/generated/solidity-api/#fulfilled_5","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _documentId , address _grantee , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_9","text":"function hashValues ( bytes32 _documentId , address _grantee , address _contractAddress ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_10","text":"function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access conditions only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#inftholder","text":"","title":"INFTHolder"},{"location":"architecture/contracts/generated/solidity-api/#fulfilled_6","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _address , bytes32 _conditionId , uint256 _amount )","title":"Fulfilled"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_10","text":"function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_11","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#inftlock","text":"","title":"INFTLock"},{"location":"architecture/contracts/generated/solidity-api/#fulfilled_7","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _lockAddress , bytes32 _conditionId , uint256 _amount , address _receiver , address _nftContractAddress )","title":"Fulfilled"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_11","text":"function hashValues ( bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the NFTs locked _nftContractAddress address Is the address of the NFT (ERC-721, ERC-1155) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#hashvaluesmarked","text":"function hashValuesMarked ( bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) external pure returns ( bytes32 )","title":"hashValuesMarked"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_12","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#fulfillmarked","text":"function fulfillMarked ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfillMarked"},{"location":"architecture/contracts/generated/solidity-api/#itransfernft","text":"","title":"ITransferNFT"},{"location":"architecture/contracts/generated/solidity-api/#fulfilled_8","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _receiver , uint256 _amount , bytes32 _conditionId , address _contract )","title":"Fulfilled"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_12","text":"function hashValues ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockCondition , address _contract , bool _transfer ) external pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _contract address _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_13","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _contract , bool _transfer ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _contract address _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#getnftdefaultaddress","text":"function getNFTDefaultAddress () external view returns ( address ) returns if the default NFT contract address The default NFT contract address was given to the Transfer Condition during the contract initialization Name Type Description [0] address the NFT contract address used by default in the transfer condition","title":"getNFTDefaultAddress"},{"location":"architecture/contracts/generated/solidity-api/#nft721holdercondition","text":"Implementation of the Nft Holder Condition","title":"NFT721HolderCondition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_6","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#initialize_11","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_13","text":"function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_14","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#nft721lockcondition","text":"Implementation of the NFT Lock Condition for ERC-721 based NFTs","title":"NFT721LockCondition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_7","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#initialize_12","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_14","text":"function hashValues ( bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#hashvaluesmarked_1","text":"function hashValuesMarked ( bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) public pure returns ( bytes32 )","title":"hashValuesMarked"},{"location":"architecture/contracts/generated/solidity-api/#fulfillmarked_1","text":"function fulfillMarked ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method lock a NFT into the _lockAddress . Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens (1) _receiver address _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfillMarked"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_15","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-721) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#onerc721received","text":"function onERC721Received ( address , address , uint256 , bytes ) public virtual returns ( bytes4 ) Always returns IERC721Receiver.onERC721Received.selector .","title":"onERC721Received"},{"location":"architecture/contracts/generated/solidity-api/#nftaccesscondition","text":"_Implementation of the Access Condition specific for NFTs NFT Access Condition is special condition used to give access to a specific NFT related to a DID._","title":"NFTAccessCondition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_8","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#documentpermission_1","text":"struct DocumentPermission { bytes32 agreementIdDeprecated ; mapping ( address &# x3D ; & gt ; bool ) permission ; }","title":"DocumentPermission"},{"location":"architecture/contracts/generated/solidity-api/#nftpermissions","text":"mapping ( bytes32 => struct NFTAccessCondition . DocumentPermission ) nftPermissions","title":"nftPermissions"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_3","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#onlydidownerorprovider_2","text":"modifier onlyDIDOwnerOrProvider ( bytes32 _documentId )","title":"onlyDIDOwnerOrProvider"},{"location":"architecture/contracts/generated/solidity-api/#initialize_13","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID registry address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_15","text":"function hashValues ( bytes32 _documentId , address _grantee ) public view returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_16","text":"function hashValues ( bytes32 _documentId , address _grantee , address _contractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_16","text":"function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_17","text":"function fulfill ( bytes32 _agreementId , bytes32 _documentId , address _grantee , address _contractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill NFT Access condition only DID owner or DID provider can call this method. Fulfill method sets the permissions for the granted consumer's address to true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _documentId bytes32 refers to the DID in which secret store will issue the decryption keys _grantee address is the address of the granted user or the DID provider _contractAddress address is the contract address of the NFT implementation (ERC-1155 or ERC-721) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#grantpermission_1","text":"function grantPermission ( address _grantee , bytes32 _documentId ) public grantPermission is called only by DID owner or provider Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID in which secret store will issue the decryption keys","title":"grantPermission"},{"location":"architecture/contracts/generated/solidity-api/#checkpermissions_1","text":"function checkPermissions ( address _grantee , bytes32 _documentId ) external view returns ( bool permissionGranted ) checkPermissions is called to validate the permissions of user related to the NFT attached to an asset Name Type Description _grantee address is the address of the granted user or the DID provider _documentId bytes32 refers to the DID Name Type Description permissionGranted bool true if the access was granted","title":"checkPermissions"},{"location":"architecture/contracts/generated/solidity-api/#nftholdercondition","text":"Implementation of the Nft Holder Condition","title":"NFTHolderCondition"},{"location":"architecture/contracts/generated/solidity-api/#erc1155","text":"contract ERC1155BurnableUpgradeable erc1155","title":"erc1155"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_9","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#initialize_14","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _ercAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _ercAddress address Nevermined ERC-1155 address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_17","text":"function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount ) public view returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_18","text":"function hashValues ( bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the Decentralized Identifier of the asset _holderAddress address the address of the NFT holder _amount uint256 is the amount NFTs that need to be hold by the holder _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_18","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_19","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _holderAddress , uint256 _amount , address _contractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill requires a validation that holder has enough NFTs for a specific DID Name Type Description _agreementId bytes32 SEA agreement identifier _did bytes32 the Decentralized Identifier of the asset _holderAddress address the contract address where the reward is locked _amount uint256 is the amount of NFT to be hold _contractAddress address contract address holding the NFT (ERC-721) or the NFT Factory (ERC-1155) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#nftlockcondition","text":"Implementation of the NFT Lock Condition","title":"NFTLockCondition"},{"location":"architecture/contracts/generated/solidity-api/#erc1155_1","text":"contract IERC1155Upgradeable erc1155","title":"erc1155"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_10","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#erc1155_accepted","text":"bytes4 ERC1155_ACCEPTED","title":"ERC1155_ACCEPTED"},{"location":"architecture/contracts/generated/solidity-api/#erc1155_batch_accepted","text":"bytes4 ERC1155_BATCH_ACCEPTED","title":"ERC1155_BATCH_ACCEPTED"},{"location":"architecture/contracts/generated/solidity-api/#initialize_15","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _ercAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _ercAddress address Nevermined ERC-1155 address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_19","text":"function hashValues ( bytes32 _did , address _lockAddress , uint256 _amount ) public view returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_20","text":"function hashValues ( bytes32 _did , address _lockAddress , uint256 _amount , address _nftContractAddress ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset with NFTs attached to lock _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _nftContractAddress address Is the address of the NFT (ERC-1155) contract to use Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#hashvaluesmarked_2","text":"function hashValuesMarked ( bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) public pure returns ( bytes32 )","title":"hashValuesMarked"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_20","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_21","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _nft ) public returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#fulfillmarked_2","text":"function fulfillMarked ( bytes32 _agreementId , bytes32 _did , address _lockAddress , uint256 _amount , address _receiver , address _nftContractAddress ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _lockAddress address the contract address where the NFT will be locked _amount uint256 is the amount of the locked tokens _receiver address _nftContractAddress address Is the address of the NFT (ERC-1155) contract to use Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfillMarked"},{"location":"architecture/contracts/generated/solidity-api/#onerc1155received","text":"function onERC1155Received ( address , address , uint256 , uint256 , bytes ) external pure returns ( bytes4 )","title":"onERC1155Received"},{"location":"architecture/contracts/generated/solidity-api/#onerc1155batchreceived","text":"function onERC1155BatchReceived ( address , address , uint256 [], uint256 [], bytes ) external pure returns ( bytes4 )","title":"onERC1155BatchReceived"},{"location":"architecture/contracts/generated/solidity-api/#supportsinterface","text":"function supportsInterface ( bytes4 interfaceId ) external pure returns ( bool ) _Returns true if this contract implements the interface defined by interfaceId . See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas._","title":"supportsInterface"},{"location":"architecture/contracts/generated/solidity-api/#transfernft721condition","text":"Implementation of condition allowing to transfer an NFT between the original owner and a receiver","title":"TransferNFT721Condition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_11","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#market_role","text":"bytes32 MARKET_ROLE","title":"MARKET_ROLE"},{"location":"architecture/contracts/generated/solidity-api/#erc721","text":"contract NFT721Upgradeable erc721","title":"erc721"},{"location":"architecture/contracts/generated/solidity-api/#_lockconditionaddress_1","text":"address _lockConditionAddress","title":"_lockConditionAddress"},{"location":"architecture/contracts/generated/solidity-api/#proxy_role_3","text":"bytes32 PROXY_ROLE","title":"PROXY_ROLE"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_4","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#grantproxyrole_3","text":"function grantProxyRole ( address _address ) public","title":"grantProxyRole"},{"location":"architecture/contracts/generated/solidity-api/#revokeproxyrole_3","text":"function revokeProxyRole ( address _address ) public","title":"revokeProxyRole"},{"location":"architecture/contracts/generated/solidity-api/#initialize_16","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress , address _ercAddress , address _lockNFTConditionAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address _ercAddress address Nevermined ERC-721 address _lockNFTConditionAddress address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#getnftdefaultaddress_1","text":"function getNFTDefaultAddress () external view returns ( address ) returns if the default NFT contract address The default NFT contract address was given to the Transfer Condition during the contract initialization Name Type Description [0] address the NFT contract address used by default in the transfer condition","title":"getNFTDefaultAddress"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_21","text":"function hashValues ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockCondition , address _contract , bool _transfer ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _contract address NFT contract to use _transfer bool Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#encodeparams_1","text":"function encodeParams ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) external pure returns ( bytes ) Encodes/serialize all the parameters received Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address the NFT contract to use _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] bytes the encoded parameters","title":"encodeParams"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_22","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _contract , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _contract address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#fulfillproxy_2","text":"function fulfillProxy ( address _account , bytes32 _agreementId , bytes _params ) external payable fulfill the transfer NFT condition by a proxy Fulfill method transfer a certain amount of NFTs Name Type Description _account address NFT Holder _agreementId bytes32 agreement identifier _params bytes encoded parameters","title":"fulfillProxy"},{"location":"architecture/contracts/generated/solidity-api/#fulfillinternal_1","text":"function fulfillInternal ( address _account , bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _contract , bool _transfer , uint256 _expirationBlock ) internal returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfillInternal"},{"location":"architecture/contracts/generated/solidity-api/#fulfillfordelegate","text":"function fulfillForDelegate ( bytes32 _agreementId , bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address in the DIDRegistry contract. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfillForDelegate"},{"location":"architecture/contracts/generated/solidity-api/#fulfillfordelegate_1","text":"function fulfillForDelegate ( bytes32 _agreementId , bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , bool _transfer , address _nftContractAddress , uint256 _expirationBlock ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address in the DIDRegistry contract. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _transfer bool if yes it does a transfer if false it mints the NFT _nftContractAddress address the address of the ERC-721 NFT contract _expirationBlock uint256 in which block the nft expires, if 0 it doesn't expire Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfillForDelegate"},{"location":"architecture/contracts/generated/solidity-api/#transfernftcondition","text":"Implementation of condition allowing to transfer an NFT between the original owner and a receiver","title":"TransferNFTCondition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_12","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#market_role_1","text":"bytes32 MARKET_ROLE","title":"MARKET_ROLE"},{"location":"architecture/contracts/generated/solidity-api/#erc1155_2","text":"contract NFTUpgradeable erc1155","title":"erc1155"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_5","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#proxy_role_4","text":"bytes32 PROXY_ROLE","title":"PROXY_ROLE"},{"location":"architecture/contracts/generated/solidity-api/#grantproxyrole_4","text":"function grantProxyRole ( address _address ) public","title":"grantProxyRole"},{"location":"architecture/contracts/generated/solidity-api/#revokeproxyrole_4","text":"function revokeProxyRole ( address _address ) public","title":"revokeProxyRole"},{"location":"architecture/contracts/generated/solidity-api/#initialize_17","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress , address _ercAddress , address _nftContractAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address _ercAddress address Nevermined ERC-1155 address _nftContractAddress address Market address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#grantmarketrole","text":"function grantMarketRole ( address _nftContractAddress ) public","title":"grantMarketRole"},{"location":"architecture/contracts/generated/solidity-api/#revokemarketrole","text":"function revokeMarketRole ( address _nftContractAddress ) public","title":"revokeMarketRole"},{"location":"architecture/contracts/generated/solidity-api/#getnftdefaultaddress_2","text":"function getNFTDefaultAddress () external view returns ( address ) returns if the default NFT contract address The default NFT contract address was given to the Transfer Condition during the contract initialization Name Type Description [0] address the NFT contract address used by default in the transfer condition","title":"getNFTDefaultAddress"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_22","text":"function hashValues ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockCondition ) public view returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_23","text":"function hashValues ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockCondition , address _nftContractAddress , bool _transfer ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address _nftReceiver address is the address of the granted user or the DID provider _nftAmount uint256 amount of NFTs to transfer _lockCondition bytes32 lock condition identifier _nftContractAddress address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_23","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition ) public returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#encodeparams_2","text":"function encodeParams ( bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) external pure returns ( bytes ) Encodes/serialize all the parameters received Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address the NFT contract to use _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] bytes the encoded parameters","title":"encodeParams"},{"location":"architecture/contracts/generated/solidity-api/#fulfillproxy_3","text":"function fulfillProxy ( address _account , bytes32 _agreementId , bytes _params ) external payable fulfill the transfer NFT condition by a proxy Fulfill method transfer a certain amount of NFTs Name Type Description _account address NFT Holder _agreementId bytes32 agreement identifier _params bytes encoded parameters","title":"fulfillProxy"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_24","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address NFT contract to use _transfer bool Indicates if the NFT will be transferred (true) or minted (false) Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#fulfillinternal_2","text":"function fulfillInternal ( address _account , bytes32 _agreementId , bytes32 _did , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) internal returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfillInternal"},{"location":"architecture/contracts/generated/solidity-api/#fulfillfordelegate_2","text":"function fulfillForDelegate ( bytes32 _agreementId , bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address in the DIDRegistry contract. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfillForDelegate"},{"location":"architecture/contracts/generated/solidity-api/#fulfillfordelegate_3","text":"function fulfillForDelegate ( bytes32 _agreementId , bytes32 _did , address _nftHolder , address _nftReceiver , uint256 _nftAmount , bytes32 _lockPaymentCondition , address _nftContractAddress , bool _transfer ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer NFT condition Fulfill method transfer a certain amount of NFTs to the _nftReceiver address in the DIDRegistry contract. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _nftHolder address is the address of the account to receive the NFT _nftReceiver address is the address of the account to receive the NFT _nftAmount uint256 amount of NFTs to transfer _lockPaymentCondition bytes32 lock payment condition identifier _nftContractAddress address the address of the ERC-721 NFT contract _transfer bool if yes it does a transfer if false it mints the NFT Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfillForDelegate"},{"location":"architecture/contracts/generated/solidity-api/#signcondition","text":"Implementation of the Sign Condition","title":"SignCondition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_13","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#initialize_18","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_24","text":"function hashValues ( bytes32 _message , address _publicKey ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _message bytes32 the message to be signed _publicKey address the public key of the signing address Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_25","text":"function fulfill ( bytes32 _agreementId , bytes32 _message , address _publicKey , bytes _signature ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill validate the signed message and fulfill the condition Name Type Description _agreementId bytes32 SEA agreement identifier _message bytes32 the message to be signed _publicKey address the public key of the signing address _signature bytes signature of the signed message using the public key Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#thresholdcondition","text":"_Implementation of the Threshold Condition Threshold condition acts as a filter for a set of input condition(s) in which sends a signal whether to complete the flow execution or abort it. This type of conditions works as intermediary conditions where they wire SEA conditions in order to support more complex scenarios._","title":"ThresholdCondition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_14","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#initialize_19","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_25","text":"function hashValues ( bytes32 [] inputConditions , uint256 threshold ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_26","text":"function fulfill ( bytes32 _agreementId , bytes32 [] _inputConditions , uint256 threshold ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill threshold condition the fulfill method check whether input conditions are fulfilled or not. Name Type Description _agreementId bytes32 agreement identifier _inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#canfulfill","text":"function canFulfill ( bytes32 [] _inputConditions , uint256 threshold ) private view returns ( bool _fulfill ) canFulfill check if condition can be fulfilled Name Type Description _inputConditions bytes32[] array of input conditions IDs threshold uint256 the required number of fulfilled input conditions Name Type Description _fulfill bool true if can fulfill","title":"canFulfill"},{"location":"architecture/contracts/generated/solidity-api/#transferdidownershipcondition","text":"Implementation of condition allowing to transfer the ownership between the original owner and a receiver","title":"TransferDIDOwnershipCondition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_15","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_6","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#fulfilled_9","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , address _receiver , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/generated/solidity-api/#initialize_20","text":"function initialize ( address _owner , address _conditionStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address _didRegistryAddress address DID Registry address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_26","text":"function hashValues ( bytes32 _did , address _receiver ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user or the DID provider Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_27","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _receiver ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill the transfer DID ownership condition only DID owner or DID provider can call this method. Fulfill method transfer full ownership permissions to to _receiver address. When true then fulfill the condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 refers to the DID in which secret store will issue the decryption keys _receiver address is the address of the granted user Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#whitelistingcondition","text":"Implementation of the Whitelisting Condition","title":"WhitelistingCondition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_16","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#initialize_21","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_27","text":"function hashValues ( address _listAddress , bytes32 _item ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _listAddress address list contract address _item bytes32 item in the list Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_28","text":"function fulfill ( bytes32 _agreementId , address _listAddress , bytes32 _item ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill check whether address is whitelisted in order to fulfill the condition. This method will be called by any one in this whitelist. Name Type Description _agreementId bytes32 SEA agreement identifier _listAddress address list contract address _item bytes32 item in the list Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#aaveborrowcondition","text":"Implementation of the Aave Borrow Credit Condition","title":"AaveBorrowCondition"},{"location":"architecture/contracts/generated/solidity-api/#aavecreditvault_1","text":"contract AaveCreditVault aaveCreditVault","title":"aaveCreditVault"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_17","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#fulfilled_10","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/generated/solidity-api/#initialize_22","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_28","text":"function hashValues ( bytes32 _did , address _vaultAddress , address _assetToBorrow , uint256 _amount , uint256 _interestRateMode ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToBorrow address the address of the asset to borrow (i.e DAI) _amount uint256 the amount of the ERC-20 the assets to borrow (i.e 50 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_29","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _assetToBorrow , uint256 _amount , uint256 _interestRateMode ) external returns ( enum ConditionStoreLibrary . ConditionState ) It allows the borrower to borrow the asset deposited by the lender Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToBorrow address the address of the asset to borrow (i.e DAI) _amount uint256 the amount of the ERC-20 the assets to borrow (i.e 50 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#aavecollateraldepositcondition","text":"Implementation of the Aave Collateral Deposit Condition This condition allows a Lender to deposit the collateral that into account the royalties to be paid to the original creators in a secondary market.","title":"AaveCollateralDepositCondition"},{"location":"architecture/contracts/generated/solidity-api/#aavecreditvault_2","text":"contract AaveCreditVault aaveCreditVault","title":"aaveCreditVault"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_18","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#fulfilled_11","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/generated/solidity-api/#initialize_23","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_29","text":"function hashValues ( bytes32 _did , address _vaultAddress , address _collateralAsset , uint256 _collateralAmount , address _delegatedAsset , uint256 _delegatedAmount , uint256 _interestRateMode ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the ERC-20 that will be used as collateral (i.e WETH) _collateralAmount uint256 the amount of the ERC-20 that will be used as collateral (i.e 10 WETH) _delegatedAsset address the address of the ERC-20 that will be delegated to the borrower (i.e DAI) _delegatedAmount uint256 the amount of the ERC-20 that will be delegated to the borrower (i.e 500 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_30","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _collateralAsset , uint256 _collateralAmount , address _delegatedAsset , uint256 _delegatedAmount , uint256 _interestRateMode ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) It fulfills the condition if the collateral can be deposited into the vault Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the ERC-20 that will be used as collateral (i.e WETH) _collateralAmount uint256 the amount of the ERC-20 that will be used as collateral (i.e 10 WETH) _delegatedAsset address the address of the ERC-20 that will be delegated to the borrower (i.e DAI) _delegatedAmount uint256 the amount of the ERC-20 that will be delegated to the borrower (i.e 500 DAI) _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#aavecollateralwithdrawcondition","text":"Implementation of the Collateral Withdraw Condition This condition allows to credit delegator withdraw the collateral and fees after the agreement expiration","title":"AaveCollateralWithdrawCondition"},{"location":"architecture/contracts/generated/solidity-api/#aavecreditvault_3","text":"contract AaveCreditVault aaveCreditVault","title":"aaveCreditVault"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_19","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#fulfilled_12","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/generated/solidity-api/#initialize_24","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_30","text":"function hashValues ( bytes32 _did , address _vaultAddress , address _collateralAsset ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the asset used as collateral (i.e DAI) Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_31","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _collateralAsset ) external payable returns ( enum ConditionStoreLibrary . ConditionState ) It allows the borrower to repay the loan Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address Address of the vault _collateralAsset address the address of the asset used as collateral (i.e DAI) Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#aavecreditvault_4","text":"","title":"AaveCreditVault"},{"location":"architecture/contracts/generated/solidity-api/#lendingpool","text":"contract ILendingPool lendingPool","title":"lendingPool"},{"location":"architecture/contracts/generated/solidity-api/#dataprovider","text":"contract IProtocolDataProvider dataProvider","title":"dataProvider"},{"location":"architecture/contracts/generated/solidity-api/#weth","text":"contract IWETHGateway weth","title":"weth"},{"location":"architecture/contracts/generated/solidity-api/#addressprovider","text":"contract ILendingPoolAddressesProvider addressProvider","title":"addressProvider"},{"location":"architecture/contracts/generated/solidity-api/#priceoracle","text":"contract IPriceOracleGetter priceOracle","title":"priceOracle"},{"location":"architecture/contracts/generated/solidity-api/#borrowedasset","text":"address borrowedAsset","title":"borrowedAsset"},{"location":"architecture/contracts/generated/solidity-api/#borrowedamount","text":"uint256 borrowedAmount","title":"borrowedAmount"},{"location":"architecture/contracts/generated/solidity-api/#nvmfee","text":"uint256 nvmFee","title":"nvmFee"},{"location":"architecture/contracts/generated/solidity-api/#agreementfee","text":"uint256 agreementFee","title":"agreementFee"},{"location":"architecture/contracts/generated/solidity-api/#fee_base","text":"uint256 FEE_BASE","title":"FEE_BASE"},{"location":"architecture/contracts/generated/solidity-api/#treasuryaddress","text":"address treasuryAddress","title":"treasuryAddress"},{"location":"architecture/contracts/generated/solidity-api/#borrower","text":"address borrower","title":"borrower"},{"location":"architecture/contracts/generated/solidity-api/#lender","text":"address lender","title":"lender"},{"location":"architecture/contracts/generated/solidity-api/#repayconditionid","text":"bytes32 repayConditionId","title":"repayConditionId"},{"location":"architecture/contracts/generated/solidity-api/#nftid","text":"uint256 nftId","title":"nftId"},{"location":"architecture/contracts/generated/solidity-api/#nftaddress","text":"address nftAddress","title":"nftAddress"},{"location":"architecture/contracts/generated/solidity-api/#borrower_role","text":"bytes32 BORROWER_ROLE","title":"BORROWER_ROLE"},{"location":"architecture/contracts/generated/solidity-api/#lender_role","text":"bytes32 LENDER_ROLE","title":"LENDER_ROLE"},{"location":"architecture/contracts/generated/solidity-api/#condition_role","text":"bytes32 CONDITION_ROLE","title":"CONDITION_ROLE"},{"location":"architecture/contracts/generated/solidity-api/#initialize_25","text":"function initialize ( address _lendingPool , address _dataProvider , address _weth , uint256 _nvmFee , uint256 _agreementFee , address _treasuryAddress , address _borrower , address _lender , address [] _conditions ) public Vault constructor, creates a unique vault for each agreement Name Type Description _lendingPool address Aave lending pool address _dataProvider address Aave data provider address _weth address WETH address _nvmFee uint256 Nevermined fee that will apply to this agreeement _agreementFee uint256 Agreement fee that lender will receive on agreement maturity _treasuryAddress address Address of nevermined contract to store fees _borrower address _lender address _conditions address[]","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#islender","text":"function isLender ( address _address ) public view returns ( bool )","title":"isLender"},{"location":"architecture/contracts/generated/solidity-api/#isborrower","text":"function isBorrower ( address _address ) public view returns ( bool )","title":"isBorrower"},{"location":"architecture/contracts/generated/solidity-api/#deposit","text":"function deposit ( address _collateralAsset , uint256 _amount ) public payable Deposit function. Receives the funds from the delegator and deposits the funds in the Aave contracts Name Type Description _collateralAsset address collateral asset that will be deposit on Aave _amount uint256 Amount of collateral to deposit","title":"deposit"},{"location":"architecture/contracts/generated/solidity-api/#approveborrower","text":"function approveBorrower ( address _borrower , uint256 _amount , address _asset , uint256 _interestRateMode ) public Appproves delegatee to borrow funds from Aave on behalf of delegator Name Type Description _borrower address delegatee that will borrow the funds _amount uint256 Amount of funds to delegate _asset address Asset to delegate the borrow _interestRateMode uint256 interest rate type stable 1, variable 2","title":"approveBorrower"},{"location":"architecture/contracts/generated/solidity-api/#delegatedamount","text":"function delegatedAmount ( address _borrower , address _asset , uint256 _interestRateMode ) public view returns ( uint256 ) Return the actual delegated amount for the borrower in the specific asset Name Type Description _borrower address The borrower of the funds (i.e. delgatee) _asset address The asset they are allowed to borrow _interestRateMode uint256 interest rate type stable 1, variable 2","title":"delegatedAmount"},{"location":"architecture/contracts/generated/solidity-api/#borrow","text":"function borrow ( address _assetToBorrow , uint256 _amount , address _delgatee , uint256 _interestRateMode ) public Borrower can call this function to borrow the delegated funds Name Type Description _assetToBorrow address The asset they are allowed to borrow _amount uint256 Amount to borrow _delgatee address Address where the funds will be transfered _interestRateMode uint256 interest rate type stable 1, variable 2","title":"borrow"},{"location":"architecture/contracts/generated/solidity-api/#repay","text":"function repay ( address _asset , uint256 _interestRateMode , bytes32 _repayConditionId ) public Repay an uncollaterised loan Name Type Description _asset address The asset to be repaid _interestRateMode uint256 interest rate type stable 1, variable 2 _repayConditionId bytes32 identifier of the condition id working as lock for other vault methods","title":"repay"},{"location":"architecture/contracts/generated/solidity-api/#setrepayconditionid","text":"function setRepayConditionId ( bytes32 _repayConditionId ) public","title":"setRepayConditionId"},{"location":"architecture/contracts/generated/solidity-api/#getborrowedamount","text":"function getBorrowedAmount () public view returns ( uint256 ) Returns the borrowed amount from the delegatee on this agreement","title":"getBorrowedAmount"},{"location":"architecture/contracts/generated/solidity-api/#getassetprice","text":"function getAssetPrice ( address _asset ) public view returns ( uint256 ) Returns the priceof the asset in the Aave oracles Name Type Description _asset address The asset to get the actual price","title":"getAssetPrice"},{"location":"architecture/contracts/generated/solidity-api/#getcreditassetdebt","text":"function getCreditAssetDebt () public view returns ( uint256 ) Returns the total debt of the credit in the Aave protocol expressed in token units","title":"getCreditAssetDebt"},{"location":"architecture/contracts/generated/solidity-api/#getactualcreditdebt","text":"function getActualCreditDebt () public view returns ( uint256 ) Returns the total debt of the credit in the Aave protocol expressed in ETH units","title":"getActualCreditDebt"},{"location":"architecture/contracts/generated/solidity-api/#gettotalactualdebt","text":"function getTotalActualDebt () public view returns ( uint256 ) Returns the total actual debt of the agreement credit + fees in token units","title":"getTotalActualDebt"},{"location":"architecture/contracts/generated/solidity-api/#withdrawcollateral","text":"function withdrawCollateral ( address _asset , address _delegator ) public Withdraw all of a collateral as the underlying asset, if no outstanding loans delegated Name Type Description _asset address The underlying asset to withdraw _delegator address Delegator address that deposited the collateral","title":"withdrawCollateral"},{"location":"architecture/contracts/generated/solidity-api/#transfernft","text":"function transferNFT ( uint256 _tokenId , address _receiver ) public Transfer a NFT (ERC-721) locked into the vault to a receiver address Name Type Description _tokenId uint256 the token id _receiver address the receiver adddress","title":"transferNFT"},{"location":"architecture/contracts/generated/solidity-api/#_transfererc20","text":"function _transferERC20 ( address _collateralAsset , uint256 _amount ) internal Transfers the ERC20 token deposited to the Aave contracts Name Type Description _collateralAsset address collateral asset that will be deposit on Aave _amount uint256 Amount of collateral to deposit","title":"_transferERC20"},{"location":"architecture/contracts/generated/solidity-api/#onerc721received_1","text":"function onERC721Received ( address , address , uint256 _tokenId , bytes ) public virtual returns ( bytes4 ) Handle the receipt of an NFT _The ERC721 smart contract calls this function on the recipient after a {IERC721-safeTransferFrom}. This function MUST return the function selector, otherwise the caller will revert the transaction. Note: the ERC721 contract address is always the message sender. (param not used): operator The address which called safeTransferFrom function (param not used): from The address which previously owned the token_ Name Type Description address address _tokenId uint256 The NFT identifier which is being transferred (param not used): data Additional data with no specified format bytes Name Type Description [0] bytes4 bytes4 bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))","title":"onERC721Received"},{"location":"architecture/contracts/generated/solidity-api/#aaverepaycondition","text":"Implementation of the Aave Repay Condition This condition allows to a borrower to repay a credit as part of a credit template","title":"AaveRepayCondition"},{"location":"architecture/contracts/generated/solidity-api/#aavecreditvault_5","text":"contract AaveCreditVault aaveCreditVault","title":"aaveCreditVault"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_20","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#fulfilled_13","text":"event Fulfilled ( bytes32 _agreementId , bytes32 _did , bytes32 _conditionId )","title":"Fulfilled"},{"location":"architecture/contracts/generated/solidity-api/#initialize_26","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters this function is called only once during the contract initialization. Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_31","text":"function hashValues ( bytes32 _did , address _vaultAddress , address _assetToRepay , uint256 _amountToRepay , uint256 _interestRateMode ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToRepay address the address of the asset to repay (i.e DAI) _amountToRepay uint256 Amount to repay _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_32","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , address _vaultAddress , address _assetToRepay , uint256 _amountToRepay , uint256 _interestRateMode ) external returns ( enum ConditionStoreLibrary . ConditionState ) It allows the borrower to repay the loan Name Type Description _agreementId bytes32 the identifier of the agreement _did bytes32 the DID of the asset _vaultAddress address the address of vault locking the deposited collateral and the asset _assetToRepay address the address of the asset to repay (i.e DAI) _amountToRepay uint256 Amount to repay _interestRateMode uint256 interest rate type stable 1, variable 2 Name Type Description [0] enum ConditionStoreLibrary.ConditionState ConditionStoreLibrary.ConditionState the state of the condition (Fulfilled if everything went good)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#escrowpaymentcondition","text":"_Implementation of the Escrow Payment Condition The Escrow payment is reward condition in which only can release reward if lock and release conditions are fulfilled._","title":"EscrowPaymentCondition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_21","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#used_payment_id","text":"bytes32 USED_PAYMENT_ID","title":"USED_PAYMENT_ID"},{"location":"architecture/contracts/generated/solidity-api/#fulfilled_14","text":"event Fulfilled ( bytes32 _agreementId , address _tokenAddress , address [] _receivers , bytes32 _conditionId , uint256 [] _amounts )","title":"Fulfilled"},{"location":"architecture/contracts/generated/solidity-api/#received","text":"event Received ( address _from , uint256 _value )","title":"Received"},{"location":"architecture/contracts/generated/solidity-api/#receive","text":"receive () external payable","title":"receive"},{"location":"architecture/contracts/generated/solidity-api/#initialize_27","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvaluesmulti","text":"function hashValuesMulti ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValuesMulti"},{"location":"architecture/contracts/generated/solidity-api/#encodeparams_3","text":"function encodeParams ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public pure returns ( bytes )","title":"encodeParams"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_32","text":"function hashValues ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 _releaseCondition ) public pure returns ( bytes32 )","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#hashvalueslockpayment","text":"function hashValuesLockPayment ( bytes32 _did , address _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public pure returns ( bytes32 ) hashValuesLockPayment generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _rewardAddress address the contract address where the reward is locked _tokenAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValuesLockPayment"},{"location":"architecture/contracts/generated/solidity-api/#fulfillmulti","text":"function fulfillMulti ( bytes32 _agreementId , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public returns ( enum ConditionStoreLibrary . ConditionState ) fulfill escrow reward condition fulfill method checks whether the lock and release conditions are fulfilled in order to release/refund the reward to receiver/sender respectively. Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfillMulti"},{"location":"architecture/contracts/generated/solidity-api/#args","text":"struct Args { bytes32 _agreementId ; bytes32 _did ; uint256 [] _amounts ; address [] _receivers ; address _returnAddress ; address _lockPaymentAddress ; address _tokenAddress ; bytes32 _lockCondition ; bytes32 [] _releaseConditions ; }","title":"Args"},{"location":"architecture/contracts/generated/solidity-api/#fulfillkludge","text":"function fulfillKludge ( struct EscrowPaymentCondition . Args a ) internal returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfillKludge"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_33","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 _releaseCondition ) external returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#_transferandfulfillerc20","text":"function _transferAndFulfillERC20 ( bytes32 _id , address _tokenAddress , address [] _receivers , uint256 [] _amounts ) private returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfill transfer ERC20 tokens and fulfill the condition Name Type Description _id bytes32 condition identifier _tokenAddress address the ERC20 contract address to use during the payment _receivers address[] receiver's address _amounts uint256[] token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"_transferAndFulfillERC20"},{"location":"architecture/contracts/generated/solidity-api/#_transferandfulfilleth","text":"function _transferAndFulfillETH ( bytes32 _id , address [] _receivers , uint256 [] _amounts ) private returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfill transfer ETH and fulfill the condition Name Type Description _id bytes32 condition identifier _receivers address[] receiver's address _amounts uint256[] token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"_transferAndFulfillETH"},{"location":"architecture/contracts/generated/solidity-api/#inftescrow","text":"Common interface for ERC-721 and ERC-1155","title":"INFTEscrow"},{"location":"architecture/contracts/generated/solidity-api/#fulfilled_15","text":"event Fulfilled ( bytes32 _agreementId , address _tokenAddress , bytes32 _did , address _receivers , bytes32 _conditionId , uint256 _amounts )","title":"Fulfilled"},{"location":"architecture/contracts/generated/solidity-api/#nft721escrowpaymentcondition","text":"_Implementation of the Escrow Payment Condition The Escrow payment is reward condition in which only can release reward if lock and release conditions are fulfilled._","title":"NFT721EscrowPaymentCondition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_22","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#received_1","text":"event Received ( address _from , uint256 _value )","title":"Received"},{"location":"architecture/contracts/generated/solidity-api/#receive_1","text":"receive () external payable","title":"receive"},{"location":"architecture/contracts/generated/solidity-api/#initialize_28","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_33","text":"function hashValues ( bytes32 _did , uint256 _amounts , address _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 asset decentralized identifier _amounts uint256 token amounts to be locked/released _receivers address receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#hashvalueslockpayment_1","text":"function hashValuesLockPayment ( bytes32 _did , address _lockAddress , address _nftContractAddress , uint256 _amount , address _receiver ) public pure returns ( bytes32 ) hashValuesLockPayment generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _lockAddress address the contract address where the reward is locked _nftContractAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amount uint256 token amounts to be locked/released _receiver address receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValuesLockPayment"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_34","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , uint256 _amount , address _receiver , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill escrow reward condition fulfill method checks whether the lock and release conditions are fulfilled in order to release/refund the reward to receiver/sender respectively. Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amount uint256 token amounts to be locked/released _receiver address receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#args_1","text":"struct Args { bytes32 _agreementId ; bytes32 _did ; uint256 _amount ; address _receiver ; address _returnAddress ; address _lockPaymentAddress ; address _tokenAddress ; bytes32 _lockCondition ; bytes32 [] _releaseConditions ; }","title":"Args"},{"location":"architecture/contracts/generated/solidity-api/#fulfillkludge_1","text":"function fulfillKludge ( struct NFT721EscrowPaymentCondition . Args a ) internal returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfillKludge"},{"location":"architecture/contracts/generated/solidity-api/#_transferandfulfillnft","text":"function _transferAndFulfillNFT ( bytes32 _agreementId , bytes32 _id , bytes32 _did , address _tokenAddress , address _receiver , uint256 _amount ) private returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfill transfer ERC20 tokens and fulfill the condition Name Type Description _agreementId bytes32 _id bytes32 condition identifier _did bytes32 _tokenAddress address the ERC20 contract address to use during the payment _receiver address receiver's address _amount uint256 token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"_transferAndFulfillNFT"},{"location":"architecture/contracts/generated/solidity-api/#onerc721received_2","text":"function onERC721Received ( address , address , uint256 , bytes ) public virtual returns ( bytes4 )","title":"onERC721Received"},{"location":"architecture/contracts/generated/solidity-api/#nftescrowpaymentcondition","text":"_Implementation of the Escrow Payment Condition The Escrow payment is reward condition in which only can release reward if lock and release conditions are fulfilled._","title":"NFTEscrowPaymentCondition"},{"location":"architecture/contracts/generated/solidity-api/#condition_type_23","text":"bytes32 CONDITION_TYPE","title":"CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#lock_condition_type","text":"bytes32 LOCK_CONDITION_TYPE","title":"LOCK_CONDITION_TYPE"},{"location":"architecture/contracts/generated/solidity-api/#received_2","text":"event Received ( address _from , uint256 _value )","title":"Received"},{"location":"architecture/contracts/generated/solidity-api/#receive_2","text":"receive () external payable","title":"receive"},{"location":"architecture/contracts/generated/solidity-api/#initialize_29","text":"function initialize ( address _owner , address _conditionStoreManagerAddress ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address _conditionStoreManagerAddress address condition store manager address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hashvalues_34","text":"function hashValues ( bytes32 _did , uint256 _amounts , address _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public pure returns ( bytes32 ) hashValues generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 asset decentralized identifier _amounts uint256 token amounts to be locked/released _receivers address receiver's addresses _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValues"},{"location":"architecture/contracts/generated/solidity-api/#hashvalueslockpayment_2","text":"function hashValuesLockPayment ( bytes32 _did , address _lockAddress , address _nftContractAddress , uint256 _amount , address _receiver ) public pure returns ( bytes32 ) hashValuesLockPayment generates the hash of condition inputs with the following parameters Name Type Description _did bytes32 the asset decentralized identifier _lockAddress address the contract address where the reward is locked _nftContractAddress address the ERC20 contract address to use during the lock payment. If the address is 0x0 means we won't use a ERC20 but ETH for payment _amount uint256 token amounts to be locked/released _receiver address receiver's addresses Name Type Description [0] bytes32 bytes32 hash of all these values","title":"hashValuesLockPayment"},{"location":"architecture/contracts/generated/solidity-api/#fulfill_35","text":"function fulfill ( bytes32 _agreementId , bytes32 _did , uint256 _amount , address _receiver , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) external returns ( enum ConditionStoreLibrary . ConditionState ) fulfill escrow reward condition fulfill method checks whether the lock and release conditions are fulfilled in order to release/refund the reward to receiver/sender respectively. Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amount uint256 token amounts to be locked/released _receiver address receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"fulfill"},{"location":"architecture/contracts/generated/solidity-api/#args_2","text":"struct Args { bytes32 _agreementId ; bytes32 _did ; uint256 _amount ; address _receiver ; address _returnAddress ; address _lockPaymentAddress ; address _tokenAddress ; bytes32 _lockCondition ; bytes32 [] _releaseConditions ; }","title":"Args"},{"location":"architecture/contracts/generated/solidity-api/#fulfillkludge_2","text":"function fulfillKludge ( struct NFTEscrowPaymentCondition . Args a ) internal returns ( enum ConditionStoreLibrary . ConditionState )","title":"fulfillKludge"},{"location":"architecture/contracts/generated/solidity-api/#_transferandfulfillnft_1","text":"function _transferAndFulfillNFT ( bytes32 _agreementId , bytes32 _id , bytes32 _did , address _tokenAddress , address _receiver , uint256 _amount ) private returns ( enum ConditionStoreLibrary . ConditionState ) _transferAndFulfill transfer ERC20 tokens and fulfill the condition Name Type Description _agreementId bytes32 _id bytes32 condition identifier _did bytes32 _tokenAddress address the ERC20 contract address to use during the payment _receiver address receiver's address _amount uint256 token amount to be locked/released Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state (Fulfilled/Aborted)","title":"_transferAndFulfillNFT"},{"location":"architecture/contracts/generated/solidity-api/#erc1155_accepted_1","text":"bytes4 ERC1155_ACCEPTED","title":"ERC1155_ACCEPTED"},{"location":"architecture/contracts/generated/solidity-api/#erc1155_batch_accepted_1","text":"bytes4 ERC1155_BATCH_ACCEPTED","title":"ERC1155_BATCH_ACCEPTED"},{"location":"architecture/contracts/generated/solidity-api/#onerc1155received_1","text":"function onERC1155Received ( address , address , uint256 , uint256 , bytes ) external pure returns ( bytes4 )","title":"onERC1155Received"},{"location":"architecture/contracts/generated/solidity-api/#onerc1155batchreceived_1","text":"function onERC1155BatchReceived ( address , address , uint256 [], uint256 [], bytes ) external pure returns ( bytes4 )","title":"onERC1155BatchReceived"},{"location":"architecture/contracts/generated/solidity-api/#supportsinterface_1","text":"function supportsInterface ( bytes4 interfaceId ) external pure returns ( bool ) _Returns true if this contract implements the interface defined by interfaceId . See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas._","title":"supportsInterface"},{"location":"architecture/contracts/generated/solidity-api/#reward","text":"_Implementation of the Reward. Generic reward condition_","title":"Reward"},{"location":"architecture/contracts/generated/solidity-api/#invmconfig","text":"","title":"INVMConfig"},{"location":"architecture/contracts/generated/solidity-api/#governor_role","text":"bytes32 GOVERNOR_ROLE","title":"GOVERNOR_ROLE"},{"location":"architecture/contracts/generated/solidity-api/#neverminedconfigchange","text":"event NeverminedConfigChange ( address _whoChanged , bytes32 _parameter ) Event that is emitted when a parameter is changed Name Type Description _whoChanged address the address of the governor changing the parameter _parameter bytes32 the hash of the name of the parameter changed","title":"NeverminedConfigChange"},{"location":"architecture/contracts/generated/solidity-api/#initialize_30","text":"function initialize ( address _owner , address _governor ) external virtual Used to initialize the contract during delegator constructor Name Type Description _owner address The owner of the contract _governor address The address to be granted with the GOVERNOR_ROLE","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#setmarketplacefees","text":"function setMarketplaceFees ( uint256 _marketplaceFee , address _feeReceiver ) external virtual The governor can update the Nevermined Marketplace fees Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee","title":"setMarketplaceFees"},{"location":"architecture/contracts/generated/solidity-api/#isgovernor","text":"function isGovernor ( address _address ) external view virtual returns ( bool ) Indicates if an address is a having the GOVERNOR role Name Type Description _address address The address to validate Name Type Description [0] bool true if is a governor","title":"isGovernor"},{"location":"architecture/contracts/generated/solidity-api/#getmarketplacefee","text":"function getMarketplaceFee () external view virtual returns ( uint256 ) Returns the marketplace fee Name Type Description [0] uint256 the marketplace fee","title":"getMarketplaceFee"},{"location":"architecture/contracts/generated/solidity-api/#getfeereceiver","text":"function getFeeReceiver () external view virtual returns ( address ) Returns the receiver address of the marketplace fee Name Type Description [0] address the receiver address","title":"getFeeReceiver"},{"location":"architecture/contracts/generated/solidity-api/#neverminedconfig","text":"","title":"NeverminedConfig"},{"location":"architecture/contracts/generated/solidity-api/#marketplacefee","text":"uint256 marketplaceFee","title":"marketplaceFee"},{"location":"architecture/contracts/generated/solidity-api/#feereceiver","text":"address feeReceiver","title":"feeReceiver"},{"location":"architecture/contracts/generated/solidity-api/#initialize_31","text":"function initialize ( address _owner , address _governor ) public Used to initialize the contract during delegator constructor Name Type Description _owner address The owner of the contract _governor address The address to be granted with the GOVERNOR_ROLE","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#setmarketplacefees_1","text":"function setMarketplaceFees ( uint256 _marketplaceFee , address _feeReceiver ) external virtual The governor can update the Nevermined Marketplace fees Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee","title":"setMarketplaceFees"},{"location":"architecture/contracts/generated/solidity-api/#setgovernor","text":"function setGovernor ( address _address ) external","title":"setGovernor"},{"location":"architecture/contracts/generated/solidity-api/#isgovernor_1","text":"function isGovernor ( address _address ) external view returns ( bool ) Indicates if an address is a having the GOVERNOR role Name Type Description _address address The address to validate Name Type Description [0] bool true if is a governor","title":"isGovernor"},{"location":"architecture/contracts/generated/solidity-api/#getmarketplacefee_1","text":"function getMarketplaceFee () external view returns ( uint256 ) Returns the marketplace fee Name Type Description [0] uint256 the marketplace fee","title":"getMarketplaceFee"},{"location":"architecture/contracts/generated/solidity-api/#getfeereceiver_1","text":"function getFeeReceiver () external view returns ( address ) Returns the receiver address of the marketplace fee Name Type Description [0] address the receiver address","title":"getFeeReceiver"},{"location":"architecture/contracts/generated/solidity-api/#onlygovernor","text":"modifier onlyGovernor ( address _address )","title":"onlyGovernor"},{"location":"architecture/contracts/generated/solidity-api/#ierc20","text":"","title":"IERC20"},{"location":"architecture/contracts/generated/solidity-api/#totalsupply","text":"function totalSupply () external view returns ( uint256 ) Returns the amount of tokens in existence.","title":"totalSupply"},{"location":"architecture/contracts/generated/solidity-api/#balanceof","text":"function balanceOf ( address account ) external view returns ( uint256 ) Returns the amount of tokens owned by account .","title":"balanceOf"},{"location":"architecture/contracts/generated/solidity-api/#transfer","text":"function transfer ( address recipient , uint256 amount ) external returns ( bool ) _Moves amount tokens from the caller's account to recipient . Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event._","title":"transfer"},{"location":"architecture/contracts/generated/solidity-api/#allowance","text":"function allowance ( address owner , address spender ) external view returns ( uint256 ) _Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called._","title":"allowance"},{"location":"architecture/contracts/generated/solidity-api/#approve","text":"function approve ( address spender , uint256 amount ) external returns ( bool ) _Sets amount as the allowance of spender over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event._","title":"approve"},{"location":"architecture/contracts/generated/solidity-api/#transferfrom","text":"function transferFrom ( address sender , address recipient , uint256 amount ) external returns ( bool ) _Moves amount tokens from sender to recipient using the allowance mechanism. amount is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event._","title":"transferFrom"},{"location":"architecture/contracts/generated/solidity-api/#transfer_1","text":"event Transfer ( address from , address to , uint256 value ) _Emitted when value tokens are moved from one account ( from ) to another ( to ). Note that value may be zero._","title":"Transfer"},{"location":"architecture/contracts/generated/solidity-api/#approval","text":"event Approval ( address owner , address spender , uint256 value ) Emitted when the allowance of a spender for an owner is set by a call to {approve}. value is the new allowance.","title":"Approval"},{"location":"architecture/contracts/generated/solidity-api/#ipriceoraclegetter","text":"Interface for the Aave price oracle.","title":"IPriceOracleGetter"},{"location":"architecture/contracts/generated/solidity-api/#getassetprice_1","text":"function getAssetPrice ( address asset ) external view returns ( uint256 ) returns the asset price in ETH Name Type Description asset address the address of the asset Name Type Description [0] uint256 the ETH price of the asset","title":"getAssetPrice"},{"location":"architecture/contracts/generated/solidity-api/#iprotocoldataprovider","text":"","title":"IProtocolDataProvider"},{"location":"architecture/contracts/generated/solidity-api/#tokendata","text":"struct TokenData { string symbol ; address tokenAddress ; }","title":"TokenData"},{"location":"architecture/contracts/generated/solidity-api/#addresses_provider","text":"function ADDRESSES_PROVIDER () external view returns ( contract ILendingPoolAddressesProvider )","title":"ADDRESSES_PROVIDER"},{"location":"architecture/contracts/generated/solidity-api/#getallreservestokens","text":"function getAllReservesTokens () external view returns ( struct IProtocolDataProvider . TokenData [])","title":"getAllReservesTokens"},{"location":"architecture/contracts/generated/solidity-api/#getallatokens","text":"function getAllATokens () external view returns ( struct IProtocolDataProvider . TokenData [])","title":"getAllATokens"},{"location":"architecture/contracts/generated/solidity-api/#getreserveconfigurationdata","text":"function getReserveConfigurationData ( address asset ) external view returns ( uint256 decimals , uint256 ltv , uint256 liquidationThreshold , uint256 liquidationBonus , uint256 reserveFactor , bool usageAsCollateralEnabled , bool borrowingEnabled , bool stableBorrowRateEnabled , bool isActive , bool isFrozen )","title":"getReserveConfigurationData"},{"location":"architecture/contracts/generated/solidity-api/#getreservedata","text":"function getReserveData ( address asset ) external view returns ( uint256 availableLiquidity , uint256 totalStableDebt , uint256 totalVariableDebt , uint256 liquidityRate , uint256 variableBorrowRate , uint256 stableBorrowRate , uint256 averageStableBorrowRate , uint256 liquidityIndex , uint256 variableBorrowIndex , uint40 lastUpdateTimestamp )","title":"getReserveData"},{"location":"architecture/contracts/generated/solidity-api/#getuserreservedata","text":"function getUserReserveData ( address asset , address user ) external view returns ( uint256 currentATokenBalance , uint256 currentStableDebt , uint256 currentVariableDebt , uint256 principalStableDebt , uint256 scaledVariableDebt , uint256 stableBorrowRate , uint256 liquidityRate , uint40 stableRateLastUpdated , bool usageAsCollateralEnabled )","title":"getUserReserveData"},{"location":"architecture/contracts/generated/solidity-api/#getreservetokensaddresses","text":"function getReserveTokensAddresses ( address asset ) external view returns ( address aTokenAddress , address stableDebtTokenAddress , address variableDebtTokenAddress )","title":"getReserveTokensAddresses"},{"location":"architecture/contracts/generated/solidity-api/#ilendingpooladdressesprovider","text":"","title":"ILendingPoolAddressesProvider"},{"location":"architecture/contracts/generated/solidity-api/#marketidset","text":"event MarketIdSet ( string newMarketId )","title":"MarketIdSet"},{"location":"architecture/contracts/generated/solidity-api/#lendingpoolupdated","text":"event LendingPoolUpdated ( address newAddress )","title":"LendingPoolUpdated"},{"location":"architecture/contracts/generated/solidity-api/#configurationadminupdated","text":"event ConfigurationAdminUpdated ( address newAddress )","title":"ConfigurationAdminUpdated"},{"location":"architecture/contracts/generated/solidity-api/#emergencyadminupdated","text":"event EmergencyAdminUpdated ( address newAddress )","title":"EmergencyAdminUpdated"},{"location":"architecture/contracts/generated/solidity-api/#lendingpoolconfiguratorupdated","text":"event LendingPoolConfiguratorUpdated ( address newAddress )","title":"LendingPoolConfiguratorUpdated"},{"location":"architecture/contracts/generated/solidity-api/#lendingpoolcollateralmanagerupdated","text":"event LendingPoolCollateralManagerUpdated ( address newAddress )","title":"LendingPoolCollateralManagerUpdated"},{"location":"architecture/contracts/generated/solidity-api/#priceoracleupdated","text":"event PriceOracleUpdated ( address newAddress )","title":"PriceOracleUpdated"},{"location":"architecture/contracts/generated/solidity-api/#lendingrateoracleupdated","text":"event LendingRateOracleUpdated ( address newAddress )","title":"LendingRateOracleUpdated"},{"location":"architecture/contracts/generated/solidity-api/#proxycreated","text":"event ProxyCreated ( bytes32 id , address newAddress )","title":"ProxyCreated"},{"location":"architecture/contracts/generated/solidity-api/#addressset","text":"event AddressSet ( bytes32 id , address newAddress , bool hasProxy )","title":"AddressSet"},{"location":"architecture/contracts/generated/solidity-api/#getmarketid","text":"function getMarketId () external view returns ( string )","title":"getMarketId"},{"location":"architecture/contracts/generated/solidity-api/#setmarketid","text":"function setMarketId ( string marketId ) external","title":"setMarketId"},{"location":"architecture/contracts/generated/solidity-api/#setaddress","text":"function setAddress ( bytes32 id , address newAddress ) external","title":"setAddress"},{"location":"architecture/contracts/generated/solidity-api/#setaddressasproxy","text":"function setAddressAsProxy ( bytes32 id , address impl ) external","title":"setAddressAsProxy"},{"location":"architecture/contracts/generated/solidity-api/#getaddress","text":"function getAddress ( bytes32 id ) external view returns ( address )","title":"getAddress"},{"location":"architecture/contracts/generated/solidity-api/#getlendingpool","text":"function getLendingPool () external view returns ( address )","title":"getLendingPool"},{"location":"architecture/contracts/generated/solidity-api/#setlendingpoolimpl","text":"function setLendingPoolImpl ( address pool ) external","title":"setLendingPoolImpl"},{"location":"architecture/contracts/generated/solidity-api/#getlendingpoolconfigurator","text":"function getLendingPoolConfigurator () external view returns ( address )","title":"getLendingPoolConfigurator"},{"location":"architecture/contracts/generated/solidity-api/#setlendingpoolconfiguratorimpl","text":"function setLendingPoolConfiguratorImpl ( address configurator ) external","title":"setLendingPoolConfiguratorImpl"},{"location":"architecture/contracts/generated/solidity-api/#getlendingpoolcollateralmanager","text":"function getLendingPoolCollateralManager () external view returns ( address )","title":"getLendingPoolCollateralManager"},{"location":"architecture/contracts/generated/solidity-api/#setlendingpoolcollateralmanager","text":"function setLendingPoolCollateralManager ( address manager ) external","title":"setLendingPoolCollateralManager"},{"location":"architecture/contracts/generated/solidity-api/#getpooladmin","text":"function getPoolAdmin () external view returns ( address )","title":"getPoolAdmin"},{"location":"architecture/contracts/generated/solidity-api/#setpooladmin","text":"function setPoolAdmin ( address admin ) external","title":"setPoolAdmin"},{"location":"architecture/contracts/generated/solidity-api/#getemergencyadmin","text":"function getEmergencyAdmin () external view returns ( address )","title":"getEmergencyAdmin"},{"location":"architecture/contracts/generated/solidity-api/#setemergencyadmin","text":"function setEmergencyAdmin ( address admin ) external","title":"setEmergencyAdmin"},{"location":"architecture/contracts/generated/solidity-api/#getpriceoracle","text":"function getPriceOracle () external view returns ( address )","title":"getPriceOracle"},{"location":"architecture/contracts/generated/solidity-api/#setpriceoracle","text":"function setPriceOracle ( address priceOracle ) external","title":"setPriceOracle"},{"location":"architecture/contracts/generated/solidity-api/#getlendingrateoracle","text":"function getLendingRateOracle () external view returns ( address )","title":"getLendingRateOracle"},{"location":"architecture/contracts/generated/solidity-api/#setlendingrateoracle","text":"function setLendingRateOracle ( address lendingRateOracle ) external","title":"setLendingRateOracle"},{"location":"architecture/contracts/generated/solidity-api/#ilendingpool","text":"","title":"ILendingPool"},{"location":"architecture/contracts/generated/solidity-api/#deposit_1","text":"event Deposit ( address reserve , address user , address onBehalfOf , uint256 amount , uint16 referral ) Emitted on deposit() Name Type Description reserve address The address of the underlying asset of the reserve user address The address initiating the deposit onBehalfOf address The beneficiary of the deposit, receiving the aTokens amount uint256 The amount deposited referral uint16 The referral code used","title":"Deposit"},{"location":"architecture/contracts/generated/solidity-api/#withdraw","text":"event Withdraw ( address reserve , address user , address to , uint256 amount ) Emitted on withdraw() Name Type Description reserve address The address of the underlyng asset being withdrawn user address The address initiating the withdrawal, owner of aTokens to address Address that will receive the underlying amount uint256 The amount to be withdrawn","title":"Withdraw"},{"location":"architecture/contracts/generated/solidity-api/#borrow_1","text":"event Borrow ( address reserve , address user , address onBehalfOf , uint256 amount , uint256 borrowRateMode , uint256 borrowRate , uint16 referral ) Emitted on borrow() and flashLoan() when debt needs to be opened Name Type Description reserve address The address of the underlying asset being borrowed user address The address of the user initiating the borrow(), receiving the funds on borrow() or just initiator of the transaction on flashLoan() onBehalfOf address The address that will be getting the debt amount uint256 The amount borrowed out borrowRateMode uint256 The rate mode: 1 for Stable, 2 for Variable borrowRate uint256 The numeric rate at which the user has borrowed referral uint16 The referral code used","title":"Borrow"},{"location":"architecture/contracts/generated/solidity-api/#repay_1","text":"event Repay ( address reserve , address user , address repayer , uint256 amount ) Emitted on repay() Name Type Description reserve address The address of the underlying asset of the reserve user address The beneficiary of the repayment, getting his debt reduced repayer address The address of the user initiating the repay(), providing the funds amount uint256 The amount repaid","title":"Repay"},{"location":"architecture/contracts/generated/solidity-api/#swap","text":"event Swap ( address reserve , address user , uint256 rateMode ) Emitted on swapBorrowRateMode() Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user swapping his rate mode rateMode uint256 The rate mode that the user wants to swap to","title":"Swap"},{"location":"architecture/contracts/generated/solidity-api/#reserveusedascollateralenabled","text":"event ReserveUsedAsCollateralEnabled ( address reserve , address user ) Emitted on setUserUseReserveAsCollateral() Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user enabling the usage as collateral","title":"ReserveUsedAsCollateralEnabled"},{"location":"architecture/contracts/generated/solidity-api/#reserveusedascollateraldisabled","text":"event ReserveUsedAsCollateralDisabled ( address reserve , address user ) Emitted on setUserUseReserveAsCollateral() Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user enabling the usage as collateral","title":"ReserveUsedAsCollateralDisabled"},{"location":"architecture/contracts/generated/solidity-api/#rebalancestableborrowrate","text":"event RebalanceStableBorrowRate ( address reserve , address user ) Emitted on rebalanceStableBorrowRate() Name Type Description reserve address The address of the underlying asset of the reserve user address The address of the user for which the rebalance has been executed","title":"RebalanceStableBorrowRate"},{"location":"architecture/contracts/generated/solidity-api/#flashloan","text":"event FlashLoan ( address target , address initiator , address asset , uint256 amount , uint256 premium , uint16 referralCode ) Emitted on flashLoan() Name Type Description target address The address of the flash loan receiver contract initiator address The address initiating the flash loan asset address The address of the asset being flash borrowed amount uint256 The amount flash borrowed premium uint256 The fee flash borrowed referralCode uint16 The referral code used","title":"FlashLoan"},{"location":"architecture/contracts/generated/solidity-api/#paused","text":"event Paused () Emitted when the pause is triggered.","title":"Paused"},{"location":"architecture/contracts/generated/solidity-api/#unpaused","text":"event Unpaused () Emitted when the pause is lifted.","title":"Unpaused"},{"location":"architecture/contracts/generated/solidity-api/#liquidationcall","text":"event LiquidationCall ( address collateralAsset , address debtAsset , address user , uint256 debtToCover , uint256 liquidatedCollateralAmount , address liquidator , bool receiveAToken ) Emitted when a borrower is liquidated. This event is emitted by the LendingPool via LendingPoolCollateral manager using a DELEGATECALL This allows to have the events in the generated ABI for LendingPool. Name Type Description collateralAsset address The address of the underlying asset used as collateral, to receive as result of the liquidation debtAsset address The address of the underlying borrowed asset to be repaid with the liquidation user address The address of the borrower getting liquidated debtToCover uint256 The debt amount of borrowed asset the liquidator wants to cover liquidatedCollateralAmount uint256 The amount of collateral received by the liiquidator liquidator address The address of the liquidator receiveAToken bool true if the liquidators wants to receive the collateral aTokens, false if he wants to receive the underlying collateral asset directly","title":"LiquidationCall"},{"location":"architecture/contracts/generated/solidity-api/#reservedataupdated","text":"event ReserveDataUpdated ( address reserve , uint256 liquidityRate , uint256 stableBorrowRate , uint256 variableBorrowRate , uint256 liquidityIndex , uint256 variableBorrowIndex ) Emitted when the state of a reserve is updated. NOTE: This event is actually declared in the ReserveLogic library and emitted in the updateInterestRates() function. Since the function is internal, the event will actually be fired by the LendingPool contract. The event is therefore replicated here so it gets added to the LendingPool ABI Name Type Description reserve address The address of the underlying asset of the reserve liquidityRate uint256 The new liquidity rate stableBorrowRate uint256 The new stable borrow rate variableBorrowRate uint256 The new variable borrow rate liquidityIndex uint256 The new liquidity index variableBorrowIndex uint256 The new variable borrow index","title":"ReserveDataUpdated"},{"location":"architecture/contracts/generated/solidity-api/#deposit_2","text":"function deposit ( address asset , uint256 amount , address onBehalfOf , uint16 referralCode ) external Deposits an amount of underlying asset into the reserve, receiving in return overlying aTokens. - E.g. User deposits 100 USDC and gets in return 100 aUSDC Name Type Description asset address The address of the underlying asset to deposit amount uint256 The amount to be deposited onBehalfOf address The address that will receive the aTokens, same as msg.sender if the user wants to receive them on his own wallet, or a different address if the beneficiary of aTokens is a different wallet referralCode uint16 Code used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-man","title":"deposit"},{"location":"architecture/contracts/generated/solidity-api/#withdraw_1","text":"function withdraw ( address asset , uint256 amount , address to ) external returns ( uint256 ) Withdraws an amount of underlying asset from the reserve, burning the equivalent aTokens owned E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC Name Type Description asset address The address of the underlying asset to withdraw amount uint256 The underlying amount to be withdrawn - Send the value type(uint256).max in order to withdraw the whole aToken balance to address Address that will receive the underlying, same as msg.sender if the user wants to receive it on his own wallet, or a different address if the beneficiary is a different wallet Name Type Description [0] uint256 The final amount withdrawn","title":"withdraw"},{"location":"architecture/contracts/generated/solidity-api/#borrow_2","text":"function borrow ( address asset , uint256 amount , uint256 interestRateMode , uint16 referralCode , address onBehalfOf ) external Allows users to borrow a specific amount of the reserve underlying asset, provided that the borrower already deposited enough collateral, or he was given enough allowance by a credit delegator on the corresponding debt token (StableDebtToken or VariableDebtToken) - E.g. User borrows 100 USDC passing as onBehalfOf his own address, receiving the 100 USDC in his wallet and 100 stable/variable debt tokens, depending on the interestRateMode Name Type Description asset address The address of the underlying asset to borrow amount uint256 The amount to be borrowed interestRateMode uint256 The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable referralCode uint16 Code used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-man onBehalfOf address Address of the user who will receive the debt. Should be the address of the borrower itself calling the function if he wants to borrow against his own collateral, or the address of the credit delegator if he has been given credit delegation allowance","title":"borrow"},{"location":"architecture/contracts/generated/solidity-api/#repay_2","text":"function repay ( address asset , uint256 amount , uint256 rateMode , address onBehalfOf ) external returns ( uint256 ) Repays a borrowed amount on a specific reserve, burning the equivalent debt tokens owned - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the onBehalfOf address Name Type Description asset address The address of the borrowed underlying asset previously borrowed amount uint256 The amount to repay - Send the value type(uint256).max in order to repay the whole debt for asset on the specific debtMode rateMode uint256 The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable onBehalfOf address Address of the user who will get his debt reduced/removed. Should be the address of the user calling the function if he wants to reduce/remove his own debt, or the address of any other other borrower whose debt should be removed Name Type Description [0] uint256 The final amount repaid","title":"repay"},{"location":"architecture/contracts/generated/solidity-api/#swapborrowratemode","text":"function swapBorrowRateMode ( address asset , uint256 rateMode ) external Allows a borrower to swap his debt between stable and variable mode, or viceversa Name Type Description asset address The address of the underlying asset borrowed rateMode uint256 The rate mode that the user wants to swap to","title":"swapBorrowRateMode"},{"location":"architecture/contracts/generated/solidity-api/#rebalancestableborrowrate_1","text":"function rebalanceStableBorrowRate ( address asset , address user ) external Rebalances the stable interest rate of a user to the current stable rate defined on the reserve. - Users can be rebalanced if the following conditions are satisfied: 1. Usage ratio is above 95% 2. the current deposit APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too much has been borrowed at a stable rate and depositors are not earning enough Name Type Description asset address The address of the underlying asset borrowed user address The address of the user to be rebalanced","title":"rebalanceStableBorrowRate"},{"location":"architecture/contracts/generated/solidity-api/#setuserusereserveascollateral","text":"function setUserUseReserveAsCollateral ( address asset , bool useAsCollateral ) external Allows depositors to enable/disable a specific deposited asset as collateral Name Type Description asset address The address of the underlying asset deposited useAsCollateral bool true if the user wants to use the deposit as collateral, false otherwise","title":"setUserUseReserveAsCollateral"},{"location":"architecture/contracts/generated/solidity-api/#liquidationcall_1","text":"function liquidationCall ( address collateralAsset , address debtAsset , address user , uint256 debtToCover , bool receiveAToken ) external Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1 - The caller (liquidator) covers debtToCover amount of debt of the user getting liquidated, and receives a proportionally amount of the collateralAsset plus a bonus to cover market risk Name Type Description collateralAsset address The address of the underlying asset used as collateral, to receive as result of the liquidation debtAsset address The address of the underlying borrowed asset to be repaid with the liquidation user address The address of the borrower getting liquidated debtToCover uint256 The debt amount of borrowed asset the liquidator wants to cover receiveAToken bool true if the liquidators wants to receive the collateral aTokens, false if he wants to receive the underlying collateral asset directly","title":"liquidationCall"},{"location":"architecture/contracts/generated/solidity-api/#flashloan_1","text":"function flashLoan ( address receiverAddress , address [] assets , uint256 [] amounts , uint256 [] modes , address onBehalfOf , bytes params , uint16 referralCode ) external Allows smartcontracts to access the liquidity of the pool within one transaction, as long as the amount taken plus a fee is returned. IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept into consideration. For further details please visit https://developers.aave.com Name Type Description receiverAddress address The address of the contract receiving the funds, implementing the IFlashLoanReceiver interface assets address[] The addresses of the assets being flash-borrowed amounts uint256[] The amounts amounts being flash-borrowed modes uint256[] Types of the debt to open if the flash loan is not returned: 0 -> Don't open any debt, just revert if funds can't be transferred from the receiver 1 -> Open debt at stable rate for the value of the amount flash-borrowed to the onBehalfOf address 2 -> Open debt at variable rate for the value of the amount flash-borrowed to the onBehalfOf address onBehalfOf address The address that will receive the debt in the case of using on modes 1 or 2 params bytes Variadic packed params to pass to the receiver as extra information referralCode uint16 Code used to register the integrator originating the operation, for potential rewards. 0 if the action is executed directly by the user, without any middle-man","title":"flashLoan"},{"location":"architecture/contracts/generated/solidity-api/#getuseraccountdata","text":"function getUserAccountData ( address user ) external view returns ( uint256 totalCollateralETH , uint256 totalDebtETH , uint256 availableBorrowsETH , uint256 currentLiquidationThreshold , uint256 ltv , uint256 healthFactor ) Returns the user account data across all the reserves Name Type Description user address The address of the user Name Type Description totalCollateralETH uint256 the total collateral in ETH of the user totalDebtETH uint256 the total debt in ETH of the user availableBorrowsETH uint256 the borrowing power left of the user currentLiquidationThreshold uint256 the liquidation threshold of the user ltv uint256 the loan to value of the user healthFactor uint256 the current health factor of the user","title":"getUserAccountData"},{"location":"architecture/contracts/generated/solidity-api/#initreserve","text":"function initReserve ( address reserve , address aTokenAddress , address stableDebtAddress , address variableDebtAddress , address interestRateStrategyAddress ) external","title":"initReserve"},{"location":"architecture/contracts/generated/solidity-api/#setreserveinterestratestrategyaddress","text":"function setReserveInterestRateStrategyAddress ( address reserve , address rateStrategyAddress ) external","title":"setReserveInterestRateStrategyAddress"},{"location":"architecture/contracts/generated/solidity-api/#setconfiguration","text":"function setConfiguration ( address reserve , uint256 configuration ) external","title":"setConfiguration"},{"location":"architecture/contracts/generated/solidity-api/#getconfiguration","text":"function getConfiguration ( address asset ) external view returns ( struct DataTypes . ReserveConfigurationMap ) Returns the configuration of the reserve Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] struct DataTypes.ReserveConfigurationMap The configuration of the reserve","title":"getConfiguration"},{"location":"architecture/contracts/generated/solidity-api/#getuserconfiguration","text":"function getUserConfiguration ( address user ) external view returns ( struct DataTypes . UserConfigurationMap ) Returns the configuration of the user across all the reserves Name Type Description user address The user address Name Type Description [0] struct DataTypes.UserConfigurationMap The configuration of the user","title":"getUserConfiguration"},{"location":"architecture/contracts/generated/solidity-api/#getreservenormalizedincome","text":"function getReserveNormalizedIncome ( address asset ) external view returns ( uint256 ) Returns the normalized income normalized income of the reserve Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] uint256 The reserve's normalized income","title":"getReserveNormalizedIncome"},{"location":"architecture/contracts/generated/solidity-api/#getreservenormalizedvariabledebt","text":"function getReserveNormalizedVariableDebt ( address asset ) external view returns ( uint256 ) Returns the normalized variable debt per unit of asset Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] uint256 The reserve normalized variable debt","title":"getReserveNormalizedVariableDebt"},{"location":"architecture/contracts/generated/solidity-api/#getreservedata_1","text":"function getReserveData ( address asset ) external view returns ( struct DataTypes . ReserveData ) Returns the state and configuration of the reserve Name Type Description asset address The address of the underlying asset of the reserve Name Type Description [0] struct DataTypes.ReserveData The state of the reserve","title":"getReserveData"},{"location":"architecture/contracts/generated/solidity-api/#finalizetransfer","text":"function finalizeTransfer ( address asset , address from , address to , uint256 amount , uint256 balanceFromAfter , uint256 balanceToBefore ) external","title":"finalizeTransfer"},{"location":"architecture/contracts/generated/solidity-api/#getreserveslist","text":"function getReservesList () external view returns ( address [])","title":"getReservesList"},{"location":"architecture/contracts/generated/solidity-api/#getaddressesprovider","text":"function getAddressesProvider () external view returns ( contract ILendingPoolAddressesProvider )","title":"getAddressesProvider"},{"location":"architecture/contracts/generated/solidity-api/#setpause","text":"function setPause ( bool val ) external","title":"setPause"},{"location":"architecture/contracts/generated/solidity-api/#paused_1","text":"function paused () external view returns ( bool )","title":"paused"},{"location":"architecture/contracts/generated/solidity-api/#istabledebttoken","text":"","title":"IStableDebtToken"},{"location":"architecture/contracts/generated/solidity-api/#mint_1","text":"event Mint ( address user , address onBehalfOf , uint256 amount , uint256 currentBalance , uint256 balanceIncrease , uint256 newRate , uint256 avgStableRate , uint256 newTotalSupply ) Emitted when new stable debt is minted Name Type Description user address The address of the user who triggered the minting onBehalfOf address The recipient of stable debt tokens amount uint256 The amount minted currentBalance uint256 The current balance of the user balanceIncrease uint256 The increase in balance since the last action of the user newRate uint256 The rate of the debt after the minting avgStableRate uint256 The new average stable rate after the minting newTotalSupply uint256 The new total supply of the stable debt token after the action","title":"Mint"},{"location":"architecture/contracts/generated/solidity-api/#burn","text":"event Burn ( address user , uint256 amount , uint256 currentBalance , uint256 balanceIncrease , uint256 avgStableRate , uint256 newTotalSupply ) Emitted when new stable debt is burned Name Type Description user address The address of the user amount uint256 The amount being burned currentBalance uint256 The current balance of the user balanceIncrease uint256 The the increase in balance since the last action of the user avgStableRate uint256 The new average stable rate after the burning newTotalSupply uint256 The new total supply of the stable debt token after the action","title":"Burn"},{"location":"architecture/contracts/generated/solidity-api/#approvedelegation","text":"function approveDelegation ( address delegatee , uint256 amount ) external delegates borrowing power to a user on the specific debt token Name Type Description delegatee address the address receiving the delegated borrowing power amount uint256 the maximum amount being delegated. Delegation will still respect the liquidation constraints (even if delegated, a delegatee cannot force a delegator HF to go below 1)","title":"approveDelegation"},{"location":"architecture/contracts/generated/solidity-api/#borrowallowance","text":"function borrowAllowance ( address fromUser , address toUser ) external view returns ( uint256 ) returns the borrow allowance of the user Name Type Description fromUser address The user to giving allowance toUser address The user to give allowance to Name Type Description [0] uint256 the current allowance of toUser","title":"borrowAllowance"},{"location":"architecture/contracts/generated/solidity-api/#mint_2","text":"function mint ( address user , address onBehalfOf , uint256 amount , uint256 rate ) external returns ( bool ) Mints debt token to the onBehalfOf address. - The resulting rate is the weighted average between the rate of the new debt and the rate of the previous debt Name Type Description user address The address receiving the borrowed underlying, being the delegatee in case of credit delegate, or same as onBehalfOf otherwise onBehalfOf address The address receiving the debt tokens amount uint256 The amount of debt tokens to mint rate uint256 The rate of the debt being minted","title":"mint"},{"location":"architecture/contracts/generated/solidity-api/#burn_1","text":"function burn ( address user , uint256 amount ) external Burns debt of user - The resulting rate is the weighted average between the rate of the new debt and the rate of the previous debt Name Type Description user address The address of the user getting his debt burned amount uint256 The amount of debt tokens getting burned","title":"burn"},{"location":"architecture/contracts/generated/solidity-api/#getaveragestablerate","text":"function getAverageStableRate () external view returns ( uint256 ) Returns the average rate of all the stable rate loans. Name Type Description [0] uint256 The average stable rate","title":"getAverageStableRate"},{"location":"architecture/contracts/generated/solidity-api/#getuserstablerate","text":"function getUserStableRate ( address user ) external view returns ( uint256 ) Returns the stable rate of the user debt Name Type Description [0] uint256 The stable rate of the user","title":"getUserStableRate"},{"location":"architecture/contracts/generated/solidity-api/#getuserlastupdated","text":"function getUserLastUpdated ( address user ) external view returns ( uint40 ) Returns the timestamp of the last update of the user Name Type Description [0] uint40 The timestamp","title":"getUserLastUpdated"},{"location":"architecture/contracts/generated/solidity-api/#getsupplydata","text":"function getSupplyData () external view returns ( uint256 , uint256 , uint256 , uint40 ) Returns the principal, the total supply and the average stable rate","title":"getSupplyData"},{"location":"architecture/contracts/generated/solidity-api/#gettotalsupplylastupdated","text":"function getTotalSupplyLastUpdated () external view returns ( uint40 ) Returns the timestamp of the last update of the total supply Name Type Description [0] uint40 The timestamp","title":"getTotalSupplyLastUpdated"},{"location":"architecture/contracts/generated/solidity-api/#gettotalsupplyandavgrate","text":"function getTotalSupplyAndAvgRate () external view returns ( uint256 , uint256 ) Returns the total supply and the average stable rate","title":"getTotalSupplyAndAvgRate"},{"location":"architecture/contracts/generated/solidity-api/#principalbalanceof","text":"function principalBalanceOf ( address user ) external view returns ( uint256 ) Returns the principal debt balance of the user Name Type Description [0] uint256 The debt balance of the user since the last burn/mint action","title":"principalBalanceOf"},{"location":"architecture/contracts/generated/solidity-api/#idynamicpricing","text":"","title":"IDynamicPricing"},{"location":"architecture/contracts/generated/solidity-api/#dynamicpricingstate","text":"enum DynamicPricingState { NotStarted , Finished , InProgress , Aborted }","title":"DynamicPricingState"},{"location":"architecture/contracts/generated/solidity-api/#getpricingtype","text":"function getPricingType () external view returns ( bytes32 )","title":"getPricingType"},{"location":"architecture/contracts/generated/solidity-api/#getprice","text":"function getPrice ( bytes32 did ) external view returns ( uint256 )","title":"getPrice"},{"location":"architecture/contracts/generated/solidity-api/#gettokenaddress","text":"function getTokenAddress ( bytes32 did ) external view returns ( address )","title":"getTokenAddress"},{"location":"architecture/contracts/generated/solidity-api/#getstatus","text":"function getStatus ( bytes32 did ) external view returns ( enum IDynamicPricing . DynamicPricingState , uint256 , address )","title":"getStatus"},{"location":"architecture/contracts/generated/solidity-api/#canbepurchased","text":"function canBePurchased ( bytes32 did ) external view returns ( bool )","title":"canBePurchased"},{"location":"architecture/contracts/generated/solidity-api/#withdraw_2","text":"function withdraw ( bytes32 did , address withdrawAddress ) external returns ( bool )","title":"withdraw"},{"location":"architecture/contracts/generated/solidity-api/#ilist","text":"","title":"IList"},{"location":"architecture/contracts/generated/solidity-api/#has_2","text":"function has ( bytes32 value ) external view returns ( bool )","title":"has"},{"location":"architecture/contracts/generated/solidity-api/#has_3","text":"function has ( bytes32 value , bytes32 id ) external view returns ( bool )","title":"has"},{"location":"architecture/contracts/generated/solidity-api/#iroyaltyscheme","text":"","title":"IRoyaltyScheme"},{"location":"architecture/contracts/generated/solidity-api/#check","text":"function check ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _tokenAddress ) external view returns ( bool ) check that royalties are correct Name Type Description _did bytes32 compute royalties for this DID _amounts uint256[] amounts in payment _receivers address[] receivers of payments _tokenAddress address payment token. zero address means native token (ether)","title":"check"},{"location":"architecture/contracts/generated/solidity-api/#isecretstore","text":"","title":"ISecretStore"},{"location":"architecture/contracts/generated/solidity-api/#checkpermissions_2","text":"function checkPermissions ( address user , bytes32 documentKeyId ) external view returns ( bool permissionGranted ) checkPermissions is called by Parity secret store","title":"checkPermissions"},{"location":"architecture/contracts/generated/solidity-api/#isecretstorepermission","text":"","title":"ISecretStorePermission"},{"location":"architecture/contracts/generated/solidity-api/#grantpermission_2","text":"function grantPermission ( address user , bytes32 documentKeyId ) external grantPermission is called only by documentKeyId Owner or provider","title":"grantPermission"},{"location":"architecture/contracts/generated/solidity-api/#renouncepermission_1","text":"function renouncePermission ( address user , bytes32 documentKeyId ) external renouncePermission is called only by documentKeyId Owner or provider","title":"renouncePermission"},{"location":"architecture/contracts/generated/solidity-api/#iwethgateway","text":"","title":"IWETHGateway"},{"location":"architecture/contracts/generated/solidity-api/#depositeth","text":"function depositETH ( address lendingPool , address onBehalfOf , uint16 referralCode ) external payable","title":"depositETH"},{"location":"architecture/contracts/generated/solidity-api/#withdraweth","text":"function withdrawETH ( address lendingPool , uint256 amount , address to ) external","title":"withdrawETH"},{"location":"architecture/contracts/generated/solidity-api/#repayeth","text":"function repayETH ( address lendingPool , uint256 amount , uint256 rateMode , address onBehalfOf ) external payable","title":"repayETH"},{"location":"architecture/contracts/generated/solidity-api/#borroweth","text":"function borrowETH ( address lendingPool , uint256 amount , uint256 interesRateMode , uint16 referralCode ) external","title":"borrowETH"},{"location":"architecture/contracts/generated/solidity-api/#datatypes","text":"","title":"DataTypes"},{"location":"architecture/contracts/generated/solidity-api/#reservedata","text":"struct ReserveData { struct DataTypes . ReserveConfigurationMap configuration ; uint128 liquidityIndex ; uint128 variableBorrowIndex ; uint128 currentLiquidityRate ; uint128 currentVariableBorrowRate ; uint128 currentStableBorrowRate ; uint40 lastUpdateTimestamp ; address aTokenAddress ; address stableDebtTokenAddress ; address variableDebtTokenAddress ; address interestRateStrategyAddress ; uint8 id ; }","title":"ReserveData"},{"location":"architecture/contracts/generated/solidity-api/#reserveconfigurationmap","text":"struct ReserveConfigurationMap { uint256 data ; }","title":"ReserveConfigurationMap"},{"location":"architecture/contracts/generated/solidity-api/#userconfigurationmap","text":"struct UserConfigurationMap { uint256 data ; }","title":"UserConfigurationMap"},{"location":"architecture/contracts/generated/solidity-api/#interestratemode","text":"enum InterestRateMode { NONE , STABLE , VARIABLE }","title":"InterestRateMode"},{"location":"architecture/contracts/generated/solidity-api/#safemath","text":"","title":"SafeMath"},{"location":"architecture/contracts/generated/solidity-api/#add_2","text":"function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the addition of two unsigned integers, reverting on overflow. Counterpart to Solidity's + operator. Requirements: - Addition cannot overflow._","title":"add"},{"location":"architecture/contracts/generated/solidity-api/#sub","text":"function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the subtraction of two unsigned integers, reverting on overflow (when the result is negative). Counterpart to Solidity's - operator. Requirements: - Subtraction cannot overflow._","title":"sub"},{"location":"architecture/contracts/generated/solidity-api/#sub_1","text":"function sub ( uint256 a , uint256 b , string errorMessage ) internal pure returns ( uint256 ) _Returns the subtraction of two unsigned integers, reverting with custom message on overflow (when the result is negative). Counterpart to Solidity's - operator. Requirements: - Subtraction cannot overflow._","title":"sub"},{"location":"architecture/contracts/generated/solidity-api/#mul","text":"function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the multiplication of two unsigned integers, reverting on overflow. Counterpart to Solidity's * operator. Requirements: - Multiplication cannot overflow._","title":"mul"},{"location":"architecture/contracts/generated/solidity-api/#div","text":"function div ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the integer division of two unsigned integers. Reverts on division by zero. The result is rounded towards zero. Counterpart to Solidity's / operator. Note: this function uses a revert opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas). Requirements: - The divisor cannot be zero._","title":"div"},{"location":"architecture/contracts/generated/solidity-api/#div_1","text":"function div ( uint256 a , uint256 b , string errorMessage ) internal pure returns ( uint256 ) _Returns the integer division of two unsigned integers. Reverts with custom message on division by zero. The result is rounded towards zero. Counterpart to Solidity's / operator. Note: this function uses a revert opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas). Requirements: - The divisor cannot be zero._","title":"div"},{"location":"architecture/contracts/generated/solidity-api/#mod","text":"function mod ( uint256 a , uint256 b ) internal pure returns ( uint256 ) _Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), Reverts when dividing by zero. Counterpart to Solidity's % operator. This function uses a revert opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas). Requirements: - The divisor cannot be zero._","title":"mod"},{"location":"architecture/contracts/generated/solidity-api/#mod_1","text":"function mod ( uint256 a , uint256 b , string errorMessage ) internal pure returns ( uint256 ) _Returns the remainder of dividing two unsigned integers. (unsigned integer modulo), Reverts with custom message when dividing by zero. Counterpart to Solidity's % operator. This function uses a revert opcode (which leaves remaining gas untouched) while Solidity uses an invalid opcode to revert (consuming all remaining gas). Requirements: - The divisor cannot be zero._","title":"mod"},{"location":"architecture/contracts/generated/solidity-api/#address","text":"","title":"Address"},{"location":"architecture/contracts/generated/solidity-api/#iscontract_1","text":"function isContract ( address account ) internal view returns ( bool ) _Returns true if account is a contract.","title":"isContract"},{"location":"architecture/contracts/generated/solidity-api/#important","text":"It is unsafe to assume that an address for which this function returns false is an externally-owned account (EOA) and not a contract. Among others, isContract will return false for the following types of addresses: an externally-owned account a contract in construction an address where a contract will be created an address where a contract lived, but was destroyed ====_","title":"[IMPORTANT]"},{"location":"architecture/contracts/generated/solidity-api/#sendvalue","text":"function sendValue ( address payable recipient , uint256 amount ) internal _Replacement for Solidity's transfer : sends amount wei to recipient , forwarding all available gas and reverting on errors. https://eips.ethereum.org/EIPS/eip-1884[EIP1884 ] increases the gas cost of certain opcodes, possibly making contracts go over the 2300 gas limit imposed by transfer , making them unable to receive funds via transfer . {sendValue} removes this limitation. https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more]. IMPORTANT: because control is transferred to recipient , care must be taken to not create reentrancy vulnerabilities. Consider using {ReentrancyGuard} or the https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern]._","title":"sendValue"},{"location":"architecture/contracts/generated/solidity-api/#safeerc20","text":"Wrappers around ERC20 operations that throw on failure (when the token contract returns false). Tokens that return no value (and instead revert or throw on failure) are also supported, non-reverting calls are assumed to be successful. To use this library you can add a using SafeERC20 for IERC20; statement to your contract, which allows you to call the safe operations as token.safeTransfer(...) , etc.","title":"SafeERC20"},{"location":"architecture/contracts/generated/solidity-api/#safetransfer","text":"function safeTransfer ( contract IERC20 token , address to , uint256 value ) internal","title":"safeTransfer"},{"location":"architecture/contracts/generated/solidity-api/#safetransferfrom","text":"function safeTransferFrom ( contract IERC20 token , address from , address to , uint256 value ) internal","title":"safeTransferFrom"},{"location":"architecture/contracts/generated/solidity-api/#safeapprove","text":"function safeApprove ( contract IERC20 token , address spender , uint256 value ) internal","title":"safeApprove"},{"location":"architecture/contracts/generated/solidity-api/#calloptionalreturn","text":"function callOptionalReturn ( contract IERC20 token , bytes data ) private","title":"callOptionalReturn"},{"location":"architecture/contracts/generated/solidity-api/#clonefactory","text":"","title":"CloneFactory"},{"location":"architecture/contracts/generated/solidity-api/#createclone","text":"function createClone ( address target ) internal returns ( address result )","title":"createClone"},{"location":"architecture/contracts/generated/solidity-api/#isclone","text":"function isClone ( address target , address query ) internal view returns ( bool result )","title":"isClone"},{"location":"architecture/contracts/generated/solidity-api/#epochlibrary","text":"Implementation of Epoch Library. For an arbitrary Epoch, this library manages the life cycle of an Epoch. Usually this library is used for handling the time window between conditions in an agreement.","title":"EpochLibrary"},{"location":"architecture/contracts/generated/solidity-api/#epoch","text":"struct Epoch { uint256 timeLock ; uint256 timeOut ; uint256 blockNumber ; }","title":"Epoch"},{"location":"architecture/contracts/generated/solidity-api/#epochlist_1","text":"struct EpochList { mapping ( bytes32 &# x3D ; & gt ; struct EpochLibrary . Epoch ) epochs ; bytes32 [] epochIds ; }","title":"EpochList"},{"location":"architecture/contracts/generated/solidity-api/#create_2","text":"function create ( struct EpochLibrary . EpochList _self , bytes32 _id , uint256 _timeLock , uint256 _timeOut ) internal create creates new Epoch Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 _timeLock uint256 value in block count (can not fulfill before) _timeOut uint256 value in block count (can not fulfill after)","title":"create"},{"location":"architecture/contracts/generated/solidity-api/#istimedout","text":"function isTimedOut ( struct EpochLibrary . EpochList _self , bytes32 _id ) external view returns ( bool ) isTimedOut means you cannot fulfill after Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 Name Type Description [0] bool true if the current block number is gt timeOut","title":"isTimedOut"},{"location":"architecture/contracts/generated/solidity-api/#istimelocked","text":"function isTimeLocked ( struct EpochLibrary . EpochList _self , bytes32 _id ) external view returns ( bool ) isTimeLocked means you cannot fulfill before Name Type Description _self struct EpochLibrary.EpochList is the Epoch storage pointer _id bytes32 Name Type Description [0] bool true if the current block number is gt timeLock","title":"isTimeLocked"},{"location":"architecture/contracts/generated/solidity-api/#getepochtimeout","text":"function getEpochTimeOut ( struct EpochLibrary . Epoch _self ) public view returns ( uint256 ) getEpochTimeOut Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer","title":"getEpochTimeOut"},{"location":"architecture/contracts/generated/solidity-api/#getepochtimelock","text":"function getEpochTimeLock ( struct EpochLibrary . Epoch _self ) public view returns ( uint256 ) getEpochTimeLock Name Type Description _self struct EpochLibrary.Epoch is the Epoch storage pointer","title":"getEpochTimeLock"},{"location":"architecture/contracts/generated/solidity-api/#hashlistlibrary","text":"Implementation of the basic functionality of list of hash values. This library allows other contracts to build and maintain lists and also preserves the privacy of the data by accepting only hashed content (bytes32 based data type)","title":"HashListLibrary"},{"location":"architecture/contracts/generated/solidity-api/#list","text":"struct List { address _owner ; bytes32 [] values ; mapping ( bytes32 &# x3D ; & gt ; uint256 ) indices ; }","title":"List"},{"location":"architecture/contracts/generated/solidity-api/#onlylistowner","text":"modifier onlyListOwner ( struct HashListLibrary . List _self )","title":"onlyListOwner"},{"location":"architecture/contracts/generated/solidity-api/#add_3","text":"function add ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) add index an element then add it to a list Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is a bytes32 value Name Type Description [0] bool true if value is added successfully","title":"add"},{"location":"architecture/contracts/generated/solidity-api/#add_4","text":"function add ( struct HashListLibrary . List _self , bytes32 [] values ) public returns ( bool ) put an array of elements without indexing this meant to save gas in case of large arrays Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage values bytes32[] is an array of elements value Name Type Description [0] bool true if values are added successfully","title":"add"},{"location":"architecture/contracts/generated/solidity-api/#update_1","text":"function update ( struct HashListLibrary . List _self , bytes32 oldValue , bytes32 newValue ) public returns ( bool ) update the value with a new value and maintain indices Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage oldValue bytes32 is an element value in a list newValue bytes32 new value Name Type Description [0] bool true if value is updated successfully","title":"update"},{"location":"architecture/contracts/generated/solidity-api/#remove_1","text":"function remove ( struct HashListLibrary . List _self , bytes32 value ) public returns ( bool ) remove value from a list, updates indices, and list size Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is an element value in a list Name Type Description [0] bool true if value is removed successfully","title":"remove"},{"location":"architecture/contracts/generated/solidity-api/#get_1","text":"function get ( struct HashListLibrary . List _self , uint256 __index ) public view returns ( bytes32 ) has value by index Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage __index uint256 is where is value is stored in the list Name Type Description [0] bytes32 the value if exists","title":"get"},{"location":"architecture/contracts/generated/solidity-api/#index_1","text":"function index ( struct HashListLibrary . List _self , uint256 from , uint256 to ) public returns ( bool ) index is used to map each element value to its index on the list Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage from uint256 index is where to 'from' indexing in the list to uint256 index is where to stop indexing Name Type Description [0] bool true if the sub list is indexed","title":"index"},{"location":"architecture/contracts/generated/solidity-api/#setowner","text":"function setOwner ( struct HashListLibrary . List _self , address _owner ) public setOwner set list owner param _owner owner address","title":"setOwner"},{"location":"architecture/contracts/generated/solidity-api/#indexof_1","text":"function indexOf ( struct HashListLibrary . List _self , bytes32 value ) public view returns ( uint256 ) indexOf gets the index of a value in a list Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list Name Type Description [0] uint256 value index in list","title":"indexOf"},{"location":"architecture/contracts/generated/solidity-api/#isindexed_1","text":"function isIndexed ( struct HashListLibrary . List _self ) public view returns ( bool ) isIndexed checks if the list is indexed Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] bool true if the list is indexed","title":"isIndexed"},{"location":"architecture/contracts/generated/solidity-api/#all_1","text":"function all ( struct HashListLibrary . List _self ) public view returns ( bytes32 []) all returns all list elements Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] bytes32[] all list elements","title":"all"},{"location":"architecture/contracts/generated/solidity-api/#has_4","text":"function has ( struct HashListLibrary . List _self , bytes32 value ) public view returns ( bool ) size returns the list size Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage value bytes32 is element value in list Name Type Description [0] bool true if the value exists","title":"has"},{"location":"architecture/contracts/generated/solidity-api/#size_1","text":"function size ( struct HashListLibrary . List _self ) public view returns ( uint256 ) size gets the list size Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] uint256 total length of the list","title":"size"},{"location":"architecture/contracts/generated/solidity-api/#ownedby_1","text":"function ownedBy ( struct HashListLibrary . List _self ) public view returns ( address ) ownedBy gets the list owner Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage Name Type Description [0] address list owner","title":"ownedBy"},{"location":"architecture/contracts/generated/solidity-api/#_index","text":"function _index ( struct HashListLibrary . List _self , uint256 from , uint256 to ) private returns ( bool ) __index assign index to the list elements_ Name Type Description _self struct HashListLibrary.List is a pointer to list in the storage from uint256 is the starting index id to uint256 is the ending index id","title":"_index"},{"location":"architecture/contracts/generated/solidity-api/#abstractauction","text":"","title":"AbstractAuction"},{"location":"architecture/contracts/generated/solidity-api/#auction_manager_role","text":"bytes32 AUCTION_MANAGER_ROLE","title":"AUCTION_MANAGER_ROLE"},{"location":"architecture/contracts/generated/solidity-api/#nvm_agreement_role","text":"bytes32 NVM_AGREEMENT_ROLE","title":"NVM_AGREEMENT_ROLE"},{"location":"architecture/contracts/generated/solidity-api/#auction","text":"struct Auction { bytes32 did ; enum IDynamicPricing . DynamicPricingState state ; address creator ; uint256 blockNumberCreated ; uint256 floor ; uint256 starts ; uint256 ends ; uint256 price ; address tokenAddress ; address whoCanClaim ; string hash ; }","title":"Auction"},{"location":"architecture/contracts/generated/solidity-api/#auctions","text":"mapping ( bytes32 => struct AbstractAuction . Auction ) auctions","title":"auctions"},{"location":"architecture/contracts/generated/solidity-api/#auctionbids","text":"mapping ( bytes32 => mapping ( address => uint256 )) auctionBids","title":"auctionBids"},{"location":"architecture/contracts/generated/solidity-api/#auctioncreated","text":"event AuctionCreated ( bytes32 auctionId , bytes32 did , address creator , uint256 blockNumberCreated , uint256 floor , uint256 starts , uint256 ends , address tokenAddress )","title":"AuctionCreated"},{"location":"architecture/contracts/generated/solidity-api/#auctionchangedstate","text":"event AuctionChangedState ( bytes32 auctionId , address who , enum IDynamicPricing . DynamicPricingState previousState , enum IDynamicPricing . DynamicPricingState newState )","title":"AuctionChangedState"},{"location":"architecture/contracts/generated/solidity-api/#auctionbidreceived","text":"event AuctionBidReceived ( bytes32 auctionId , address bidder , address tokenAddress , uint256 amount )","title":"AuctionBidReceived"},{"location":"architecture/contracts/generated/solidity-api/#auctionwithdrawal","text":"event AuctionWithdrawal ( bytes32 auctionId , address receiver , address tokenAddress , uint256 amount )","title":"AuctionWithdrawal"},{"location":"architecture/contracts/generated/solidity-api/#receive_3","text":"receive () external payable","title":"receive"},{"location":"architecture/contracts/generated/solidity-api/#abortauction","text":"function abortAuction ( bytes32 _auctionId ) external virtual","title":"abortAuction"},{"location":"architecture/contracts/generated/solidity-api/#withdraw_3","text":"function withdraw ( bytes32 _auctionId , address _withdrawAddress ) external virtual returns ( bool )","title":"withdraw"},{"location":"architecture/contracts/generated/solidity-api/#getpricingtype_1","text":"function getPricingType () external pure virtual returns ( bytes32 )","title":"getPricingType"},{"location":"architecture/contracts/generated/solidity-api/#getprice_1","text":"function getPrice ( bytes32 _auctionId ) external view returns ( uint256 )","title":"getPrice"},{"location":"architecture/contracts/generated/solidity-api/#gettokenaddress_1","text":"function getTokenAddress ( bytes32 _auctionId ) external view returns ( address )","title":"getTokenAddress"},{"location":"architecture/contracts/generated/solidity-api/#getstatus_1","text":"function getStatus ( bytes32 _auctionId ) external view returns ( enum IDynamicPricing . DynamicPricingState state , uint256 price , address whoCanClaim )","title":"getStatus"},{"location":"architecture/contracts/generated/solidity-api/#canbepurchased_1","text":"function canBePurchased ( bytes32 _auctionId ) external view virtual returns ( bool )","title":"canBePurchased"},{"location":"architecture/contracts/generated/solidity-api/#addnvmagreementrole","text":"function addNVMAgreementRole ( address account ) public","title":"addNVMAgreementRole"},{"location":"architecture/contracts/generated/solidity-api/#onlycreator","text":"modifier onlyCreator ( bytes32 _auctionId )","title":"onlyCreator"},{"location":"architecture/contracts/generated/solidity-api/#onlycreatororadmin","text":"modifier onlyCreatorOrAdmin ( bytes32 _auctionId )","title":"onlyCreatorOrAdmin"},{"location":"architecture/contracts/generated/solidity-api/#onlynotcreator","text":"modifier onlyNotCreator ( bytes32 _auctionId )","title":"onlyNotCreator"},{"location":"architecture/contracts/generated/solidity-api/#onlyafterstart","text":"modifier onlyAfterStart ( bytes32 _auctionId )","title":"onlyAfterStart"},{"location":"architecture/contracts/generated/solidity-api/#onlybeforestarts","text":"modifier onlyBeforeStarts ( bytes32 _auctionId )","title":"onlyBeforeStarts"},{"location":"architecture/contracts/generated/solidity-api/#onlybeforeend","text":"modifier onlyBeforeEnd ( bytes32 _auctionId )","title":"onlyBeforeEnd"},{"location":"architecture/contracts/generated/solidity-api/#onlynotabortedorfinished","text":"modifier onlyNotAbortedOrFinished ( bytes32 _auctionId )","title":"onlyNotAbortedOrFinished"},{"location":"architecture/contracts/generated/solidity-api/#onlyabortedorfinished","text":"modifier onlyAbortedOrFinished ( bytes32 _auctionId )","title":"onlyAbortedOrFinished"},{"location":"architecture/contracts/generated/solidity-api/#onlynotaborted","text":"modifier onlyNotAborted ( bytes32 _auctionId )","title":"onlyNotAborted"},{"location":"architecture/contracts/generated/solidity-api/#onlyfinishedoraborted","text":"modifier onlyFinishedOrAborted ( bytes32 _auctionId )","title":"onlyFinishedOrAborted"},{"location":"architecture/contracts/generated/solidity-api/#dutchauction","text":"","title":"DutchAuction"},{"location":"architecture/contracts/generated/solidity-api/#initialize_32","text":"function initialize ( address _owner ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#create_3","text":"function create ( bytes32 _auctionId , bytes32 _did , uint256 _startPrice , uint256 _starts , uint256 _ends , address _tokenAddress , string _hash ) external virtual It creates a new Auction given some setup parameters Name Type Description _auctionId bytes32 unique auction identifier _did bytes32 reference to the asset part of the auction _startPrice uint256 start price (and max) for the auction _starts uint256 block number when the auction starts _ends uint256 block number of when the auction ends _tokenAddress address token address to use for the auction. If address(0) means native token _hash string ipfs hash referring to the auction metadata","title":"create"},{"location":"architecture/contracts/generated/solidity-api/#placenativetokenbid","text":"function placeNativeTokenBid ( bytes32 _auctionId ) external payable virtual","title":"placeNativeTokenBid"},{"location":"architecture/contracts/generated/solidity-api/#placeerc20bid","text":"function placeERC20Bid ( bytes32 _auctionId , uint256 _bidAmount ) external virtual","title":"placeERC20Bid"},{"location":"architecture/contracts/generated/solidity-api/#withdraw_4","text":"function withdraw ( bytes32 _auctionId , address _withdrawAddress ) external virtual returns ( bool )","title":"withdraw"},{"location":"architecture/contracts/generated/solidity-api/#getpricingtype_2","text":"function getPricingType () external pure returns ( bytes32 )","title":"getPricingType"},{"location":"architecture/contracts/generated/solidity-api/#englishauction","text":"","title":"EnglishAuction"},{"location":"architecture/contracts/generated/solidity-api/#initialize_33","text":"function initialize ( address _owner ) external initialize init the contract with the following parameters Name Type Description _owner address contract's owner account address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#create_4","text":"function create ( bytes32 _auctionId , bytes32 _did , uint256 _floor , uint256 _starts , uint256 _ends , address _tokenAddress , string _hash ) external virtual It creates a new Auction given some setup parameters Name Type Description _auctionId bytes32 unique auction identifier _did bytes32 reference to the asset part of the auction _floor uint256 floor price _starts uint256 block number when the auction starts _ends uint256 block number of when the auction ends _tokenAddress address token address to use for the auction. If address(0) means native token _hash string ipfs hash referring to the auction metadata","title":"create"},{"location":"architecture/contracts/generated/solidity-api/#placenativetokenbid_1","text":"function placeNativeTokenBid ( bytes32 _auctionId ) external payable virtual","title":"placeNativeTokenBid"},{"location":"architecture/contracts/generated/solidity-api/#placeerc20bid_1","text":"function placeERC20Bid ( bytes32 _auctionId , uint256 _bidAmount ) external virtual","title":"placeERC20Bid"},{"location":"architecture/contracts/generated/solidity-api/#getpricingtype_3","text":"function getPricingType () external pure returns ( bytes32 )","title":"getPricingType"},{"location":"architecture/contracts/generated/solidity-api/#didfactory","text":"Implementation of the DID Registry.","title":"DIDFactory"},{"location":"architecture/contracts/generated/solidity-api/#didregisterlist","text":"struct DIDRegistryLibrary . DIDRegisterList didRegisterList state storage for the DID registry","title":"didRegisterList"},{"location":"architecture/contracts/generated/solidity-api/#didpermissions","text":"mapping ( bytes32 => mapping ( address => bool )) didPermissions","title":"didPermissions"},{"location":"architecture/contracts/generated/solidity-api/#manager","text":"address manager","title":"manager"},{"location":"architecture/contracts/generated/solidity-api/#onlydidowner","text":"modifier onlyDIDOwner ( bytes32 _did )","title":"onlyDIDOwner"},{"location":"architecture/contracts/generated/solidity-api/#onlymanager","text":"modifier onlyManager ()","title":"onlyManager"},{"location":"architecture/contracts/generated/solidity-api/#onlyownerproviderordelegated","text":"modifier onlyOwnerProviderOrDelegated ( bytes32 _did )","title":"onlyOwnerProviderOrDelegated"},{"location":"architecture/contracts/generated/solidity-api/#onlyvalidattributes","text":"modifier onlyValidAttributes ( string _attributes )","title":"onlyValidAttributes"},{"location":"architecture/contracts/generated/solidity-api/#nftisinitialized","text":"modifier nftIsInitialized ( bytes32 _did )","title":"nftIsInitialized"},{"location":"architecture/contracts/generated/solidity-api/#nft721isinitialized","text":"modifier nft721IsInitialized ( bytes32 _did )","title":"nft721IsInitialized"},{"location":"architecture/contracts/generated/solidity-api/#didattributeregistered","text":"event DIDAttributeRegistered ( bytes32 _did , address _owner , bytes32 _checksum , string _value , address _lastUpdatedBy , uint256 _blockNumberUpdated ) DID Events","title":"DIDAttributeRegistered"},{"location":"architecture/contracts/generated/solidity-api/#didproviderremoved","text":"event DIDProviderRemoved ( bytes32 _did , address _provider , bool state )","title":"DIDProviderRemoved"},{"location":"architecture/contracts/generated/solidity-api/#didprovideradded","text":"event DIDProviderAdded ( bytes32 _did , address _provider )","title":"DIDProviderAdded"},{"location":"architecture/contracts/generated/solidity-api/#didownershiptransferred","text":"event DIDOwnershipTransferred ( bytes32 _did , address _previousOwner , address _newOwner )","title":"DIDOwnershipTransferred"},{"location":"architecture/contracts/generated/solidity-api/#didpermissiongranted","text":"event DIDPermissionGranted ( bytes32 _did , address _owner , address _grantee )","title":"DIDPermissionGranted"},{"location":"architecture/contracts/generated/solidity-api/#didpermissionrevoked","text":"event DIDPermissionRevoked ( bytes32 _did , address _owner , address _grantee )","title":"DIDPermissionRevoked"},{"location":"architecture/contracts/generated/solidity-api/#didprovenancedelegateremoved","text":"event DIDProvenanceDelegateRemoved ( bytes32 _did , address _delegate , bool state )","title":"DIDProvenanceDelegateRemoved"},{"location":"architecture/contracts/generated/solidity-api/#didprovenancedelegateadded","text":"event DIDProvenanceDelegateAdded ( bytes32 _did , address _delegate )","title":"DIDProvenanceDelegateAdded"},{"location":"architecture/contracts/generated/solidity-api/#setmanager","text":"function setManager ( address _addr ) external Sets the manager role. Should be the TransferCondition contract address","title":"setManager"},{"location":"architecture/contracts/generated/solidity-api/#registerattribute","text":"function registerAttribute ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url ) public virtual Register DID attributes. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] _url string refers to the attribute value, limited to 2048 bytes.","title":"registerAttribute"},{"location":"architecture/contracts/generated/solidity-api/#registerdid","text":"function registerDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , bytes32 _activityId , string _attributes ) public virtual Register DID attributes. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). The final DID will be calculated with the creator address using the hashDID function _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _activityId bytes32 refers to activity _attributes string refers to the provenance attributes","title":"registerDID"},{"location":"architecture/contracts/generated/solidity-api/#hashdid","text":"function hashDID ( bytes32 _didSeed , address _creator ) public pure returns ( bytes32 ) It generates a DID using as seed a bytes32 and the address of the DID creator Name Type Description _didSeed bytes32 refers to DID Seed used as base to generate the final DID _creator address address of the creator of the DID Name Type Description [0] bytes32 the new DID created","title":"hashDID"},{"location":"architecture/contracts/generated/solidity-api/#areroyaltiesvalid","text":"function areRoyaltiesValid ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _tokenAddress ) public view returns ( bool ) areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards _tokenAddress address Name Type Description [0] bool true if the rewards distribution respect the original creator royalties","title":"areRoyaltiesValid"},{"location":"architecture/contracts/generated/solidity-api/#wasgeneratedby","text":"function wasGeneratedBy ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal returns ( bool )","title":"wasGeneratedBy"},{"location":"architecture/contracts/generated/solidity-api/#used","text":"function used ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , bytes _signatureUsing , string _attributes ) public returns ( bool success )","title":"used"},{"location":"architecture/contracts/generated/solidity-api/#wasderivedfrom","text":"function wasDerivedFrom ( bytes32 _provId , bytes32 _newEntityDid , bytes32 _usedEntityDid , address _agentId , bytes32 _activityId , string _attributes ) public returns ( bool success )","title":"wasDerivedFrom"},{"location":"architecture/contracts/generated/solidity-api/#wasassociatedwith","text":"function wasAssociatedWith ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) public returns ( bool success )","title":"wasAssociatedWith"},{"location":"architecture/contracts/generated/solidity-api/#actedonbehalf","text":"function actedOnBehalf ( bytes32 _provId , bytes32 _did , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes _signatureDelegate , string _attributes ) public returns ( bool success ) Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId & _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId) Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered","title":"actedOnBehalf"},{"location":"architecture/contracts/generated/solidity-api/#adddidprovider","text":"function addDIDProvider ( bytes32 _did , address _provider ) external addDIDProvider add new DID provider. it adds new DID provider to the providers list. A provider is any entity that can serve the registered asset Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address.","title":"addDIDProvider"},{"location":"architecture/contracts/generated/solidity-api/#removedidprovider","text":"function removeDIDProvider ( bytes32 _did , address _provider ) external removeDIDProvider delete an existing DID provider. Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address.","title":"removeDIDProvider"},{"location":"architecture/contracts/generated/solidity-api/#adddidprovenancedelegate","text":"function addDIDProvenanceDelegate ( bytes32 _did , address _delegate ) public addDIDProvenanceDelegate add new DID provenance delegate. it adds new DID provenance delegate to the delegates list. A delegate is any entity that interact with the provenance entries of one DID Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegates's address.","title":"addDIDProvenanceDelegate"},{"location":"architecture/contracts/generated/solidity-api/#removedidprovenancedelegate","text":"function removeDIDProvenanceDelegate ( bytes32 _did , address _delegate ) external removeDIDProvenanceDelegate delete an existing DID delegate. Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address.","title":"removeDIDProvenanceDelegate"},{"location":"architecture/contracts/generated/solidity-api/#transferdidownership","text":"function transferDIDOwnership ( bytes32 _did , address _newOwner ) external transferDIDOwnership transfer DID ownership Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _newOwner address new owner address","title":"transferDIDOwnership"},{"location":"architecture/contracts/generated/solidity-api/#transferdidownershipmanaged","text":"function transferDIDOwnershipManaged ( address _sender , bytes32 _did , address _newOwner ) external transferDIDOwnershipManaged transfer DID ownership Name Type Description _sender address _did bytes32 refers to decentralized identifier (a bytes32 length ID) _newOwner address new owner address","title":"transferDIDOwnershipManaged"},{"location":"architecture/contracts/generated/solidity-api/#_transferdidownership","text":"function _transferDIDOwnership ( address _sender , bytes32 _did , address _newOwner ) internal","title":"_transferDIDOwnership"},{"location":"architecture/contracts/generated/solidity-api/#grantpermission_3","text":"function grantPermission ( bytes32 _did , address _grantee ) external grantPermission grants access permission to grantee Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"grantPermission"},{"location":"architecture/contracts/generated/solidity-api/#revokepermission","text":"function revokePermission ( bytes32 _did , address _grantee ) external revokePermission revokes access permission from grantee Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"revokePermission"},{"location":"architecture/contracts/generated/solidity-api/#getpermission","text":"function getPermission ( bytes32 _did , address _grantee ) external view returns ( bool ) getPermission gets access permission of a grantee Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address Name Type Description [0] bool true if grantee has access permission to a DID","title":"getPermission"},{"location":"architecture/contracts/generated/solidity-api/#isdidprovider","text":"function isDIDProvider ( bytes32 _did , address _provider ) public view returns ( bool ) isDIDProvider check whether a given DID provider exists Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _provider address provider's address.","title":"isDIDProvider"},{"location":"architecture/contracts/generated/solidity-api/#isdidproviderorowner","text":"function isDIDProviderOrOwner ( bytes32 _did , address _provider ) public view returns ( bool )","title":"isDIDProviderOrOwner"},{"location":"architecture/contracts/generated/solidity-api/#getdidregister","text":"function getDIDRegister ( bytes32 _did ) public view returns ( address owner , bytes32 lastChecksum , string url , address lastUpdatedBy , uint256 blockNumberUpdated , address [] providers , uint256 nftSupply , uint256 mintCap , uint256 royalties ) Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description owner address the did owner lastChecksum bytes32 last checksum url string URL to the DID metadata lastUpdatedBy address who was the last updating the DID blockNumberUpdated uint256 In which block was the DID updated providers address[] the list of providers nftSupply uint256 the supply of nfts mintCap uint256 the maximum number of nfts that can be minted royalties uint256 the royalties amount","title":"getDIDRegister"},{"location":"architecture/contracts/generated/solidity-api/#getdidsupply","text":"function getDIDSupply ( bytes32 _did ) public view returns ( uint256 nftSupply , uint256 mintCap )","title":"getDIDSupply"},{"location":"architecture/contracts/generated/solidity-api/#getblocknumberupdated","text":"function getBlockNumberUpdated ( bytes32 _did ) public view returns ( uint256 blockNumberUpdated ) Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description blockNumberUpdated uint256 last modified (update) block number of a DID.","title":"getBlockNumberUpdated"},{"location":"architecture/contracts/generated/solidity-api/#getdidowner","text":"function getDIDOwner ( bytes32 _did ) public view returns ( address didOwner ) Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description didOwner address the address of the DID owner.","title":"getDIDOwner"},{"location":"architecture/contracts/generated/solidity-api/#getdidroyaltyrecipient","text":"function getDIDRoyaltyRecipient ( bytes32 _did ) public view returns ( address )","title":"getDIDRoyaltyRecipient"},{"location":"architecture/contracts/generated/solidity-api/#getdidroyaltyscheme","text":"function getDIDRoyaltyScheme ( bytes32 _did ) public view returns ( address )","title":"getDIDRoyaltyScheme"},{"location":"architecture/contracts/generated/solidity-api/#getdidcreator","text":"function getDIDCreator ( bytes32 _did ) public view returns ( address )","title":"getDIDCreator"},{"location":"architecture/contracts/generated/solidity-api/#_grantpermission","text":"function _grantPermission ( bytes32 _did , address _grantee ) internal __grantPermission grants access permission to grantee_ Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"_grantPermission"},{"location":"architecture/contracts/generated/solidity-api/#_revokepermission","text":"function _revokePermission ( bytes32 _did , address _grantee ) internal __revokePermission revokes access permission from grantee_ Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address","title":"_revokePermission"},{"location":"architecture/contracts/generated/solidity-api/#_getpermission","text":"function _getPermission ( bytes32 _did , address _grantee ) internal view returns ( bool ) __getPermission gets access permission of a grantee_ Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID) _grantee address address Name Type Description [0] bool true if grantee has access permission to a DID","title":"_getPermission"},{"location":"architecture/contracts/generated/solidity-api/#getprovenanceentry","text":"function getProvenanceEntry ( bytes32 _provId ) public view returns ( bytes32 did , bytes32 relatedDid , address agentId , bytes32 activityId , address agentInvolvedId , uint8 method , address createdBy , uint256 blockNumberUpdated , bytes signature ) Fetch the complete provenance entry attributes Name Type Description _provId bytes32 refers to the provenance identifier Name Type Description did bytes32 to what DID refers this entry relatedDid bytes32 DID related with the entry agentId address the agent identifier activityId bytes32 referring to the id of the activity agentInvolvedId address agent involved with the action method uint8 the w3c provenance method createdBy address who is creating this entry blockNumberUpdated uint256 in which block was updated signature bytes digital signature","title":"getProvenanceEntry"},{"location":"architecture/contracts/generated/solidity-api/#isdidowner","text":"function isDIDOwner ( address _address , bytes32 _did ) public view returns ( bool ) isDIDOwner check whether a given address is owner for a DID Name Type Description _address address user address. _did bytes32 refers to decentralized identifier (a bytes32 length ID).","title":"isDIDOwner"},{"location":"architecture/contracts/generated/solidity-api/#isownerproviderordelegate","text":"function isOwnerProviderOrDelegate ( bytes32 _did ) public view returns ( bool ) isOwnerProviderOrDelegate check whether msg.sender is owner, provider or delegate for a DID given Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description [0] bool boolean true if yes","title":"isOwnerProviderOrDelegate"},{"location":"architecture/contracts/generated/solidity-api/#isprovenancedelegate","text":"function isProvenanceDelegate ( bytes32 _did , address _delegate ) public view returns ( bool ) isProvenanceDelegate check whether a given DID delegate exists Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _delegate address delegate's address. Name Type Description [0] bool boolean true if yes","title":"isProvenanceDelegate"},{"location":"architecture/contracts/generated/solidity-api/#getprovenanceowner","text":"function getProvenanceOwner ( bytes32 _did ) public view returns ( address provenanceOwner ) Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). Name Type Description provenanceOwner address the address of the Provenance owner.","title":"getProvenanceOwner"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_7","text":"Implementation of a Mintable DID Registry.","title":"DIDRegistry"},{"location":"architecture/contracts/generated/solidity-api/#erc1155_3","text":"contract NFTUpgradeable erc1155","title":"erc1155"},{"location":"architecture/contracts/generated/solidity-api/#erc721_1","text":"contract NFT721Upgradeable erc721","title":"erc721"},{"location":"architecture/contracts/generated/solidity-api/#royaltiescheckers","text":"mapping ( address => bool ) royaltiesCheckers","title":"royaltiesCheckers"},{"location":"architecture/contracts/generated/solidity-api/#initialize_34","text":"function initialize ( address _owner , address _erc1155 , address _erc721 ) public DIDRegistry Initializer Initialize Ownable. Only on contract creation. Name Type Description _owner address refers to the owner of the contract. _erc1155 address _erc721 address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#registerroyaltieschecker","text":"function registerRoyaltiesChecker ( address _addr ) public","title":"registerRoyaltiesChecker"},{"location":"architecture/contracts/generated/solidity-api/#didroyaltiesadded","text":"event DIDRoyaltiesAdded ( bytes32 did , address addr )","title":"DIDRoyaltiesAdded"},{"location":"architecture/contracts/generated/solidity-api/#didroyaltyrecipientchanged","text":"event DIDRoyaltyRecipientChanged ( bytes32 did , address addr )","title":"DIDRoyaltyRecipientChanged"},{"location":"architecture/contracts/generated/solidity-api/#setdidroyalties","text":"function setDIDRoyalties ( bytes32 _did , address _royalties ) public","title":"setDIDRoyalties"},{"location":"architecture/contracts/generated/solidity-api/#setdidroyaltyrecipient","text":"function setDIDRoyaltyRecipient ( bytes32 _did , address _recipient ) public","title":"setDIDRoyaltyRecipient"},{"location":"architecture/contracts/generated/solidity-api/#registermintabledid","text":"function registerMintableDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , uint256 _cap , uint8 _royalties , bool _mint , bytes32 _activityId , string _nftMetadata ) public Register a Mintable DID using NFTs based in the ERC-1155 standard. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if true it mints the ERC-1155 NFTs attached to the asset _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata","title":"registerMintableDID"},{"location":"architecture/contracts/generated/solidity-api/#registermintabledid721","text":"function registerMintableDID721 ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , uint8 _royalties , bool _mint , bytes32 _activityId , string _nftMetadata ) public Register a Mintable DID using NFTs based in the ERC-721 standard. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if true it mints the ERC-1155 NFTs attached to the asset _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata","title":"registerMintableDID721"},{"location":"architecture/contracts/generated/solidity-api/#registermintabledid_1","text":"function registerMintableDID ( bytes32 _didSeed , bytes32 _checksum , address [] _providers , string _url , uint256 _cap , uint8 _royalties , bytes32 _activityId , string _nftMetadata ) public Register a Mintable DID. The first attribute of a DID registered sets the DID owner. Subsequent updates record _checksum and update info. Name Type Description _didSeed bytes32 refers to decentralized identifier seed (a bytes32 length ID). _checksum bytes32 includes a one-way HASH calculated using the DDO content. _providers address[] list of addresses that can act as an asset provider _url string refers to the url resolving the DID into a DID Document (DDO), limited to 2048 bytes. _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _activityId bytes32 refers to activity _nftMetadata string refers to the url providing the NFT Metadata","title":"registerMintableDID"},{"location":"architecture/contracts/generated/solidity-api/#enableandmintdidnft","text":"function enableAndMintDidNft ( bytes32 _did , uint256 _cap , uint8 _royalties , bool _mint , string _nftMetadata ) public returns ( bool success ) enableDidNft creates the initial setup of NFTs minting and royalties distribution for ERC-1155 NFTs. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if is true mint directly the amount capped tokens and lock in the _lockAddress _nftMetadata string refers to the url providing the NFT Metadata","title":"enableAndMintDidNft"},{"location":"architecture/contracts/generated/solidity-api/#enableandmintdidnft721","text":"function enableAndMintDidNft721 ( bytes32 _did , uint8 _royalties , bool _mint , string _nftMetadata ) public returns ( bool success ) enableAndMintDidNft721 creates the initial setup of NFTs minting and royalties distribution for ERC-721 NFTs. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration Name Type Description _did bytes32 refers to decentralized identifier (a byte32 length ID) _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market _mint bool if is true mint directly the amount capped tokens and lock in the _lockAddress _nftMetadata string refers to the url providing the NFT Metadata","title":"enableAndMintDidNft721"},{"location":"architecture/contracts/generated/solidity-api/#mint_3","text":"function mint ( bytes32 _did , uint256 _amount , address _receiver ) public Mints a NFT associated to the DID Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both Only the DID owner can mint NFTs associated to the DID Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to mint _receiver address the address that will receive the new nfts minted","title":"mint"},{"location":"architecture/contracts/generated/solidity-api/#mint_4","text":"function mint ( bytes32 _did , uint256 _amount ) public","title":"mint"},{"location":"architecture/contracts/generated/solidity-api/#mint721","text":"function mint721 ( bytes32 _did , address _receiver ) public Mints a ERC-721 NFT associated to the DID Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _receiver address the address that will receive the new nfts minted","title":"mint721"},{"location":"architecture/contracts/generated/solidity-api/#mint721_1","text":"function mint721 ( bytes32 _did ) public","title":"mint721"},{"location":"architecture/contracts/generated/solidity-api/#burn_2","text":"function burn ( bytes32 _did , uint256 _amount ) public Burns NFTs associated to the DID Because ERC-1155 uses uint256 and DID's are bytes32, there is a conversion between both Only the DID owner can burn NFTs associated to the DID Name Type Description _did bytes32 refers to decentralized identifier (a bytes32 length ID). _amount uint256 amount to burn","title":"burn"},{"location":"architecture/contracts/generated/solidity-api/#burn721","text":"function burn721 ( bytes32 _did ) public","title":"burn721"},{"location":"architecture/contracts/generated/solidity-api/#didregistrylibrary","text":"All function calls are currently implemented without side effects","title":"DIDRegistryLibrary"},{"location":"architecture/contracts/generated/solidity-api/#didregister","text":"struct DIDRegister { address owner ; uint8 royalties ; bool nftInitialized ; bool nft721Initialized ; address creator ; bytes32 lastChecksum ; string url ; address lastUpdatedBy ; uint256 blockNumberUpdated ; address [] providers ; address [] delegates ; uint256 nftSupply ; uint256 mintCap ; address royaltyRecipient ; contract IRoyaltyScheme royaltyScheme ; }","title":"DIDRegister"},{"location":"architecture/contracts/generated/solidity-api/#didregisterlist_1","text":"struct DIDRegisterList { mapping ( bytes32 &# x3D ; & gt ; struct DIDRegistryLibrary . DIDRegister ) didRegisters ; bytes32 [] didRegisterIds ; }","title":"DIDRegisterList"},{"location":"architecture/contracts/generated/solidity-api/#update_2","text":"function update ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , bytes32 _checksum , string _url ) external update the DID store access modifiers and storage pointer should be implemented in DIDRegistry Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _checksum bytes32 includes a one-way HASH calculated using the DDO content _url string includes the url resolving to the DID Document (DDO)","title":"update"},{"location":"architecture/contracts/generated/solidity-api/#initializenftconfig","text":"function initializeNftConfig ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint256 _cap , uint8 _royalties ) internal initializeNftConfig creates the initial setup of NFTs minting and royalties distribution. After this initial setup, this data can't be changed anymore for the DID given, even for the owner of the DID. The reason of this is to avoid minting additional NFTs after the initial agreement, what could affect the valuation of NFTs of a DID already created. update the DID registry providers list by adding the mintCap and royalties configuration Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _cap uint256 refers to the mint cap _royalties uint8 refers to the royalties to reward to the DID creator in the secondary market The royalties in secondary market for the creator should be between 0% >= x < 100%","title":"initializeNftConfig"},{"location":"architecture/contracts/generated/solidity-api/#initializenft721config","text":"function initializeNft721Config ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint8 _royalties ) internal","title":"initializeNft721Config"},{"location":"architecture/contracts/generated/solidity-api/#areroyaltiesvalid_1","text":"function areRoyaltiesValid ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _tokenAddress ) internal view returns ( bool ) areRoyaltiesValid checks if for a given DID and rewards distribution, this allocate the original creator royalties properly Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _amounts uint256[] refers to the amounts to reward _receivers address[] refers to the receivers of rewards _tokenAddress address Name Type Description [0] bool true if the rewards distribution respect the original creator royalties","title":"areRoyaltiesValid"},{"location":"architecture/contracts/generated/solidity-api/#addprovider","text":"function addProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address provider ) internal addProvider add provider to DID registry update the DID registry providers list by adding a new provider Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) provider address the provider's address","title":"addProvider"},{"location":"architecture/contracts/generated/solidity-api/#removeprovider","text":"function removeProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _provider ) internal returns ( bool ) removeProvider remove provider from DID registry update the DID registry providers list by removing an existing provider Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address","title":"removeProvider"},{"location":"architecture/contracts/generated/solidity-api/#updatedidowner","text":"function updateDIDOwner ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _newOwner ) internal updateDIDOwner transfer DID ownership to a new owner Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _newOwner address the new DID owner address","title":"updateDIDOwner"},{"location":"architecture/contracts/generated/solidity-api/#isprovider","text":"function isProvider ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _provider ) public view returns ( bool ) isProvider check whether DID provider exists Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _provider address the provider's address Name Type Description [0] bool true if the provider already exists","title":"isProvider"},{"location":"architecture/contracts/generated/solidity-api/#getproviderindex","text":"function getProviderIndex ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address provider ) private view returns ( int256 ) getProviderIndex get the index of a provider Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) provider address the provider's address Name Type Description [0] int256 the index if the provider exists otherwise return -1","title":"getProviderIndex"},{"location":"architecture/contracts/generated/solidity-api/#adddelegate","text":"function addDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address delegate ) internal addDelegate add delegate to DID registry update the DID registry delegates list by adding a new delegate Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) delegate address the delegate's address","title":"addDelegate"},{"location":"architecture/contracts/generated/solidity-api/#removedelegate","text":"function removeDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _delegate ) internal returns ( bool ) removeDelegate remove delegate from DID registry update the DID registry delegates list by removing an existing delegate Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address","title":"removeDelegate"},{"location":"architecture/contracts/generated/solidity-api/#isdelegate","text":"function isDelegate ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address _delegate ) public view returns ( bool ) isDelegate check whether DID delegate exists Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) _delegate address the delegate's address Name Type Description [0] bool true if the delegate already exists","title":"isDelegate"},{"location":"architecture/contracts/generated/solidity-api/#getdelegateindex","text":"function getDelegateIndex ( struct DIDRegistryLibrary . DIDRegisterList _self , bytes32 _did , address delegate ) private view returns ( int256 ) getDelegateIndex get the index of a delegate Name Type Description _self struct DIDRegistryLibrary.DIDRegisterList refers to storage pointer _did bytes32 refers to decentralized identifier (a byte32 length ID) delegate address the delegate's address Name Type Description [0] int256 the index if the delegate exists otherwise return -1","title":"getDelegateIndex"},{"location":"architecture/contracts/generated/solidity-api/#provenanceregistry","text":"All function calls are currently implemented without side effects","title":"ProvenanceRegistry"},{"location":"architecture/contracts/generated/solidity-api/#__provenanceregistry_init","text":"function __ProvenanceRegistry_init () internal","title":"__ProvenanceRegistry_init"},{"location":"architecture/contracts/generated/solidity-api/#__provenanceregistry_init_unchained","text":"function __ProvenanceRegistry_init_unchained () internal","title":"__ProvenanceRegistry_init_unchained"},{"location":"architecture/contracts/generated/solidity-api/#provenance","text":"struct Provenance { bytes32 did ; bytes32 relatedDid ; address agentId ; bytes32 activityId ; address agentInvolvedId ; uint8 method ; address createdBy ; uint256 blockNumberUpdated ; bytes signature ; }","title":"Provenance"},{"location":"architecture/contracts/generated/solidity-api/#provenanceregistrylist","text":"struct ProvenanceRegistryList { mapping ( bytes32 &# x3D ; & gt ; struct ProvenanceRegistry . Provenance ) list ; }","title":"ProvenanceRegistryList"},{"location":"architecture/contracts/generated/solidity-api/#provenanceregistry_1","text":"struct ProvenanceRegistry . ProvenanceRegistryList provenanceRegistry","title":"provenanceRegistry"},{"location":"architecture/contracts/generated/solidity-api/#provenancemethod","text":"enum ProvenanceMethod { ENTITY , ACTIVITY , WAS_GENERATED_BY , USED , WAS_INFORMED_BY , WAS_STARTED_BY , WAS_ENDED_BY , WAS_INVALIDATED_BY , WAS_DERIVED_FROM , AGENT , WAS_ATTRIBUTED_TO , WAS_ASSOCIATED_WITH , ACTED_ON_BEHALF }","title":"ProvenanceMethod"},{"location":"architecture/contracts/generated/solidity-api/#provenanceattributeregistered","text":"event ProvenanceAttributeRegistered ( bytes32 provId , bytes32 _did , address _agentId , bytes32 _activityId , bytes32 _relatedDid , address _agentInvolvedId , enum ProvenanceRegistry . ProvenanceMethod _method , string _attributes , uint256 _blockNumberUpdated ) Provenance Events","title":"ProvenanceAttributeRegistered"},{"location":"architecture/contracts/generated/solidity-api/#wasgeneratedby_1","text":"event WasGeneratedBy ( bytes32 _did , address _agentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated )","title":"WasGeneratedBy"},{"location":"architecture/contracts/generated/solidity-api/#used_1","text":"event Used ( bytes32 _did , address _agentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated )","title":"Used"},{"location":"architecture/contracts/generated/solidity-api/#wasderivedfrom_1","text":"event WasDerivedFrom ( bytes32 _newEntityDid , bytes32 _usedEntityDid , address _agentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated )","title":"WasDerivedFrom"},{"location":"architecture/contracts/generated/solidity-api/#wasassociatedwith_1","text":"event WasAssociatedWith ( bytes32 _entityDid , address _agentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated )","title":"WasAssociatedWith"},{"location":"architecture/contracts/generated/solidity-api/#actedonbehalf_1","text":"event ActedOnBehalf ( bytes32 _entityDid , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes32 provId , string _attributes , uint256 _blockNumberUpdated )","title":"ActedOnBehalf"},{"location":"architecture/contracts/generated/solidity-api/#createprovenanceentry","text":"function createProvenanceEntry ( bytes32 _provId , bytes32 _did , bytes32 _relatedDid , address _agentId , bytes32 _activityId , address _agentInvolvedId , enum ProvenanceRegistry . ProvenanceMethod _method , address _createdBy , bytes _signatureDelegate , string _attributes ) internal returns ( bool ) create an event in the Provenance store access modifiers and storage pointer should be implemented in ProvenanceRegistry Name Type Description _provId bytes32 refers to provenance event identifier _did bytes32 refers to decentralized identifier (a byte32 length ID) _relatedDid bytes32 refers to decentralized identifier (a byte32 length ID) of a related entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _agentInvolvedId address refers to address of the agent involved with the provenance record _method enum ProvenanceRegistry.ProvenanceMethod refers to the W3C Provenance method _createdBy address refers to address of the agent triggering the activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string","title":"createProvenanceEntry"},{"location":"architecture/contracts/generated/solidity-api/#_wasgeneratedby","text":"function _wasGeneratedBy ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal virtual returns ( bool ) Implements the W3C PROV Generation action Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description [0] bool the number of the new provenance size","title":"_wasGeneratedBy"},{"location":"architecture/contracts/generated/solidity-api/#_used","text":"function _used ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , bytes _signatureUsing , string _attributes ) internal virtual returns ( bool success ) Implements the W3C PROV Usage action Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _signatureUsing bytes refers to the digital signature provided by the agent using the _did _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered","title":"_used"},{"location":"architecture/contracts/generated/solidity-api/#_wasderivedfrom","text":"function _wasDerivedFrom ( bytes32 _provId , bytes32 _newEntityDid , bytes32 _usedEntityDid , address _agentId , bytes32 _activityId , string _attributes ) internal virtual returns ( bool success ) Implements the W3C PROV Derivation action Name Type Description _provId bytes32 unique identifier referring to the provenance entry _newEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity created _usedEntityDid bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity used to derive the new did _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered","title":"_wasDerivedFrom"},{"location":"architecture/contracts/generated/solidity-api/#_wasassociatedwith","text":"function _wasAssociatedWith ( bytes32 _provId , bytes32 _did , address _agentId , bytes32 _activityId , string _attributes ) internal virtual returns ( bool success ) Implements the W3C PROV Association action Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _agentId address refers to address of the agent creating the provenance record _activityId bytes32 refers to activity _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered","title":"_wasAssociatedWith"},{"location":"architecture/contracts/generated/solidity-api/#_actedonbehalf","text":"function _actedOnBehalf ( bytes32 _provId , bytes32 _did , address _delegateAgentId , address _responsibleAgentId , bytes32 _activityId , bytes _signatureDelegate , string _attributes ) internal virtual returns ( bool success ) Implements the W3C PROV Delegation action Each party involved in this method (_delegateAgentId & _responsibleAgentId) must provide a valid signature. The content to sign is a representation of the footprint of the event (_did + _delegateAgentId + _responsibleAgentId + _activityId) Name Type Description _provId bytes32 unique identifier referring to the provenance entry _did bytes32 refers to decentralized identifier (a bytes32 length ID) of the entity _delegateAgentId address refers to address acting on behalf of the provenance record _responsibleAgentId address refers to address responsible of the provenance record _activityId bytes32 refers to activity _signatureDelegate bytes refers to the digital signature provided by the did delegate. _attributes string refers to the provenance attributes Name Type Description success bool true if the action was properly registered","title":"_actedOnBehalf"},{"location":"architecture/contracts/generated/solidity-api/#curveroyalties","text":"","title":"CurveRoyalties"},{"location":"architecture/contracts/generated/solidity-api/#registry","text":"contract DIDRegistry registry","title":"registry"},{"location":"architecture/contracts/generated/solidity-api/#denominator","text":"uint256 DENOMINATOR","title":"DENOMINATOR"},{"location":"architecture/contracts/generated/solidity-api/#royalties","text":"mapping ( bytes32 => uint256 ) royalties","title":"royalties"},{"location":"architecture/contracts/generated/solidity-api/#initialize_35","text":"function initialize ( address _registry ) public","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#royaltycurve","text":"function royaltyCurve ( uint256 num , uint256 max , uint256 rate ) public pure virtual returns ( uint256 )","title":"royaltyCurve"},{"location":"architecture/contracts/generated/solidity-api/#setroyalty","text":"function setRoyalty ( bytes32 _did , uint256 _royalty ) public Set royalties for a DID Can only be called by creator of the DID Name Type Description _did bytes32 DID for which the royalties are set _royalty uint256 Royalty, the actual royalty will be _royalty / 10000 percent","title":"setRoyalty"},{"location":"architecture/contracts/generated/solidity-api/#check_1","text":"function check ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _token ) external view returns ( bool )","title":"check"},{"location":"architecture/contracts/generated/solidity-api/#rewardsdistributor","text":"","title":"RewardsDistributor"},{"location":"architecture/contracts/generated/solidity-api/#used_2","text":"mapping ( bytes32 => bool ) used","title":"used"},{"location":"architecture/contracts/generated/solidity-api/#receivers","text":"mapping ( bytes32 => address []) receivers","title":"receivers"},{"location":"architecture/contracts/generated/solidity-api/#registry_1","text":"contract DIDRegistry registry","title":"registry"},{"location":"architecture/contracts/generated/solidity-api/#conditionstoremanager_3","text":"contract ConditionStoreManager conditionStoreManager","title":"conditionStoreManager"},{"location":"architecture/contracts/generated/solidity-api/#escrow","text":"address escrow","title":"escrow"},{"location":"architecture/contracts/generated/solidity-api/#initialize_36","text":"function initialize ( address _registry , address _conditionStoreManager , address _escrow ) public","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#setreceivers","text":"function setReceivers ( bytes32 _did , address [] _addr ) public set receivers for did Name Type Description _did bytes32 DID _addr address[] list of receivers","title":"setReceivers"},{"location":"architecture/contracts/generated/solidity-api/#claimreward","text":"function claimReward ( bytes32 _agreementId , bytes32 _did , uint256 [] _amounts , address [] _receivers , address _returnAddress , address _lockPaymentAddress , address _tokenAddress , bytes32 _lockCondition , bytes32 [] _releaseConditions ) public distribute rewards associated with an escrow condition as paramemeters, it just gets the same parameters as fulfill for escrow condition Name Type Description _agreementId bytes32 agreement identifier _did bytes32 asset decentralized identifier _amounts uint256[] token amounts to be locked/released _receivers address[] receiver's address _returnAddress address _lockPaymentAddress address lock payment contract address _tokenAddress address the ERC20 contract address to use during the payment _lockCondition bytes32 lock condition identifier _releaseConditions bytes32[] release condition identifier","title":"claimReward"},{"location":"architecture/contracts/generated/solidity-api/#standardroyalties","text":"","title":"StandardRoyalties"},{"location":"architecture/contracts/generated/solidity-api/#registry_2","text":"contract DIDRegistry registry","title":"registry"},{"location":"architecture/contracts/generated/solidity-api/#denominator_1","text":"uint256 DENOMINATOR","title":"DENOMINATOR"},{"location":"architecture/contracts/generated/solidity-api/#royalties_1","text":"mapping ( bytes32 => uint256 ) royalties","title":"royalties"},{"location":"architecture/contracts/generated/solidity-api/#initialize_37","text":"function initialize ( address _registry ) public","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#setroyalty_1","text":"function setRoyalty ( bytes32 _did , uint256 _royalty ) public Set royalties for a DID Can only be called by creator of the DID Name Type Description _did bytes32 DID for which the royalties are set _royalty uint256 Royalty, the actual royalty will be _royalty / 10000 percent","title":"setRoyalty"},{"location":"architecture/contracts/generated/solidity-api/#check_2","text":"function check ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address ) external view returns ( bool )","title":"check"},{"location":"architecture/contracts/generated/solidity-api/#aavecredittemplate","text":"Implementation of the Aaven Credit Agreement Template 0. Initialize the agreement 1. LockNFT - Delegatee locks the NFT 2. AaveCollateralDeposit - Delegator deposits the collateral into Aave. And approves the delegation flow 3. AaveBorrowCondition - The Delegatee claim the credit amount from Aave 4. AaveRepayCondition. Options: 4.a Fulfilled state - The Delegatee pay back the loan (including fee) into Aave and gets back the NFT 4.b Aborted state - The Delegatee doesn't pay the loan in time so the Delegator gets the NFT. The Delegator pays the loan to Aave 5. TransferNFT. Options: 5.a if AaveRepayCondition was fulfilled, it will allow transfer back to the Delegatee or Borrower 5.b if AaveRepayCondition was aborted, it will allow transfer the NFT to the Delegator or Lender","title":"AaveCreditTemplate"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_8","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#nftlockcondition_1","text":"contract INFTLock nftLockCondition","title":"nftLockCondition"},{"location":"architecture/contracts/generated/solidity-api/#depositcondition","text":"contract AaveCollateralDepositCondition depositCondition","title":"depositCondition"},{"location":"architecture/contracts/generated/solidity-api/#borrowcondition","text":"contract AaveBorrowCondition borrowCondition","title":"borrowCondition"},{"location":"architecture/contracts/generated/solidity-api/#repaycondition","text":"contract AaveRepayCondition repayCondition","title":"repayCondition"},{"location":"architecture/contracts/generated/solidity-api/#transfercondition","text":"contract DistributeNFTCollateralCondition transferCondition","title":"transferCondition"},{"location":"architecture/contracts/generated/solidity-api/#withdrawcondition","text":"contract AaveCollateralWithdrawCondition withdrawCondition","title":"withdrawCondition"},{"location":"architecture/contracts/generated/solidity-api/#vaultaddress","text":"mapping ( bytes32 => address ) vaultAddress","title":"vaultAddress"},{"location":"architecture/contracts/generated/solidity-api/#nvmfee_1","text":"uint256 nvmFee","title":"nvmFee"},{"location":"architecture/contracts/generated/solidity-api/#vaultlibrary","text":"address vaultLibrary","title":"vaultLibrary"},{"location":"architecture/contracts/generated/solidity-api/#vaultcreated","text":"event VaultCreated ( address _vaultAddress , address _creator , address _lender , address _borrower )","title":"VaultCreated"},{"location":"architecture/contracts/generated/solidity-api/#initialize_38","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _nftLockConditionAddress , address _depositConditionAddress , address _borrowConditionAddress , address _repayConditionAddress , address _withdrawCollateralAddress , address _transferConditionAddress , address _vaultLibrary ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftLockConditionAddress address NFT Lock Condition contract address _depositConditionAddress address Aave collateral deposit Condition address _borrowConditionAddress address Aave borrow deposit Condition address _repayConditionAddress address Aave repay credit Condition address _withdrawCollateralAddress address _transferConditionAddress address NFT Transfer Condition address _vaultLibrary address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#createvaultagreement","text":"function createVaultAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _vaultAddress ) public","title":"createVaultAgreement"},{"location":"architecture/contracts/generated/solidity-api/#createagreement_1","text":"function createAgreement ( bytes32 _id , address _lendingPool , address _dataProvider , address _weth , uint256 _agreementFee , address _treasuryAddress , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _lender ) public","title":"createAgreement"},{"location":"architecture/contracts/generated/solidity-api/#deployvault","text":"function deployVault ( address _lendingPool , address _dataProvider , address _weth , uint256 _agreementFee , address _treasuryAddress , address _borrower , address _lender ) public returns ( address )","title":"deployVault"},{"location":"architecture/contracts/generated/solidity-api/#getvaultforagreement","text":"function getVaultForAgreement ( bytes32 _agreementId ) public view returns ( address )","title":"getVaultForAgreement"},{"location":"architecture/contracts/generated/solidity-api/#updatenvmfee","text":"function updateNVMFee ( uint256 _newFee ) public Updates the nevermined fee for this type of agreement Name Type Description _newFee uint256 New nevermined fee expressed in basis points","title":"updateNVMFee"},{"location":"architecture/contracts/generated/solidity-api/#changecreditvaultlibrary","text":"function changeCreditVaultLibrary ( address _vaultLibrary ) public","title":"changeCreditVaultLibrary"},{"location":"architecture/contracts/generated/solidity-api/#accessprooftemplate","text":"Implementation of Access Agreement Template","title":"AccessProofTemplate"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_9","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#accesscondition_1","text":"contract AccessProofCondition accessCondition","title":"accessCondition"},{"location":"architecture/contracts/generated/solidity-api/#lockcondition","text":"contract LockPaymentCondition lockCondition","title":"lockCondition"},{"location":"architecture/contracts/generated/solidity-api/#escrowreward","text":"contract EscrowPaymentCondition escrowReward","title":"escrowReward"},{"location":"architecture/contracts/generated/solidity-api/#initialize_39","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _accessConditionAddress , address _lockConditionAddress , address payable _escrowConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#accesstemplate","text":"_Implementation of Access Agreement Template Access template is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an on-chain SEA. The template is a composite of three basic conditions. Once the agreement is created, the consumer will lock an amount of tokens (as listed in the DID document - off-chain metadata) to the the lock reward contract which in turn will fire an event. ON the other hand the provider is listening to all the emitted events, the provider will catch the event and grant permissions to the consumer through secret store contract, the consumer now is able to download the data set by asking the off-chain component of secret store to decrypt the DID and encrypt it using the consumer's public key. Then the secret store will provide an on-chain proof that the consumer had access to the data set. Finally, the provider can call the escrow reward condition in order to release the payment. Every condition has a time window (time lock and time out). This implies that if the provider didn't grant the access to the consumer through secret store within this time window, the consumer can ask for refund._","title":"AccessTemplate"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_10","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#accesscondition_2","text":"contract AccessCondition accessCondition","title":"accessCondition"},{"location":"architecture/contracts/generated/solidity-api/#lockcondition_1","text":"contract LockPaymentCondition lockCondition","title":"lockCondition"},{"location":"architecture/contracts/generated/solidity-api/#escrowreward_1","text":"contract EscrowPaymentCondition escrowReward","title":"escrowReward"},{"location":"architecture/contracts/generated/solidity-api/#initialize_40","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _accessConditionAddress , address _lockConditionAddress , address payable _escrowConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access , lock payment and escrow payment conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _accessConditionAddress address access condition address _lockConditionAddress address lock reward condition contract address _escrowConditionAddress address payable escrow reward contract address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#agreementtemplate","text":"_Implementation of Agreement Template Agreement template is a reference template where it has the ability to create agreements from whitelisted template_","title":"AgreementTemplate"},{"location":"architecture/contracts/generated/solidity-api/#conditiontypes","text":"address [] conditionTypes","title":"conditionTypes"},{"location":"architecture/contracts/generated/solidity-api/#agreementstoremanager_4","text":"contract AgreementStoreManager agreementStoreManager","title":"agreementStoreManager"},{"location":"architecture/contracts/generated/solidity-api/#createagreement_2","text":"function createAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts ) public createAgreement create new agreement Name Type Description _id bytes32 agreement unique identifier _did bytes32 refers to decentralized identifier (a bytes32 length ID). _conditionIds bytes32[] list of condition identifiers _timeLocks uint256[] list of time locks, each time lock will be assigned to the same condition that has the same index _timeOuts uint256[] list of time outs, each time out will be assigned to the same condition that has the same index","title":"createAgreement"},{"location":"architecture/contracts/generated/solidity-api/#createagreementandpay_1","text":"function createAgreementAndPay ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , uint256 _idx , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public payable","title":"createAgreementAndPay"},{"location":"architecture/contracts/generated/solidity-api/#createagreementandfulfill_1","text":"function createAgreementAndFulfill ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , uint256 [] _indices , address [] _accounts , bytes [] _params ) internal","title":"createAgreementAndFulfill"},{"location":"architecture/contracts/generated/solidity-api/#getconditiontypes_1","text":"function getConditionTypes () public view returns ( address []) getConditionTypes gets the conditions addresses list for the current template returns list of condition contracts addresses Name Type Description [0] address[] list of conditions contract addresses","title":"getConditionTypes"},{"location":"architecture/contracts/generated/solidity-api/#baseescrowtemplate","text":"","title":"BaseEscrowTemplate"},{"location":"architecture/contracts/generated/solidity-api/#agreementdata","text":"struct BaseEscrowTemplate . AgreementData agreementData","title":"agreementData"},{"location":"architecture/contracts/generated/solidity-api/#agreementcreated","text":"event AgreementCreated ( bytes32 _agreementId , bytes32 _did , address _accessConsumer , address _accessProvider , uint256 [] _timeLocks , uint256 [] _timeOuts , bytes32 [] _conditionIdSeeds , bytes32 [] _conditionIds , bytes32 _idSeed , address _creator )","title":"AgreementCreated"},{"location":"architecture/contracts/generated/solidity-api/#agreementdatamodel","text":"struct AgreementDataModel { address accessConsumer ; address accessProvider ; bytes32 did ; }","title":"AgreementDataModel"},{"location":"architecture/contracts/generated/solidity-api/#agreementdata_1","text":"struct AgreementData { mapping ( bytes32 &# x3D ; & gt ; struct BaseEscrowTemplate . AgreementDataModel ) agreementDataItems ; bytes32 [] agreementIds ; }","title":"AgreementData"},{"location":"architecture/contracts/generated/solidity-api/#createagreement_3","text":"function createAgreement ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer ) public createAgreement creates agreements through agreement template this function initializes the agreement by setting the DID, conditions ID, timeouts, time locks and the consumer address. The DID provider/owner is automatically detected by the DID Registry Name Type Description _id bytes32 SEA agreement unique identifier _did bytes32 Decentralized Identifier (DID) _conditionIds bytes32[] conditions ID associated with the condition types _timeLocks uint256[] the starting point of the time window ,time lock is in block number not seconds _timeOuts uint256[] the ending point of the time window ,time lock is in block number not seconds _accessConsumer address consumer address","title":"createAgreement"},{"location":"architecture/contracts/generated/solidity-api/#createagreementandpayescrow","text":"function createAgreementAndPayEscrow ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer , uint256 _idx , address payable _rewardAddress , address _tokenAddress , uint256 [] _amounts , address [] _receivers ) public payable","title":"createAgreementAndPayEscrow"},{"location":"architecture/contracts/generated/solidity-api/#createagreementandfulfill_2","text":"function createAgreementAndFulfill ( bytes32 _id , bytes32 _did , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer , uint256 [] _indices , address [] _accounts , bytes [] _params ) internal","title":"createAgreementAndFulfill"},{"location":"architecture/contracts/generated/solidity-api/#_makeids","text":"function _makeIds ( bytes32 _idSeed , bytes32 [] _conditionIds ) internal view returns ( bytes32 [])","title":"_makeIds"},{"location":"architecture/contracts/generated/solidity-api/#_initagreement","text":"function _initAgreement ( bytes32 _idSeed , bytes32 _did , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer , bytes32 [] _conditionIds ) internal","title":"_initAgreement"},{"location":"architecture/contracts/generated/solidity-api/#getagreementdata","text":"function getAgreementData ( bytes32 _id ) external view returns ( address accessConsumer , address accessProvider ) getAgreementData return the agreement Data Name Type Description _id bytes32 SEA agreement unique identifier Name Type Description accessConsumer address the agreement consumer accessProvider address the provider addresses","title":"getAgreementData"},{"location":"architecture/contracts/generated/solidity-api/#didsalestemplate","text":"_Implementation of DID Sales Template The DID Sales template supports an scenario where an Asset owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing an Asset owner to get transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer DID Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the ownership transfer of an asset from the current owner for a specific DID._","title":"DIDSalesTemplate"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_11","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#lockpaymentcondition_1","text":"contract LockPaymentCondition lockPaymentCondition","title":"lockPaymentCondition"},{"location":"architecture/contracts/generated/solidity-api/#transfercondition_1","text":"contract TransferDIDOwnershipCondition transferCondition","title":"transferCondition"},{"location":"architecture/contracts/generated/solidity-api/#rewardcondition","text":"contract EscrowPaymentCondition rewardCondition","title":"rewardCondition"},{"location":"architecture/contracts/generated/solidity-api/#id","text":"function id () public pure returns ( uint256 )","title":"id"},{"location":"architecture/contracts/generated/solidity-api/#initialize_41","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockConditionAddress address lock reward condition contract address _transferConditionAddress address transfer ownership condition contract address _escrowPaymentAddress address payable escrow reward condition contract address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#dynamicaccesstemplate","text":"Implementation of Agreement Template This is a dynamic template that allows to setup flexible conditions depending on the use case.","title":"DynamicAccessTemplate"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_12","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#templateconfig","text":"struct DynamicAccessTemplate . TemplateConditions templateConfig","title":"templateConfig"},{"location":"architecture/contracts/generated/solidity-api/#templateconditions","text":"struct TemplateConditions { mapping ( address &# x3D ; & gt ; contract Condition ) templateConditions ; }","title":"TemplateConditions"},{"location":"architecture/contracts/generated/solidity-api/#initialize_42","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#addtemplatecondition","text":"function addTemplateCondition ( address _conditionAddress ) external returns ( uint256 length ) addTemplateCondition adds a new condition to the template Name Type Description _conditionAddress address condition contract address Name Type Description length uint256 conditionTypes array size","title":"addTemplateCondition"},{"location":"architecture/contracts/generated/solidity-api/#removelasttemplatecondition","text":"function removeLastTemplateCondition () external returns ( address []) removeLastTemplateCondition removes last condition added to the template Name Type Description [0] address[] conditionTypes existing in the array","title":"removeLastTemplateCondition"},{"location":"architecture/contracts/generated/solidity-api/#escrowcomputeexecutiontemplate","text":"_Implementation of a Compute Execution Agreement Template EscrowComputeExecutionTemplate is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an on-chain SEA. The template is a composite of three basic conditions. Once the agreement is created, the consumer will lock an amount of tokens (as listed in the DID document - off-chain metadata) to the the lock reward contract which in turn will fire an event. ON the other hand the provider is listening to all the emitted events, the provider will catch the event and grant permissions to trigger a computation granting the execution via the ComputeExecutionCondition contract. The consumer now is able to trigger that computation by asking the off-chain gateway to start the execution of a compute workflow. Finally, the provider can call the escrow reward condition in order to release the payment. Every condition has a time window (time lock and time out). This implies that if the provider didn't grant the execution to the consumer within this time window, the consumer can ask for refund._","title":"EscrowComputeExecutionTemplate"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_13","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#computeexecutioncondition_1","text":"contract ComputeExecutionCondition computeExecutionCondition","title":"computeExecutionCondition"},{"location":"architecture/contracts/generated/solidity-api/#lockpaymentcondition_2","text":"contract LockPaymentCondition lockPaymentCondition","title":"lockPaymentCondition"},{"location":"architecture/contracts/generated/solidity-api/#escrowpayment","text":"contract EscrowPaymentCondition escrowPayment","title":"escrowPayment"},{"location":"architecture/contracts/generated/solidity-api/#initialize_43","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _didRegistryAddress , address _computeExecutionConditionAddress , address _lockPaymentConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including service executor condition, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _didRegistryAddress address DID registry contract address _computeExecutionConditionAddress address service executor condition contract address _lockPaymentConditionAddress address lock reward condition contract address _escrowPaymentAddress address payable escrow reward contract address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#name","text":"function name () public pure returns ( string )","title":"name"},{"location":"architecture/contracts/generated/solidity-api/#nft721accessprooftemplate","text":"Implementation of NFT721 Access Proof Template","title":"NFT721AccessProofTemplate"},{"location":"architecture/contracts/generated/solidity-api/#nft721accessswaptemplate","text":"","title":"NFT721AccessSwapTemplate"},{"location":"architecture/contracts/generated/solidity-api/#nft721accesstemplate","text":"Implementation of NFT Access Template","title":"NFT721AccessTemplate"},{"location":"architecture/contracts/generated/solidity-api/#nft721salestemplate","text":"Implementation of NFT Sales Template","title":"NFT721SalesTemplate"},{"location":"architecture/contracts/generated/solidity-api/#nft721saleswithaccesstemplate","text":"","title":"NFT721SalesWithAccessTemplate"},{"location":"architecture/contracts/generated/solidity-api/#nftaccessprooftemplate","text":"_Implementation of NFT Access Template The NFT Access template is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing NFT holders to get access to Nevermined services. The template is a composite of 2 basic conditions: - NFT Holding Condition - Access Condition Once the agreement is created, the consumer can demonstrate is holding a NFT for a specific DID. If that's the case the Access condition can be fulfilled by the asset owner or provider and all the agreement is fulfilled. This can be used in scenarios where a data or services owner, can allow users to get access to exclusive services only when they demonstrate the are holding a specific number of NFTs of a DID. This is very useful in use cases like arts._","title":"NFTAccessProofTemplate"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_14","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#nftholdercondition_1","text":"contract INFTHolder nftHolderCondition","title":"nftHolderCondition"},{"location":"architecture/contracts/generated/solidity-api/#accesscondition_3","text":"contract AccessProofCondition accessCondition","title":"accessCondition"},{"location":"architecture/contracts/generated/solidity-api/#initialize_44","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _nftHolderConditionAddress , address _accessConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftHolderConditionAddress address lock reward condition contract address _accessConditionAddress address access condition contract address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#nftaccessswaptemplate","text":"_Implementation of NFT Sales Template The NFT Sales template supports an scenario where a NFT owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing a NFT owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer NFT Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the transfer of the NFT from the current owner for a specific DID._","title":"NFTAccessSwapTemplate"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_15","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#lockpaymentcondition_3","text":"contract INFTLock lockPaymentCondition","title":"lockPaymentCondition"},{"location":"architecture/contracts/generated/solidity-api/#rewardcondition_1","text":"contract INFTEscrow rewardCondition","title":"rewardCondition"},{"location":"architecture/contracts/generated/solidity-api/#accesscondition_4","text":"contract AccessProofCondition accessCondition","title":"accessCondition"},{"location":"architecture/contracts/generated/solidity-api/#id_1","text":"function id () public pure returns ( uint256 )","title":"id"},{"location":"architecture/contracts/generated/solidity-api/#initialize_45","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockPaymentConditionAddress , address payable _escrowPaymentAddress , address _accessCondition ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _escrowPaymentAddress address payable escrow reward condition contract address _accessCondition address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#nftaccesstemplate","text":"_Implementation of NFT Access Template The NFT Access template is use case specific template. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing NFT holders to get access to Nevermined services. The template is a composite of 2 basic conditions: - NFT Holding Condition - Access Condition Once the agreement is created, the consumer can demonstrate is holding a NFT for a specific DID. If that's the case the Access condition can be fulfilled by the asset owner or provider and all the agreement is fulfilled. This can be used in scenarios where a data or services owner, can allow users to get access to exclusive services only when they demonstrate the are holding a specific number of NFTs of a DID. This is very useful in use cases like arts._","title":"NFTAccessTemplate"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_16","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#nftholdercondition_2","text":"contract INFTHolder nftHolderCondition","title":"nftHolderCondition"},{"location":"architecture/contracts/generated/solidity-api/#accesscondition_5","text":"contract INFTAccess accessCondition","title":"accessCondition"},{"location":"architecture/contracts/generated/solidity-api/#initialize_46","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _nftHolderConditionAddress , address _accessConditionAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _nftHolderConditionAddress address lock reward condition contract address _accessConditionAddress address access condition contract address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#nftsalestemplate","text":"_Implementation of NFT Sales Template The NFT Sales template supports an scenario where a NFT owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing a NFT owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer NFT Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the transfer of the NFT from the current owner for a specific DID._","title":"NFTSalesTemplate"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_17","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#lockpaymentcondition_4","text":"contract LockPaymentCondition lockPaymentCondition","title":"lockPaymentCondition"},{"location":"architecture/contracts/generated/solidity-api/#transfercondition_2","text":"contract ITransferNFT transferCondition","title":"transferCondition"},{"location":"architecture/contracts/generated/solidity-api/#rewardcondition_2","text":"contract EscrowPaymentCondition rewardCondition","title":"rewardCondition"},{"location":"architecture/contracts/generated/solidity-api/#id_2","text":"function id () public pure returns ( uint256 )","title":"id"},{"location":"architecture/contracts/generated/solidity-api/#initialize_47","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockPaymentConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _transferConditionAddress address transfer NFT condition contract address _escrowPaymentAddress address payable escrow reward condition contract address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#nftprice","text":"mapping ( address => mapping ( address => mapping ( address => mapping ( bytes32 => uint256 )))) nftPrice","title":"nftPrice"},{"location":"architecture/contracts/generated/solidity-api/#nftsale","text":"function nftSale ( address nftAddress , bytes32 nftId , address token , uint256 amount ) external","title":"nftSale"},{"location":"architecture/contracts/generated/solidity-api/#checkparamstransfer","text":"function checkParamsTransfer ( bytes [] _params , bytes32 lockPaymentConditionId , bytes32 _did ) internal view returns ( address )","title":"checkParamsTransfer"},{"location":"architecture/contracts/generated/solidity-api/#checkparamsescrow","text":"function checkParamsEscrow ( bytes [] _params , bytes32 lockPaymentId , bytes32 transferId ) internal pure","title":"checkParamsEscrow"},{"location":"architecture/contracts/generated/solidity-api/#createagreementfulfill","text":"function createAgreementFulfill ( bytes32 _id , bytes32 _did , uint256 [] _timeLocks , uint256 [] _timeOuts , address _accessConsumer , bytes [] _params ) external payable","title":"createAgreementFulfill"},{"location":"architecture/contracts/generated/solidity-api/#nftsaleswithaccesstemplate","text":"_Implementation of NFT Sales Template The NFT Sales template supports an scenario where a NFT owner can sell that asset to a new Owner. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing a NFT owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer NFT Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the transfer of the NFT from the current owner for a specific DID._","title":"NFTSalesWithAccessTemplate"},{"location":"architecture/contracts/generated/solidity-api/#didregistry_18","text":"contract DIDRegistry didRegistry","title":"didRegistry"},{"location":"architecture/contracts/generated/solidity-api/#lockpaymentcondition_5","text":"contract LockPaymentCondition lockPaymentCondition","title":"lockPaymentCondition"},{"location":"architecture/contracts/generated/solidity-api/#transfercondition_3","text":"contract ITransferNFT transferCondition","title":"transferCondition"},{"location":"architecture/contracts/generated/solidity-api/#rewardcondition_3","text":"contract EscrowPaymentCondition rewardCondition","title":"rewardCondition"},{"location":"architecture/contracts/generated/solidity-api/#accesscondition_6","text":"contract AccessProofCondition accessCondition","title":"accessCondition"},{"location":"architecture/contracts/generated/solidity-api/#initialize_48","text":"function initialize ( address _owner , address _agreementStoreManagerAddress , address _lockPaymentConditionAddress , address _transferConditionAddress , address payable _escrowPaymentAddress , address _accessCondition ) external initialize init the contract with the following parameters. this function is called only once during the contract initialization. It initializes the ownable feature, and set push the required condition types including access secret store, lock reward and escrow reward conditions. Name Type Description _owner address contract's owner account address _agreementStoreManagerAddress address agreement store manager contract address _lockPaymentConditionAddress address lock reward condition contract address _transferConditionAddress address transfer NFT condition contract address _escrowPaymentAddress address payable escrow reward condition contract address _accessCondition address","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#templatestorelibrary","text":"_Implementation of the Template Store Library. Templates are blueprints for modular SEAs. When creating an Agreement, a templateId defines the condition and reward types that are instantiated in the ConditionStore._","title":"TemplateStoreLibrary"},{"location":"architecture/contracts/generated/solidity-api/#templatestate","text":"enum TemplateState { Uninitialized , Proposed , Approved , Revoked }","title":"TemplateState"},{"location":"architecture/contracts/generated/solidity-api/#template_1","text":"struct Template { enum TemplateStoreLibrary . TemplateState state ; address owner ; address lastUpdatedBy ; uint256 blockNumberUpdated ; }","title":"Template"},{"location":"architecture/contracts/generated/solidity-api/#templatelist","text":"struct TemplateList { mapping ( address &# x3D ; & gt ; struct TemplateStoreLibrary . Template ) templates ; address [] templateIds ; }","title":"TemplateList"},{"location":"architecture/contracts/generated/solidity-api/#propose","text":"function propose ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal returns ( uint256 size ) propose new template Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address Name Type Description size uint256 which is the index of the proposed template","title":"propose"},{"location":"architecture/contracts/generated/solidity-api/#approve_1","text":"function approve ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal approve new template Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address proposed template contract address","title":"approve"},{"location":"architecture/contracts/generated/solidity-api/#revoke","text":"function revoke ( struct TemplateStoreLibrary . TemplateList _self , address _id ) internal revoke new template Name Type Description _self struct TemplateStoreLibrary.TemplateList is the TemplateList storage pointer _id address approved template contract address","title":"revoke"},{"location":"architecture/contracts/generated/solidity-api/#templatestoremanager_1","text":"Implementation of the Template Store Manager. Templates are blueprints for modular SEAs. When creating an Agreement, a templateId defines the condition and reward types that are instantiated in the ConditionStore. This contract manages the life cycle of the template ( Propose \u2192 Approve \u2192 Revoke ).","title":"TemplateStoreManager"},{"location":"architecture/contracts/generated/solidity-api/#templatelist_1","text":"struct TemplateStoreLibrary . TemplateList templateList","title":"templateList"},{"location":"architecture/contracts/generated/solidity-api/#onlyownerortemplateowner","text":"modifier onlyOwnerOrTemplateOwner ( address _id )","title":"onlyOwnerOrTemplateOwner"},{"location":"architecture/contracts/generated/solidity-api/#initialize_49","text":"function initialize ( address _owner ) public initialize TemplateStoreManager Initializer Initializes Ownable. Only on contract creation. Name Type Description _owner address refers to the owner of the contract","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#proposetemplate","text":"function proposeTemplate ( address _id ) external returns ( uint256 size ) proposeTemplate proposes a new template Name Type Description _id address unique template identifier which is basically the template contract address","title":"proposeTemplate"},{"location":"architecture/contracts/generated/solidity-api/#approvetemplate","text":"function approveTemplate ( address _id ) external approveTemplate approves a template Name Type Description _id address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) can approve this template.","title":"approveTemplate"},{"location":"architecture/contracts/generated/solidity-api/#revoketemplate","text":"function revokeTemplate ( address _id ) external revokeTemplate revoke a template Name Type Description _id address unique template identifier which is basically the template contract address. Only template store manager owner (i.e OPNF) or template owner can revoke this template.","title":"revokeTemplate"},{"location":"architecture/contracts/generated/solidity-api/#gettemplate","text":"function getTemplate ( address _id ) external view returns ( enum TemplateStoreLibrary . TemplateState state , address owner , address lastUpdatedBy , uint256 blockNumberUpdated ) getTemplate get more information about a template Name Type Description _id address unique template identifier which is basically the template contract address. Name Type Description state enum TemplateStoreLibrary.TemplateState template status owner address template owner lastUpdatedBy address last updated by blockNumberUpdated uint256 last updated at.","title":"getTemplate"},{"location":"architecture/contracts/generated/solidity-api/#gettemplatelistsize","text":"function getTemplateListSize () external view virtual returns ( uint256 size ) getTemplateListSize number of templates Name Type Description size uint256 number of templates","title":"getTemplateListSize"},{"location":"architecture/contracts/generated/solidity-api/#istemplateapproved","text":"function isTemplateApproved ( address _id ) external view returns ( bool ) isTemplateApproved check whether the template is approved Name Type Description _id address unique template identifier which is basically the template contract address. Name Type Description [0] bool true if the template is approved","title":"isTemplateApproved"},{"location":"architecture/contracts/generated/solidity-api/#agreementstoremanagerchangefunctionsignature","text":"","title":"AgreementStoreManagerChangeFunctionSignature"},{"location":"architecture/contracts/generated/solidity-api/#createagreement_4","text":"function createAgreement ( bytes32 _id , bytes32 _did , address [] _conditionTypes , bytes32 [] _conditionIds , uint256 [] _timeLocks , uint256 [] _timeOuts , address _creator , address _sender ) public","title":"createAgreement"},{"location":"architecture/contracts/generated/solidity-api/#agreementstoremanagerchangeinstorage","text":"","title":"AgreementStoreManagerChangeInStorage"},{"location":"architecture/contracts/generated/solidity-api/#agreementcount","text":"uint256 agreementCount","title":"agreementCount"},{"location":"architecture/contracts/generated/solidity-api/#agreementstoremanagerchangeinstorageandlogic","text":"","title":"AgreementStoreManagerChangeInStorageAndLogic"},{"location":"architecture/contracts/generated/solidity-api/#agreementstoremanagerextrafunctionality","text":"","title":"AgreementStoreManagerExtraFunctionality"},{"location":"architecture/contracts/generated/solidity-api/#dummyfunction","text":"function dummyFunction () public pure returns ( bool )","title":"dummyFunction"},{"location":"architecture/contracts/generated/solidity-api/#agreementstoremanagerwithbug","text":"","title":"AgreementStoreManagerWithBug"},{"location":"architecture/contracts/generated/solidity-api/#getdidregistryaddress_1","text":"function getDIDRegistryAddress () public pure returns ( address ) getDIDRegistryAddress utility function used by other contracts or any EOA. Name Type Description [0] address the DIDRegistry address","title":"getDIDRegistryAddress"},{"location":"architecture/contracts/generated/solidity-api/#conditionstorechangefunctionsignature","text":"","title":"ConditionStoreChangeFunctionSignature"},{"location":"architecture/contracts/generated/solidity-api/#createcondition_2","text":"function createCondition ( bytes32 _id , address _typeRef , address _sender ) public","title":"createCondition"},{"location":"architecture/contracts/generated/solidity-api/#conditionstorechangeinstorage","text":"","title":"ConditionStoreChangeInStorage"},{"location":"architecture/contracts/generated/solidity-api/#conditioncount","text":"uint256 conditionCount","title":"conditionCount"},{"location":"architecture/contracts/generated/solidity-api/#conditionstorechangeinstorageandlogic","text":"","title":"ConditionStoreChangeInStorageAndLogic"},{"location":"architecture/contracts/generated/solidity-api/#conditionstoreextrafunctionality","text":"","title":"ConditionStoreExtraFunctionality"},{"location":"architecture/contracts/generated/solidity-api/#dummyfunction_1","text":"function dummyFunction () public pure returns ( bool )","title":"dummyFunction"},{"location":"architecture/contracts/generated/solidity-api/#conditionstorewithbug","text":"","title":"ConditionStoreWithBug"},{"location":"architecture/contracts/generated/solidity-api/#getconditionstate_1","text":"function getConditionState ( bytes32 _id ) public view returns ( enum ConditionStoreLibrary . ConditionState ) getConditionState Name Type Description [0] enum ConditionStoreLibrary.ConditionState condition state","title":"getConditionState"},{"location":"architecture/contracts/generated/solidity-api/#didregistrychangefunctionsignature","text":"","title":"DIDRegistryChangeFunctionSignature"},{"location":"architecture/contracts/generated/solidity-api/#registerattribute_1","text":"function registerAttribute ( bytes32 _didSeed , address [] _providers , bytes32 _checksum , string _url ) public","title":"registerAttribute"},{"location":"architecture/contracts/generated/solidity-api/#didregistrychangeinstorage","text":"","title":"DIDRegistryChangeInStorage"},{"location":"architecture/contracts/generated/solidity-api/#timeofregister","text":"mapping ( bytes32 => uint256 ) timeOfRegister","title":"timeOfRegister"},{"location":"architecture/contracts/generated/solidity-api/#didregistrychangeinstorageandlogic","text":"","title":"DIDRegistryChangeInStorageAndLogic"},{"location":"architecture/contracts/generated/solidity-api/#didregistryextrafunctionality","text":"","title":"DIDRegistryExtraFunctionality"},{"location":"architecture/contracts/generated/solidity-api/#getnumber","text":"function getNumber () public pure returns ( uint256 )","title":"getNumber"},{"location":"architecture/contracts/generated/solidity-api/#didregistrywithbug","text":"","title":"DIDRegistryWithBug"},{"location":"architecture/contracts/generated/solidity-api/#registerattribute_2","text":"function registerAttribute ( bytes32 _checksum , bytes32 _didSeed , address [] _providers , string _url ) public registerAttribute is called only by DID owner. this function registers DID attributes Name Type Description _checksum bytes32 includes a one-way HASH calculated using the DDO content _didSeed bytes32 refers to decentralized identifier (a byte32 length ID) _providers address[] _url string refers to the attribute value","title":"registerAttribute"},{"location":"architecture/contracts/generated/solidity-api/#ipnft","text":"","title":"IPNFT"},{"location":"architecture/contracts/generated/solidity-api/#tokenurichanged","text":"event TokenURIChanged ( uint256 tokenId , string newURI )","title":"TokenURIChanged"},{"location":"architecture/contracts/generated/solidity-api/#initialize_50","text":"function initialize ( string _name , string _symbol ) public","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#settokenuri","text":"function setTokenURI ( uint256 tokenId , string _tokenURI ) public","title":"setTokenURI"},{"location":"architecture/contracts/generated/solidity-api/#mint_5","text":"function mint ( address to , uint256 _tokenId , string _tokenURI ) public returns ( bool )","title":"mint"},{"location":"architecture/contracts/generated/solidity-api/#mintwithouttokenuri","text":"function mintWithoutTokenURI ( address to , uint256 _tokenId ) external","title":"mintWithoutTokenURI"},{"location":"architecture/contracts/generated/solidity-api/#transfer_2","text":"function transfer ( address from , address to , uint256 _tokenId ) public","title":"transfer"},{"location":"architecture/contracts/generated/solidity-api/#neverminedconfigchangeinstorage","text":"","title":"NeverminedConfigChangeInStorage"},{"location":"architecture/contracts/generated/solidity-api/#newvariable","text":"uint256 newVariable","title":"newVariable"},{"location":"architecture/contracts/generated/solidity-api/#neverminedconfigchangefunctionsignature","text":"","title":"NeverminedConfigChangeFunctionSignature"},{"location":"architecture/contracts/generated/solidity-api/#setmarketplacefees_2","text":"function setMarketplaceFees ( uint256 _marketplaceFee , address _feeReceiver , uint256 _newParameter ) external virtual","title":"setMarketplaceFees"},{"location":"architecture/contracts/generated/solidity-api/#neverminedconfigchangeinstorageandlogic","text":"","title":"NeverminedConfigChangeInStorageAndLogic"},{"location":"architecture/contracts/generated/solidity-api/#neverminedconfigwithbug","text":"","title":"NeverminedConfigWithBug"},{"location":"architecture/contracts/generated/solidity-api/#setmarketplacefees_3","text":"function setMarketplaceFees ( uint256 _marketplaceFee , address _feeReceiver ) external virtual The governor can update the Nevermined Marketplace fees Name Type Description _marketplaceFee uint256 new marketplace fee _feeReceiver address The address receiving the fee","title":"setMarketplaceFees"},{"location":"architecture/contracts/generated/solidity-api/#templatestorechangefunctionsignature","text":"","title":"TemplateStoreChangeFunctionSignature"},{"location":"architecture/contracts/generated/solidity-api/#proposetemplate_1","text":"function proposeTemplate ( address _id , address _sender ) external returns ( uint256 size )","title":"proposeTemplate"},{"location":"architecture/contracts/generated/solidity-api/#templatestorechangeinstorage","text":"","title":"TemplateStoreChangeInStorage"},{"location":"architecture/contracts/generated/solidity-api/#templatecount","text":"uint256 templateCount","title":"templateCount"},{"location":"architecture/contracts/generated/solidity-api/#templatestorechangeinstorageandlogic","text":"","title":"TemplateStoreChangeInStorageAndLogic"},{"location":"architecture/contracts/generated/solidity-api/#templatestoreextrafunctionality","text":"","title":"TemplateStoreExtraFunctionality"},{"location":"architecture/contracts/generated/solidity-api/#dummyfunction_2","text":"function dummyFunction () public pure returns ( bool )","title":"dummyFunction"},{"location":"architecture/contracts/generated/solidity-api/#templatestorewithbug","text":"","title":"TemplateStoreWithBug"},{"location":"architecture/contracts/generated/solidity-api/#gettemplatelistsize_1","text":"function getTemplateListSize () external view returns ( uint256 size ) getTemplateListSize number of templates Name Type Description size uint256 number of templates","title":"getTemplateListSize"},{"location":"architecture/contracts/generated/solidity-api/#testerc721","text":"","title":"TestERC721"},{"location":"architecture/contracts/generated/solidity-api/#initialize_51","text":"function initialize () public","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#mint_6","text":"function mint ( uint256 id ) public","title":"mint"},{"location":"architecture/contracts/generated/solidity-api/#didregistrylibraryproxy","text":"","title":"DIDRegistryLibraryProxy"},{"location":"architecture/contracts/generated/solidity-api/#didregister_1","text":"struct DIDRegistryLibrary . DIDRegister didRegister","title":"didRegister"},{"location":"architecture/contracts/generated/solidity-api/#didregisterlist_2","text":"struct DIDRegistryLibrary . DIDRegisterList didRegisterList","title":"didRegisterList"},{"location":"architecture/contracts/generated/solidity-api/#areroyaltiesvalid_2","text":"function areRoyaltiesValid ( bytes32 _did , uint256 [] _amounts , address [] _receivers , address _tokenAddress ) public view returns ( bool )","title":"areRoyaltiesValid"},{"location":"architecture/contracts/generated/solidity-api/#updatedidowner_1","text":"function updateDIDOwner ( bytes32 _did , address _newOwner ) public","title":"updateDIDOwner"},{"location":"architecture/contracts/generated/solidity-api/#update_3","text":"function update ( bytes32 _did , bytes32 _checksum , string _url ) public","title":"update"},{"location":"architecture/contracts/generated/solidity-api/#initializenftconfig_1","text":"function initializeNftConfig ( bytes32 _did , uint256 _cap , uint8 _royalties ) public","title":"initializeNftConfig"},{"location":"architecture/contracts/generated/solidity-api/#initializenft721config_1","text":"function initializeNft721Config ( bytes32 _did , uint8 _royalties ) public","title":"initializeNft721Config"},{"location":"architecture/contracts/generated/solidity-api/#getdidinfo","text":"function getDIDInfo ( bytes32 _did ) public view returns ( address owner , address creator , uint256 royalties )","title":"getDIDInfo"},{"location":"architecture/contracts/generated/solidity-api/#epochlibraryproxy","text":"","title":"EpochLibraryProxy"},{"location":"architecture/contracts/generated/solidity-api/#epoch_1","text":"struct EpochLibrary . Epoch epoch","title":"epoch"},{"location":"architecture/contracts/generated/solidity-api/#epochlist_2","text":"struct EpochLibrary . EpochList epochList","title":"epochList"},{"location":"architecture/contracts/generated/solidity-api/#create_5","text":"function create ( bytes32 _id , uint256 _timeLock , uint256 _timeOut ) external","title":"create"},{"location":"architecture/contracts/generated/solidity-api/#hashlistlibraryproxy","text":"","title":"HashListLibraryProxy"},{"location":"architecture/contracts/generated/solidity-api/#testdata","text":"struct HashListLibrary . List testData","title":"testData"},{"location":"architecture/contracts/generated/solidity-api/#initialize_52","text":"function initialize ( address _owner ) public","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#hash_1","text":"function hash ( address _address ) public pure returns ( bytes32 )","title":"hash"},{"location":"architecture/contracts/generated/solidity-api/#add_5","text":"function add ( bytes32 [] values ) external returns ( bool )","title":"add"},{"location":"architecture/contracts/generated/solidity-api/#add_6","text":"function add ( bytes32 value ) external returns ( bool )","title":"add"},{"location":"architecture/contracts/generated/solidity-api/#update_4","text":"function update ( bytes32 oldValue , bytes32 newValue ) external returns ( bool )","title":"update"},{"location":"architecture/contracts/generated/solidity-api/#index_2","text":"function index ( uint256 from , uint256 to ) external returns ( bool )","title":"index"},{"location":"architecture/contracts/generated/solidity-api/#has_5","text":"function has ( bytes32 value ) external view returns ( bool )","title":"has"},{"location":"architecture/contracts/generated/solidity-api/#remove_2","text":"function remove ( bytes32 value ) external returns ( bool )","title":"remove"},{"location":"architecture/contracts/generated/solidity-api/#get_2","text":"function get ( uint256 _index ) external view returns ( bytes32 )","title":"get"},{"location":"architecture/contracts/generated/solidity-api/#size_2","text":"function size () external view returns ( uint256 )","title":"size"},{"location":"architecture/contracts/generated/solidity-api/#all_2","text":"function all () external view returns ( bytes32 [])","title":"all"},{"location":"architecture/contracts/generated/solidity-api/#indexof_2","text":"function indexOf ( bytes32 value ) external view returns ( uint256 )","title":"indexOf"},{"location":"architecture/contracts/generated/solidity-api/#ownedby_2","text":"function ownedBy () external view returns ( address )","title":"ownedBy"},{"location":"architecture/contracts/generated/solidity-api/#isindexed_2","text":"function isIndexed () external view returns ( bool )","title":"isIndexed"},{"location":"architecture/contracts/generated/solidity-api/#nftbase","text":"Implementation of the Royalties EIP-2981 base contract See https://eips.ethereum.org/EIPS/eip-2981","title":"NFTBase"},{"location":"architecture/contracts/generated/solidity-api/#_proxyapprovals","text":"mapping ( address => bool ) _proxyApprovals","title":"_proxyApprovals"},{"location":"architecture/contracts/generated/solidity-api/#minter_role","text":"bytes32 MINTER_ROLE","title":"MINTER_ROLE"},{"location":"architecture/contracts/generated/solidity-api/#royaltyinfo","text":"struct RoyaltyInfo { address receiver ; uint256 royaltyAmount ; }","title":"RoyaltyInfo"},{"location":"architecture/contracts/generated/solidity-api/#nftmetadata","text":"struct NFTMetadata { string nftURI ; }","title":"NFTMetadata"},{"location":"architecture/contracts/generated/solidity-api/#_royalties","text":"mapping ( uint256 => struct NFTBase . RoyaltyInfo ) _royalties","title":"_royalties"},{"location":"architecture/contracts/generated/solidity-api/#_metadata","text":"mapping ( uint256 => struct NFTBase . NFTMetadata ) _metadata","title":"_metadata"},{"location":"architecture/contracts/generated/solidity-api/#_expiration","text":"mapping ( address => uint256 ) _expiration","title":"_expiration"},{"location":"architecture/contracts/generated/solidity-api/#proxyapproval","text":"event ProxyApproval ( address sender , address operator , bool approved ) Event for recording proxy approvals.","title":"ProxyApproval"},{"location":"architecture/contracts/generated/solidity-api/#setproxyapproval","text":"function setProxyApproval ( address operator , bool approved ) public virtual","title":"setProxyApproval"},{"location":"architecture/contracts/generated/solidity-api/#_setnftmetadata","text":"function _setNFTMetadata ( uint256 tokenId , string tokenURI ) internal","title":"_setNFTMetadata"},{"location":"architecture/contracts/generated/solidity-api/#_settokenroyalty","text":"function _setTokenRoyalty ( uint256 tokenId , address receiver , uint256 royaltyAmount ) internal","title":"_setTokenRoyalty"},{"location":"architecture/contracts/generated/solidity-api/#royaltyinfo_1","text":"function royaltyInfo ( uint256 tokenId , uint256 value ) external view returns ( address receiver , uint256 royaltyAmount ) @inheritdoc IERC2981Upgradeable","title":"royaltyInfo"},{"location":"architecture/contracts/generated/solidity-api/#nftupgradeable","text":"Implementation of the basic standard multi-token. See https://eips.ethereum.org/EIPS/eip-1155","title":"NFTUpgradeable"},{"location":"architecture/contracts/generated/solidity-api/#initialize_53","text":"function initialize ( string uri_ ) public See {_setURI}.","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#isapprovedforall","text":"function isApprovedForAll ( address account , address operator ) public view virtual returns ( bool ) See {IERC1155-isApprovedForAll}.","title":"isApprovedForAll"},{"location":"architecture/contracts/generated/solidity-api/#mint_7","text":"function mint ( address to , uint256 id , uint256 amount , bytes data ) public","title":"mint"},{"location":"architecture/contracts/generated/solidity-api/#burn_3","text":"function burn ( address to , uint256 id , uint256 amount ) public","title":"burn"},{"location":"architecture/contracts/generated/solidity-api/#addminter","text":"function addMinter ( address account ) public","title":"addMinter"},{"location":"architecture/contracts/generated/solidity-api/#uri","text":"function uri ( uint256 tokenId ) public view returns ( string )","title":"uri"},{"location":"architecture/contracts/generated/solidity-api/#setnftmetadata","text":"function setNFTMetadata ( uint256 tokenId , string nftURI ) public Record some NFT Metadata Name Type Description tokenId uint256 the id of the asset with the royalties associated nftURI string the URI (https, ipfs, etc) to the metadata describing the NFT","title":"setNFTMetadata"},{"location":"architecture/contracts/generated/solidity-api/#settokenroyalty","text":"function setTokenRoyalty ( uint256 tokenId , address receiver , uint256 royaltyAmount ) public Record the asset royalties Name Type Description tokenId uint256 the id of the asset with the royalties associated receiver address the receiver of the royalties (the original creator) royaltyAmount uint256 percentage (no decimals, between 0 and 100)","title":"setTokenRoyalty"},{"location":"architecture/contracts/generated/solidity-api/#supportsinterface_2","text":"function supportsInterface ( bytes4 interfaceId ) public view virtual returns ( bool )","title":"supportsInterface"},{"location":"architecture/contracts/generated/solidity-api/#nft721subscriptionupgradeable","text":"","title":"NFT721SubscriptionUpgradeable"},{"location":"architecture/contracts/generated/solidity-api/#mint_8","text":"function mint ( address to , uint256 id , uint256 expirationBlock ) public _This mint function allows to define when the NFT expires. The minter should calculate this block number depending on the network velocity TransferNFT721Condition needs to have the MINTER_ROLE _","title":"mint"},{"location":"architecture/contracts/generated/solidity-api/#balanceof_1","text":"function balanceOf ( address owner ) public view returns ( uint256 ) See {IERC721-balanceOf}.","title":"balanceOf"},{"location":"architecture/contracts/generated/solidity-api/#nft721upgradeable","text":"Implementation of the basic standard multi-token.","title":"NFT721Upgradeable"},{"location":"architecture/contracts/generated/solidity-api/#initialize_54","text":"function initialize ( string name , string symbol ) public virtual","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#initialize_55","text":"function initialize () public virtual","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#isapprovedforall_1","text":"function isApprovedForAll ( address account , address operator ) public view virtual returns ( bool ) See {IERC1155-isApprovedForAll}.","title":"isApprovedForAll"},{"location":"architecture/contracts/generated/solidity-api/#addminter_1","text":"function addMinter ( address account ) public","title":"addMinter"},{"location":"architecture/contracts/generated/solidity-api/#mint_9","text":"function mint ( address to , uint256 id ) public virtual","title":"mint"},{"location":"architecture/contracts/generated/solidity-api/#burn_4","text":"function burn ( uint256 id ) public","title":"burn"},{"location":"architecture/contracts/generated/solidity-api/#tokenuri","text":"function tokenURI ( uint256 tokenId ) public view virtual returns ( string ) See {IERC721Metadata-tokenURI}.","title":"tokenURI"},{"location":"architecture/contracts/generated/solidity-api/#setnftmetadata_1","text":"function setNFTMetadata ( uint256 tokenId , string nftURI ) public Record some NFT Metadata Name Type Description tokenId uint256 the id of the asset with the royalties associated nftURI string the URI (https, ipfs, etc) to the metadata describing the NFT","title":"setNFTMetadata"},{"location":"architecture/contracts/generated/solidity-api/#settokenroyalty_1","text":"function setTokenRoyalty ( uint256 tokenId , address receiver , uint256 royaltyAmount ) public Record the asset royalties Name Type Description tokenId uint256 the id of the asset with the royalties associated receiver address the receiver of the royalties (the original creator) royaltyAmount uint256 percentage (no decimals, between 0 and 100)","title":"setTokenRoyalty"},{"location":"architecture/contracts/generated/solidity-api/#supportsinterface_3","text":"function supportsInterface ( bytes4 interfaceId ) public view virtual returns ( bool )","title":"supportsInterface"},{"location":"architecture/contracts/generated/solidity-api/#poapupgradeable","text":"","title":"POAPUpgradeable"},{"location":"architecture/contracts/generated/solidity-api/#_tokenidcounter","text":"struct CountersUpgradeable . Counter _tokenIdCounter","title":"_tokenIdCounter"},{"location":"architecture/contracts/generated/solidity-api/#_tokenevent","text":"mapping ( uint256 => uint256 ) _tokenEvent","title":"_tokenEvent"},{"location":"architecture/contracts/generated/solidity-api/#initialize_56","text":"function initialize () public","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#initialize_57","text":"function initialize ( string name , string symbol ) public virtual","title":"initialize"},{"location":"architecture/contracts/generated/solidity-api/#mint_10","text":"function mint ( address to , string uri , uint256 eventId ) public","title":"mint"},{"location":"architecture/contracts/generated/solidity-api/#mint_11","text":"function mint ( address to , uint256 id ) public","title":"mint"},{"location":"architecture/contracts/generated/solidity-api/#tokenevent","text":"function tokenEvent ( uint256 tokenId ) public view returns ( uint256 )","title":"tokenEvent"},{"location":"architecture/contracts/generated/solidity-api/#_beforetokentransfer_1","text":"function _beforeTokenTransfer ( address from , address to , uint256 tokenId ) internal","title":"_beforeTokenTransfer"},{"location":"architecture/contracts/generated/solidity-api/#_burn","text":"function _burn ( uint256 tokenId ) internal","title":"_burn"},{"location":"architecture/contracts/generated/solidity-api/#tokendetailsofowner","text":"function tokenDetailsOfOwner ( address owner ) public view returns ( uint256 [] tokenIds , uint256 [] eventIds )","title":"tokenDetailsOfOwner"},{"location":"architecture/contracts/generated/solidity-api/#tokenuri_1","text":"function tokenURI ( uint256 tokenId ) public view returns ( string )","title":"tokenURI"},{"location":"architecture/contracts/generated/solidity-api/#isapprovedforall_2","text":"function isApprovedForAll ( address account , address operator ) public view returns ( bool )","title":"isApprovedForAll"},{"location":"architecture/contracts/generated/solidity-api/#supportsinterface_4","text":"function supportsInterface ( bytes4 interfaceId ) public view virtual returns ( bool )","title":"supportsInterface"},{"location":"architecture/contracts/generated/solidity-api/#plonkverifier","text":"","title":"PlonkVerifier"},{"location":"architecture/contracts/generated/solidity-api/#n","text":"uint32 n","title":"n"},{"location":"architecture/contracts/generated/solidity-api/#npublic","text":"uint16 nPublic","title":"nPublic"},{"location":"architecture/contracts/generated/solidity-api/#nlagrange","text":"uint16 nLagrange","title":"nLagrange"},{"location":"architecture/contracts/generated/solidity-api/#qmx","text":"uint256 Qmx","title":"Qmx"},{"location":"architecture/contracts/generated/solidity-api/#qmy","text":"uint256 Qmy","title":"Qmy"},{"location":"architecture/contracts/generated/solidity-api/#qlx","text":"uint256 Qlx","title":"Qlx"},{"location":"architecture/contracts/generated/solidity-api/#qly","text":"uint256 Qly","title":"Qly"},{"location":"architecture/contracts/generated/solidity-api/#qrx","text":"uint256 Qrx","title":"Qrx"},{"location":"architecture/contracts/generated/solidity-api/#qry","text":"uint256 Qry","title":"Qry"},{"location":"architecture/contracts/generated/solidity-api/#qox","text":"uint256 Qox","title":"Qox"},{"location":"architecture/contracts/generated/solidity-api/#qoy","text":"uint256 Qoy","title":"Qoy"},{"location":"architecture/contracts/generated/solidity-api/#qcx","text":"uint256 Qcx","title":"Qcx"},{"location":"architecture/contracts/generated/solidity-api/#qcy","text":"uint256 Qcy","title":"Qcy"},{"location":"architecture/contracts/generated/solidity-api/#s1x","text":"uint256 S1x","title":"S1x"},{"location":"architecture/contracts/generated/solidity-api/#s1y","text":"uint256 S1y","title":"S1y"},{"location":"architecture/contracts/generated/solidity-api/#s2x","text":"uint256 S2x","title":"S2x"},{"location":"architecture/contracts/generated/solidity-api/#s2y","text":"uint256 S2y","title":"S2y"},{"location":"architecture/contracts/generated/solidity-api/#s3x","text":"uint256 S3x","title":"S3x"},{"location":"architecture/contracts/generated/solidity-api/#s3y","text":"uint256 S3y","title":"S3y"},{"location":"architecture/contracts/generated/solidity-api/#k1","text":"uint256 k1","title":"k1"},{"location":"architecture/contracts/generated/solidity-api/#k2","text":"uint256 k2","title":"k2"},{"location":"architecture/contracts/generated/solidity-api/#x2x1","text":"uint256 X2x1","title":"X2x1"},{"location":"architecture/contracts/generated/solidity-api/#x2x2","text":"uint256 X2x2","title":"X2x2"},{"location":"architecture/contracts/generated/solidity-api/#x2y1","text":"uint256 X2y1","title":"X2y1"},{"location":"architecture/contracts/generated/solidity-api/#x2y2","text":"uint256 X2y2","title":"X2y2"},{"location":"architecture/contracts/generated/solidity-api/#q","text":"uint256 q","title":"q"},{"location":"architecture/contracts/generated/solidity-api/#qf","text":"uint256 qf","title":"qf"},{"location":"architecture/contracts/generated/solidity-api/#w1","text":"uint256 w1","title":"w1"},{"location":"architecture/contracts/generated/solidity-api/#g1x","text":"uint256 G1x","title":"G1x"},{"location":"architecture/contracts/generated/solidity-api/#g1y","text":"uint256 G1y","title":"G1y"},{"location":"architecture/contracts/generated/solidity-api/#g2x1","text":"uint256 G2x1","title":"G2x1"},{"location":"architecture/contracts/generated/solidity-api/#g2x2","text":"uint256 G2x2","title":"G2x2"},{"location":"architecture/contracts/generated/solidity-api/#g2y1","text":"uint256 G2y1","title":"G2y1"},{"location":"architecture/contracts/generated/solidity-api/#g2y2","text":"uint256 G2y2","title":"G2y2"},{"location":"architecture/contracts/generated/solidity-api/#pa","text":"uint16 pA","title":"pA"},{"location":"architecture/contracts/generated/solidity-api/#pb","text":"uint16 pB","title":"pB"},{"location":"architecture/contracts/generated/solidity-api/#pc","text":"uint16 pC","title":"pC"},{"location":"architecture/contracts/generated/solidity-api/#pz","text":"uint16 pZ","title":"pZ"},{"location":"architecture/contracts/generated/solidity-api/#pt1","text":"uint16 pT1","title":"pT1"},{"location":"architecture/contracts/generated/solidity-api/#pt2","text":"uint16 pT2","title":"pT2"},{"location":"architecture/contracts/generated/solidity-api/#pt3","text":"uint16 pT3","title":"pT3"},{"location":"architecture/contracts/generated/solidity-api/#pwxi","text":"uint16 pWxi","title":"pWxi"},{"location":"architecture/contracts/generated/solidity-api/#pwxiw","text":"uint16 pWxiw","title":"pWxiw"},{"location":"architecture/contracts/generated/solidity-api/#peval_a","text":"uint16 pEval_a","title":"pEval_a"},{"location":"architecture/contracts/generated/solidity-api/#peval_b","text":"uint16 pEval_b","title":"pEval_b"},{"location":"architecture/contracts/generated/solidity-api/#peval_c","text":"uint16 pEval_c","title":"pEval_c"},{"location":"architecture/contracts/generated/solidity-api/#peval_s1","text":"uint16 pEval_s1","title":"pEval_s1"},{"location":"architecture/contracts/generated/solidity-api/#peval_s2","text":"uint16 pEval_s2","title":"pEval_s2"},{"location":"architecture/contracts/generated/solidity-api/#peval_zw","text":"uint16 pEval_zw","title":"pEval_zw"},{"location":"architecture/contracts/generated/solidity-api/#peval_r","text":"uint16 pEval_r","title":"pEval_r"},{"location":"architecture/contracts/generated/solidity-api/#palpha","text":"uint16 pAlpha","title":"pAlpha"},{"location":"architecture/contracts/generated/solidity-api/#pbeta","text":"uint16 pBeta","title":"pBeta"},{"location":"architecture/contracts/generated/solidity-api/#pgamma","text":"uint16 pGamma","title":"pGamma"},{"location":"architecture/contracts/generated/solidity-api/#pxi","text":"uint16 pXi","title":"pXi"},{"location":"architecture/contracts/generated/solidity-api/#pxin","text":"uint16 pXin","title":"pXin"},{"location":"architecture/contracts/generated/solidity-api/#pbetaxi","text":"uint16 pBetaXi","title":"pBetaXi"},{"location":"architecture/contracts/generated/solidity-api/#pv1","text":"uint16 pV1","title":"pV1"},{"location":"architecture/contracts/generated/solidity-api/#pv2","text":"uint16 pV2","title":"pV2"},{"location":"architecture/contracts/generated/solidity-api/#pv3","text":"uint16 pV3","title":"pV3"},{"location":"architecture/contracts/generated/solidity-api/#pv4","text":"uint16 pV4","title":"pV4"},{"location":"architecture/contracts/generated/solidity-api/#pv5","text":"uint16 pV5","title":"pV5"},{"location":"architecture/contracts/generated/solidity-api/#pv6","text":"uint16 pV6","title":"pV6"},{"location":"architecture/contracts/generated/solidity-api/#pu","text":"uint16 pU","title":"pU"},{"location":"architecture/contracts/generated/solidity-api/#ppl","text":"uint16 pPl","title":"pPl"},{"location":"architecture/contracts/generated/solidity-api/#peval_t","text":"uint16 pEval_t","title":"pEval_t"},{"location":"architecture/contracts/generated/solidity-api/#pa1","text":"uint16 pA1","title":"pA1"},{"location":"architecture/contracts/generated/solidity-api/#pb1","text":"uint16 pB1","title":"pB1"},{"location":"architecture/contracts/generated/solidity-api/#pzh","text":"uint16 pZh","title":"pZh"},{"location":"architecture/contracts/generated/solidity-api/#pzhinv","text":"uint16 pZhInv","title":"pZhInv"},{"location":"architecture/contracts/generated/solidity-api/#peval_l1","text":"uint16 pEval_l1","title":"pEval_l1"},{"location":"architecture/contracts/generated/solidity-api/#peval_l2","text":"uint16 pEval_l2","title":"pEval_l2"},{"location":"architecture/contracts/generated/solidity-api/#peval_l3","text":"uint16 pEval_l3","title":"pEval_l3"},{"location":"architecture/contracts/generated/solidity-api/#peval_l4","text":"uint16 pEval_l4","title":"pEval_l4"},{"location":"architecture/contracts/generated/solidity-api/#peval_l5","text":"uint16 pEval_l5","title":"pEval_l5"},{"location":"architecture/contracts/generated/solidity-api/#peval_l6","text":"uint16 pEval_l6","title":"pEval_l6"},{"location":"architecture/contracts/generated/solidity-api/#peval_l7","text":"uint16 pEval_l7","title":"pEval_l7"},{"location":"architecture/contracts/generated/solidity-api/#lastmem","text":"uint16 lastMem","title":"lastMem"},{"location":"architecture/contracts/generated/solidity-api/#verifyproof_1","text":"function verifyProof ( bytes proof , uint256 [] pubSignals ) public view returns ( bool )","title":"verifyProof"},{"location":"architecture/integrations/aave/nft-collateral-agreement/","text":"NFTs collateralization via Nevermined and Aave integration \u00b6 shortname: AAV-NFT name: NFT Collateral Agreements type: Standard status: Draft version: 0.1 Table of Contents \u00b6 NFTs collateralization via Nevermined and Aave integration Table of Contents Price discovery Value Integration Details Architecture User Flows Setting up the credit What happens when credit is not repaid in time Aave credit template Nevermined is an Open Source solution developed by Keyko , offering the users the ability to build ecosystems where untrusted parties can share and monetize their digital assets in a way that\u2019s efficient, secure and privacy preserving. On top of this Nevermined provides the mechanisms to tokenize these digital assets allowing content creators to trade and transfer them in a secure way. It is designed to support the following use cases: Art publishing, exhibition, selling. Secondary market Collection of objects Tokenization of digital and physical assets (real estate, etc.) Using this baseline, Nevermined will provide to digital assets owners the possibility of leverage them via their utilization in Decentralized Finance (DeFi) scenarios. In this document we introduce the architecture of Nevermined integrating Aave protocol. This will allow the NFT marketplaces built on Nevermined to augment their existing functionality for their communities allowing loans using NFTs as collateral. This functionality will be offered as a library for these marketplaces, providing new functionalities without lower level integrations with Nevermined or Aave protocols. Price discovery \u00b6 Assets price discovery is a complex topic out of the scope of this integration . The focus of this specific integration is to allow NFT owners (ERC-721) to use them as collateral for their loans. The support of ERC-1155 will be evaluated in further phases. The process of negotiating between Lenders and Borrowers can be done via marketplace (see nftfi ). One of the key factors in setting up a credit collateralized by an asset is how to establish that asset price. Depending on the use case there are different options: No external interaction. Pure negotiation between lender and borrower. Auctions or additional mechanisms can be used. Central or distributed independent authority (notary) setting up independent valuations. In the art sector can be curators, real estate can be a local authority. Notaries can be rewarded and be curated themselves by the network. Each non-fungible asset is associated with a token (ERC20 or ERC1155) and its own AMM. Users can stake/add liquidity, working as automatic way to curate the assets. On top of the price of an asset different credit conditions can be established (repayment period and assets). Value \u00b6 The integration of Aave into Nevermined brings is valuable because: Facilitate for NFT owners to put their assets at work. NFT owners can leverage their assets and get liquidity they can use any way they want. Facilitate a new business where users can loan to others and get a fee for that (or the collateral if the borrower doesn't refund to the lender) Bring more usage to Aave protocol Bring more usage to Nevermined Integration Details \u00b6 The integration of Aave require the modification and delivery of the following components: The Nevermined Contracts . It will be necessary to extend the Service Agreements to provide a new template and the conditions required to execute a fully end-to-end scenario with the different options. SDK-JS . Javascript library exposing the Nevermined service agreements for an easier integration Architecture \u00b6 User Flows \u00b6 The final goal is to have a fully functional end to end integration, allowing for the users to ask for a credit backed by their NFTs (ERC-721): Setting up the credit \u00b6 Setting up the Credit Line This is the happy path for a end-to-end flow. Steps: The Borrower or the Lender agree on terms (off-chain via Marketplace for example) for a credit line. When this happens any of them can initialize a service agreement on-chain with the credit conditions. This service agreement will be based in a new template: AaveCreditTemplate . As part of this process a new instance of the AaveVault contract will be deployed on-chain. This contract will lock the borrower NFT and the lender ERC20 collateral. The Borrower and the Lender can review that contract properties are aligned with their initial agreement. The Borrower locks the NFT in the Vault contract instance via NVM NFTLock condition The Lender locks the payment in the Vault contract instance via the AaveCollateralDeposit condition. When this happens NVM call the Aave approveDelegation method allowing to borrow from Aave The Borrower borrow from NVM via AaveBorrowCredit condition After some time the Borrower repays the credit through NVM fulfilling the AaveRepayCredit condition. The Borrower request transfer back the NFT to NVM via DistributeNFTCollateral condition What happens when credit is not repaid in time \u00b6 In the case the credit is not repaid in time, the borrower will get the NFT in return: Credit is not repaid in time Steps: The Borrower try to repay the credit when this is already expired The contracts gets debt amount via the Aave getUserAccountData contract call and checks if the credit already expired or the condition timeout is expired If that is the case, the AaveRepayCredit condition will change the state to aborted If the Lender or the Borrower call the DistributeNFTCollateral condition and the AaveRepayCredit condition is aborted, the NFT will be transfered to the Lender instead of the Borrower In addition to this the pending fees will be transferred to Aave This scenario can happens also if the Lender inform about a credit expired via AaveRepayCredit condition Aave credit template \u00b6 Setting up the Credit Line NVM will provide a new template integrating the following conditions: Lock NFT - When called by the Borrower will lock the ERC-721 NFT into the Aave Vault Aave Collateral Deposit - When called by the Lender will lock the credit funds into the Aave Vault and approve the delegation into Aave Aave Borrow Credit - When called by the Borrower will borrow the credit funds from Aave Vault Aave Repay Credit - When called by the Borrower will repay the credit funds into Aave Vault Transfer NFT - When called by the Borrower or the Lender will transfer the NFT to one of them depending if credit was repaid in time or not Distribute Payment - Distribute the payments and fees between the users depending of the above conditions","title":"NFTs collateralization via Nevermined and Aave integration"},{"location":"architecture/integrations/aave/nft-collateral-agreement/#nfts-collateralization-via-nevermined-and-aave-integration","text":"shortname: AAV-NFT name: NFT Collateral Agreements type: Standard status: Draft version: 0.1","title":"NFTs collateralization via Nevermined and Aave integration"},{"location":"architecture/integrations/aave/nft-collateral-agreement/#table-of-contents","text":"NFTs collateralization via Nevermined and Aave integration Table of Contents Price discovery Value Integration Details Architecture User Flows Setting up the credit What happens when credit is not repaid in time Aave credit template Nevermined is an Open Source solution developed by Keyko , offering the users the ability to build ecosystems where untrusted parties can share and monetize their digital assets in a way that\u2019s efficient, secure and privacy preserving. On top of this Nevermined provides the mechanisms to tokenize these digital assets allowing content creators to trade and transfer them in a secure way. It is designed to support the following use cases: Art publishing, exhibition, selling. Secondary market Collection of objects Tokenization of digital and physical assets (real estate, etc.) Using this baseline, Nevermined will provide to digital assets owners the possibility of leverage them via their utilization in Decentralized Finance (DeFi) scenarios. In this document we introduce the architecture of Nevermined integrating Aave protocol. This will allow the NFT marketplaces built on Nevermined to augment their existing functionality for their communities allowing loans using NFTs as collateral. This functionality will be offered as a library for these marketplaces, providing new functionalities without lower level integrations with Nevermined or Aave protocols.","title":"Table of Contents"},{"location":"architecture/integrations/aave/nft-collateral-agreement/#price-discovery","text":"Assets price discovery is a complex topic out of the scope of this integration . The focus of this specific integration is to allow NFT owners (ERC-721) to use them as collateral for their loans. The support of ERC-1155 will be evaluated in further phases. The process of negotiating between Lenders and Borrowers can be done via marketplace (see nftfi ). One of the key factors in setting up a credit collateralized by an asset is how to establish that asset price. Depending on the use case there are different options: No external interaction. Pure negotiation between lender and borrower. Auctions or additional mechanisms can be used. Central or distributed independent authority (notary) setting up independent valuations. In the art sector can be curators, real estate can be a local authority. Notaries can be rewarded and be curated themselves by the network. Each non-fungible asset is associated with a token (ERC20 or ERC1155) and its own AMM. Users can stake/add liquidity, working as automatic way to curate the assets. On top of the price of an asset different credit conditions can be established (repayment period and assets).","title":"Price discovery"},{"location":"architecture/integrations/aave/nft-collateral-agreement/#value","text":"The integration of Aave into Nevermined brings is valuable because: Facilitate for NFT owners to put their assets at work. NFT owners can leverage their assets and get liquidity they can use any way they want. Facilitate a new business where users can loan to others and get a fee for that (or the collateral if the borrower doesn't refund to the lender) Bring more usage to Aave protocol Bring more usage to Nevermined","title":"Value"},{"location":"architecture/integrations/aave/nft-collateral-agreement/#integration-details","text":"The integration of Aave require the modification and delivery of the following components: The Nevermined Contracts . It will be necessary to extend the Service Agreements to provide a new template and the conditions required to execute a fully end-to-end scenario with the different options. SDK-JS . Javascript library exposing the Nevermined service agreements for an easier integration","title":"Integration Details"},{"location":"architecture/integrations/aave/nft-collateral-agreement/#architecture","text":"","title":"Architecture"},{"location":"architecture/integrations/aave/nft-collateral-agreement/#user-flows","text":"The final goal is to have a fully functional end to end integration, allowing for the users to ask for a credit backed by their NFTs (ERC-721):","title":"User Flows"},{"location":"architecture/integrations/aave/nft-collateral-agreement/#setting-up-the-credit","text":"Setting up the Credit Line This is the happy path for a end-to-end flow. Steps: The Borrower or the Lender agree on terms (off-chain via Marketplace for example) for a credit line. When this happens any of them can initialize a service agreement on-chain with the credit conditions. This service agreement will be based in a new template: AaveCreditTemplate . As part of this process a new instance of the AaveVault contract will be deployed on-chain. This contract will lock the borrower NFT and the lender ERC20 collateral. The Borrower and the Lender can review that contract properties are aligned with their initial agreement. The Borrower locks the NFT in the Vault contract instance via NVM NFTLock condition The Lender locks the payment in the Vault contract instance via the AaveCollateralDeposit condition. When this happens NVM call the Aave approveDelegation method allowing to borrow from Aave The Borrower borrow from NVM via AaveBorrowCredit condition After some time the Borrower repays the credit through NVM fulfilling the AaveRepayCredit condition. The Borrower request transfer back the NFT to NVM via DistributeNFTCollateral condition","title":"Setting up the credit"},{"location":"architecture/integrations/aave/nft-collateral-agreement/#what-happens-when-credit-is-not-repaid-in-time","text":"In the case the credit is not repaid in time, the borrower will get the NFT in return: Credit is not repaid in time Steps: The Borrower try to repay the credit when this is already expired The contracts gets debt amount via the Aave getUserAccountData contract call and checks if the credit already expired or the condition timeout is expired If that is the case, the AaveRepayCredit condition will change the state to aborted If the Lender or the Borrower call the DistributeNFTCollateral condition and the AaveRepayCredit condition is aborted, the NFT will be transfered to the Lender instead of the Borrower In addition to this the pending fees will be transferred to Aave This scenario can happens also if the Lender inform about a credit expired via AaveRepayCredit condition","title":"What happens when credit is not repaid in time"},{"location":"architecture/integrations/aave/nft-collateral-agreement/#aave-credit-template","text":"Setting up the Credit Line NVM will provide a new template integrating the following conditions: Lock NFT - When called by the Borrower will lock the ERC-721 NFT into the Aave Vault Aave Collateral Deposit - When called by the Lender will lock the credit funds into the Aave Vault and approve the delegation into Aave Aave Borrow Credit - When called by the Borrower will borrow the credit funds from Aave Vault Aave Repay Credit - When called by the Borrower will repay the credit funds into Aave Vault Transfer NFT - When called by the Borrower or the Lender will transfer the NFT to one of them depending if credit was repaid in time or not Distribute Payment - Distribute the payments and fees between the users depending of the above conditions","title":"Aave credit template"},{"location":"architecture/integrations/filecoin/filecoin-storage/","text":"Integration of Filecoin as decentralized storage for Nevermined users \u00b6 shortname: FIL-STO name: Filecoin Storage Integration type: Standard status: Draft version: 0.1 Nevermined is an Open Source solution developed by Keyko , offering the users the ability to build data sharing ecosystems where untrusted parties can share and monetize their data in a way that\u2019s efficient, secure and privacy preserving. As data creation continues to proliferate, entities have the necessity of organising, understanding, using and sharing their data internally and externally. Nevermined provides Data Sharing and Data In-Situ Computation solutions that allow organizations to unlock data for a more insights-driven approach. What we call a Data Ecosystem is an environment where independent organizations can cooperate with each other to publish, discover, and access data and the associated assets and services. Nevermined enables the usage of data without the members of these ecosystems having to lose control of their assets. One of the main principles of Nevermined is that Data Owners and Providers always keep control of their data. The solution is designed to be integrated with existing Big Data environments and allows for the execution of models or algorithms in-situ, or where the data resides. With Nevermined, the data never moves; instead the algorithms and models move to where the data sits. Currently Nevermined integrated with the most popular centralized/cloud based storage providers (Amazon S3, Azure, etc.). This document details the integration of Nevermined with Filecoin allowing to: Use Filecoin as one of the options supported allowing Nevermined users to publish & share their data via Filecoin Facilitate access control & data monetization of Filecoin existing data Enable a decentralized storage solution where users don't need to upload their data to any existing centralized solution Nevermined & Filecoin High Level integration Value \u00b6 The integration of Filecoin into Nevermined brings is valuable for Filecoin community because: Increase the usage of Filecoin network Provides utility to Filecoin network via integration with existing and mature Open Source software Filecoin doesn't provide a granular access control allowing the data owners or publishers to decided when, and from whom their data can be accessed Allows user using centralized data storage based on cloud providers to use Filecoin as alternative Nevermined is L2 solution, network independent, and can be deployed in public or private networks. Via this integration, Filecoin could be used in any Nevermined user deployment Nevermined provides compute to the data and provenance (based on W3C PROV) capabilities. Via the integration, the Filecoin community would be able to use high value capabilities on top of their data Integration Details \u00b6 The integration of Filecoin as a fully supported storage provider require the modification and delivery of the following components: The Nevermined Gateway . This component is in charge of making available Nevermined users data. Before this integration the gateway supports different storage providers (Amazon S3, Azure, On Premise, etc.). This integration adds support to Filecoin as storage mechanism allowing to decrypt user urls and resolve Filecoin CIDs. The Nevermined SDKs. To facilitate user adoption, Nevermined support SDKs in 3 different programming languages: Javascript SDK , to facilitate the integration of Nevermined in web interfaces and DApps Python SDK , to facilitate the integration of Nevermined in data science tools It will deliver a modification of the 3 SDKs allowing to the users to publish in Nevermined Filecoin contents (CIDs) Java SDK , to facilitate the integration of Nevermined with existing industry big data solutions. Marketplace . It's a frontend application where users can publish and share files. The intention is to modify this application to support data sharing of assets stored in the Filecoin network. User Flows \u00b6 The final goal is to have a fully functional end to end integration, allowing for the registering of existing Filecoin assets into the Nevermined network: Registering of Filecoin assets into Nevermined After this publishing flow, it's intended to provide the downloading functionality (after access control) of Filecoin contents registered in the Nevermined network: Data Access of Filecoin assets existing into Nevermined Architecture \u00b6 The Nevermined architecture is evolved to integrate Powergate as gateway for supporting Filecoin data store. That integration requires the following modifications: SDKs \u00b6 The publishing flow of Nevermined assets allows to include CIDs as files The consumption flow of Nevermined assets integrates the gateway and work with assets including Filecoin files The SDK will include in the Metadata files attribute a URL using the cid prefix. Example: \"files\" : [ { \"url\" : \"cid://QmW68jbcqSRtqSQb6xkukQ6tfonZGhu1VrZv9zAicNmovs\" , \"index\" : 0 , \"checksum\" : \"efb2c764274b745f5fc37f97c6b0e761\" , \"contentLength\" : \"4535431\" , \"contentType\" : \"text/csv\" , \"encoding\" : \"UTF-8\" , \"compression\" : \"zip\" } ] In the case of a Filecoin asset, the CID included in the url field of the DDO can include the following information: CID Hash - Identifier of the content in the Filecoin network Powergate host - Hostname of the powergate node that can be used to fetch the file Powergate port - Port where is running the powergate service that can be used to fetch the file Powergate token - Token to use to fetch the file Deal Id - Identifier of the Deal that allow to pin the file to IPFS Here some examples of Filecoin CIDs urls: cid://POWERGATE_TOKEN:DEAL_ID@POWERGATE_HOST:POWERGATE_PORT/CID_HASH cid://POWERGATE_HOST:POWERGATE_PORT/CID_HASH cid://POWERGATE_TOKEN:DEAL_ID@CID_HASH cid://POWERGATE_TOKEN:@CID_HASH cid://:DEAL_ID@CID_HASH cid://CID_HASH As in the regular Nevermined Access flow the URL will be encrypted for the client and decrypted during the consumption phase by the gateway. See more about the File Attributes in the Metadata Specs . Gateway integration \u00b6 The Gateway supports the connectivity with the Filecoin network via Powergate. This behavior can be enabled/disabled from the Gateway via configuration. The Gateway support the usage of an existing Filecoin wallet. When a Nevermined asset is resolved and includes a CID, the gateway is capable of resolving that file and return it to the final user The Filecoin connectivity is encapsulated in the Filecoin Driver . Marketplace \u00b6 The visual publishing flow of Nevermined assets allow to include CIDs as files The consumption flow of Nevermined assets integrates the gateway and work with assets including Filecoin files","title":"Filecoin Storage"},{"location":"architecture/integrations/filecoin/filecoin-storage/#integration-of-filecoin-as-decentralized-storage-for-nevermined-users","text":"shortname: FIL-STO name: Filecoin Storage Integration type: Standard status: Draft version: 0.1 Nevermined is an Open Source solution developed by Keyko , offering the users the ability to build data sharing ecosystems where untrusted parties can share and monetize their data in a way that\u2019s efficient, secure and privacy preserving. As data creation continues to proliferate, entities have the necessity of organising, understanding, using and sharing their data internally and externally. Nevermined provides Data Sharing and Data In-Situ Computation solutions that allow organizations to unlock data for a more insights-driven approach. What we call a Data Ecosystem is an environment where independent organizations can cooperate with each other to publish, discover, and access data and the associated assets and services. Nevermined enables the usage of data without the members of these ecosystems having to lose control of their assets. One of the main principles of Nevermined is that Data Owners and Providers always keep control of their data. The solution is designed to be integrated with existing Big Data environments and allows for the execution of models or algorithms in-situ, or where the data resides. With Nevermined, the data never moves; instead the algorithms and models move to where the data sits. Currently Nevermined integrated with the most popular centralized/cloud based storage providers (Amazon S3, Azure, etc.). This document details the integration of Nevermined with Filecoin allowing to: Use Filecoin as one of the options supported allowing Nevermined users to publish & share their data via Filecoin Facilitate access control & data monetization of Filecoin existing data Enable a decentralized storage solution where users don't need to upload their data to any existing centralized solution Nevermined & Filecoin High Level integration","title":"Integration of Filecoin as decentralized storage for Nevermined users"},{"location":"architecture/integrations/filecoin/filecoin-storage/#value","text":"The integration of Filecoin into Nevermined brings is valuable for Filecoin community because: Increase the usage of Filecoin network Provides utility to Filecoin network via integration with existing and mature Open Source software Filecoin doesn't provide a granular access control allowing the data owners or publishers to decided when, and from whom their data can be accessed Allows user using centralized data storage based on cloud providers to use Filecoin as alternative Nevermined is L2 solution, network independent, and can be deployed in public or private networks. Via this integration, Filecoin could be used in any Nevermined user deployment Nevermined provides compute to the data and provenance (based on W3C PROV) capabilities. Via the integration, the Filecoin community would be able to use high value capabilities on top of their data","title":"Value"},{"location":"architecture/integrations/filecoin/filecoin-storage/#integration-details","text":"The integration of Filecoin as a fully supported storage provider require the modification and delivery of the following components: The Nevermined Gateway . This component is in charge of making available Nevermined users data. Before this integration the gateway supports different storage providers (Amazon S3, Azure, On Premise, etc.). This integration adds support to Filecoin as storage mechanism allowing to decrypt user urls and resolve Filecoin CIDs. The Nevermined SDKs. To facilitate user adoption, Nevermined support SDKs in 3 different programming languages: Javascript SDK , to facilitate the integration of Nevermined in web interfaces and DApps Python SDK , to facilitate the integration of Nevermined in data science tools It will deliver a modification of the 3 SDKs allowing to the users to publish in Nevermined Filecoin contents (CIDs) Java SDK , to facilitate the integration of Nevermined with existing industry big data solutions. Marketplace . It's a frontend application where users can publish and share files. The intention is to modify this application to support data sharing of assets stored in the Filecoin network.","title":"Integration Details"},{"location":"architecture/integrations/filecoin/filecoin-storage/#user-flows","text":"The final goal is to have a fully functional end to end integration, allowing for the registering of existing Filecoin assets into the Nevermined network: Registering of Filecoin assets into Nevermined After this publishing flow, it's intended to provide the downloading functionality (after access control) of Filecoin contents registered in the Nevermined network: Data Access of Filecoin assets existing into Nevermined","title":"User Flows"},{"location":"architecture/integrations/filecoin/filecoin-storage/#architecture","text":"The Nevermined architecture is evolved to integrate Powergate as gateway for supporting Filecoin data store. That integration requires the following modifications:","title":"Architecture"},{"location":"architecture/integrations/filecoin/filecoin-storage/#sdks","text":"The publishing flow of Nevermined assets allows to include CIDs as files The consumption flow of Nevermined assets integrates the gateway and work with assets including Filecoin files The SDK will include in the Metadata files attribute a URL using the cid prefix. Example: \"files\" : [ { \"url\" : \"cid://QmW68jbcqSRtqSQb6xkukQ6tfonZGhu1VrZv9zAicNmovs\" , \"index\" : 0 , \"checksum\" : \"efb2c764274b745f5fc37f97c6b0e761\" , \"contentLength\" : \"4535431\" , \"contentType\" : \"text/csv\" , \"encoding\" : \"UTF-8\" , \"compression\" : \"zip\" } ] In the case of a Filecoin asset, the CID included in the url field of the DDO can include the following information: CID Hash - Identifier of the content in the Filecoin network Powergate host - Hostname of the powergate node that can be used to fetch the file Powergate port - Port where is running the powergate service that can be used to fetch the file Powergate token - Token to use to fetch the file Deal Id - Identifier of the Deal that allow to pin the file to IPFS Here some examples of Filecoin CIDs urls: cid://POWERGATE_TOKEN:DEAL_ID@POWERGATE_HOST:POWERGATE_PORT/CID_HASH cid://POWERGATE_HOST:POWERGATE_PORT/CID_HASH cid://POWERGATE_TOKEN:DEAL_ID@CID_HASH cid://POWERGATE_TOKEN:@CID_HASH cid://:DEAL_ID@CID_HASH cid://CID_HASH As in the regular Nevermined Access flow the URL will be encrypted for the client and decrypted during the consumption phase by the gateway. See more about the File Attributes in the Metadata Specs .","title":"SDKs"},{"location":"architecture/integrations/filecoin/filecoin-storage/#gateway-integration","text":"The Gateway supports the connectivity with the Filecoin network via Powergate. This behavior can be enabled/disabled from the Gateway via configuration. The Gateway support the usage of an existing Filecoin wallet. When a Nevermined asset is resolved and includes a CID, the gateway is capable of resolving that file and return it to the final user The Filecoin connectivity is encapsulated in the Filecoin Driver .","title":"Gateway integration"},{"location":"architecture/integrations/filecoin/filecoin-storage/#marketplace","text":"The visual publishing flow of Nevermined assets allow to include CIDs as files The consumption flow of Nevermined assets integrates the gateway and work with assets including Filecoin files","title":"Marketplace"},{"location":"architecture/specs/access/","text":"ACCESS SPEC: Decentralized Access Control \u00b6 shortname: ACCESS name: Decentralized Access Control type: Standard status: Valid version: 0.1 editor: Aitor Argomaniz <aitor@nevermined.io> contributors: ACCESS SPEC: Decentralized Access Control Motivation Actors and Technical Components Payment Crypto Currencies Rewards Distribution Royalties in the secondary market Flows Publishing Assets Constructing an Asset DDO Service Agreement Templates Access Execution of the service agreement Lock Payment Condition Grant Access Condition Release Payment Condition Consuming the Data Consuming without direct integration of Secret Store Abort Conditions Encryption and Decryption Encryption Process Authorization Types Using Secret Store Using the Data Gateway PSK ECDSA PSK RSA This SPEC introduces an integration pattern for the use of Service Execution Agreements (SEAs) (also called \"Service Agreements\" or \"Agreements\") as contracts between parties interacting in a transaction. This SPEC uses the SEAs as the core element to orchestrate the publish/consume transactions for multiple services. Motivation \u00b6 The main motivations of this SPEC are: Understand how in an environment where different actors don't trust each other, a decentralized access control can work Detail the interaction between parties allowing to grant access to assets in a decentralized manner Identify the API methods exposed via the different libraries Actors and Technical Components \u00b6 PUBLISHERS - Provide access to assets and/or services CONSUMERS - Want to get access to assets and/or services MARKETPLACES - Store the DDO (including metadata) associated with the assets and/or services Note: Below, we write \"assets\" to mean \"assets and/or services.\" The following technical components are involved with the publishing flow or the consumption flow: MARKETPLACE - Exposes a web interface allowing users to publish and purchase assets. It also facilitates the discovery of assets. SDK - Software library encapsulating the Nevermined business logic. It's used to interact with all the components & APIs of the system. It's currently implemented in the following packages: nevermined-sdk-js - JavaScript version of the Nevermined SDK to be integrated with front-end applications. nevermined-sdk-py - Python version of the Nevermined SDK to be integrated with back-end applications. The primary users are data scientists. nevermined-sdk-java - Java version of the Nevermined SDK to be integrated with JVM applications. The primary users are data engineers. SMART CONTRACTS - Solidity Smart Contracts providing the Service Agreements business logic. SECRET STORE - Included as part of the Parity Ethereum client. Allows the PUBLISHER to encrypt the asset URL. Integrates with the SA to authorize (on-chain) the decryption of the asset URL by the CONSUMER. GATEWAY - Microservice to be executed by PUBLISHERS. It exposes an HTTP REST API permitting access to PUBLISHER assets or additional services such as computation. METADATA-API - Microservice to be executed by MARKETPLACES. Facilitates creating, updating, deleting and searching the asset metadata registered by the PUBLISHERS. This metadata is included as part of a DDO (see DID SPEC and METADATA SPEC ) and also includes the services associated with the asset (consumption, computation, etc.). Actors running Components Payment \u00b6 Crypto Currencies \u00b6 Nevermined allows the asset publishers to define the crypto-currencies they accept. This gives the flexibility of decide different payments and prices depending on the currency and the service attached to the asset. In Nevermined is possible to define multiple services (access, compute, transfer ownership, nft sales, etc). Each service can have different payment options depending on publisher interest. This provides a high level of flexibility allowing to get paid using the following options: Payment of a service using the Nevermined ERC20 token Payment using an external ERC20 token Payment using ETH The combination of the above for the same service. What means for the same service I can ask 1000 NVM Tokens, 10 xDAI or 1 ETH. This can be achieved specifying multiple times a service with prices in different currencies. All the prices are expressed in the DDOs with the crypto-currency lower level denominator. This is wei for ETH or drops for any other ERC20 token. This configuration is possible using the _tokenAddress parameter in the LockPayment and EscrowPayment conditions. The value options are: If the value is 0x0 means the payment is in ETH If the value is empty means the payment is in the Nevermined ERC20 Token If the value is an address means the payment is using the ERC20 Token deployed on that address In the following example is using a ETH payment: { \"name\" : \"_tokenAddress\" , \"type\" : \"address\" , \"value\" : \"0x0\" } Rewards Distribution \u00b6 In combination with the above, Nevermined allows the definition of payment schemes where multiple users can be paid for providing a service associated to an asset. For example, it's typical for a marketplace to get a commission for a sale because the infrastructure provided. This can be defined case by case, each marketplace could require different commissions, and can include multiple reward addresses to receive the payment as part of the sales flow. This configuration is possible using the _amounts and _receivers parameters in the LockPayment and EscrowPayment conditions. In the following example, as part of the DDO we define that address starting by 0xa99 is going to receive a payment of 10 drops or wei (depending on the token used), and the address starting by 0x068 a payment of 2. Example: { \"name\" : \"_amounts\" , \"type\" : \"uint256[]\" , \"value\" : [ \"10\" , \"2\" ] }, { \"name\" : \"_receivers\" , \"type\" : \"address[]\" , \"value\" : [ \"0xa99d43d86a0758d5632313b8fa3972b6088a21bb\" , \"0x068ed00cf0441e4829d9784fcbe7b9e26d4bd8d0\" ] } Royalties in the secondary market \u00b6 Asset creators can define what are the royalties they want to receive in the secondary market. These royalties must be between 0 and 100 percent. The royalties can not be changed after they are initialized. This protects the buyers of an Asset or NFT to have to pay for a different commission to the one agreed during the purchase of that Asset or NFT. In Nevermined the Assets or NFTs can be transferred, what means the owner can be different to the original creator, but the original creator can't be modified in the Smart Contracts once the asset is defined. Flows \u00b6 This section describes the asset publishing flow and the asset consuming flow in detail. It should be straightforward to implement those flows by reading it, although the actual implementation may deviate slightly. The detailed description is an attempt to account for important edge cases and to create a good reference for the authors of particular implementations. The intention of the Access flow is to be as lean as possible, allowing data sharing solution with low friction. In the below image you can see a high level view of the Nevermined Data Sharing flow: Nevermined Data Sharing flow The following parameters are used: did - Decentralized Identifier (DID). See DID SPEC . agreementId or serviceAgreementId - The unique ID referring to a Service Agreement established between a PUBLISHER and a CONSUMER. The CONSUMER (via SDK) is the one creating this unique ID. serviceDefinitionId - Identifies one service in the array of services included in the DDO. It is created by the PUBLISHER (via SDK) upon DDO creation. templateId - Identifies a unique Service Agreement template. Publishing Assets \u00b6 When a PUBLISHER uses the Nevermined SDK to publish (register) an asset, here is a summary of what the SDK does: Construct a new DDO (JSON object describing the asset). Calculate the checksum of all the services (access, provenance, etc) included as part of the DDO Calculates an unique DID Register using the Smart Contracts the DID, checksum of the DDO and the URL pointing to the METADATA API resolving the DDO Store the DDO off-chain in the METADATA API Those steps are explained in more detail below. The PUBLISHER is able to publish (register) an asset by making a single SDK call. where metadata is a dict containing the METADATA SPEC metadata about the asset. We now expand on the publishing (registration) steps in more detail. Constructing an Asset DDO \u00b6 An asset DDO is a DID Document conforming with the Decentralized Identifiers (DIDs) spec . Validate the metadata to ensure that it conforms with METADATA SPEC . (It should be in \"local metadata\" form at this point.) Compute a DID following DID SPEC . Create an empty DDO and add the following things to it: DID Public key of the PUBLISHER Authentication section (with RSA public key) Encrypt the URLs in the attributes.main.files array of the metadata. The PUBLISHER must specify which encryption service/procedure/plugin they wish to use. That encryption service gets recorded in the asset DDO. For details, see the section about Encryption and Decryption below. Note: This step changes the metadata and also the \"service\" section of the DDO. Sign the checksum using the publisher_account (i.e. compute a signature) and add the computed signature to the proof attribute. Add the rest of the services to the DDO. Each service in the list contains certain information depending on its type. Here we document two types of services required for purchasing and consuming an asset. A service of type \"Access\" contains: Service Definition ID ( serviceDefinitionId ); this helps PUBLISHER find the service definition of a DDO signed by CONSUMER Service Agreement Template ID ( templateId ); points to an unique instance of a template of a Service Agreement Service endpoint ( serviceEndpoint ); CONSUMERS signing this service send their signatures to this endpoint A list of condition keys; condition key is the keccak256 hash of the following: SLA template ID controller contract address (obtained from the solidity contract json file matching the contract name in the SLA condition) controller contract function fingerprint (referred to as function signature or selector) For each condition, a list is required of its parameter values, a timeout, a set of fields determining what conditions depend on other conditions, and a mapping of events emitted by the condition to the off-chain handlers of these events Each event is identified by name. Each event handler is a function from a whitelisted module Service Agreement contract address and the event mapping in the same format as the condition events, for off-chain listeners An integer defining when the agreement is fulfilled in case there are multiple terminal conditions, according to the Service Agreement smart contract A service of type \"Access\" contains 2 different endpoints: serviceEndpoint - A URL to initialize the Service Agreement consumeEndpoint - A URL to fetch data decryption keys from An example of a complete DDO can be found here . Please do note that the condition's order in the DID document should reflect the same order in on-chain service agreement. PUBLISHER registers the DID, associating the asset DID to the METADATA API link that resolves the DID to a DDO. To do that, the SDK needs to integrate the DIDRegistry contract using the registerAttribute method. function registerAttribute ( bytes32 _did , bytes32 _checksum , address [] memory _providers , string memory _value ) The parameters to pass are: bytes32 _did - The hash part of the DID, the part just after did:nv: bytes32 _checksum - The checksum generated after compute the DID address[] _providers - The list of providers which PUBLISHER delegates URL decryption capabilities and SEA management string _value - The Metadata service endpoint. In the above DDO its: http://metadata.org/api/v1/metadata/assets/ddo/{did } Publishing Flow The SMART CONTRACT will emit the DIDAttributeRegistered including the did , checksum and url registered. Service Agreement Templates \u00b6 It represents a standard template of a Service Agreement between parties. A template includes standard conditions allowing to be used by Nevermined users as reference during the negotiation between parties to establish a formal agreement on-chain. A Service Agreement Template includes: * A template identifier: `templateId` * A list of Conditions * Timeouts To facilitate the creation of agreements between parties, the templates provide standard agreements ready to be used during the creation of Service Agreement instances between parties. Interaction with templates can be done via the TemplateStoreManager contract. For the Data Sharing use case, Nevermined provides the EscrowAccessSecretStore template. The EscrowAccessSecretStore Service Agreement template has the following shape: const agreement = { id : id , did : did , templateId : templateId , conditionIds : [ conditionIdAccess , conditionIdLock , conditionIdEscrow ], timeLocks : [ timeLockAccess , 0 , 0 ], timeOuts : [ timeOutAccess , 0 , 0 ], actors : [ actors ] } For the different conditionIds, the CONSUMER needs to generate those and add them to the agreement to be defined on-chain. This requires to generate the hash including the agreementId and all the values of the specific condition: const conditionIdAccess = await accessCondition . generateId ( agreementId , await accessCondition . hashValues ( did , receiver )) const conditionIdLock = await lockPaymentConditon . generateId ( agreementId , await lockPaymentConditon . hashValues ( escrowPayment . address , escrowAmount )) const conditionIdEscrow = await escrowPayment . generateId ( agreementId , await escrowPayment . hashValues ( escrowAmount , receiver , sender , conditionIdLock , conditionIdAccess )) PUBLISHER publishes the DDO in the METADATA API. Access \u00b6 Using SDK calls, a CONSUMER can discover, purchase and get access to assets. Steps for leveraging SDK: The CONSUMER uses the search method to find relevant assets related with his query. It returns a list of DDO's. assets = nevermined.assets.search(\"weather Germany 2019\") The CONSUMER chooses a service inside a DDO (the CONSUMER selects a serviceDefinitionId ). The Service Agreement needs to have an associated unique serviceAgreementId that can be generated/provided by the CONSUMER. In the Smart Contracts, this serviceAgreementId will be stored as a bytes32 . This serviceAgreementId is generated randomly and is represented by a 64-character hex string (using the characters 0-9 and a-f). The CONSUMER can generate the serviceAgreementId using any kind of implementation providing enough randomness to generate this ID (64-characters hex string). The CONSUMER signs the service details. The signature contains (templateId, valuesHashList, timeoutValues, agreementId) . The agreementId is provided by the CONSUMER and has to be globally unique. Each ith item in values_hash_list lists corresponds to the ith condition in conditions list values_hash_list : a hash of the parameters types and values of each condition This signature is used to correlate events and to prevent the PUBLISHER from instantiating multiple Service Agreements from a single request. The CONSUMER sends (did, serviceAgreementId, serviceDefinitionId, signature, consumerAddress) to the service endpoint (GATEWAY). serviceDefinitionId tells the PUBLISHER where to find the preimage to verify the signature. The DID tells the PUBLISHER which asset to serve under these terms. HTTP POST /api/v1/GATEWAY/services/access/initialize { \"did\": \"did:nv:08a429b8529856d59867503f8056903a680935a76950bb9649785cc97869a43d\", \"serviceAgreementId\": \"bb23s87856d59867503f80a690357406857698570b964ac8dcc9d86da4ada010\", \"index\": 0, \"signature\": \"cade376598342cdae231321a0097876aeda656a567a67c6767fd8710129a9dc1\", \"consumerAddress\": \"0x00a329c0648769A73afAc7F9381E08FB43dBEA72\" } The execution of this endpoint should return a HTTP 201 if everything goes okay. Satisfactory conditions include: When GATEWAY receives a signature from the service endpoint and verifies the signature. Having the did , GATEWAY fetches the DDO related with this did . GATEWAY records the serviceAgreementId as corresponding to the given did . GATEWAY executes the Service Agreement by calling EscrowAccessSecretStoreTemplate.createAgreement , providing it with the agreementId and all the agreement values GATEWAY starts listening for the publisher events from the events section of the service definition. After receiving the HTTP response confirmation from GATEWAY, the CONSUMER starts listening for the AgreementCreated events specified in the corresponding service definition, filtering them by agreementId . Execution of the service agreement \u00b6 Consider an asset purchase example. CONSUMER locks the payment. Then PUBLISHER grants access to the document. Then payment is released. Now CONSUMER may decrypt the document. In general, there is a broad range of conditions which can be implemented and integrated into the described workflow. Lock Payment Condition \u00b6 Consider a sample of a service definition. \"serviceAgreementTemplate\": { \"contractName\": \"EscrowAccessSecretStoreTemplate\", \"events\": [{ \"name\": \"AgreementCreated\", \"actorType\": \"consumer\", \"handler\": { \"moduleName\": \"escrowAccessSecretStoreTemplate\", \"functionName\": \"fulfillLockPaymentCondition\", \"version\": \"0.1\" } }] } According to this sample, the CONSUMER listens for the AgreementCreated event emitted in the very beginning of Service Agreement execution, filtering it by agreementId . Note that the structure of serviceAgreementContract.events is identical to conditions.events . SDK needs to offer a utility that subscribes the specified callbacks to the events from both lists. When the CONSUMER receives this event it means the agreement is in place and can perform the lock reward: await token.approve(lockPaymentConditon.address, escrowAmount, { from: sender }) await lockPaymentConditon.fulfill(agreementId, escrowPayment.address, escrowAmount) If everything goes right, it will emit LockPaymentCondition.Fulfilled and thus will trigger the next condition. Grant Access Condition \u00b6 PUBLISHER (via GATEWAY) listens for LockPaymentCondition.Fulfilled event filtered by agreementId to confirm the reward was locked by the CONSUMER. \"conditions\": [{ \"events\": [{ \"name\": \"Fulfilled\", \"actorType\": \"publisher\", \"handler\": { \"moduleName\": \"lockPaymentConditon\", \"functionName\": \"fulfillAccessCondition\", \"version\": \"0.1\" } }] }] In this case the PUBLISHER can grant access to the CONSUMER for a specific agreementId and documentId using in this case the AccessCondition.fulfill : await accessCondition.fulfill(agreementId, agreement.did, receiver) If everything goes right, the Smart Contract will emit the AccessCondition.Fulfilled event. Release Payment Condition \u00b6 PUBLISHER (via GATEWAY) listens for AccessCondition.Fulfilled event to transfer tokens to PUBLISHER's account. \"conditions\": [{ \"events\": [{ \"name\": \"Fulfilled\", \"actorType\": \"publisher\", \"handler\": { \"moduleName\": \"access\", \"functionName\": \"fulfillEscrowPaymentCondition\", \"version\": \"0.1\" } }] }] So when the PUBLISHER receives the AccessCondition.Fulfilled he can call the EscrowPayment.fulfill method to receive the reward: await escrowPayment.fulfill(agreementId, escrowAmount, receiver, sender, agreement.conditionIds[1], agreement.conditionIds[0]) Consuming the Data \u00b6 CONSUMER (via SDK) listens for AccessCondition.Fulfilled event to access the document. \"conditions\": [{ \"events\": [{ \"name\": \"TimedOut\", \"actorType\": \"consumer\", \"handler\": { \"moduleName\": \"access\", \"functionName\": \"fulfillEscrowPaymentCondition\", \"version\": \"0.1\" } }] }] The following are steps that have to be performed by the CONSUMER to receive the data. CONSUMER decrypts the URL using the SDK. This only requires the encryptedUrl existing in the DDO and the DID. A Parity EVM client (local or remote) and SECRET STORE cluster can be used for that. CONSUMER retrieves data by calling the dedicated GATEWAY endpoint ( serviceEndpoint in the service definition) providing it with Consumer ethereum address, service agreement ID, and decrypted URL. The consume URL may look like: HTTP GET /api/v1/GATEWAY/services/access/consume?consumerAddress=${consumerAddress}&serviceAgreementId={serviceAgreementId}&url={url}` This method will return a HTTP 200 status code if everything was okay and the data file. When CONSUMER requests purchased data, GATEWAY gets 3 parameters: Consumer ethereum address: consumerAddress Service Agreement ID: serviceAgreementId Decrypted URL: url . This URL is only valid if GATEWAY acts as a gateway. CONSUMER cannot download using the URL if it's not done through GATEWAY. Using those parameters, GATEWAY does the following things: Find the did by the given serviceAgreementId Verify the given service is allowed to be consumed by the given consumerAddress and did using the checkPermissions method of the SLA Smart Contract. If CONSUMER has permissions to consume, download and provide data for the given DID Consuming Flow Consuming without direct integration of Secret Store \u00b6 If the CONSUMER (via SDK) can't integrate directly SECRET STORE for decryption (nevermined-sdk-js using Metamask can't provide the account password), it's possible to call GATEWAY with an alternative consume method. In this scenario, the GATEWAY is in charge of decrypting the content in behalf of the CONSUMER. The consume URL may look like: HTTP GET /api/v1/gateway/services/access/consume?pubKey=${pubKey}&serviceAgreementId={serviceAgreementId}&signature={signature}&index={index}` This method will return an HTTP 200 status code if everything was okay, plus the URL required to get access to the data. When CONSUMER requests purchased data, GATEWAY gets 3 parameters: Consumer public key: pubKey Service Agreement ID: serviceAgreementId Signature: signature . The signed serviceAgreementId value by the CONSUMER to validate his/her identity Index: index . Integer value representing the position of the content to download in the DDO.files array Abort Conditions \u00b6 Every condition can be fulfilled or aborted using the configured timeout. For example it would allows to the CONSUMER to cancel the payment after locking it but not receiving access to the asset for a long period of time. Mechanisms implemented in the Service Agreement contract ensure there are no race conditions. Encryption and Decryption \u00b6 The PUBLISHER can define how they want to encrypt the URLs included in the attributes.main.files array of the metadata. This information must be added to the DDO to allow CONSUMERs (via SDK) to understand how to deal with the URLs. Below is an example of how to add an encryption service to the service section of a DDO. \"service\" : [{ \"type\" : \"authorization\" , \"index\" : 0 , \"service\" : \"SecretStore\" , \"serviceEndpoint\" : \"http://secretstore.org:12001\" , \"config\" : { \"threshold\" : 3 }, }, \u2026 ] The encryption service is one object with the following attributes: type - Differentiate this kind of service with the word Authorization index - Existing in all the DDO services to differentiate one entry in the services list serviceEndpoint (optional) - URL used during the encryption and decryption process. attributes.main - List of mandatory attributes specific of the type service - The authorization service type. It could be SecretStore , PSK_ECDSA or PSK_RSA . The encryption/authorization service is optional. If it's not provided, the usual SECRET STORE cluster defined in the SDK configuration will be used. Encryption Process \u00b6 Suppose the attributes.main.files array in the metadata has three URLs: \"files\" : [ { \"url\" : \"https://example.com/data-file-0.csv\" , \"index\" : 0 , \"checksum\" : \"efb2c764274b745f5fc37f97c6b0e761\" , \"contentLength\" : \"4535431\" , \"resourceId\" : \"access-log2018-02-13-15-17-29-18386C502CAEA932\" }, { \"url\" : \"https://example.com/data-file-1.csv\" , \"index\" : 1 , \"checksum\" : \"085340abffh21495345af97c6b0e761\" , \"contentLength\" : \"12324\" }, { \"url\" : \"https://example.com/data-file-2.csv\" , \"index\" : 2 } ] The attributes.main.files array is encrypted as follows. First it is converted into a string like so: [{ \"url\" : \"https://example.com/data-file-0.csv\" , \"index\" : 0 , \u2026 , \"index\" : 2 }] where all spaces are removed (except inside the string values). Also, all newlines, line feeds, and carriage returns are removed. That JSON string can then be encrypted. After encryption, all \"url\" keys and values are removed from the attributes.main.files array objects, and a new attributes.encryptedFiles key and value are added to the metadata, e.g. \"encryptedFiles\" : \"0x2e48ceefcca7abb024f90\u2026f3fec0e1c\" We now describe the supported encryption procedures. Authorization Types \u00b6 The system supports different implementation for managing the authorization of the encryption/decryption of secrets. The authorization type can be found in attributes.main.service attribute. The authorization mechanisms supported are: SecretStore - Parity Secret Store PK-ECDSA - ECDSA Pre-Shared Keys PK-RSA - RSA Pre-Shared Keys Using Secret Store \u00b6 The SECRET STORE cluster to use during the encryption and decryption is specified in the serviceEndpoint attribute, e.g. \"service\" : [{ \"type\" : \"authorization\" , \"index\" : 0 , \"attributes\" : { \"main\" : { \"service\" : \"SecretStore\" , \"threshold\" : \"1\" } }, \"serviceEndpoint\" : \"http://secretstore.org:12001\" }, \u2026 ] More information about the integration of a SECRET STORE can be found Parity Secret Store page . Using the Data Gateway \u00b6 For those clients not able to integrate SECRET STORE directly, GATEWAY will support an encryption endpoint supporting the following parameters: HTTP POST /api/v1/gateway/services/encrypt { \"id\": \"did:nv:08a429b8529856d59867503f8056903a680935a76950bb9649785cc97869a43d\", \"document\": [ { \"url\": \"234ab87234acbd09543085340abffh21983ddhiiee982143827423421\", \"checksum\": \"efb2c764274b745f5fc37f97c6b0e761\", \"contentLength\": \"4535431\", \"resourceId\": \"access-log2018-02-13-15-17-29-18386C502CAEA932\" }, { \"url\": \"234ab87234acbd6894237582309543085340abffh21983ddhiiee982143827423421\", \"checksum\": \"085340abffh21495345af97c6b0e761\", \"contentLength\": \"12324\" }, { \"url\":\"80684089027358963495379879a543085340abffh21983ddhiiee982143827abcc2\" } ] } That is, the value of document should be the attributes.main.files array. This endpoint will return the content encrypted using the GATEWAY account. The GATEWAY will expose the public keys using for encryption in the following endpoint: http://0.0.0.0:8030/ In the JSON returned there will be the *-public-key entries with the different public keys enabled in the GATEWAY: { ... \"ecdsa-public-key\" : \"0xaaaaa\" , \"rsa-public-key\" : \"0xaaaaa\" , ... } PSK ECDSA \u00b6 In a DDO definition, can be defined a Pre-Shared ECDSA mechanism using the following configuration: \"service\" : [{ \"type\" : \"authorization\" , \"index\" : 0 , \"attributes\" : { \"main\" : { \"service\" : \"PSK-ECDSA\" , \"publicKey\" : \"0xaaaa\" // ECDSA Public Key of the Gateway } }, \"serviceEndpoint\" : \"http://mygateway.net/\" }, \u2026 ] PSK RSA \u00b6 In a DDO definition, can be defined a Pre-Shared RSA mechanism using the following configuration: \"service\" : [{ \"type\" : \"authorization\" , \"index\" : 0 , \"attributes\" : { \"main\" : { \"service\" : \"PSK-RSA\" , \"publicKey\" : \"0xaaaa\" // RSA Public Key of the Gateway } }, \"serviceEndpoint\" : \"http://mygateway.net/\" }, \u2026 ]","title":"Access Control"},{"location":"architecture/specs/access/#access-spec-decentralized-access-control","text":"shortname: ACCESS name: Decentralized Access Control type: Standard status: Valid version: 0.1 editor: Aitor Argomaniz <aitor@nevermined.io> contributors: ACCESS SPEC: Decentralized Access Control Motivation Actors and Technical Components Payment Crypto Currencies Rewards Distribution Royalties in the secondary market Flows Publishing Assets Constructing an Asset DDO Service Agreement Templates Access Execution of the service agreement Lock Payment Condition Grant Access Condition Release Payment Condition Consuming the Data Consuming without direct integration of Secret Store Abort Conditions Encryption and Decryption Encryption Process Authorization Types Using Secret Store Using the Data Gateway PSK ECDSA PSK RSA This SPEC introduces an integration pattern for the use of Service Execution Agreements (SEAs) (also called \"Service Agreements\" or \"Agreements\") as contracts between parties interacting in a transaction. This SPEC uses the SEAs as the core element to orchestrate the publish/consume transactions for multiple services.","title":"ACCESS SPEC: Decentralized Access Control"},{"location":"architecture/specs/access/#motivation","text":"The main motivations of this SPEC are: Understand how in an environment where different actors don't trust each other, a decentralized access control can work Detail the interaction between parties allowing to grant access to assets in a decentralized manner Identify the API methods exposed via the different libraries","title":"Motivation"},{"location":"architecture/specs/access/#actors-and-technical-components","text":"PUBLISHERS - Provide access to assets and/or services CONSUMERS - Want to get access to assets and/or services MARKETPLACES - Store the DDO (including metadata) associated with the assets and/or services Note: Below, we write \"assets\" to mean \"assets and/or services.\" The following technical components are involved with the publishing flow or the consumption flow: MARKETPLACE - Exposes a web interface allowing users to publish and purchase assets. It also facilitates the discovery of assets. SDK - Software library encapsulating the Nevermined business logic. It's used to interact with all the components & APIs of the system. It's currently implemented in the following packages: nevermined-sdk-js - JavaScript version of the Nevermined SDK to be integrated with front-end applications. nevermined-sdk-py - Python version of the Nevermined SDK to be integrated with back-end applications. The primary users are data scientists. nevermined-sdk-java - Java version of the Nevermined SDK to be integrated with JVM applications. The primary users are data engineers. SMART CONTRACTS - Solidity Smart Contracts providing the Service Agreements business logic. SECRET STORE - Included as part of the Parity Ethereum client. Allows the PUBLISHER to encrypt the asset URL. Integrates with the SA to authorize (on-chain) the decryption of the asset URL by the CONSUMER. GATEWAY - Microservice to be executed by PUBLISHERS. It exposes an HTTP REST API permitting access to PUBLISHER assets or additional services such as computation. METADATA-API - Microservice to be executed by MARKETPLACES. Facilitates creating, updating, deleting and searching the asset metadata registered by the PUBLISHERS. This metadata is included as part of a DDO (see DID SPEC and METADATA SPEC ) and also includes the services associated with the asset (consumption, computation, etc.). Actors running Components","title":"Actors and Technical Components"},{"location":"architecture/specs/access/#payment","text":"","title":"Payment"},{"location":"architecture/specs/access/#crypto-currencies","text":"Nevermined allows the asset publishers to define the crypto-currencies they accept. This gives the flexibility of decide different payments and prices depending on the currency and the service attached to the asset. In Nevermined is possible to define multiple services (access, compute, transfer ownership, nft sales, etc). Each service can have different payment options depending on publisher interest. This provides a high level of flexibility allowing to get paid using the following options: Payment of a service using the Nevermined ERC20 token Payment using an external ERC20 token Payment using ETH The combination of the above for the same service. What means for the same service I can ask 1000 NVM Tokens, 10 xDAI or 1 ETH. This can be achieved specifying multiple times a service with prices in different currencies. All the prices are expressed in the DDOs with the crypto-currency lower level denominator. This is wei for ETH or drops for any other ERC20 token. This configuration is possible using the _tokenAddress parameter in the LockPayment and EscrowPayment conditions. The value options are: If the value is 0x0 means the payment is in ETH If the value is empty means the payment is in the Nevermined ERC20 Token If the value is an address means the payment is using the ERC20 Token deployed on that address In the following example is using a ETH payment: { \"name\" : \"_tokenAddress\" , \"type\" : \"address\" , \"value\" : \"0x0\" }","title":"Crypto Currencies"},{"location":"architecture/specs/access/#rewards-distribution","text":"In combination with the above, Nevermined allows the definition of payment schemes where multiple users can be paid for providing a service associated to an asset. For example, it's typical for a marketplace to get a commission for a sale because the infrastructure provided. This can be defined case by case, each marketplace could require different commissions, and can include multiple reward addresses to receive the payment as part of the sales flow. This configuration is possible using the _amounts and _receivers parameters in the LockPayment and EscrowPayment conditions. In the following example, as part of the DDO we define that address starting by 0xa99 is going to receive a payment of 10 drops or wei (depending on the token used), and the address starting by 0x068 a payment of 2. Example: { \"name\" : \"_amounts\" , \"type\" : \"uint256[]\" , \"value\" : [ \"10\" , \"2\" ] }, { \"name\" : \"_receivers\" , \"type\" : \"address[]\" , \"value\" : [ \"0xa99d43d86a0758d5632313b8fa3972b6088a21bb\" , \"0x068ed00cf0441e4829d9784fcbe7b9e26d4bd8d0\" ] }","title":"Rewards Distribution"},{"location":"architecture/specs/access/#royalties-in-the-secondary-market","text":"Asset creators can define what are the royalties they want to receive in the secondary market. These royalties must be between 0 and 100 percent. The royalties can not be changed after they are initialized. This protects the buyers of an Asset or NFT to have to pay for a different commission to the one agreed during the purchase of that Asset or NFT. In Nevermined the Assets or NFTs can be transferred, what means the owner can be different to the original creator, but the original creator can't be modified in the Smart Contracts once the asset is defined.","title":"Royalties in the secondary market"},{"location":"architecture/specs/access/#flows","text":"This section describes the asset publishing flow and the asset consuming flow in detail. It should be straightforward to implement those flows by reading it, although the actual implementation may deviate slightly. The detailed description is an attempt to account for important edge cases and to create a good reference for the authors of particular implementations. The intention of the Access flow is to be as lean as possible, allowing data sharing solution with low friction. In the below image you can see a high level view of the Nevermined Data Sharing flow: Nevermined Data Sharing flow The following parameters are used: did - Decentralized Identifier (DID). See DID SPEC . agreementId or serviceAgreementId - The unique ID referring to a Service Agreement established between a PUBLISHER and a CONSUMER. The CONSUMER (via SDK) is the one creating this unique ID. serviceDefinitionId - Identifies one service in the array of services included in the DDO. It is created by the PUBLISHER (via SDK) upon DDO creation. templateId - Identifies a unique Service Agreement template.","title":"Flows"},{"location":"architecture/specs/access/#publishing-assets","text":"When a PUBLISHER uses the Nevermined SDK to publish (register) an asset, here is a summary of what the SDK does: Construct a new DDO (JSON object describing the asset). Calculate the checksum of all the services (access, provenance, etc) included as part of the DDO Calculates an unique DID Register using the Smart Contracts the DID, checksum of the DDO and the URL pointing to the METADATA API resolving the DDO Store the DDO off-chain in the METADATA API Those steps are explained in more detail below. The PUBLISHER is able to publish (register) an asset by making a single SDK call. where metadata is a dict containing the METADATA SPEC metadata about the asset. We now expand on the publishing (registration) steps in more detail.","title":"Publishing Assets"},{"location":"architecture/specs/access/#constructing-an-asset-ddo","text":"An asset DDO is a DID Document conforming with the Decentralized Identifiers (DIDs) spec . Validate the metadata to ensure that it conforms with METADATA SPEC . (It should be in \"local metadata\" form at this point.) Compute a DID following DID SPEC . Create an empty DDO and add the following things to it: DID Public key of the PUBLISHER Authentication section (with RSA public key) Encrypt the URLs in the attributes.main.files array of the metadata. The PUBLISHER must specify which encryption service/procedure/plugin they wish to use. That encryption service gets recorded in the asset DDO. For details, see the section about Encryption and Decryption below. Note: This step changes the metadata and also the \"service\" section of the DDO. Sign the checksum using the publisher_account (i.e. compute a signature) and add the computed signature to the proof attribute. Add the rest of the services to the DDO. Each service in the list contains certain information depending on its type. Here we document two types of services required for purchasing and consuming an asset. A service of type \"Access\" contains: Service Definition ID ( serviceDefinitionId ); this helps PUBLISHER find the service definition of a DDO signed by CONSUMER Service Agreement Template ID ( templateId ); points to an unique instance of a template of a Service Agreement Service endpoint ( serviceEndpoint ); CONSUMERS signing this service send their signatures to this endpoint A list of condition keys; condition key is the keccak256 hash of the following: SLA template ID controller contract address (obtained from the solidity contract json file matching the contract name in the SLA condition) controller contract function fingerprint (referred to as function signature or selector) For each condition, a list is required of its parameter values, a timeout, a set of fields determining what conditions depend on other conditions, and a mapping of events emitted by the condition to the off-chain handlers of these events Each event is identified by name. Each event handler is a function from a whitelisted module Service Agreement contract address and the event mapping in the same format as the condition events, for off-chain listeners An integer defining when the agreement is fulfilled in case there are multiple terminal conditions, according to the Service Agreement smart contract A service of type \"Access\" contains 2 different endpoints: serviceEndpoint - A URL to initialize the Service Agreement consumeEndpoint - A URL to fetch data decryption keys from An example of a complete DDO can be found here . Please do note that the condition's order in the DID document should reflect the same order in on-chain service agreement. PUBLISHER registers the DID, associating the asset DID to the METADATA API link that resolves the DID to a DDO. To do that, the SDK needs to integrate the DIDRegistry contract using the registerAttribute method. function registerAttribute ( bytes32 _did , bytes32 _checksum , address [] memory _providers , string memory _value ) The parameters to pass are: bytes32 _did - The hash part of the DID, the part just after did:nv: bytes32 _checksum - The checksum generated after compute the DID address[] _providers - The list of providers which PUBLISHER delegates URL decryption capabilities and SEA management string _value - The Metadata service endpoint. In the above DDO its: http://metadata.org/api/v1/metadata/assets/ddo/{did } Publishing Flow The SMART CONTRACT will emit the DIDAttributeRegistered including the did , checksum and url registered.","title":"Constructing an Asset DDO"},{"location":"architecture/specs/access/#service-agreement-templates","text":"It represents a standard template of a Service Agreement between parties. A template includes standard conditions allowing to be used by Nevermined users as reference during the negotiation between parties to establish a formal agreement on-chain. A Service Agreement Template includes: * A template identifier: `templateId` * A list of Conditions * Timeouts To facilitate the creation of agreements between parties, the templates provide standard agreements ready to be used during the creation of Service Agreement instances between parties. Interaction with templates can be done via the TemplateStoreManager contract. For the Data Sharing use case, Nevermined provides the EscrowAccessSecretStore template. The EscrowAccessSecretStore Service Agreement template has the following shape: const agreement = { id : id , did : did , templateId : templateId , conditionIds : [ conditionIdAccess , conditionIdLock , conditionIdEscrow ], timeLocks : [ timeLockAccess , 0 , 0 ], timeOuts : [ timeOutAccess , 0 , 0 ], actors : [ actors ] } For the different conditionIds, the CONSUMER needs to generate those and add them to the agreement to be defined on-chain. This requires to generate the hash including the agreementId and all the values of the specific condition: const conditionIdAccess = await accessCondition . generateId ( agreementId , await accessCondition . hashValues ( did , receiver )) const conditionIdLock = await lockPaymentConditon . generateId ( agreementId , await lockPaymentConditon . hashValues ( escrowPayment . address , escrowAmount )) const conditionIdEscrow = await escrowPayment . generateId ( agreementId , await escrowPayment . hashValues ( escrowAmount , receiver , sender , conditionIdLock , conditionIdAccess )) PUBLISHER publishes the DDO in the METADATA API.","title":"Service Agreement Templates"},{"location":"architecture/specs/access/#access","text":"Using SDK calls, a CONSUMER can discover, purchase and get access to assets. Steps for leveraging SDK: The CONSUMER uses the search method to find relevant assets related with his query. It returns a list of DDO's. assets = nevermined.assets.search(\"weather Germany 2019\") The CONSUMER chooses a service inside a DDO (the CONSUMER selects a serviceDefinitionId ). The Service Agreement needs to have an associated unique serviceAgreementId that can be generated/provided by the CONSUMER. In the Smart Contracts, this serviceAgreementId will be stored as a bytes32 . This serviceAgreementId is generated randomly and is represented by a 64-character hex string (using the characters 0-9 and a-f). The CONSUMER can generate the serviceAgreementId using any kind of implementation providing enough randomness to generate this ID (64-characters hex string). The CONSUMER signs the service details. The signature contains (templateId, valuesHashList, timeoutValues, agreementId) . The agreementId is provided by the CONSUMER and has to be globally unique. Each ith item in values_hash_list lists corresponds to the ith condition in conditions list values_hash_list : a hash of the parameters types and values of each condition This signature is used to correlate events and to prevent the PUBLISHER from instantiating multiple Service Agreements from a single request. The CONSUMER sends (did, serviceAgreementId, serviceDefinitionId, signature, consumerAddress) to the service endpoint (GATEWAY). serviceDefinitionId tells the PUBLISHER where to find the preimage to verify the signature. The DID tells the PUBLISHER which asset to serve under these terms. HTTP POST /api/v1/GATEWAY/services/access/initialize { \"did\": \"did:nv:08a429b8529856d59867503f8056903a680935a76950bb9649785cc97869a43d\", \"serviceAgreementId\": \"bb23s87856d59867503f80a690357406857698570b964ac8dcc9d86da4ada010\", \"index\": 0, \"signature\": \"cade376598342cdae231321a0097876aeda656a567a67c6767fd8710129a9dc1\", \"consumerAddress\": \"0x00a329c0648769A73afAc7F9381E08FB43dBEA72\" } The execution of this endpoint should return a HTTP 201 if everything goes okay. Satisfactory conditions include: When GATEWAY receives a signature from the service endpoint and verifies the signature. Having the did , GATEWAY fetches the DDO related with this did . GATEWAY records the serviceAgreementId as corresponding to the given did . GATEWAY executes the Service Agreement by calling EscrowAccessSecretStoreTemplate.createAgreement , providing it with the agreementId and all the agreement values GATEWAY starts listening for the publisher events from the events section of the service definition. After receiving the HTTP response confirmation from GATEWAY, the CONSUMER starts listening for the AgreementCreated events specified in the corresponding service definition, filtering them by agreementId .","title":"Access"},{"location":"architecture/specs/access/#execution-of-the-service-agreement","text":"Consider an asset purchase example. CONSUMER locks the payment. Then PUBLISHER grants access to the document. Then payment is released. Now CONSUMER may decrypt the document. In general, there is a broad range of conditions which can be implemented and integrated into the described workflow.","title":"Execution of the service agreement"},{"location":"architecture/specs/access/#lock-payment-condition","text":"Consider a sample of a service definition. \"serviceAgreementTemplate\": { \"contractName\": \"EscrowAccessSecretStoreTemplate\", \"events\": [{ \"name\": \"AgreementCreated\", \"actorType\": \"consumer\", \"handler\": { \"moduleName\": \"escrowAccessSecretStoreTemplate\", \"functionName\": \"fulfillLockPaymentCondition\", \"version\": \"0.1\" } }] } According to this sample, the CONSUMER listens for the AgreementCreated event emitted in the very beginning of Service Agreement execution, filtering it by agreementId . Note that the structure of serviceAgreementContract.events is identical to conditions.events . SDK needs to offer a utility that subscribes the specified callbacks to the events from both lists. When the CONSUMER receives this event it means the agreement is in place and can perform the lock reward: await token.approve(lockPaymentConditon.address, escrowAmount, { from: sender }) await lockPaymentConditon.fulfill(agreementId, escrowPayment.address, escrowAmount) If everything goes right, it will emit LockPaymentCondition.Fulfilled and thus will trigger the next condition.","title":"Lock Payment Condition"},{"location":"architecture/specs/access/#grant-access-condition","text":"PUBLISHER (via GATEWAY) listens for LockPaymentCondition.Fulfilled event filtered by agreementId to confirm the reward was locked by the CONSUMER. \"conditions\": [{ \"events\": [{ \"name\": \"Fulfilled\", \"actorType\": \"publisher\", \"handler\": { \"moduleName\": \"lockPaymentConditon\", \"functionName\": \"fulfillAccessCondition\", \"version\": \"0.1\" } }] }] In this case the PUBLISHER can grant access to the CONSUMER for a specific agreementId and documentId using in this case the AccessCondition.fulfill : await accessCondition.fulfill(agreementId, agreement.did, receiver) If everything goes right, the Smart Contract will emit the AccessCondition.Fulfilled event.","title":"Grant Access Condition"},{"location":"architecture/specs/access/#release-payment-condition","text":"PUBLISHER (via GATEWAY) listens for AccessCondition.Fulfilled event to transfer tokens to PUBLISHER's account. \"conditions\": [{ \"events\": [{ \"name\": \"Fulfilled\", \"actorType\": \"publisher\", \"handler\": { \"moduleName\": \"access\", \"functionName\": \"fulfillEscrowPaymentCondition\", \"version\": \"0.1\" } }] }] So when the PUBLISHER receives the AccessCondition.Fulfilled he can call the EscrowPayment.fulfill method to receive the reward: await escrowPayment.fulfill(agreementId, escrowAmount, receiver, sender, agreement.conditionIds[1], agreement.conditionIds[0])","title":"Release Payment Condition"},{"location":"architecture/specs/access/#consuming-the-data","text":"CONSUMER (via SDK) listens for AccessCondition.Fulfilled event to access the document. \"conditions\": [{ \"events\": [{ \"name\": \"TimedOut\", \"actorType\": \"consumer\", \"handler\": { \"moduleName\": \"access\", \"functionName\": \"fulfillEscrowPaymentCondition\", \"version\": \"0.1\" } }] }] The following are steps that have to be performed by the CONSUMER to receive the data. CONSUMER decrypts the URL using the SDK. This only requires the encryptedUrl existing in the DDO and the DID. A Parity EVM client (local or remote) and SECRET STORE cluster can be used for that. CONSUMER retrieves data by calling the dedicated GATEWAY endpoint ( serviceEndpoint in the service definition) providing it with Consumer ethereum address, service agreement ID, and decrypted URL. The consume URL may look like: HTTP GET /api/v1/GATEWAY/services/access/consume?consumerAddress=${consumerAddress}&serviceAgreementId={serviceAgreementId}&url={url}` This method will return a HTTP 200 status code if everything was okay and the data file. When CONSUMER requests purchased data, GATEWAY gets 3 parameters: Consumer ethereum address: consumerAddress Service Agreement ID: serviceAgreementId Decrypted URL: url . This URL is only valid if GATEWAY acts as a gateway. CONSUMER cannot download using the URL if it's not done through GATEWAY. Using those parameters, GATEWAY does the following things: Find the did by the given serviceAgreementId Verify the given service is allowed to be consumed by the given consumerAddress and did using the checkPermissions method of the SLA Smart Contract. If CONSUMER has permissions to consume, download and provide data for the given DID Consuming Flow","title":"Consuming the Data"},{"location":"architecture/specs/access/#consuming-without-direct-integration-of-secret-store","text":"If the CONSUMER (via SDK) can't integrate directly SECRET STORE for decryption (nevermined-sdk-js using Metamask can't provide the account password), it's possible to call GATEWAY with an alternative consume method. In this scenario, the GATEWAY is in charge of decrypting the content in behalf of the CONSUMER. The consume URL may look like: HTTP GET /api/v1/gateway/services/access/consume?pubKey=${pubKey}&serviceAgreementId={serviceAgreementId}&signature={signature}&index={index}` This method will return an HTTP 200 status code if everything was okay, plus the URL required to get access to the data. When CONSUMER requests purchased data, GATEWAY gets 3 parameters: Consumer public key: pubKey Service Agreement ID: serviceAgreementId Signature: signature . The signed serviceAgreementId value by the CONSUMER to validate his/her identity Index: index . Integer value representing the position of the content to download in the DDO.files array","title":"Consuming without direct integration of Secret Store"},{"location":"architecture/specs/access/#abort-conditions","text":"Every condition can be fulfilled or aborted using the configured timeout. For example it would allows to the CONSUMER to cancel the payment after locking it but not receiving access to the asset for a long period of time. Mechanisms implemented in the Service Agreement contract ensure there are no race conditions.","title":"Abort Conditions"},{"location":"architecture/specs/access/#encryption-and-decryption","text":"The PUBLISHER can define how they want to encrypt the URLs included in the attributes.main.files array of the metadata. This information must be added to the DDO to allow CONSUMERs (via SDK) to understand how to deal with the URLs. Below is an example of how to add an encryption service to the service section of a DDO. \"service\" : [{ \"type\" : \"authorization\" , \"index\" : 0 , \"service\" : \"SecretStore\" , \"serviceEndpoint\" : \"http://secretstore.org:12001\" , \"config\" : { \"threshold\" : 3 }, }, \u2026 ] The encryption service is one object with the following attributes: type - Differentiate this kind of service with the word Authorization index - Existing in all the DDO services to differentiate one entry in the services list serviceEndpoint (optional) - URL used during the encryption and decryption process. attributes.main - List of mandatory attributes specific of the type service - The authorization service type. It could be SecretStore , PSK_ECDSA or PSK_RSA . The encryption/authorization service is optional. If it's not provided, the usual SECRET STORE cluster defined in the SDK configuration will be used.","title":"Encryption and Decryption"},{"location":"architecture/specs/access/#encryption-process","text":"Suppose the attributes.main.files array in the metadata has three URLs: \"files\" : [ { \"url\" : \"https://example.com/data-file-0.csv\" , \"index\" : 0 , \"checksum\" : \"efb2c764274b745f5fc37f97c6b0e761\" , \"contentLength\" : \"4535431\" , \"resourceId\" : \"access-log2018-02-13-15-17-29-18386C502CAEA932\" }, { \"url\" : \"https://example.com/data-file-1.csv\" , \"index\" : 1 , \"checksum\" : \"085340abffh21495345af97c6b0e761\" , \"contentLength\" : \"12324\" }, { \"url\" : \"https://example.com/data-file-2.csv\" , \"index\" : 2 } ] The attributes.main.files array is encrypted as follows. First it is converted into a string like so: [{ \"url\" : \"https://example.com/data-file-0.csv\" , \"index\" : 0 , \u2026 , \"index\" : 2 }] where all spaces are removed (except inside the string values). Also, all newlines, line feeds, and carriage returns are removed. That JSON string can then be encrypted. After encryption, all \"url\" keys and values are removed from the attributes.main.files array objects, and a new attributes.encryptedFiles key and value are added to the metadata, e.g. \"encryptedFiles\" : \"0x2e48ceefcca7abb024f90\u2026f3fec0e1c\" We now describe the supported encryption procedures.","title":"Encryption Process"},{"location":"architecture/specs/access/#authorization-types","text":"The system supports different implementation for managing the authorization of the encryption/decryption of secrets. The authorization type can be found in attributes.main.service attribute. The authorization mechanisms supported are: SecretStore - Parity Secret Store PK-ECDSA - ECDSA Pre-Shared Keys PK-RSA - RSA Pre-Shared Keys","title":"Authorization Types"},{"location":"architecture/specs/access/#using-secret-store","text":"The SECRET STORE cluster to use during the encryption and decryption is specified in the serviceEndpoint attribute, e.g. \"service\" : [{ \"type\" : \"authorization\" , \"index\" : 0 , \"attributes\" : { \"main\" : { \"service\" : \"SecretStore\" , \"threshold\" : \"1\" } }, \"serviceEndpoint\" : \"http://secretstore.org:12001\" }, \u2026 ] More information about the integration of a SECRET STORE can be found Parity Secret Store page .","title":"Using Secret Store"},{"location":"architecture/specs/access/#using-the-data-gateway","text":"For those clients not able to integrate SECRET STORE directly, GATEWAY will support an encryption endpoint supporting the following parameters: HTTP POST /api/v1/gateway/services/encrypt { \"id\": \"did:nv:08a429b8529856d59867503f8056903a680935a76950bb9649785cc97869a43d\", \"document\": [ { \"url\": \"234ab87234acbd09543085340abffh21983ddhiiee982143827423421\", \"checksum\": \"efb2c764274b745f5fc37f97c6b0e761\", \"contentLength\": \"4535431\", \"resourceId\": \"access-log2018-02-13-15-17-29-18386C502CAEA932\" }, { \"url\": \"234ab87234acbd6894237582309543085340abffh21983ddhiiee982143827423421\", \"checksum\": \"085340abffh21495345af97c6b0e761\", \"contentLength\": \"12324\" }, { \"url\":\"80684089027358963495379879a543085340abffh21983ddhiiee982143827abcc2\" } ] } That is, the value of document should be the attributes.main.files array. This endpoint will return the content encrypted using the GATEWAY account. The GATEWAY will expose the public keys using for encryption in the following endpoint: http://0.0.0.0:8030/ In the JSON returned there will be the *-public-key entries with the different public keys enabled in the GATEWAY: { ... \"ecdsa-public-key\" : \"0xaaaaa\" , \"rsa-public-key\" : \"0xaaaaa\" , ... }","title":"Using the Data Gateway"},{"location":"architecture/specs/access/#psk-ecdsa","text":"In a DDO definition, can be defined a Pre-Shared ECDSA mechanism using the following configuration: \"service\" : [{ \"type\" : \"authorization\" , \"index\" : 0 , \"attributes\" : { \"main\" : { \"service\" : \"PSK-ECDSA\" , \"publicKey\" : \"0xaaaa\" // ECDSA Public Key of the Gateway } }, \"serviceEndpoint\" : \"http://mygateway.net/\" }, \u2026 ]","title":"PSK ECDSA"},{"location":"architecture/specs/access/#psk-rsa","text":"In a DDO definition, can be defined a Pre-Shared RSA mechanism using the following configuration: \"service\" : [{ \"type\" : \"authorization\" , \"index\" : 0 , \"attributes\" : { \"main\" : { \"service\" : \"PSK-RSA\" , \"publicKey\" : \"0xaaaa\" // RSA Public Key of the Gateway } }, \"serviceEndpoint\" : \"http://mygateway.net/\" }, \u2026 ]","title":"PSK RSA"},{"location":"architecture/specs/compute/","text":"COMPUTE SPEC: Data in situ Computation \u00b6 shortname: COMPUTE name: Data In Situ Computation type: Standard status: Valid version: 0.1 editor: Aitor Argomaniz <aitor@nevermined.io> contributors: COMPUTE SPEC: Data in situ Computation Execution of Remote Compute Services using Service Agreements Motivation Actors Technical components Flow Terminology Requirements Workflows Publishing an Asset including Compute Services Setting up the Service Execution Agreement Registering Asset Consuming Asset Execution phase Infrastructure Orchestration Services Provided by the Operator Orchestration Steps Infrastructure Operator Volumes Network isolation Execution of Remote Compute Services using Service Agreements \u00b6 This SPEC introduces the integration pattern for the usage of Service Execution Agreements (SEA) (also called Service Agreements or Agreements) as contracts between parties interacting in the execution of a Compute Service transaction. This SPEC using the SEA as core element, orchestrates the publishing/execution of this type of compute services. The intention of this SPEC is to describe the flow and integration pattern independently of the infrastructure Cloud Compute Service. This SPEC MUST be valid for integrating classical infrastructure cloud providers like Amazon EC2 or Azure, but also can be used to integrate other compute providers or On-Premise infrastructure. It's out of the scope to detail the Service Execution Agreements implementation. Motivation \u00b6 The main motivations of this SPEC are: Identify the actors involved on the definition and execution of a Nevermined Compute service Detail the main characteristics of this interaction Specify the pros and cons of this approach Identify the API methods exposed via the different libraries Actors \u00b6 The different actors interacting in this flow are: PROVIDERS - Give access to the Compute Services CONSUMERS - Want to make use of the Compute Services MARKETPLACES or DOMAINS - Store the DDO/Metadata related with the Assets/services INFRASTRUCTURE - Cloud or on-premise infrastructure services providing computing. Typically Amazon, Azure, etc. Technical components \u00b6 The following technical components are involved in an end-to-end publishing and consumption flow: MARKETPLACE - Exposes a web interface allowing the users to publish and purchase assets and services associated to these assets. It also facilitates the discovery of assets. SDK - Software library encapsulating the Nevermined business logic. It's used to interact with all the components & APIs of the system. It's currently implemented in the following packages: nevermined-sdk-js - JavaScript version of the Nevermined SDK to be integrated with front-end applications. nevermined-sdk-py - Python version of the Nevermined SDK to be integrated with back-end applications. The primary users are data scientists. nevermined-sdk-java - Java version of the Nevermined SDK to be integrated with JVM applications. The primary users are data engineers. SMART CONTRACTS - Solidity Smart Contracts providing the Service Agreements business logic. GATEWAY - Microservice to be executed by PUBLISHERS. It exposes an HTTP REST API permitting access to PUBLISHER assets or additional services such as computation. METADATA-API - Microservice to be executed by MARKETPLACES. Facilitates creating, updating, deleting and searching the asset metadata registered by the PUBLISHERS. This metadata is included as part of a DDO (see DID SPEC and METADATA SPEC ) and also includes the services associated with the asset (consumption, computation, etc.). Flow \u00b6 This section describes the Asset Compute Service flow in detail. There are some parameters used in this flow: DID - See DID SPEC . serviceAgreementId - Is the unique ID referring to a Service Execution Agreement established between a PUBLISHER and a CONSUMER. The CONSUMER (via SDK) is the one creating this random unique serviceAgreementId. serviceDefinitionId - Identifies one service in the array of services included in the DDO. It is created by the PUBLISHER (via SDK) upon DDO creation and is associated with different services. templateId - Identifies a unique Service Agreement template. Terminology \u00b6 Compute Provider - Entity providing a compute service for a price (or for free). Compute Service - Service offered by a Compute Provider. It could have different conditions like the type of services, price, etc. Workflow - It describes an execution pipeline where you put together input data and an algorithm to process this data and you run using a Compute Service. Requirements \u00b6 A COMPUTE PROVIDER or PROVIDER define the conditions that a Compute service supports. It includes: What kind of image (Docker container) can be deployed in the infrastructure What are the infrastructure resources available (CPU, memory, storage) What is the price of using the infrastructure resources A COMPUTE PROVIDER defines a Compute Service in the scope of the Asset (DID/DDO) of the dataset that can be computed A CONSUMER defines the task to execute modeling it in a Workflow (including configuration, input, transformations and output) A workflow is a new type of Asset. It can be resolvable and be used across multiple independent compute services A CONSUMER purchasing a compute service defines which Workflow (DID) is going to execute A CONSUMER can purchase a service given by a PROVIDER and execute multiple times till the timeout expires A CONSUMER could purchase a service and execute later, the purchase MUST be totally decoupled of execution The previous two points could support to buy once a compute service and execute for example the service every night at 3 am Data in situ Computation Workflows \u00b6 From a high-level point of view, a workflow may be considered a view or representation of a real work. A workflow consists of an orchestrated and repeatable pattern of activities transformed into tasks that transform or process information. In Nevermined, we use the concept of workflow to represent a list of tasks to accomplish with the intention of process data. From a technical point of view, a workflow is a type of Asset (it takes advantage of all the Nevermined plumbing of registering, metadata publishing, resolving, etc.). The main objective of a workflow is to describe an execution pipeline. A workflow can be split in sequential stages, having each stage an input, transformation (via algorithm) and output. In the below example, a workflow is modeled in a JSON document with the following characteristics: It has a list of sorted stages by the stages.index parameter to be executed sequentially Each stage has a list of minimum requirements, like the image required to support the execution of the algorithm, minimum cpu, memory, etc. Each stage has an array of sorted input parameters. Each input parameter may be: A DID (example: \"id\": \"did:nv:12345\" ) The output of a previous stage (example: \"previousIndexStage\": 0 ) Each stage has one transformation entry. It includes the id (DID) of the asset in charge of process the input to generate some output Each stage includes an entry with some additional output details. This could be a DID or a specific detail about the expected output. Workflow JSON Model Example of a Workflow: { \"service\" : [{ \"index\" : \"0\" , \"type\" : \"metadata\" , \"serviceEndpoint\" : \"https://service/api/v1/metadata/assets/ddo/did:nv:0ebed8226ada17fde24b6bf2b95d27f8f05fcce09139ff5cec31f6d81a7cd2ea\" , \"attributes\" : { \"main\" : { \"type\" : \"workflow\" , \"workflow\" : { \"stages\" : [{ \"index\" : 0 , \"stageType\" : \"Filtering\" , \"requirements\" : { \"serverInstances\" : 1 , \"container\" : { \"image\" : \"tensorflow/tensorflow\" , \"tag\" : \"latest\" , \"checksum\" : \"sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc\" } }, \"input\" : [{ \"index\" : 0 , \"id\" : \"did:nv:12345\" }, { \"index\" : 1 , \"id\" : \"did:nv:67890\" }], \"transformation\" : { \"id\" : \"did:nv:abcde\" }, \"output\" : {} }, { \"index\" : 1 , \"stageType\" : \"Transformation\" , \"requirements\" : { \"serverInstances\" : 1 , \"container\" : { \"image\" : \"tensorflow/tensorflow\" , \"tag\" : \"latest\" , \"checksum\" : \"sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc\" } }, \"input\" : [{ \"index\" : 0 , \"previousStage\" : 0 }], \"transformation\" : { \"id\" : \"did:nv:999999\" }, \"output\" : {} }] } }, \"additional\" : {}, \"curation\" : {} } }, {} ] } A Workflow is a new type of Asset (a part of datasets, algorithms, etc.). You can find a complete DDO of type workflow in the ddo.workflow.json example file . As a new kind of asset, the workflow details will be persisted inside a DDO as part of the \"Metadata\" service where the type is workflow . An Asset of type workflow, will include in the DDO the following information: The Workflow model as part of the DDO.services[\"metadata\"].main.workflow entity The rest of the Workflow metadata information (title, author, ect.) as part of the existing Metadata service A workflow, as every DDO in Nevermined, can be resolved using the Asset Id (DID). By the time being, the workflow definition supports the execution of sequential stages. It's not supported yet the execution of parallel stages. Publishing an Asset including Compute Services \u00b6 The Compute services are published as part of the asset (dataset) metadata as an additional service offered for that specific asset. The complete flow of publishing an asset with a compute service attached is: PUBLISHER generates a DID. See How to compute a DID . PUBLISHER creates a DDO including the following information: DID Metadata. It contains the asset name, description, etc. For more details see METADATA SPEC . Public key of the PUBLISHER A list of services (Access, etc). For more details see ACCESS SPEC . Each service in the list contains certain information depending on its type. Here we document the Compute service. The Access and Metadata services where discussed in the scope of the ACCESS SPEC . A service of type \"compute\" contains: Service Definition ID ( serviceDefinitionId ); this helps PUBLISHER find the service definition of a DDO signed by CONSUMER Service Agreement Template ID ( templateId ); points to an instance of a Service Agreement Template stored by the Template Store Manager. In this case is a template implementing the Compute end to end flow Service endpoint ( serviceEndpoint ); CONSUMERS signing this service send their signatures to this endpoint to request the execution of a workflow A list of condition keys; condition key is the keccak256 hash of the following: SLA template ID controller contract address (obtained from the solidity contract json file matching the contract name in the SLA condition) controller contract function fingerprint (referred to as function signature or selector) For each condition, a list is required of its parameter values, a timeout, a set of fields determining what conditions depend on other conditions, and a mapping of events emitted by the condition to the off-chain handlers of these events Each event is identified by name. Each event handler is a function from a whitelisted module Service Agreement contract address and the event mapping in the same format as the condition events, for off-chain listeners An integer defining when the agreement is fulfilled in case there are multiple terminal conditions, according to the Service Agreement smart contract A service of type \"compute\" contains one endpoint: - serviceEndpoint - A URL to call when the CONSUMER request the execution of a workflow An example of a complete DDO can be found [here](/tree/master/docs/architecture/specs/compute/examples/ddo.workflow.json). Please do note that the condition's order in the DID document should reflect the same order in on-chain service agreement. PUBLISHER publishes the DDO in the METADATA-API . This DDO must include at least one service of type \"compute\". here you have an example of the DDO including a Compute service. Below you can find a small fraction of this: \"container\": \"service\" : [{ \"type\" : \"compute\" , \"serviceDefinitionId\" : \"2\" , \"serviceEndpoint\" : \"http://mygateway.org/api/v1/gateway/services/execute\" , \"templateId\" : \"804932804923850985093485039850349850439583409583404534231321131a\" , \"attributes\" : { \"main\" : { \"creator\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"datePublished\" : \"2019-04-09T19:02:11Z\" , \"price\" : \"10\" , \"timeout\" : 86400 , \"provider\" : { \"type\" : \"Azure\" , \"description\" : \"\" , \"environment\" : { \"cluster\" : { \"type\" : \"Kubernetes\" , \"url\" : \"http://10.0.0.17/xxx\" }, \"supportedContainers\" : [{ \"image\" : \"tensorflow/tensorflow\" , \"tag\" : \"latest\" , \"checksum\" : \"sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc\" }, { \"image\" : \"tensorflow/tensorflow\" , \"tag\" : \"latest\" , \"checksum\" : \"sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc\" }], \"supportedServers\" : [{ \"serverId\" : \"1\" , \"serverType\" : \"xlsize\" , \"price\" : \"5000000000000000000\" , \"cpu\" : \"16\" , \"gpu\" : \"0\" , \"memory\" : \"128gb\" , \"disk\" : \"160gb\" , \"maxExecutionTime\" : 86400 }, { \"containerId\" : \"2\" , \"typeContainer\" : \"medium\" , \"price\" : \"1000000000000000000\" , \"cpu\" : \"2\" , \"gpu\" : \"0\" , \"memory\" : \"8gb\" , \"disk\" : \"80gb\" , \"maxExecutionTime\" : 86400 }] } }, \"serviceAgreementTemplate\" : { \"contractName\" : \"ServiceExecutionTemplate\" , \"events\" : [{ \"name\" : \"AgreementCreated\" , \"actorType\" : \"consumer\" , \"handler\" : { \"moduleName\" : \"serviceExecutionTemplate\" , \"functionName\" : \"fulfillLockPaymentCondition\" , \"version\" : \"0.1\" } }], \"fulfillmentOrder\" : [ \"lockPayment.fulfill\" , \"serviceExecution.fulfill\" , \"escrowPayment.fulfill\" ], \"conditionDependency\" : { \"lockPayment\" : [], \"serviceExecution\" : [], \"releaseReward\" : [ \"lockPayment\" , \"serviceExecution\" ] }, \"conditions\" : [{ \"name\" : \"lockPayment\" , \"timelock\" : 0 , \"timeout\" : 0 , \"contractName\" : \"LockPaymentCondition\" , \"functionName\" : \"fulfill\" , \"parameters\" : [ { \"name\" : \"_did\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_rewardAddress\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_tokenAddress\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_amounts\" , \"type\" : \"uint256[]\" , \"value\" : [] }, { \"name\" : \"_receivers\" , \"type\" : \"address[]\" , \"value\" : [] } ], \"events\" : [{ \"name\" : \"Fulfilled\" , \"actorType\" : \"publisher\" , \"handler\" : { \"moduleName\" : \"lockPaymentConditon\" , \"functionName\" : \"fulfillServiceExecutionCondition\" , \"version\" : \"0.1\" } }] }, { \"name\" : \"execCompute\" , \"timelock\" : 0 , \"timeout\" : 0 , \"contractName\" : \"ComputeExecutionCondition\" , \"functionName\" : \"fulfill\" , \"parameters\" : [{ \"name\" : \"_did\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_grantee\" , \"type\" : \"address\" , \"value\" : \"\" } ], \"events\" : [{ \"name\" : \"Fulfilled\" , \"actorType\" : \"publisher\" , \"handler\" : { \"moduleName\" : \"execCompute\" , \"functionName\" : \"fulfillServiceExecutionCondition\" , \"version\" : \"0.1\" } }, { \"name\" : \"TimedOut\" , \"actorType\" : \"consumer\" , \"handler\" : { \"moduleName\" : \"execCompute\" , \"functionName\" : \"fulfillServiceExecutionCondition\" , \"version\" : \"0.1\" } } ] }, { \"name\" : \"escrowPayment\" , \"timelock\" : 0 , \"timeout\" : 0 , \"contractName\" : \"EscrowPaymentCondition\" , \"functionName\" : \"fulfill\" , \"parameters\" : [ { \"name\" : \"_did\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_amounts\" , \"type\" : \"uint256[]\" , \"value\" : [] }, { \"name\" : \"_receivers\" , \"type\" : \"address[]\" , \"value\" : [] }, { \"name\" : \"_sender\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_tokenAddress\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_lockCondition\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_releaseCondition\" , \"type\" : \"bytes32\" , \"value\" : \"\" } ], \"events\" : [{ \"name\" : \"Fulfilled\" , \"actorType\" : \"publisher\" , \"handler\" : { \"moduleName\" : \"escrowPaymentConditon\" , \"functionName\" : \"verifyRewardTokens\" , \"version\" : \"0.1\" } }] } ] } } } }] PUBLISHER registers the DID, associating the Asset DID to the METADATA API URL that resolves the DID to a DDO. To do that, the SDK integrates the DIDRegistry contract using the registerAttribute method. Publishing & Executing a Compute Service Setting up the Service Execution Agreement \u00b6 Registering Asset \u00b6 Using only one SDK call registerAsset(asset_metadata, services_description, publisher_public_key) , the PUBLISHER should be able to register an Asset including a Compute service. The services_description attribute includes the different services (like compute) associated to this asset. Consuming Asset \u00b6 During this phase, through the CONSUMER and the PROVIDER (via GATEWAY) negotiation, the Service Execution Agreement (SEA) is created and initialized. Using the SDK, a CONSUMER can discover, purchase and use the PROVIDER Compute services. The complete flow for setting up the SEA is: The CONSUMER chooses a service inside a DDO (the CONSUMER selects a serviceDefinitionId ). The Service Agreement needs to have an associated unique serviceAgreementId that can be generated/provided by the CONSUMER. In the Smart Contracts, this serviceAgreementId will be stored as a bytes32 . This serviceAgreementId is random and is represented by a 64-character hex string (using the characters 0-9 and a-f). The CONSUMER can generate the serviceAgreementId using any kind of implementation providing enough randomness to generate this ID (64-characters hex string). The CONSUMER signs the service details. The signature contains (templateId, conditionTypes, valuesHashList, timeoutValues, serviceAgreementId) . serviceAgreementId is provided by the CONSUMER and has to be globally unique. Each ith item in values_hash_list and timeoutValues lists corresponds to the ith condition in conditionKeys values_hash_list : a hash of the parameters types and values of each condition timeoutValues : list of numbers to specify a timeout value for each condition. It is used to correlate events and to prevent the PUBLISHER from instantiating multiple Service Agreements from a single request. The CONSUMER initializes the SEA on-chain (did, serviceAgreementId, serviceDefinitionId, signature, consumerAddress, workflowId ). The CONSUMER locks the payment on-chain through the LockPaymentCondition Smart Contract The PROVIDER via GATEWAY, receives the LockPayment.Fulfilled event where he/she is the provider for this agreement The PROVIDER grants the execution permissions for the computation on-chain calling the executeComputeCondition.Fullfill method The CONSUMER gets the executeComputeCondition.Fullfilled event. When he/she receives the event, can call the GATEWAY serviceEndpoint url added in the DDO to start the execution of the computation workflow. Typically: HTTP POST /api/v1/gateway/services/exec The GATEWAY receives the CONSUMER request, and calls the checkPermissions method to validate if the CONSUMER address is granted to execute the service. If user is granted, the GATEWAY triggers the Execute Algorithm action in the infrastructure Execution phase \u00b6 During this phase, if and only if the CONSUMER is granted, the CONSUMER can request the start of the Computation in the PUBLISHER infrastructure via GATEWAY. The complete flow for the Execution phase is: The GATEWAY after receiving the execution request from CONSUMER, validates the permissions using the checkPermissions function If the CONSUMER is authorized, the GATEWAY resolves the DID of the Workflow associated with the Service Agreement. The workflow includes the details of the pipeline to execute, including the different stages, inputs and outputs. The GATEWAY starts the communicates with the OPERATOR SERVICE, this register a new execution in the PROVIDER INFRASTRUCTURE (cloud or on-premise). The sends a \"Workflow Registration\" HTTP REST request to the Infrastructure Operator (aka OPERATOR SERVICE). This request must include the serviceAgreementId and the Workflow (JSON) The OPERATOR SERVICE receives a \"Workflow Registration\" request and: Validates in K8s there is no an existing/running workflow with the same serviceAgreementId Creates an unique workflowExecutionId identifying a unique execution of the service Validates the container flavour defined by the CONSUMER in the Workflow is supported in the compute service (DDO) Register the workflow in Kubernetes (K8s) All the actions made by the OPERATOR in the infrastructure via K8s MUST include the serviceAgreementId and workflowExecutionId as tags/labels For each stage in the workflow, the OPERATOR orchestrates Orchestration Steps When a new Workflow is created in K8s, the OPERATOR ENGINE fetch the event and execute the following 3 steps: Configuration - The OPERATOR ENGINE starts the \"Configuration Pod\". This pod is in charge of prepare the environment connecting the input volumes to a secure container. Also is in charge of resolving all the DID's involved into the real assets and leave everything ready for further execution. After finishing the pod is stopped. Executing - The OPERATOR ENGINE starts the \"Compute Pod\". This pod is in charge of using the data & algorithm existing in the input volumes, execute the algorithm. The pod only can write data to the output volume. After finishing the execution of the algorithm the pod is stopped. Publishing - The OPERATOR ENGINE starts the \"Publishing Pod\". This pod is in charge of publishing as a new Asset the result generated to the output volume. The ownership of the asset is transferred to the user triggering the computation workflow (typically the data scientist/engineer). After finishing the pod is stopped. The OPERATOR requests the deletion of all the containers and volumes created in the Kubernetes cluster The OPERATOR retrieves from the INFRASTRUCTURE (if it's available) a receipt demonstrating the execution of the service The CONSUMER receives an event including the DID of the new ASSET created The GATEWAY or any other user may requests the releasePayment through the SMART CONTRACTS. It commits on-chain the HASH of the receipt ticket collected from the INFRASTRUCTURE provider. Execution Flow Infrastructure Orchestration \u00b6 To facilitate the infrastructure orchestration the GATEWAY integrates with Kubernetes (aka K8s) via the OPERATOR component. The OPERATOR allows to abstract the execution of Docker containers with compute services independently of the backend (Amazon, Azure, On-Premise). To support that OPERATOR includes the kubernetes driver allowing to wrap the complete execution including: Download of the container images Setting up the pods Creation of volumes Starting and stopping the service Retrieval of logs Registering the new Asset Destroy the pods The OPERATOR handles 3 types of K8s Pods: Configuration Pod is in charge of resolve the Workflow resources necessary for the execution of the algorithm. It copies the data and algorithm in volumes Compute Pod is in charge of run the algorithm. This pod has access in read-only mode to the volumes with the input data and write mode to the output volume Publishing Pod is in charge of having all the data and logs generated in the output volume to publish this data in Nevermined as a new asset and handover the ownership to the CONSUMER Services Provided by the Operator \u00b6 The services provided by the OPERATOR are: Registering a new Workflow execution. Given a serviceAgreementId and a Workflow payload, starts the execution of the Workflow. It returns a workflowExecutionId valid to track the execution of the Workflow. Retrieve logs. Given a serviceAgreementId and workflowExecutionId retrieve the logs associated to that execution Stop workflow execution. Given a serviceAgreementId and workflowExecutionId stop/delete all the containers associated with them Orchestration Steps \u00b6 The compute scenario requires a complete orchestration of different stages in order to provide an end to end flow. The steps included in this scenario are: The CONSUMER send a request to the GATEWAY using the compute/exec method in order to trigger the Workflow execution The GATEWAY receives this request and check on-chain via SMART CONTRACTS if the CONSUMER has grants to execute the Workflow. If the CONSUMER has grants will continue the Infrastructure Operation integration, if not will return an error message. The GATEWAY calls the Infrastructure Operator (aka OPERATOR SERVICE) giving the Workflow that needs to be executed The OPERATOR SERVICE communicates with the K8s cluster to register the Workflow in Kubernetes The OPERATOR ENGINE is registered to the new Workflow Events. When this happens The OPERATOR via K8s starts a generic Configuration Pod . The responsibilities of the configuration pod are: Parses the Workflow document Resolves the DID resources necessary to run the Workflow Pulls the docker image from the Docker registry Plugs the different data inputs as volumes in the Compute Pod Plugs the output for data and logs as volumes in the Compute Pod After all the above steps the Configuration Pod must be stopped If the Configuration Pod ends successfully the OPERATOR via K8s starts the Compute Pod using the flavour specified by the user in the Workflow definition The Compute Pod starts and runs the compute-entrypoint.sh part of the algorithm downloaded by the Configuration Pod When the Compute Pod ends or the duration is too long (timeout), the OPERATOR via K8s stop and delete the Compute Pod If the Compute Pod ends, the OPERATOR start a new instance of the Publishing Pod . The responsibilities of the Publishing Pod are: List of the Log files generated in the Log volume and copy to the output List of the Output data generated in the Output volume Generate a new Asset Metadata using the information provided by the CONSUMER Register a new Asset in Nevermined including the Output & Log data generated Transfer the ownership of the new Asset created to the CONSUMER At this point the CONSUMER could get an event of a new created asset where he/she is the owner Infrastructure Orchestration Infrastructure Operator \u00b6 In this SPEC the PROVIDER of a computation service is in charge of defining the requirements to allow the execution of algorithms on top of the data assets. It means only the images specified in the DDO by the publisher with a specific DID and checksum will be allowed to be executed in the Runtime environment. The OPERATOR SERVICE is in charge of setting up the runtime environment speaking with the infrastructure provider via Kubernetes. The images defined in the DDO and defined by the PUBLISHER only SHOULD include the minimum libraries specified, it will reduce the risk of executing unexpected software via external libraries. In addition to this, it's recommended that the images running in the runtime environment don't have network connectivity a part of the minimum required to get access to the Assets. Volumes \u00b6 The input assets will be added to the runtime environment as read only volumes. The complete paths to the folders where the volumes are mounted will be given to the algorithm as parameters, using the same order of the parameters specified in the Workflow definition. The new derived Asset generated as a result of the execution of the algorithm MUST be written in the output volume. The pods will be destroyed after the execution, so only the data stored in the output or logs volumes should be used. Type Permissions CLI Parameter Input Read --input1=/mnt/volume1 --input2=/mnt/volume2 Output Read, Write --output=/mnt/output Logs Read, Write --logs=/mnt/logs Network isolation \u00b6 The runtime environment doesn't need to have network connectivity to external networks to be executed. To avoid sending the internal information about the data, it's recommended to restrict the output connectivity.","title":"Data In Situ Computation"},{"location":"architecture/specs/compute/#compute-spec-data-in-situ-computation","text":"shortname: COMPUTE name: Data In Situ Computation type: Standard status: Valid version: 0.1 editor: Aitor Argomaniz <aitor@nevermined.io> contributors: COMPUTE SPEC: Data in situ Computation Execution of Remote Compute Services using Service Agreements Motivation Actors Technical components Flow Terminology Requirements Workflows Publishing an Asset including Compute Services Setting up the Service Execution Agreement Registering Asset Consuming Asset Execution phase Infrastructure Orchestration Services Provided by the Operator Orchestration Steps Infrastructure Operator Volumes Network isolation","title":"COMPUTE SPEC: Data in situ Computation"},{"location":"architecture/specs/compute/#execution-of-remote-compute-services-using-service-agreements","text":"This SPEC introduces the integration pattern for the usage of Service Execution Agreements (SEA) (also called Service Agreements or Agreements) as contracts between parties interacting in the execution of a Compute Service transaction. This SPEC using the SEA as core element, orchestrates the publishing/execution of this type of compute services. The intention of this SPEC is to describe the flow and integration pattern independently of the infrastructure Cloud Compute Service. This SPEC MUST be valid for integrating classical infrastructure cloud providers like Amazon EC2 or Azure, but also can be used to integrate other compute providers or On-Premise infrastructure. It's out of the scope to detail the Service Execution Agreements implementation.","title":"Execution of Remote Compute Services using Service Agreements"},{"location":"architecture/specs/compute/#motivation","text":"The main motivations of this SPEC are: Identify the actors involved on the definition and execution of a Nevermined Compute service Detail the main characteristics of this interaction Specify the pros and cons of this approach Identify the API methods exposed via the different libraries","title":"Motivation"},{"location":"architecture/specs/compute/#actors","text":"The different actors interacting in this flow are: PROVIDERS - Give access to the Compute Services CONSUMERS - Want to make use of the Compute Services MARKETPLACES or DOMAINS - Store the DDO/Metadata related with the Assets/services INFRASTRUCTURE - Cloud or on-premise infrastructure services providing computing. Typically Amazon, Azure, etc.","title":"Actors"},{"location":"architecture/specs/compute/#technical-components","text":"The following technical components are involved in an end-to-end publishing and consumption flow: MARKETPLACE - Exposes a web interface allowing the users to publish and purchase assets and services associated to these assets. It also facilitates the discovery of assets. SDK - Software library encapsulating the Nevermined business logic. It's used to interact with all the components & APIs of the system. It's currently implemented in the following packages: nevermined-sdk-js - JavaScript version of the Nevermined SDK to be integrated with front-end applications. nevermined-sdk-py - Python version of the Nevermined SDK to be integrated with back-end applications. The primary users are data scientists. nevermined-sdk-java - Java version of the Nevermined SDK to be integrated with JVM applications. The primary users are data engineers. SMART CONTRACTS - Solidity Smart Contracts providing the Service Agreements business logic. GATEWAY - Microservice to be executed by PUBLISHERS. It exposes an HTTP REST API permitting access to PUBLISHER assets or additional services such as computation. METADATA-API - Microservice to be executed by MARKETPLACES. Facilitates creating, updating, deleting and searching the asset metadata registered by the PUBLISHERS. This metadata is included as part of a DDO (see DID SPEC and METADATA SPEC ) and also includes the services associated with the asset (consumption, computation, etc.).","title":"Technical components"},{"location":"architecture/specs/compute/#flow","text":"This section describes the Asset Compute Service flow in detail. There are some parameters used in this flow: DID - See DID SPEC . serviceAgreementId - Is the unique ID referring to a Service Execution Agreement established between a PUBLISHER and a CONSUMER. The CONSUMER (via SDK) is the one creating this random unique serviceAgreementId. serviceDefinitionId - Identifies one service in the array of services included in the DDO. It is created by the PUBLISHER (via SDK) upon DDO creation and is associated with different services. templateId - Identifies a unique Service Agreement template.","title":"Flow"},{"location":"architecture/specs/compute/#terminology","text":"Compute Provider - Entity providing a compute service for a price (or for free). Compute Service - Service offered by a Compute Provider. It could have different conditions like the type of services, price, etc. Workflow - It describes an execution pipeline where you put together input data and an algorithm to process this data and you run using a Compute Service.","title":"Terminology"},{"location":"architecture/specs/compute/#requirements","text":"A COMPUTE PROVIDER or PROVIDER define the conditions that a Compute service supports. It includes: What kind of image (Docker container) can be deployed in the infrastructure What are the infrastructure resources available (CPU, memory, storage) What is the price of using the infrastructure resources A COMPUTE PROVIDER defines a Compute Service in the scope of the Asset (DID/DDO) of the dataset that can be computed A CONSUMER defines the task to execute modeling it in a Workflow (including configuration, input, transformations and output) A workflow is a new type of Asset. It can be resolvable and be used across multiple independent compute services A CONSUMER purchasing a compute service defines which Workflow (DID) is going to execute A CONSUMER can purchase a service given by a PROVIDER and execute multiple times till the timeout expires A CONSUMER could purchase a service and execute later, the purchase MUST be totally decoupled of execution The previous two points could support to buy once a compute service and execute for example the service every night at 3 am Data in situ Computation","title":"Requirements"},{"location":"architecture/specs/compute/#workflows","text":"From a high-level point of view, a workflow may be considered a view or representation of a real work. A workflow consists of an orchestrated and repeatable pattern of activities transformed into tasks that transform or process information. In Nevermined, we use the concept of workflow to represent a list of tasks to accomplish with the intention of process data. From a technical point of view, a workflow is a type of Asset (it takes advantage of all the Nevermined plumbing of registering, metadata publishing, resolving, etc.). The main objective of a workflow is to describe an execution pipeline. A workflow can be split in sequential stages, having each stage an input, transformation (via algorithm) and output. In the below example, a workflow is modeled in a JSON document with the following characteristics: It has a list of sorted stages by the stages.index parameter to be executed sequentially Each stage has a list of minimum requirements, like the image required to support the execution of the algorithm, minimum cpu, memory, etc. Each stage has an array of sorted input parameters. Each input parameter may be: A DID (example: \"id\": \"did:nv:12345\" ) The output of a previous stage (example: \"previousIndexStage\": 0 ) Each stage has one transformation entry. It includes the id (DID) of the asset in charge of process the input to generate some output Each stage includes an entry with some additional output details. This could be a DID or a specific detail about the expected output. Workflow JSON Model Example of a Workflow: { \"service\" : [{ \"index\" : \"0\" , \"type\" : \"metadata\" , \"serviceEndpoint\" : \"https://service/api/v1/metadata/assets/ddo/did:nv:0ebed8226ada17fde24b6bf2b95d27f8f05fcce09139ff5cec31f6d81a7cd2ea\" , \"attributes\" : { \"main\" : { \"type\" : \"workflow\" , \"workflow\" : { \"stages\" : [{ \"index\" : 0 , \"stageType\" : \"Filtering\" , \"requirements\" : { \"serverInstances\" : 1 , \"container\" : { \"image\" : \"tensorflow/tensorflow\" , \"tag\" : \"latest\" , \"checksum\" : \"sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc\" } }, \"input\" : [{ \"index\" : 0 , \"id\" : \"did:nv:12345\" }, { \"index\" : 1 , \"id\" : \"did:nv:67890\" }], \"transformation\" : { \"id\" : \"did:nv:abcde\" }, \"output\" : {} }, { \"index\" : 1 , \"stageType\" : \"Transformation\" , \"requirements\" : { \"serverInstances\" : 1 , \"container\" : { \"image\" : \"tensorflow/tensorflow\" , \"tag\" : \"latest\" , \"checksum\" : \"sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc\" } }, \"input\" : [{ \"index\" : 0 , \"previousStage\" : 0 }], \"transformation\" : { \"id\" : \"did:nv:999999\" }, \"output\" : {} }] } }, \"additional\" : {}, \"curation\" : {} } }, {} ] } A Workflow is a new type of Asset (a part of datasets, algorithms, etc.). You can find a complete DDO of type workflow in the ddo.workflow.json example file . As a new kind of asset, the workflow details will be persisted inside a DDO as part of the \"Metadata\" service where the type is workflow . An Asset of type workflow, will include in the DDO the following information: The Workflow model as part of the DDO.services[\"metadata\"].main.workflow entity The rest of the Workflow metadata information (title, author, ect.) as part of the existing Metadata service A workflow, as every DDO in Nevermined, can be resolved using the Asset Id (DID). By the time being, the workflow definition supports the execution of sequential stages. It's not supported yet the execution of parallel stages.","title":"Workflows"},{"location":"architecture/specs/compute/#publishing-an-asset-including-compute-services","text":"The Compute services are published as part of the asset (dataset) metadata as an additional service offered for that specific asset. The complete flow of publishing an asset with a compute service attached is: PUBLISHER generates a DID. See How to compute a DID . PUBLISHER creates a DDO including the following information: DID Metadata. It contains the asset name, description, etc. For more details see METADATA SPEC . Public key of the PUBLISHER A list of services (Access, etc). For more details see ACCESS SPEC . Each service in the list contains certain information depending on its type. Here we document the Compute service. The Access and Metadata services where discussed in the scope of the ACCESS SPEC . A service of type \"compute\" contains: Service Definition ID ( serviceDefinitionId ); this helps PUBLISHER find the service definition of a DDO signed by CONSUMER Service Agreement Template ID ( templateId ); points to an instance of a Service Agreement Template stored by the Template Store Manager. In this case is a template implementing the Compute end to end flow Service endpoint ( serviceEndpoint ); CONSUMERS signing this service send their signatures to this endpoint to request the execution of a workflow A list of condition keys; condition key is the keccak256 hash of the following: SLA template ID controller contract address (obtained from the solidity contract json file matching the contract name in the SLA condition) controller contract function fingerprint (referred to as function signature or selector) For each condition, a list is required of its parameter values, a timeout, a set of fields determining what conditions depend on other conditions, and a mapping of events emitted by the condition to the off-chain handlers of these events Each event is identified by name. Each event handler is a function from a whitelisted module Service Agreement contract address and the event mapping in the same format as the condition events, for off-chain listeners An integer defining when the agreement is fulfilled in case there are multiple terminal conditions, according to the Service Agreement smart contract A service of type \"compute\" contains one endpoint: - serviceEndpoint - A URL to call when the CONSUMER request the execution of a workflow An example of a complete DDO can be found [here](/tree/master/docs/architecture/specs/compute/examples/ddo.workflow.json). Please do note that the condition's order in the DID document should reflect the same order in on-chain service agreement. PUBLISHER publishes the DDO in the METADATA-API . This DDO must include at least one service of type \"compute\". here you have an example of the DDO including a Compute service. Below you can find a small fraction of this: \"container\": \"service\" : [{ \"type\" : \"compute\" , \"serviceDefinitionId\" : \"2\" , \"serviceEndpoint\" : \"http://mygateway.org/api/v1/gateway/services/execute\" , \"templateId\" : \"804932804923850985093485039850349850439583409583404534231321131a\" , \"attributes\" : { \"main\" : { \"creator\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"datePublished\" : \"2019-04-09T19:02:11Z\" , \"price\" : \"10\" , \"timeout\" : 86400 , \"provider\" : { \"type\" : \"Azure\" , \"description\" : \"\" , \"environment\" : { \"cluster\" : { \"type\" : \"Kubernetes\" , \"url\" : \"http://10.0.0.17/xxx\" }, \"supportedContainers\" : [{ \"image\" : \"tensorflow/tensorflow\" , \"tag\" : \"latest\" , \"checksum\" : \"sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc\" }, { \"image\" : \"tensorflow/tensorflow\" , \"tag\" : \"latest\" , \"checksum\" : \"sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc\" }], \"supportedServers\" : [{ \"serverId\" : \"1\" , \"serverType\" : \"xlsize\" , \"price\" : \"5000000000000000000\" , \"cpu\" : \"16\" , \"gpu\" : \"0\" , \"memory\" : \"128gb\" , \"disk\" : \"160gb\" , \"maxExecutionTime\" : 86400 }, { \"containerId\" : \"2\" , \"typeContainer\" : \"medium\" , \"price\" : \"1000000000000000000\" , \"cpu\" : \"2\" , \"gpu\" : \"0\" , \"memory\" : \"8gb\" , \"disk\" : \"80gb\" , \"maxExecutionTime\" : 86400 }] } }, \"serviceAgreementTemplate\" : { \"contractName\" : \"ServiceExecutionTemplate\" , \"events\" : [{ \"name\" : \"AgreementCreated\" , \"actorType\" : \"consumer\" , \"handler\" : { \"moduleName\" : \"serviceExecutionTemplate\" , \"functionName\" : \"fulfillLockPaymentCondition\" , \"version\" : \"0.1\" } }], \"fulfillmentOrder\" : [ \"lockPayment.fulfill\" , \"serviceExecution.fulfill\" , \"escrowPayment.fulfill\" ], \"conditionDependency\" : { \"lockPayment\" : [], \"serviceExecution\" : [], \"releaseReward\" : [ \"lockPayment\" , \"serviceExecution\" ] }, \"conditions\" : [{ \"name\" : \"lockPayment\" , \"timelock\" : 0 , \"timeout\" : 0 , \"contractName\" : \"LockPaymentCondition\" , \"functionName\" : \"fulfill\" , \"parameters\" : [ { \"name\" : \"_did\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_rewardAddress\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_tokenAddress\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_amounts\" , \"type\" : \"uint256[]\" , \"value\" : [] }, { \"name\" : \"_receivers\" , \"type\" : \"address[]\" , \"value\" : [] } ], \"events\" : [{ \"name\" : \"Fulfilled\" , \"actorType\" : \"publisher\" , \"handler\" : { \"moduleName\" : \"lockPaymentConditon\" , \"functionName\" : \"fulfillServiceExecutionCondition\" , \"version\" : \"0.1\" } }] }, { \"name\" : \"execCompute\" , \"timelock\" : 0 , \"timeout\" : 0 , \"contractName\" : \"ComputeExecutionCondition\" , \"functionName\" : \"fulfill\" , \"parameters\" : [{ \"name\" : \"_did\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_grantee\" , \"type\" : \"address\" , \"value\" : \"\" } ], \"events\" : [{ \"name\" : \"Fulfilled\" , \"actorType\" : \"publisher\" , \"handler\" : { \"moduleName\" : \"execCompute\" , \"functionName\" : \"fulfillServiceExecutionCondition\" , \"version\" : \"0.1\" } }, { \"name\" : \"TimedOut\" , \"actorType\" : \"consumer\" , \"handler\" : { \"moduleName\" : \"execCompute\" , \"functionName\" : \"fulfillServiceExecutionCondition\" , \"version\" : \"0.1\" } } ] }, { \"name\" : \"escrowPayment\" , \"timelock\" : 0 , \"timeout\" : 0 , \"contractName\" : \"EscrowPaymentCondition\" , \"functionName\" : \"fulfill\" , \"parameters\" : [ { \"name\" : \"_did\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_amounts\" , \"type\" : \"uint256[]\" , \"value\" : [] }, { \"name\" : \"_receivers\" , \"type\" : \"address[]\" , \"value\" : [] }, { \"name\" : \"_sender\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_tokenAddress\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_lockCondition\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_releaseCondition\" , \"type\" : \"bytes32\" , \"value\" : \"\" } ], \"events\" : [{ \"name\" : \"Fulfilled\" , \"actorType\" : \"publisher\" , \"handler\" : { \"moduleName\" : \"escrowPaymentConditon\" , \"functionName\" : \"verifyRewardTokens\" , \"version\" : \"0.1\" } }] } ] } } } }] PUBLISHER registers the DID, associating the Asset DID to the METADATA API URL that resolves the DID to a DDO. To do that, the SDK integrates the DIDRegistry contract using the registerAttribute method. Publishing & Executing a Compute Service","title":"Publishing an Asset including Compute Services"},{"location":"architecture/specs/compute/#setting-up-the-service-execution-agreement","text":"","title":"Setting up the Service Execution Agreement"},{"location":"architecture/specs/compute/#registering-asset","text":"Using only one SDK call registerAsset(asset_metadata, services_description, publisher_public_key) , the PUBLISHER should be able to register an Asset including a Compute service. The services_description attribute includes the different services (like compute) associated to this asset.","title":"Registering Asset"},{"location":"architecture/specs/compute/#consuming-asset","text":"During this phase, through the CONSUMER and the PROVIDER (via GATEWAY) negotiation, the Service Execution Agreement (SEA) is created and initialized. Using the SDK, a CONSUMER can discover, purchase and use the PROVIDER Compute services. The complete flow for setting up the SEA is: The CONSUMER chooses a service inside a DDO (the CONSUMER selects a serviceDefinitionId ). The Service Agreement needs to have an associated unique serviceAgreementId that can be generated/provided by the CONSUMER. In the Smart Contracts, this serviceAgreementId will be stored as a bytes32 . This serviceAgreementId is random and is represented by a 64-character hex string (using the characters 0-9 and a-f). The CONSUMER can generate the serviceAgreementId using any kind of implementation providing enough randomness to generate this ID (64-characters hex string). The CONSUMER signs the service details. The signature contains (templateId, conditionTypes, valuesHashList, timeoutValues, serviceAgreementId) . serviceAgreementId is provided by the CONSUMER and has to be globally unique. Each ith item in values_hash_list and timeoutValues lists corresponds to the ith condition in conditionKeys values_hash_list : a hash of the parameters types and values of each condition timeoutValues : list of numbers to specify a timeout value for each condition. It is used to correlate events and to prevent the PUBLISHER from instantiating multiple Service Agreements from a single request. The CONSUMER initializes the SEA on-chain (did, serviceAgreementId, serviceDefinitionId, signature, consumerAddress, workflowId ). The CONSUMER locks the payment on-chain through the LockPaymentCondition Smart Contract The PROVIDER via GATEWAY, receives the LockPayment.Fulfilled event where he/she is the provider for this agreement The PROVIDER grants the execution permissions for the computation on-chain calling the executeComputeCondition.Fullfill method The CONSUMER gets the executeComputeCondition.Fullfilled event. When he/she receives the event, can call the GATEWAY serviceEndpoint url added in the DDO to start the execution of the computation workflow. Typically: HTTP POST /api/v1/gateway/services/exec The GATEWAY receives the CONSUMER request, and calls the checkPermissions method to validate if the CONSUMER address is granted to execute the service. If user is granted, the GATEWAY triggers the Execute Algorithm action in the infrastructure","title":"Consuming Asset"},{"location":"architecture/specs/compute/#execution-phase","text":"During this phase, if and only if the CONSUMER is granted, the CONSUMER can request the start of the Computation in the PUBLISHER infrastructure via GATEWAY. The complete flow for the Execution phase is: The GATEWAY after receiving the execution request from CONSUMER, validates the permissions using the checkPermissions function If the CONSUMER is authorized, the GATEWAY resolves the DID of the Workflow associated with the Service Agreement. The workflow includes the details of the pipeline to execute, including the different stages, inputs and outputs. The GATEWAY starts the communicates with the OPERATOR SERVICE, this register a new execution in the PROVIDER INFRASTRUCTURE (cloud or on-premise). The sends a \"Workflow Registration\" HTTP REST request to the Infrastructure Operator (aka OPERATOR SERVICE). This request must include the serviceAgreementId and the Workflow (JSON) The OPERATOR SERVICE receives a \"Workflow Registration\" request and: Validates in K8s there is no an existing/running workflow with the same serviceAgreementId Creates an unique workflowExecutionId identifying a unique execution of the service Validates the container flavour defined by the CONSUMER in the Workflow is supported in the compute service (DDO) Register the workflow in Kubernetes (K8s) All the actions made by the OPERATOR in the infrastructure via K8s MUST include the serviceAgreementId and workflowExecutionId as tags/labels For each stage in the workflow, the OPERATOR orchestrates Orchestration Steps When a new Workflow is created in K8s, the OPERATOR ENGINE fetch the event and execute the following 3 steps: Configuration - The OPERATOR ENGINE starts the \"Configuration Pod\". This pod is in charge of prepare the environment connecting the input volumes to a secure container. Also is in charge of resolving all the DID's involved into the real assets and leave everything ready for further execution. After finishing the pod is stopped. Executing - The OPERATOR ENGINE starts the \"Compute Pod\". This pod is in charge of using the data & algorithm existing in the input volumes, execute the algorithm. The pod only can write data to the output volume. After finishing the execution of the algorithm the pod is stopped. Publishing - The OPERATOR ENGINE starts the \"Publishing Pod\". This pod is in charge of publishing as a new Asset the result generated to the output volume. The ownership of the asset is transferred to the user triggering the computation workflow (typically the data scientist/engineer). After finishing the pod is stopped. The OPERATOR requests the deletion of all the containers and volumes created in the Kubernetes cluster The OPERATOR retrieves from the INFRASTRUCTURE (if it's available) a receipt demonstrating the execution of the service The CONSUMER receives an event including the DID of the new ASSET created The GATEWAY or any other user may requests the releasePayment through the SMART CONTRACTS. It commits on-chain the HASH of the receipt ticket collected from the INFRASTRUCTURE provider. Execution Flow","title":"Execution phase"},{"location":"architecture/specs/compute/#infrastructure-orchestration","text":"To facilitate the infrastructure orchestration the GATEWAY integrates with Kubernetes (aka K8s) via the OPERATOR component. The OPERATOR allows to abstract the execution of Docker containers with compute services independently of the backend (Amazon, Azure, On-Premise). To support that OPERATOR includes the kubernetes driver allowing to wrap the complete execution including: Download of the container images Setting up the pods Creation of volumes Starting and stopping the service Retrieval of logs Registering the new Asset Destroy the pods The OPERATOR handles 3 types of K8s Pods: Configuration Pod is in charge of resolve the Workflow resources necessary for the execution of the algorithm. It copies the data and algorithm in volumes Compute Pod is in charge of run the algorithm. This pod has access in read-only mode to the volumes with the input data and write mode to the output volume Publishing Pod is in charge of having all the data and logs generated in the output volume to publish this data in Nevermined as a new asset and handover the ownership to the CONSUMER","title":"Infrastructure Orchestration"},{"location":"architecture/specs/compute/#services-provided-by-the-operator","text":"The services provided by the OPERATOR are: Registering a new Workflow execution. Given a serviceAgreementId and a Workflow payload, starts the execution of the Workflow. It returns a workflowExecutionId valid to track the execution of the Workflow. Retrieve logs. Given a serviceAgreementId and workflowExecutionId retrieve the logs associated to that execution Stop workflow execution. Given a serviceAgreementId and workflowExecutionId stop/delete all the containers associated with them","title":"Services Provided by the Operator"},{"location":"architecture/specs/compute/#orchestration-steps","text":"The compute scenario requires a complete orchestration of different stages in order to provide an end to end flow. The steps included in this scenario are: The CONSUMER send a request to the GATEWAY using the compute/exec method in order to trigger the Workflow execution The GATEWAY receives this request and check on-chain via SMART CONTRACTS if the CONSUMER has grants to execute the Workflow. If the CONSUMER has grants will continue the Infrastructure Operation integration, if not will return an error message. The GATEWAY calls the Infrastructure Operator (aka OPERATOR SERVICE) giving the Workflow that needs to be executed The OPERATOR SERVICE communicates with the K8s cluster to register the Workflow in Kubernetes The OPERATOR ENGINE is registered to the new Workflow Events. When this happens The OPERATOR via K8s starts a generic Configuration Pod . The responsibilities of the configuration pod are: Parses the Workflow document Resolves the DID resources necessary to run the Workflow Pulls the docker image from the Docker registry Plugs the different data inputs as volumes in the Compute Pod Plugs the output for data and logs as volumes in the Compute Pod After all the above steps the Configuration Pod must be stopped If the Configuration Pod ends successfully the OPERATOR via K8s starts the Compute Pod using the flavour specified by the user in the Workflow definition The Compute Pod starts and runs the compute-entrypoint.sh part of the algorithm downloaded by the Configuration Pod When the Compute Pod ends or the duration is too long (timeout), the OPERATOR via K8s stop and delete the Compute Pod If the Compute Pod ends, the OPERATOR start a new instance of the Publishing Pod . The responsibilities of the Publishing Pod are: List of the Log files generated in the Log volume and copy to the output List of the Output data generated in the Output volume Generate a new Asset Metadata using the information provided by the CONSUMER Register a new Asset in Nevermined including the Output & Log data generated Transfer the ownership of the new Asset created to the CONSUMER At this point the CONSUMER could get an event of a new created asset where he/she is the owner Infrastructure Orchestration","title":"Orchestration Steps"},{"location":"architecture/specs/compute/#infrastructure-operator","text":"In this SPEC the PROVIDER of a computation service is in charge of defining the requirements to allow the execution of algorithms on top of the data assets. It means only the images specified in the DDO by the publisher with a specific DID and checksum will be allowed to be executed in the Runtime environment. The OPERATOR SERVICE is in charge of setting up the runtime environment speaking with the infrastructure provider via Kubernetes. The images defined in the DDO and defined by the PUBLISHER only SHOULD include the minimum libraries specified, it will reduce the risk of executing unexpected software via external libraries. In addition to this, it's recommended that the images running in the runtime environment don't have network connectivity a part of the minimum required to get access to the Assets.","title":"Infrastructure Operator"},{"location":"architecture/specs/compute/#volumes","text":"The input assets will be added to the runtime environment as read only volumes. The complete paths to the folders where the volumes are mounted will be given to the algorithm as parameters, using the same order of the parameters specified in the Workflow definition. The new derived Asset generated as a result of the execution of the algorithm MUST be written in the output volume. The pods will be destroyed after the execution, so only the data stored in the output or logs volumes should be used. Type Permissions CLI Parameter Input Read --input1=/mnt/volume1 --input2=/mnt/volume2 Output Read, Write --output=/mnt/output Logs Read, Write --logs=/mnt/logs","title":"Volumes"},{"location":"architecture/specs/compute/#network-isolation","text":"The runtime environment doesn't need to have network connectivity to external networks to be executed. To avoid sending the internal information about the data, it's recommended to restrict the output connectivity.","title":"Network isolation"},{"location":"architecture/specs/did/","text":"DID SPEC: Decentralized Identifiers \u00b6 shortname: DID name: Decentralized Identifiers type: Standard status: Valid version: 0.3 editor: Aitor Argomaniz <aitor@nevermined.io> contributors: DID SPEC: Decentralized Identifiers Motivation Specification Proposed Solution Decentralized IDs (DIDs) Publishing and Consumption Flow DID Documents (DDOs) DDO Services DDO Meta information Versions Networks Example Integrity How to compute the integrity checksum DID Document Proof Length of a DID How to compute a DID Registry Resolver References This specification is based on the W3C DID specification , which was at version 0.11 as of August 2018. Motivation \u00b6 The main motivations of this SPEC are: Design a solution to extend the current architecture to use Decentralized Identifiers (DIDs) and DID Documents (DDOs) Understand how to register information on-chain with off-chain integrity associated Understand how to resolve DIDs into DDOs Design a solution facilitating alignment of on-chain and off-chain information Establishing the mechanism to know if the DDO associated with a DID was modified Defining the common mechanisms, interfaces and APIs to implemented the designed solution Define how Nevermined assets can be modeled with a DID/DDO data model Understand how DID hubs are formed, and how they integrate a business and storage layer Specification \u00b6 Requirements are: The DID resolving capabilities MUST be exposed in the client libraries, enabling to resolve a DDO directly in a totally transparent way ASSETS are DATA objects describing RESOURCES under control of a PUBLISHER DLT stores on-chain only the essential information about ASSETS PROVIDERS store the ASSET metadata off-chain DLT doesn't store any ASSET metadata Nevermined doesn't store ASSET contents (e.g. files) An ASSET is modeled in Nevermined as on-chain information stored in the DLT and metadata stored in METADATA API ASSETS on-chain information only can be modified by OWNERS or DELEGATED USERS ASSETS can be resolved using a Decentralized ID (DID) included on-chain and off-chain A DID Document (DDO) should include the ASSET metadata Any kind of object registered in Nevermined MUST have a DID allowing one to uniquely identify that object in the system ASSET DDO (and the metadata included as part of the DDO) is associated to the ASSET information stored on-chain using a common DID A DID can be resolved to get access to a DDO ASSET DDOs can be updated without updating the on-chain information ASSET information stored in the DLT will include a checksum attribute The ASSET on-chain checksum attribute SHOULD include a one-way HASH calculated using the DDO content After the DDO resolving, the DDO HASH can be calculated off-chain to validate if the on-chain and off-chain information is aligned A HASH not matching with the checksum on-chain means the DDO was modified without the on-chain update The function to calculate the hash MUST BE standard Proposed Solution \u00b6 Decentralized IDs (DIDs) \u00b6 A DID is a unique identifier that can be resolved or de-referenced to a standard resource describing the entity (a DID Document or DDO). If we apply this to Nevermined, the DID would be the unique identifier of an object represented in Nevermined (i.e. the Asset ID of an ASSET or the Actor ID of a USER). The DDO SHOULD include the METADATA information associated with this object. The DDO is stored off-chain in Nevermined. In Nevermined, a DID is a string that looks like: did:nv:0ebed8226ada17fde24b6bf2b95d27f8f05fcce09139ff5cec31f6d81a7cd2ea which follows the generic DID scheme . Details about how to compute the DID are given below. Publishing and Consumption Flow \u00b6 Here you have the complete flow using as example a new ASSET: DID Resolver Steps: A Data Publisher, using the Smart Contracts, register the new Resource (ie. ASSET) providing the DID and the DID of the Provider acting as Public service returning the DDO of the Resource (ASSET) The DLT register the Resource using the Service Agreement Smart Contract and after of that register the identity using the DidRegistry Smart Contract. In this point, the attribute is raised as a new event The Data Publisher publishes the DDO in the Metadata api A Data Consumer (it could be a frontend application or a backend software), having a DID and using a client library (Python, Javascript, Java, etc) get the service-ddo attribute associated to the DID directly from the Smart Contracts The Data Consumer, using the provider public url, query directly to the provider passing the DID to obtain the DDO DID Documents (DDOs) \u00b6 If a DID is the index key in a key-value pair, then the DID Document is the value to which the index key points. The combination of a DID and its associated DID Document forms the root record for a decentralized identifier. A DDO document is composed of standard DDO attributes: @context id created updated publicKey authentication proof verifiableCredential service Asset metadata can be included as one of the objects inside the \"service\" array, with type \"metadata\" . DDO Services \u00b6 Each type of asset (dataset, algorithm, workflow, etc, ..) typically will have associated different kind of services. There are 2 type of services that are commonly added to all the assets: metadata - describing the asset provenance - describing the asset provenance Each service include a serviceEndpoint attribute with a URL to the server or document completing that service. Optionally, the service can include a immutableServiceEndpoint attribute with a URL to a repository/service where additional information is stored in an immutable way (i.e IPFS, Filecoin, Arweave, etc). Each service is distinguished by the DDO.service.type attribute. Each service has an attributes section where all the information related to the service is added. As mandatory content, the attributes section will have a main sub-section. This one is important because it must include all the mandatory information that a service has to provide and never change because it is used to calculate the integrity checksum of the service. A part of the attributes.main sub-section, other optional sub-sections can be added (like: attributes.curation or attributes.extra ) depending on the service type. Example: \"service\" : [ { \"index\" : 0 , \"type\" : \"metadata\" , \"serviceEndpoint\" : \"https://service/api/v1/metadata/assets/ddo/did:nv:0ebed8226ada17fde24b6bf2b95d27f8f05fcce09139ff5cec31f6d81a7cd2ea\" , \"immutableServiceEndpoint\" : \"cid://QmVT3wfySvZJqAvkBCyxoz3EvD3yeLqf3cvAssFDpFFXNm\" , \"attributes\" : { \"main\" : {}, \"additionalInformation\" : {}, \"curation\" : {} } }, { \"index\" : 1 , \"type\" : \"provenance\" , \"serviceEndpoint\" : \"https://service/api/v1/provenance/assets/ddo/did:nv:0ebed8226ada17fde24b6bf2b95d27f8f05fcce09139ff5cec31f6d81a7cd2ea\" , \"attributes\" : { \"main\" : {}, \"additionalInformation\" : {} } }, { \"index\" : 2 , \"type\" : \"access\" , \"serviceEndpoint\" : \"https://service/api/v1/access/assets/ddo/did:nv:0ebed8226ada17fde24b6bf2b95d27f8f05fcce09139ff5cec31f6d81a7cd2ea\" , \"attributes\" : { \"main\" : {}, \"additionalInformation\" : {} } } ] You can find a complete example of a DDO . You can find a complete reference of the asset metadata in METADATA SPEC . You can find a complete real world example of a DDO with extended services added, as part of the W3C DID spec. DDO Meta information \u00b6 This section (named meta ) provides additional information about the DDO itself including versions, and networks where this DDO is valid. It will include 2 main blocks of information: Versions \u00b6 Allows to register the different linear versions of the DDO created. It is an array sorted by version creation including the following information: Version Id ( _id ) - Unique identifier of the version, it could be a DID Tag or Version number ( tag ) Created date time - Datetime refereing when it was created without sub-second decimal precision Change checksum ( checksum ) - Optional attribute with a checksum of the metadata change compared with the previous version Networks \u00b6 Identify in which networks is the DDO valid. It is an unsorted array including the chainId of the network where this DID is available. Example \u00b6 Here an example of the meta section of a DDO: \"meta\" : { \"versions\" : [ { \"_id\" : \"dsadsa\" , \"tag\" : \"v0.1\" , \"createdAt\" : \"2016-02-08T16:02:20Z\" , \"checksum\" : \"4329042309a02394032\" }, { \"_id\" : \"ccacd\" , \"tag\" : \"v0.2\" , \"createdAt\" : \"2018-02-08T16:02:20Z\" , \"checksum\" : \"0000010992349\" } ], \"networks\" : [ { \"chainId\" : 1 }, { \"chainId\" : 23 }, { \"chainId\" : 8001 } ] } Integrity \u00b6 The Integrity policy for identity and metadata is a sub-specification allowing to validate the integrity of the Metadata associated to an on-chain object (initially an ASSET). How to compute the integrity checksum \u00b6 An ASSET in the system is composed by on-chain information maintained by the DLT and off-chain Metadata information (DDO) stored by the PROVIDER. Technically a user could update the DDO accessing directly to the off-chain database, modifying attributes (e.g. License information, description, etc.) relevant to a previous consumption agreement with an user. The motivation of this is to facilitate a mechanism allowing to the CONSUMER of an object, to validate if the DDO was modified after a previous agreement. This hash composing the integrity checksum is calculated in the following way: The complete content of the service[index].attributes.main is serialized in a common string The string generated is is Hashed using SHA3-256 algorithm (You might have to convert the string to bytes first.) The hash generated as a result of this process is stored in the proof.checksum[index].checksum attribute The previous 3 steps are repeated for every individual service include in the service array. The hash generated is always stored in the proof.checksum array using as key the index of the service computed During the serialization process, the objects to serialize ( service[index].attributes.main are prepared using the following process: The object is sorted alphabetically independently of the existing nested levels In the JSON generated, all the characters between entries are removed ( \\n , \\t , \\r , whitespaces, etc.) As a result must be generated a string of only one line After hashing, in the DDO, the checksums should be represented as a hex string beginning with 0x and ending with 64 hex characters (e.g. 0x52b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3bbc3377 ) After generating each individual checksum the complete proof.checksum entry is sorted, serialized and hashed as previously described in the other checksums The final hash generated as a result of hashing the checksums (DID CHECKSUM or DID HASH) will be the ID part of the DID (the string after the prefix did:nv: ) Because this DID HASH will be stored on-chain and emitted as an event, a validator could use this information to check if something changed regarding the initial registration. DID Document Proof \u00b6 A proof on a DID Document is cryptographic proof of the integrity of the DID Document. In the DID Specification the proof attribute is optional. We enforce the usage of the proof attribute to demonstrate the Owner of an Asset is signing the proof of integrity of some Asset attributes. The information to sign by the owner is the integrity checksum defined in the above section. const signature = Sign . signMessage ( DID ) The DID Document (DDO) SHOULD include the following proof information: type - Type of proof, in our case \"DDOIntegritySignature\" created - Date and time when the proof was created creator - Address of the user providing the proof signatureValue - Result of the signature given by the creator checksum - Checksums of the individual services included in the DDO inmutableUrl - Url to a copy of the DDO in an inmutable repository like IPFS, Arweave, etc. Here is an example proof section to add in the DDO: \"proof\" : { \"type\" : \"DDOIntegritySignature\" , \"created\" : \"2016-02-08T16:02:20Z\" , \"creator\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"signatureValue\" : \"0xc9eeb2b8106e\u20266abfdc5d1192641b\" , \"inmutableUrl\" : \"ipfs://QmPChd2hVbrJ6bfo3WBcTW4iZnpHm8TEzWkLHmLpXhF68A\" , \"checksum\" : { \"0\" : \"0x52b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3bbc3377\" , \"1\" : \"0x999999952b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3\" } } Using the proof information, a third-party with access to the DDO could validate the creator signed a specific integrity checksum referring to an Asset. Length of a DID \u00b6 The length of a DID must be compliant with the underlying storage layer and function calls. Given that decentralized virtual machines make use of contract languages such as Solidity and WASM, it is advised to fit the DID in structures such as bytes32 . It would be nice to store the did:nv: prefix in those 32 bytes, but that means fewer than 32 bytes would be left for storing the rest (25 bytes since \"did:nv:\" takes 7 bytes if using UTF-8). If the rest is a secure hash, then we need a 25-byte secure hash, but secure hashes typically have 28, 32 or more bytes, so that won't work. Only the hash value needs to be stored, not the did:nv: prefix, because it should be clear from context that the value is a Nevermined DID. How to compute a DID \u00b6 The DID ( id ) string begins with did:nv: and is followed by a string representation of a bytes32. As is described previously, the DID is calculating doing the Hash (SHA3-256) of the DDO.proof.checksum entry Registry \u00b6 To register the different kind of objects can be stored in a simple register contract named DidRegistry . This DidRegistry can act as generic/flexible way to associate Resources (ie. Assets) to the public providers resolving the DDO (and Metadata included) of those resources. The key of the Identity entity in Nevermined is the DID . Each entity will have a unique DID. To resolve the DDO associated to a Resource (Asset), associated to this Resource DID we have the DID of the Provider giving access to this Resource. The Provider will have associated a mapping (key - value) of attributes. One of those can be used to related with the public service returning the DDO of a specific resource. Applied to Assets, typically are part of a Service Agreement. The suggested approach to implement this is: Associate the Resource (ie. Asset DID) to the Provider DID Each Provider will have associated a Public URL where the provider is exposing the DDOs Here is a draft DidRegistry implementation: // This piece of code is for reference only! // Doesn't include any validation, types could be reviewed, enums, etc contract DidRegistry { event DIDAttributeRegistered ( bytes32 indexed did , address indexed owner , bytes32 indexed checksum , string value , uint updatedAt ); mapping ( bytes32 => DIDRegister ) private didRegister ; function registerAttribute ( bytes32 _did , bytes32 _checksum , string _value ) public { // .... emit DIDAttributeRegistered ( _did , msg.sender , _checksum , _value , block.number ); } } To register the provider publicly resolving the DDO associated to a DID, we will register an attribute with the public hostname of that provider: registerAttribute ( \"21tDAKCERh95uGgKbJNHYp\" , \"328aabb94534935864312\" , \"https://myprovider.example.com/ddo\" ) Resolver \u00b6 The resolving capabilities will be encapsulated in the Nevermined SDK libraries (JavaScript, Python, etc.), allowing to resolve a DDO directly speaking with the Smart Contracts. No third-party requests or API need to be integrated. This allows to have a simple a seam-less integration from the consumer side. This is a generic definition of what could be exposed in the client libraries from an API point of view: function DDO resolve ( String did ) { // black magic return ddo ; } To resolve a DID to the associated DDO, some information is stored on-chain associated to the DID. In the approach recommended in the scope of this SPEC, this is stored as an attribute associated to the DidAttributeRegistered event. Because the DID and key are indexed parameters of the event, a consumer in any supported web3 language could filter the DidAttributeRegistered events filtering by the DID and the key named \"service-ddo\" . A DDO pointing to a DID could be resolved hierarchically using the same mechanism. This is an example in JavaScript using web3.js: const event = contractInstance . DidAttributeRegistered ( { did : '21tDAKCERh95uGgKbJNHYp' }, { fromBlock : 0 , toBlock : 'latest' } ); Here in Python using web3.py: event = mycontract . events . DidAttributeRegistered . createFilter ( fromBlock = 'latest' , argument_filters = { 'did' : '21tDAKCERh95uGgKbJNHYp' }) This logic could be encapsulated in the client libraries ( SDK ) in different languages, allowing to the client applications to get the attributes enabling to resolve the DDO associated to the DID. Using this information a consumer can query directly to the provider able to return the DDO. References \u00b6 DID Spec from the W3C Credentials Community Group","title":"Decentralized Identifiers"},{"location":"architecture/specs/did/#did-spec-decentralized-identifiers","text":"shortname: DID name: Decentralized Identifiers type: Standard status: Valid version: 0.3 editor: Aitor Argomaniz <aitor@nevermined.io> contributors: DID SPEC: Decentralized Identifiers Motivation Specification Proposed Solution Decentralized IDs (DIDs) Publishing and Consumption Flow DID Documents (DDOs) DDO Services DDO Meta information Versions Networks Example Integrity How to compute the integrity checksum DID Document Proof Length of a DID How to compute a DID Registry Resolver References This specification is based on the W3C DID specification , which was at version 0.11 as of August 2018.","title":"DID SPEC: Decentralized Identifiers"},{"location":"architecture/specs/did/#motivation","text":"The main motivations of this SPEC are: Design a solution to extend the current architecture to use Decentralized Identifiers (DIDs) and DID Documents (DDOs) Understand how to register information on-chain with off-chain integrity associated Understand how to resolve DIDs into DDOs Design a solution facilitating alignment of on-chain and off-chain information Establishing the mechanism to know if the DDO associated with a DID was modified Defining the common mechanisms, interfaces and APIs to implemented the designed solution Define how Nevermined assets can be modeled with a DID/DDO data model Understand how DID hubs are formed, and how they integrate a business and storage layer","title":"Motivation"},{"location":"architecture/specs/did/#specification","text":"Requirements are: The DID resolving capabilities MUST be exposed in the client libraries, enabling to resolve a DDO directly in a totally transparent way ASSETS are DATA objects describing RESOURCES under control of a PUBLISHER DLT stores on-chain only the essential information about ASSETS PROVIDERS store the ASSET metadata off-chain DLT doesn't store any ASSET metadata Nevermined doesn't store ASSET contents (e.g. files) An ASSET is modeled in Nevermined as on-chain information stored in the DLT and metadata stored in METADATA API ASSETS on-chain information only can be modified by OWNERS or DELEGATED USERS ASSETS can be resolved using a Decentralized ID (DID) included on-chain and off-chain A DID Document (DDO) should include the ASSET metadata Any kind of object registered in Nevermined MUST have a DID allowing one to uniquely identify that object in the system ASSET DDO (and the metadata included as part of the DDO) is associated to the ASSET information stored on-chain using a common DID A DID can be resolved to get access to a DDO ASSET DDOs can be updated without updating the on-chain information ASSET information stored in the DLT will include a checksum attribute The ASSET on-chain checksum attribute SHOULD include a one-way HASH calculated using the DDO content After the DDO resolving, the DDO HASH can be calculated off-chain to validate if the on-chain and off-chain information is aligned A HASH not matching with the checksum on-chain means the DDO was modified without the on-chain update The function to calculate the hash MUST BE standard","title":"Specification"},{"location":"architecture/specs/did/#proposed-solution","text":"","title":"Proposed Solution"},{"location":"architecture/specs/did/#decentralized-ids-dids","text":"A DID is a unique identifier that can be resolved or de-referenced to a standard resource describing the entity (a DID Document or DDO). If we apply this to Nevermined, the DID would be the unique identifier of an object represented in Nevermined (i.e. the Asset ID of an ASSET or the Actor ID of a USER). The DDO SHOULD include the METADATA information associated with this object. The DDO is stored off-chain in Nevermined. In Nevermined, a DID is a string that looks like: did:nv:0ebed8226ada17fde24b6bf2b95d27f8f05fcce09139ff5cec31f6d81a7cd2ea which follows the generic DID scheme . Details about how to compute the DID are given below.","title":"Decentralized IDs (DIDs)"},{"location":"architecture/specs/did/#publishing-and-consumption-flow","text":"Here you have the complete flow using as example a new ASSET: DID Resolver Steps: A Data Publisher, using the Smart Contracts, register the new Resource (ie. ASSET) providing the DID and the DID of the Provider acting as Public service returning the DDO of the Resource (ASSET) The DLT register the Resource using the Service Agreement Smart Contract and after of that register the identity using the DidRegistry Smart Contract. In this point, the attribute is raised as a new event The Data Publisher publishes the DDO in the Metadata api A Data Consumer (it could be a frontend application or a backend software), having a DID and using a client library (Python, Javascript, Java, etc) get the service-ddo attribute associated to the DID directly from the Smart Contracts The Data Consumer, using the provider public url, query directly to the provider passing the DID to obtain the DDO","title":"Publishing and Consumption Flow"},{"location":"architecture/specs/did/#did-documents-ddos","text":"If a DID is the index key in a key-value pair, then the DID Document is the value to which the index key points. The combination of a DID and its associated DID Document forms the root record for a decentralized identifier. A DDO document is composed of standard DDO attributes: @context id created updated publicKey authentication proof verifiableCredential service Asset metadata can be included as one of the objects inside the \"service\" array, with type \"metadata\" .","title":"DID Documents (DDOs)"},{"location":"architecture/specs/did/#ddo-services","text":"Each type of asset (dataset, algorithm, workflow, etc, ..) typically will have associated different kind of services. There are 2 type of services that are commonly added to all the assets: metadata - describing the asset provenance - describing the asset provenance Each service include a serviceEndpoint attribute with a URL to the server or document completing that service. Optionally, the service can include a immutableServiceEndpoint attribute with a URL to a repository/service where additional information is stored in an immutable way (i.e IPFS, Filecoin, Arweave, etc). Each service is distinguished by the DDO.service.type attribute. Each service has an attributes section where all the information related to the service is added. As mandatory content, the attributes section will have a main sub-section. This one is important because it must include all the mandatory information that a service has to provide and never change because it is used to calculate the integrity checksum of the service. A part of the attributes.main sub-section, other optional sub-sections can be added (like: attributes.curation or attributes.extra ) depending on the service type. Example: \"service\" : [ { \"index\" : 0 , \"type\" : \"metadata\" , \"serviceEndpoint\" : \"https://service/api/v1/metadata/assets/ddo/did:nv:0ebed8226ada17fde24b6bf2b95d27f8f05fcce09139ff5cec31f6d81a7cd2ea\" , \"immutableServiceEndpoint\" : \"cid://QmVT3wfySvZJqAvkBCyxoz3EvD3yeLqf3cvAssFDpFFXNm\" , \"attributes\" : { \"main\" : {}, \"additionalInformation\" : {}, \"curation\" : {} } }, { \"index\" : 1 , \"type\" : \"provenance\" , \"serviceEndpoint\" : \"https://service/api/v1/provenance/assets/ddo/did:nv:0ebed8226ada17fde24b6bf2b95d27f8f05fcce09139ff5cec31f6d81a7cd2ea\" , \"attributes\" : { \"main\" : {}, \"additionalInformation\" : {} } }, { \"index\" : 2 , \"type\" : \"access\" , \"serviceEndpoint\" : \"https://service/api/v1/access/assets/ddo/did:nv:0ebed8226ada17fde24b6bf2b95d27f8f05fcce09139ff5cec31f6d81a7cd2ea\" , \"attributes\" : { \"main\" : {}, \"additionalInformation\" : {} } } ] You can find a complete example of a DDO . You can find a complete reference of the asset metadata in METADATA SPEC . You can find a complete real world example of a DDO with extended services added, as part of the W3C DID spec.","title":"DDO Services"},{"location":"architecture/specs/did/#ddo-meta-information","text":"This section (named meta ) provides additional information about the DDO itself including versions, and networks where this DDO is valid. It will include 2 main blocks of information:","title":"DDO Meta information"},{"location":"architecture/specs/did/#versions","text":"Allows to register the different linear versions of the DDO created. It is an array sorted by version creation including the following information: Version Id ( _id ) - Unique identifier of the version, it could be a DID Tag or Version number ( tag ) Created date time - Datetime refereing when it was created without sub-second decimal precision Change checksum ( checksum ) - Optional attribute with a checksum of the metadata change compared with the previous version","title":"Versions"},{"location":"architecture/specs/did/#networks","text":"Identify in which networks is the DDO valid. It is an unsorted array including the chainId of the network where this DID is available.","title":"Networks"},{"location":"architecture/specs/did/#example","text":"Here an example of the meta section of a DDO: \"meta\" : { \"versions\" : [ { \"_id\" : \"dsadsa\" , \"tag\" : \"v0.1\" , \"createdAt\" : \"2016-02-08T16:02:20Z\" , \"checksum\" : \"4329042309a02394032\" }, { \"_id\" : \"ccacd\" , \"tag\" : \"v0.2\" , \"createdAt\" : \"2018-02-08T16:02:20Z\" , \"checksum\" : \"0000010992349\" } ], \"networks\" : [ { \"chainId\" : 1 }, { \"chainId\" : 23 }, { \"chainId\" : 8001 } ] }","title":"Example"},{"location":"architecture/specs/did/#integrity","text":"The Integrity policy for identity and metadata is a sub-specification allowing to validate the integrity of the Metadata associated to an on-chain object (initially an ASSET).","title":"Integrity"},{"location":"architecture/specs/did/#how-to-compute-the-integrity-checksum","text":"An ASSET in the system is composed by on-chain information maintained by the DLT and off-chain Metadata information (DDO) stored by the PROVIDER. Technically a user could update the DDO accessing directly to the off-chain database, modifying attributes (e.g. License information, description, etc.) relevant to a previous consumption agreement with an user. The motivation of this is to facilitate a mechanism allowing to the CONSUMER of an object, to validate if the DDO was modified after a previous agreement. This hash composing the integrity checksum is calculated in the following way: The complete content of the service[index].attributes.main is serialized in a common string The string generated is is Hashed using SHA3-256 algorithm (You might have to convert the string to bytes first.) The hash generated as a result of this process is stored in the proof.checksum[index].checksum attribute The previous 3 steps are repeated for every individual service include in the service array. The hash generated is always stored in the proof.checksum array using as key the index of the service computed During the serialization process, the objects to serialize ( service[index].attributes.main are prepared using the following process: The object is sorted alphabetically independently of the existing nested levels In the JSON generated, all the characters between entries are removed ( \\n , \\t , \\r , whitespaces, etc.) As a result must be generated a string of only one line After hashing, in the DDO, the checksums should be represented as a hex string beginning with 0x and ending with 64 hex characters (e.g. 0x52b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3bbc3377 ) After generating each individual checksum the complete proof.checksum entry is sorted, serialized and hashed as previously described in the other checksums The final hash generated as a result of hashing the checksums (DID CHECKSUM or DID HASH) will be the ID part of the DID (the string after the prefix did:nv: ) Because this DID HASH will be stored on-chain and emitted as an event, a validator could use this information to check if something changed regarding the initial registration.","title":"How to compute the integrity checksum"},{"location":"architecture/specs/did/#did-document-proof","text":"A proof on a DID Document is cryptographic proof of the integrity of the DID Document. In the DID Specification the proof attribute is optional. We enforce the usage of the proof attribute to demonstrate the Owner of an Asset is signing the proof of integrity of some Asset attributes. The information to sign by the owner is the integrity checksum defined in the above section. const signature = Sign . signMessage ( DID ) The DID Document (DDO) SHOULD include the following proof information: type - Type of proof, in our case \"DDOIntegritySignature\" created - Date and time when the proof was created creator - Address of the user providing the proof signatureValue - Result of the signature given by the creator checksum - Checksums of the individual services included in the DDO inmutableUrl - Url to a copy of the DDO in an inmutable repository like IPFS, Arweave, etc. Here is an example proof section to add in the DDO: \"proof\" : { \"type\" : \"DDOIntegritySignature\" , \"created\" : \"2016-02-08T16:02:20Z\" , \"creator\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"signatureValue\" : \"0xc9eeb2b8106e\u20266abfdc5d1192641b\" , \"inmutableUrl\" : \"ipfs://QmPChd2hVbrJ6bfo3WBcTW4iZnpHm8TEzWkLHmLpXhF68A\" , \"checksum\" : { \"0\" : \"0x52b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3bbc3377\" , \"1\" : \"0x999999952b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3\" } } Using the proof information, a third-party with access to the DDO could validate the creator signed a specific integrity checksum referring to an Asset.","title":"DID Document Proof"},{"location":"architecture/specs/did/#length-of-a-did","text":"The length of a DID must be compliant with the underlying storage layer and function calls. Given that decentralized virtual machines make use of contract languages such as Solidity and WASM, it is advised to fit the DID in structures such as bytes32 . It would be nice to store the did:nv: prefix in those 32 bytes, but that means fewer than 32 bytes would be left for storing the rest (25 bytes since \"did:nv:\" takes 7 bytes if using UTF-8). If the rest is a secure hash, then we need a 25-byte secure hash, but secure hashes typically have 28, 32 or more bytes, so that won't work. Only the hash value needs to be stored, not the did:nv: prefix, because it should be clear from context that the value is a Nevermined DID.","title":"Length of a DID"},{"location":"architecture/specs/did/#how-to-compute-a-did","text":"The DID ( id ) string begins with did:nv: and is followed by a string representation of a bytes32. As is described previously, the DID is calculating doing the Hash (SHA3-256) of the DDO.proof.checksum entry","title":"How to compute a DID"},{"location":"architecture/specs/did/#registry","text":"To register the different kind of objects can be stored in a simple register contract named DidRegistry . This DidRegistry can act as generic/flexible way to associate Resources (ie. Assets) to the public providers resolving the DDO (and Metadata included) of those resources. The key of the Identity entity in Nevermined is the DID . Each entity will have a unique DID. To resolve the DDO associated to a Resource (Asset), associated to this Resource DID we have the DID of the Provider giving access to this Resource. The Provider will have associated a mapping (key - value) of attributes. One of those can be used to related with the public service returning the DDO of a specific resource. Applied to Assets, typically are part of a Service Agreement. The suggested approach to implement this is: Associate the Resource (ie. Asset DID) to the Provider DID Each Provider will have associated a Public URL where the provider is exposing the DDOs Here is a draft DidRegistry implementation: // This piece of code is for reference only! // Doesn't include any validation, types could be reviewed, enums, etc contract DidRegistry { event DIDAttributeRegistered ( bytes32 indexed did , address indexed owner , bytes32 indexed checksum , string value , uint updatedAt ); mapping ( bytes32 => DIDRegister ) private didRegister ; function registerAttribute ( bytes32 _did , bytes32 _checksum , string _value ) public { // .... emit DIDAttributeRegistered ( _did , msg.sender , _checksum , _value , block.number ); } } To register the provider publicly resolving the DDO associated to a DID, we will register an attribute with the public hostname of that provider: registerAttribute ( \"21tDAKCERh95uGgKbJNHYp\" , \"328aabb94534935864312\" , \"https://myprovider.example.com/ddo\" )","title":"Registry"},{"location":"architecture/specs/did/#resolver","text":"The resolving capabilities will be encapsulated in the Nevermined SDK libraries (JavaScript, Python, etc.), allowing to resolve a DDO directly speaking with the Smart Contracts. No third-party requests or API need to be integrated. This allows to have a simple a seam-less integration from the consumer side. This is a generic definition of what could be exposed in the client libraries from an API point of view: function DDO resolve ( String did ) { // black magic return ddo ; } To resolve a DID to the associated DDO, some information is stored on-chain associated to the DID. In the approach recommended in the scope of this SPEC, this is stored as an attribute associated to the DidAttributeRegistered event. Because the DID and key are indexed parameters of the event, a consumer in any supported web3 language could filter the DidAttributeRegistered events filtering by the DID and the key named \"service-ddo\" . A DDO pointing to a DID could be resolved hierarchically using the same mechanism. This is an example in JavaScript using web3.js: const event = contractInstance . DidAttributeRegistered ( { did : '21tDAKCERh95uGgKbJNHYp' }, { fromBlock : 0 , toBlock : 'latest' } ); Here in Python using web3.py: event = mycontract . events . DidAttributeRegistered . createFilter ( fromBlock = 'latest' , argument_filters = { 'did' : '21tDAKCERh95uGgKbJNHYp' }) This logic could be encapsulated in the client libraries ( SDK ) in different languages, allowing to the client applications to get the attributes enabling to resolve the DDO associated to the DID. Using this information a consumer can query directly to the provider able to return the DDO.","title":"Resolver"},{"location":"architecture/specs/did/#references","text":"DID Spec from the W3C Credentials Community Group","title":"References"},{"location":"architecture/specs/examples/","text":"Nevermind Specs Examples \u00b6 This folder includes examples of the DDO files related with the different Nevermind specs. You can use it as reference. These examples are used & validated in the Integration Tests flows of the Nevermind components.","title":"Nevermind Specs Examples"},{"location":"architecture/specs/examples/#nevermind-specs-examples","text":"This folder includes examples of the DDO files related with the different Nevermind specs. You can use it as reference. These examples are used & validated in the Integration Tests flows of the Nevermind components.","title":"Nevermind Specs Examples"},{"location":"architecture/specs/fl/","text":"COMPUTE FL: Nevermined Federated Learning Orchestration \u00b6 shortname: FL name: Nevermined Federated Learning Orchestration type: Draft status: Valid version: 0.1 editor: Rodolphe Marques <rodolphe@keyko.io> contributors: Aitor Argomaniz <aitor@keyko.io>, Enrique Ruiz <kike@keyko.io> COMPUTE FL: Nevermined Federated Learning Orchestration Federated Learning integration in the Nevermined Data in Situ Computation Terminology Motivation Actors Architecture Running the Coordinator Flow Running the Participants Flow Federated Learning Session Flow Federated Learning DDOs Coordinator Consumer DDO Coordinator Provider DDO Participant Consumer DDO Participant Provider DDO Federated Learning integration in the Nevermined Data in Situ Computation \u00b6 This SPEC introduces the integration pattern for the usage a Federated Learning backend in the Nevermined DISC architecture . The Nevermined Data in Situ Computation solution introduces a solution where different compute backends can be plugged in order to support different remote computation use cases. This spec details how Federated Learning sessions could be executed on Nevermined. Terminology \u00b6 Coordinator : All the components required to perform the coordination of a Federated Learning session. The components provided by the xain-fl framework (coordinator + aggregator) Participant : Component responsible for interacting with the coordinator and executing the machine learning task over the data. Federated Learning Session : The time from setup of the coordinator to the successful execution of the machine learning plan. Typically this involves coordinating the participants for a finite number or rounds and then storing the resulting model Motivation \u00b6 The main motivations of this SPEC are: Identify the actors involved in the execution of a Federated Learning session on Nevermined Identify the integration points between the xain framework components and the Nevermined components Detail the execution flow of a Federated Learning session on Nevermined Actors \u00b6 The different actors interacting in this flow are: PROVIDERS: Give access to the Compute Services and to the data CONSUMERS: Want to make use of the Compute Services and access to data MARKETPLACE or DOMAINS: Store the DDO/Metadata related to the Assets/services INFRASTRUCTURE: Infrastructure required to run the Nevermined compute stack Here we may have two types of providers. A normal provider like the one specified in Data in Situ Computation spec. And another type of provider that only provides compute but now access to the data (to run the coordinator). Architecture \u00b6 Running the Coordinator \u00b6 This section details how a Client/Data Scientist can setup and run a Coordinator using Nevermined Compute. The main requirements are: A COMPUTE PROVIDER or PROVIDER defines the conditions that a Compute service supports. It includes: What kind of image (Docker container) can be deployed in the infrastructure What are the infrastructure resources available (CPU, memory, storage) What is the price of using the infrastructure resources Allow incoming connections for the Participants A COMSUMER defines the parameters of the coordinator and creates an execution workflow using a predefined coordinator workflow template This is a different type of workflow with no inputs, outputs and access to data A CONSUMER purchasing a compute service defines which Workflow (DID) is going to execute Setting up the Coordinator Flow \u00b6 The CONSUMER / Data Scientist locks the payment for the service The CONSUMER / Data scientist provides a DID for the workflow to execute The gateway could potentially provide specific endpoints for this since the workflow is always the same. The only thing that changes is the parameters to configure the coordinator The Gateway checks if the CONSUMER / Data scientist as the permissions to start a new coordinator The Nevermined compute stack starts a new coordinator The url to connect to the coordinator is published (need to figure out how) In the meantime participants will connect to the coordinator and the coordinator will orchestrate the Federated Learning session After the Federated Learning session is finished the coordinator publishes the resulting trained model and shuts down. Running the Participants \u00b6 This section details how a Client/Data Scientist can setup and run a set of Participants using Nevermined Compute. This should be simpler to integrate because it\u2019s very similar to the data in situ computation use case. The main difference being that the algorithm is actually wrapped around the xain python sdk and it needs to be able to perform outgoing network connection to connect to the coordinator. The main requirements are: A PROVIDER defines the conditions that a Compute service supports. It includes: What kind of image (Docker container) can be deployed in the infrastructure What are the infrastructure resources available (CPU, memory, storage) What is the price of using the infrastructure resources A COMPUTE PROVIDER defines a Compute Service in the scope of the Asset (DID/DDO) of the dataset that can be computed A CONSUMER defines the task to execute modeling it in a Workflow (including configuration, input, participant) In this case the transformation is just the participant code It does not need to produce any output since that is handled by the coordinator A workflow is a new type of Asset. It can be resolvable and be used across multiple independent compute services A CONSUMER purchasing a compute service defines which Workflow (DID) is going to execute Running the participants Flow \u00b6 The CONSUMER / Data Scientist locks the payment The CONSUMER / Data Scientist requests the execution of the participant The Gateway checks if the CONSUMER / Data Scientist has the permissions to execute the participant on the data The Nevermined compute sets up the environment The participants access the data and performs the machine learning task The participant needs to be able to communicate with the coordinator throughout the entire Federated Learning session. The coordinator will be external to the Infrastructure Provider The participant does not need to create a new asset since that is handled by the coordinator Federated Learning Session Flow \u00b6 This section details a high level overview of a Federated Learning Session using two different data providers. Federated Learning Session Flow The Data Scientist starts by finding a provider to run the Coordinator compute job and the data that it requires (possibly using the marketplace). The flow is: The Data Scientist starts by setting the execution parameters for the coordinator and publishes it as a workflow/ddo The Data Scientist purchases data in situ computation for both Data Provider X and Y and defines the workflow/ddo with the code that will run the participants The Data Scientist purchases the Coordinator compute service The Data Scientist starts the Coordinator The Data Scientist starts the participants The Participants work together with the coordinator over the course of multiple rounds as defined in point 1. Once all rounds are finished the Coordinator publishes the final trained model The Data Scientist fetches the trained model. Federated Learning DDOs \u00b6 This section details the both the consumer and provider DDOs for coordinator and participant. Coordinator Consumer DDO \u00b6 { \"serviceAgreementId\" : \"bb23s87856d59867503f80a690357406857698570b964ac8dcc9d86da4ada010\" , \"workflow\" : { \"@context\" : \"https://w3id.org/future-method/v1\" , \"authentication\" : [], \"created\" : \"2019-04-09T19:02:11Z\" , \"id\" : \"did:nv:8d1b4d73e7af4634958f071ab8dfe7ab0df14019755e444090fd392c8ec9c3f4\" , \"proof\" : { \"created\" : \"2019-04-09T19:02:11Z\" , \"creator\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"signatureValue\" : \"1cd57300733bcbcda0beb59b3e076de6419c0d7674e7befb77820b53c79e3aa8f1776effc64cf088bad8cb694cc4d71ebd74a13b2f75893df5a53f3f318f6cf828\" , \"type\" : \"DDOIntegritySignature\" }, \"publicKey\" : [ { \"id\" : \"did:nv:8d1b4d73e7af4634958f071ab8dfe7ab0df14019755e444090fd392c8ec9c3f4\" , \"owner\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"type\" : \"EthereumECDSAKey\" } ], \"service\" : [ { \"index\" : 0 , \"serviceEndpoint\" : \"http://172.15.0.15:5000/api/v1/metadata/assets/ddo/did:nv:8d1b4d73e7af4634958f071ab8dfe7ab0df14019755e444090fd392c8ec9c3f4\" , \"type\" : \"metadata\" , \"attributes\" : { \"main\" : { \"dateCreated\" : \"2012-10-10T17:00:00Z\" , \"type\" : \"fl-coordinator\" , \"datePublished\" : \"2019-04-09T19:02:11Z\" , \"parameters\" : { \"minParticipants\" : 1 , \"participantsRatio\" : 1 , \"rounds\" : 10 , } \"workflow\" : { \"stages\" : [ { \"index\" : 0 , \"requirements\" : { \"serverInstances\" : 1 , \"container\" : { \"image\" : \"keykoio/xain-fl\" , \"tag\" : \"latest\" , \"checksum\" : \"sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc\" } } } ] } } } } ] } } The main information that needs to be provided is: - tag : The version of the xain-fl image to use - minParticipants : The minimum number of participants required by the coordinator - participantsRation : The ratio of participants that will be selected in every round - rounds : The number of rounds the coordinator should do Note that service.main.type is set to fl-coordinator to indicate this is not a normal workflow Coordinator Provider DDO \u00b6 { \"@context\" : \"https://w3id.org/future-method/v1\" , \"authentication\" : [], \"created\" : \"2019-04-09T19:02:11Z\" , \"id\" : \"did:op:8d1b4d73e7af4634958f071ab8dfe7ab0df14019755e444090fd392c8ec9c3f4\" , \"proof\" : { \"created\" : \"2019-04-09T19:02:11Z\" , \"creator\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"signatureValue\" : \"1cd57300733bcbcda0beb59b3e076de6419c0d7674e7befb77820b53c79e3aa8f1776effc64cf088bad8cb694cc4d71ebd74a13b2f75893df5a53f3f318f6cf828\" , \"type\" : \"DDOIntegritySignature\" }, \"publicKey\" : [ { \"id\" : \"did:op:8d1b4d73e7af4634958f071ab8dfe7ab0df14019755e444090fd392c8ec9c3f4\" , \"owner\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"type\" : \"EthereumECDSAKey\" } ], \"service\" : [ { \"type\" : \"metadata\" , \"index\" : 0 , \"serviceEndpoint\" : \"http://mymetadata-api.org/api/v1/metadata/assets/ddo/{did}\" , \"attributes\" : { \"main\" : {}, \"additionalInformation\" : {} } }, { \"type\" : \"fl-coordinator\" , \"index\" : 2 , \"serviceEndpoint\" : \"http://mygateway.org/api/v1/gateway/services/execute\" , \"templateId\" : \"804932804923850985093485039850349850439583409583404534231321131a\" , \"attributes\" : { \"main\" : { \"creator\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"datePublished\" : \"2019-04-09T19:02:11Z\" , \"price\" : \"10\" , \"timeout\" : 86400 , \"provider\" : { \"type\" : \"Azure\" , \"description\" : \"\" , \"environment\" : { \"cluster\" : { \"type\" : \"Kubernetes\" , \"url\" : \"http://10.0.0.17/xxx\" }, \"supportedContainers\" : [ { \"image\" : \"keykoio/xain-fl\" , \"tag\" : \"latest\" , \"checksum\" : \"sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc\" }, { \"image\" : \"keykoio/xain-fl\" , \"tag\" : \"v1\" , \"checksum\" : \"sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc\" } ], \"supportedServers\" : [ { \"serverId\" : \"1\" , \"serverType\" : \"xlsize\" , \"price\" : \"50\" , \"cpu\" : \"16\" , \"gpu\" : \"0\" , \"memory\" : \"128gb\" , \"disk\" : \"160gb\" , \"maxExecutionTime\" : 86400 }, { \"serverId\" : \"2\" , \"serverType\" : \"medium\" , \"price\" : \"10\" , \"cpu\" : \"2\" , \"gpu\" : \"0\" , \"memory\" : \"8gb\" , \"disk\" : \"80gb\" , \"maxExecutionTime\" : 86400 } ] } } }, \"additionalInformation\" : {} }, \"serviceAgreementTemplate\" : { \"contractName\" : \"ServiceExecutionTemplate\" , \"events\" : [ { \"name\" : \"AgreementCreated\" , \"actorType\" : \"consumer\" , \"handler\" : { \"moduleName\" : \"serviceExecutionTemplate\" , \"functionName\" : \"fulfillLockPaymentCondition\" , \"version\" : \"0.1\" } } ], \"fulfillmentOrder\" : [ \"lockPayment.fulfill\" , \"serviceExecution.fulfill\" , \"escrowPayment.fulfill\" ], \"conditionDependency\" : { \"lockPayment\" : [], \"serviceExecution\" : [], \"releaseReward\" : [ \"lockPayment\" , \"serviceExecution\" ] }, \"conditions\" : [ { \"name\" : \"lockPayment\" , \"timelock\" : 0 , \"timeout\" : 0 , \"contractName\" : \"LockPaymentCondition\" , \"functionName\" : \"fulfill\" , \"parameters\" : [ { \"name\" : \"_did\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_rewardAddress\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_tokenAddress\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_amounts\" , \"type\" : \"uint256[]\" , \"value\" : [] }, { \"name\" : \"_receivers\" , \"type\" : \"address[]\" , \"value\" : [] } ], \"events\" : [ { \"name\" : \"Fulfilled\" , \"actorType\" : \"publisher\" , \"handler\" : { \"moduleName\" : \"lockPaymentConditon\" , \"functionName\" : \"fulfillServiceExecutionCondition\" , \"version\" : \"0.1\" } } ] }, { \"name\" : \"execCompute\" , \"timelock\" : 0 , \"timeout\" : 0 , \"contractName\" : \"ComputeExecutionCondition\" , \"functionName\" : \"fulfill\" , \"parameters\" : [ { \"name\" : \"_did\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_grantee\" , \"type\" : \"address\" , \"value\" : \"\" } ], \"events\" : [ { \"name\" : \"Fulfilled\" , \"actorType\" : \"publisher\" , \"handler\" : { \"moduleName\" : \"execCompute\" , \"functionName\" : \"fulfillServiceExecutionCondition\" , \"version\" : \"0.1\" } }, { \"name\" : \"TimedOut\" , \"actorType\" : \"consumer\" , \"handler\" : { \"moduleName\" : \"execCompute\" , \"functionName\" : \"fulfillServiceExecutionCondition\" , \"version\" : \"0.1\" } } ] }, { \"name\" : \"escrowPayment\" , \"timelock\" : 0 , \"timeout\" : 0 , \"contractName\" : \"EscrowPaymentCondition\" , \"functionName\" : \"fulfill\" , \"parameters\" : [ { \"name\" : \"_did\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_amounts\" , \"type\" : \"uint256[]\" , \"value\" : [] }, { \"name\" : \"_receivers\" , \"type\" : \"address[]\" , \"value\" : [] }, { \"name\" : \"_sender\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_tokenAddress\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_lockCondition\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_releaseCondition\" , \"type\" : \"bytes32\" , \"value\" : \"\" } ], \"events\" : [ { \"name\" : \"Fulfilled\" , \"actorType\" : \"publisher\" , \"handler\" : { \"moduleName\" : \"escrowPaymentConditon\" , \"functionName\" : \"verifyRewardTokens\" , \"version\" : \"0.1\" } } ] } ] } } ] } Participant Consumer DDO \u00b6 { \"serviceAgreementId\" : \"bb23s87856d59867503f80a690357406857698570b964ac8dcc9d86da4ada010\" , \"workflow\" : { \"@context\" : \"https://w3id.org/did/v1\" , \"authentication\" : [ { \"type\" : \"RsaSignatureAuthentication2018\" , \"publicKey\" : \"did:nv:0ebed8226ada17fde24b6bf2b95d27f8f05fcce09139ff5cec31f6d81a7cd2ea\" } ], \"created\" : \"2019-02-08T08:13:49Z\" , \"updated\" : \"2019-06-30T14:53:09Z\" , \"id\" : \"did:nv:0bc278fee025464f8012b811d1bce8e22094d0984e4e49139df5d5ff7a028bdf\" , \"proof\" : { \"created\" : \"2019-02-08T08:13:41Z\" , \"creator\" : \"0x37BB53e3d293494DE59fBe1FF78500423dcFd43B\" , \"signatureValue\" : \"did:nv:0bc278fee025464f8012b811d1bce8e22094d0984e4e49139df5d5ff7a028bdf\" , \"type\" : \"DDOIntegritySignature\" , \"checksum\" : { \"0\" : \"0x52b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3bbc3377\" , \"1\" : \"0x999999952b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3\" } }, \"publicKey\" : [ { \"id\" : \"did:nv:b6e2eb5eff1a093ced9826315d5a4ef6c5b5c8bd3c49890ee284231d7e1d0aaa#keys-1\" , \"type\" : \"RsaVerificationKey2018\" , \"owner\" : \"did:nv:6027c1e7cbae06a91fce0557ee53195284825f56a7100be0c53cbf4391aa26cc\" , \"publicKeyPem\" : \"-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\\r\\n\" }, { \"id\" : \"did:nv:b6e2eb5eff1a093ced9826315d5a4ef6c5b5c8bd3c49890ee284231d7e1d0aaa#keys-2\" , \"type\" : \"Ed25519VerificationKey2018\" , \"owner\" : \"did:nv:4c27a254e607cdf91a1206480e7eb8c74856102316c1a462277d4f21c02373b6\" , \"publicKeyBase58\" : \"H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV\" }, { \"id\" : \"did:nv:b6e2eb5eff1a093ced9826315d5a4ef6c5b5c8bd3c49890ee284231d7e1d0aaa#keys-3\" , \"type\" : \"RsaPublicKeyExchangeKey2018\" , \"owner\" : \"did:nv:5f6b885202ffb9643874be529302eb00d55e226959f1fbacaeda592c5b5c9484\" , \"publicKeyPem\" : \"-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\\r\\n\" } ], \"verifiableCredential\" : [ { \"@context\" : [ \"https://www.w3.org/2018/credentials/v1\" , \"https://www.w3.org/2018/credentials/examples/v1\" ], \"id\" : \"1872\" , \"type\" : [ \"read\" , \"update\" , \"deactivate\" ], \"issuer\" : \"0x610D9314EDF2ced7681BA1633C33fdb8cF365a12\" , \"issuanceDate\" : \"2019-01-01T19:73:24Z\" , \"credentialSubject\" : { \"id\" : \"0x89328493849328493284932\" }, \"proof\" : { \"type\" : \"RsaSignature2018\" , \"created\" : \"2019-01-01T19:73:24Z\" , \"proofPurpose\" : \"assertionMethod\" , \"signatureValue\" : \"ABCJSDAO23...1tzjn4w==\" } } ], \"service\" : [ { \"index\" : 0 , \"serviceEndpoint\" : \"http://localhost:5000/api/v1/metadata/assets/ddo/{did}\" , \"type\" : \"metadata\" , \"attributes\" : { \"main\" : { \"author\" : \"John Doe\" , \"checksum\" : \"0x52b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3bbc3377\" , \"dateCreated\" : \"2019-02-08T08:13:49Z\" , \"datePublished\" : \"2019-05-08T08:13:49Z\" , \"license\" : \"CC-BY\" , \"name\" : \"My workflow\" , \"price\" : \"1\" , \"type\" : \"workflow\" , \"workflow\" : { \"stages\" : [ { \"index\" : 0 , \"stageType\" : \"Participant\" , \"requirements\" : { \"container\" : { \"image\" : \"keykoio/xain-participant\" , \"tag\" : \"latest\" , \"checksum\" : \"sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc\" } }, \"input\" : [ { \"index\" : 0 , \"id\" : \"did:nv:12345\" } ], \"transformation\" : { \"id\" : \"did:nv:abcde\" }, \"output\" : { } } ] } }, \"additionalInformation\" : { \"description\" : \"Workflow to aggregate weather information\" , \"tags\" : [ \"weather\" , \"uk\" , \"2011\" , \"workflow\" , \"aggregation\" ], \"copyrightHolder\" : \"John Doe\" } } } ] } } This is a normal data in situ computation workflow with one stage, a set of inputs, one transformation and no output since the participant shouldn't need to generate any data. Participant Provider DDO \u00b6","title":"Federated Learning"},{"location":"architecture/specs/fl/#compute-fl-nevermined-federated-learning-orchestration","text":"shortname: FL name: Nevermined Federated Learning Orchestration type: Draft status: Valid version: 0.1 editor: Rodolphe Marques <rodolphe@keyko.io> contributors: Aitor Argomaniz <aitor@keyko.io>, Enrique Ruiz <kike@keyko.io> COMPUTE FL: Nevermined Federated Learning Orchestration Federated Learning integration in the Nevermined Data in Situ Computation Terminology Motivation Actors Architecture Running the Coordinator Flow Running the Participants Flow Federated Learning Session Flow Federated Learning DDOs Coordinator Consumer DDO Coordinator Provider DDO Participant Consumer DDO Participant Provider DDO","title":"COMPUTE FL: Nevermined Federated Learning Orchestration"},{"location":"architecture/specs/fl/#federated-learning-integration-in-the-nevermined-data-in-situ-computation","text":"This SPEC introduces the integration pattern for the usage a Federated Learning backend in the Nevermined DISC architecture . The Nevermined Data in Situ Computation solution introduces a solution where different compute backends can be plugged in order to support different remote computation use cases. This spec details how Federated Learning sessions could be executed on Nevermined.","title":"Federated Learning integration in the Nevermined Data in Situ Computation"},{"location":"architecture/specs/fl/#terminology","text":"Coordinator : All the components required to perform the coordination of a Federated Learning session. The components provided by the xain-fl framework (coordinator + aggregator) Participant : Component responsible for interacting with the coordinator and executing the machine learning task over the data. Federated Learning Session : The time from setup of the coordinator to the successful execution of the machine learning plan. Typically this involves coordinating the participants for a finite number or rounds and then storing the resulting model","title":"Terminology"},{"location":"architecture/specs/fl/#motivation","text":"The main motivations of this SPEC are: Identify the actors involved in the execution of a Federated Learning session on Nevermined Identify the integration points between the xain framework components and the Nevermined components Detail the execution flow of a Federated Learning session on Nevermined","title":"Motivation"},{"location":"architecture/specs/fl/#actors","text":"The different actors interacting in this flow are: PROVIDERS: Give access to the Compute Services and to the data CONSUMERS: Want to make use of the Compute Services and access to data MARKETPLACE or DOMAINS: Store the DDO/Metadata related to the Assets/services INFRASTRUCTURE: Infrastructure required to run the Nevermined compute stack Here we may have two types of providers. A normal provider like the one specified in Data in Situ Computation spec. And another type of provider that only provides compute but now access to the data (to run the coordinator).","title":"Actors"},{"location":"architecture/specs/fl/#architecture","text":"","title":"Architecture"},{"location":"architecture/specs/fl/#running-the-coordinator","text":"This section details how a Client/Data Scientist can setup and run a Coordinator using Nevermined Compute. The main requirements are: A COMPUTE PROVIDER or PROVIDER defines the conditions that a Compute service supports. It includes: What kind of image (Docker container) can be deployed in the infrastructure What are the infrastructure resources available (CPU, memory, storage) What is the price of using the infrastructure resources Allow incoming connections for the Participants A COMSUMER defines the parameters of the coordinator and creates an execution workflow using a predefined coordinator workflow template This is a different type of workflow with no inputs, outputs and access to data A CONSUMER purchasing a compute service defines which Workflow (DID) is going to execute Setting up the Coordinator","title":"Running the Coordinator"},{"location":"architecture/specs/fl/#flow","text":"The CONSUMER / Data Scientist locks the payment for the service The CONSUMER / Data scientist provides a DID for the workflow to execute The gateway could potentially provide specific endpoints for this since the workflow is always the same. The only thing that changes is the parameters to configure the coordinator The Gateway checks if the CONSUMER / Data scientist as the permissions to start a new coordinator The Nevermined compute stack starts a new coordinator The url to connect to the coordinator is published (need to figure out how) In the meantime participants will connect to the coordinator and the coordinator will orchestrate the Federated Learning session After the Federated Learning session is finished the coordinator publishes the resulting trained model and shuts down.","title":"Flow"},{"location":"architecture/specs/fl/#running-the-participants","text":"This section details how a Client/Data Scientist can setup and run a set of Participants using Nevermined Compute. This should be simpler to integrate because it\u2019s very similar to the data in situ computation use case. The main difference being that the algorithm is actually wrapped around the xain python sdk and it needs to be able to perform outgoing network connection to connect to the coordinator. The main requirements are: A PROVIDER defines the conditions that a Compute service supports. It includes: What kind of image (Docker container) can be deployed in the infrastructure What are the infrastructure resources available (CPU, memory, storage) What is the price of using the infrastructure resources A COMPUTE PROVIDER defines a Compute Service in the scope of the Asset (DID/DDO) of the dataset that can be computed A CONSUMER defines the task to execute modeling it in a Workflow (including configuration, input, participant) In this case the transformation is just the participant code It does not need to produce any output since that is handled by the coordinator A workflow is a new type of Asset. It can be resolvable and be used across multiple independent compute services A CONSUMER purchasing a compute service defines which Workflow (DID) is going to execute Running the participants","title":"Running the Participants"},{"location":"architecture/specs/fl/#flow_1","text":"The CONSUMER / Data Scientist locks the payment The CONSUMER / Data Scientist requests the execution of the participant The Gateway checks if the CONSUMER / Data Scientist has the permissions to execute the participant on the data The Nevermined compute sets up the environment The participants access the data and performs the machine learning task The participant needs to be able to communicate with the coordinator throughout the entire Federated Learning session. The coordinator will be external to the Infrastructure Provider The participant does not need to create a new asset since that is handled by the coordinator","title":"Flow"},{"location":"architecture/specs/fl/#federated-learning-session-flow","text":"This section details a high level overview of a Federated Learning Session using two different data providers. Federated Learning Session Flow The Data Scientist starts by finding a provider to run the Coordinator compute job and the data that it requires (possibly using the marketplace). The flow is: The Data Scientist starts by setting the execution parameters for the coordinator and publishes it as a workflow/ddo The Data Scientist purchases data in situ computation for both Data Provider X and Y and defines the workflow/ddo with the code that will run the participants The Data Scientist purchases the Coordinator compute service The Data Scientist starts the Coordinator The Data Scientist starts the participants The Participants work together with the coordinator over the course of multiple rounds as defined in point 1. Once all rounds are finished the Coordinator publishes the final trained model The Data Scientist fetches the trained model.","title":"Federated Learning Session Flow"},{"location":"architecture/specs/fl/#federated-learning-ddos","text":"This section details the both the consumer and provider DDOs for coordinator and participant.","title":"Federated Learning DDOs"},{"location":"architecture/specs/fl/#coordinator-consumer-ddo","text":"{ \"serviceAgreementId\" : \"bb23s87856d59867503f80a690357406857698570b964ac8dcc9d86da4ada010\" , \"workflow\" : { \"@context\" : \"https://w3id.org/future-method/v1\" , \"authentication\" : [], \"created\" : \"2019-04-09T19:02:11Z\" , \"id\" : \"did:nv:8d1b4d73e7af4634958f071ab8dfe7ab0df14019755e444090fd392c8ec9c3f4\" , \"proof\" : { \"created\" : \"2019-04-09T19:02:11Z\" , \"creator\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"signatureValue\" : \"1cd57300733bcbcda0beb59b3e076de6419c0d7674e7befb77820b53c79e3aa8f1776effc64cf088bad8cb694cc4d71ebd74a13b2f75893df5a53f3f318f6cf828\" , \"type\" : \"DDOIntegritySignature\" }, \"publicKey\" : [ { \"id\" : \"did:nv:8d1b4d73e7af4634958f071ab8dfe7ab0df14019755e444090fd392c8ec9c3f4\" , \"owner\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"type\" : \"EthereumECDSAKey\" } ], \"service\" : [ { \"index\" : 0 , \"serviceEndpoint\" : \"http://172.15.0.15:5000/api/v1/metadata/assets/ddo/did:nv:8d1b4d73e7af4634958f071ab8dfe7ab0df14019755e444090fd392c8ec9c3f4\" , \"type\" : \"metadata\" , \"attributes\" : { \"main\" : { \"dateCreated\" : \"2012-10-10T17:00:00Z\" , \"type\" : \"fl-coordinator\" , \"datePublished\" : \"2019-04-09T19:02:11Z\" , \"parameters\" : { \"minParticipants\" : 1 , \"participantsRatio\" : 1 , \"rounds\" : 10 , } \"workflow\" : { \"stages\" : [ { \"index\" : 0 , \"requirements\" : { \"serverInstances\" : 1 , \"container\" : { \"image\" : \"keykoio/xain-fl\" , \"tag\" : \"latest\" , \"checksum\" : \"sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc\" } } } ] } } } } ] } } The main information that needs to be provided is: - tag : The version of the xain-fl image to use - minParticipants : The minimum number of participants required by the coordinator - participantsRation : The ratio of participants that will be selected in every round - rounds : The number of rounds the coordinator should do Note that service.main.type is set to fl-coordinator to indicate this is not a normal workflow","title":"Coordinator Consumer DDO"},{"location":"architecture/specs/fl/#coordinator-provider-ddo","text":"{ \"@context\" : \"https://w3id.org/future-method/v1\" , \"authentication\" : [], \"created\" : \"2019-04-09T19:02:11Z\" , \"id\" : \"did:op:8d1b4d73e7af4634958f071ab8dfe7ab0df14019755e444090fd392c8ec9c3f4\" , \"proof\" : { \"created\" : \"2019-04-09T19:02:11Z\" , \"creator\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"signatureValue\" : \"1cd57300733bcbcda0beb59b3e076de6419c0d7674e7befb77820b53c79e3aa8f1776effc64cf088bad8cb694cc4d71ebd74a13b2f75893df5a53f3f318f6cf828\" , \"type\" : \"DDOIntegritySignature\" }, \"publicKey\" : [ { \"id\" : \"did:op:8d1b4d73e7af4634958f071ab8dfe7ab0df14019755e444090fd392c8ec9c3f4\" , \"owner\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"type\" : \"EthereumECDSAKey\" } ], \"service\" : [ { \"type\" : \"metadata\" , \"index\" : 0 , \"serviceEndpoint\" : \"http://mymetadata-api.org/api/v1/metadata/assets/ddo/{did}\" , \"attributes\" : { \"main\" : {}, \"additionalInformation\" : {} } }, { \"type\" : \"fl-coordinator\" , \"index\" : 2 , \"serviceEndpoint\" : \"http://mygateway.org/api/v1/gateway/services/execute\" , \"templateId\" : \"804932804923850985093485039850349850439583409583404534231321131a\" , \"attributes\" : { \"main\" : { \"creator\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"datePublished\" : \"2019-04-09T19:02:11Z\" , \"price\" : \"10\" , \"timeout\" : 86400 , \"provider\" : { \"type\" : \"Azure\" , \"description\" : \"\" , \"environment\" : { \"cluster\" : { \"type\" : \"Kubernetes\" , \"url\" : \"http://10.0.0.17/xxx\" }, \"supportedContainers\" : [ { \"image\" : \"keykoio/xain-fl\" , \"tag\" : \"latest\" , \"checksum\" : \"sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc\" }, { \"image\" : \"keykoio/xain-fl\" , \"tag\" : \"v1\" , \"checksum\" : \"sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc\" } ], \"supportedServers\" : [ { \"serverId\" : \"1\" , \"serverType\" : \"xlsize\" , \"price\" : \"50\" , \"cpu\" : \"16\" , \"gpu\" : \"0\" , \"memory\" : \"128gb\" , \"disk\" : \"160gb\" , \"maxExecutionTime\" : 86400 }, { \"serverId\" : \"2\" , \"serverType\" : \"medium\" , \"price\" : \"10\" , \"cpu\" : \"2\" , \"gpu\" : \"0\" , \"memory\" : \"8gb\" , \"disk\" : \"80gb\" , \"maxExecutionTime\" : 86400 } ] } } }, \"additionalInformation\" : {} }, \"serviceAgreementTemplate\" : { \"contractName\" : \"ServiceExecutionTemplate\" , \"events\" : [ { \"name\" : \"AgreementCreated\" , \"actorType\" : \"consumer\" , \"handler\" : { \"moduleName\" : \"serviceExecutionTemplate\" , \"functionName\" : \"fulfillLockPaymentCondition\" , \"version\" : \"0.1\" } } ], \"fulfillmentOrder\" : [ \"lockPayment.fulfill\" , \"serviceExecution.fulfill\" , \"escrowPayment.fulfill\" ], \"conditionDependency\" : { \"lockPayment\" : [], \"serviceExecution\" : [], \"releaseReward\" : [ \"lockPayment\" , \"serviceExecution\" ] }, \"conditions\" : [ { \"name\" : \"lockPayment\" , \"timelock\" : 0 , \"timeout\" : 0 , \"contractName\" : \"LockPaymentCondition\" , \"functionName\" : \"fulfill\" , \"parameters\" : [ { \"name\" : \"_did\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_rewardAddress\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_tokenAddress\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_amounts\" , \"type\" : \"uint256[]\" , \"value\" : [] }, { \"name\" : \"_receivers\" , \"type\" : \"address[]\" , \"value\" : [] } ], \"events\" : [ { \"name\" : \"Fulfilled\" , \"actorType\" : \"publisher\" , \"handler\" : { \"moduleName\" : \"lockPaymentConditon\" , \"functionName\" : \"fulfillServiceExecutionCondition\" , \"version\" : \"0.1\" } } ] }, { \"name\" : \"execCompute\" , \"timelock\" : 0 , \"timeout\" : 0 , \"contractName\" : \"ComputeExecutionCondition\" , \"functionName\" : \"fulfill\" , \"parameters\" : [ { \"name\" : \"_did\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_grantee\" , \"type\" : \"address\" , \"value\" : \"\" } ], \"events\" : [ { \"name\" : \"Fulfilled\" , \"actorType\" : \"publisher\" , \"handler\" : { \"moduleName\" : \"execCompute\" , \"functionName\" : \"fulfillServiceExecutionCondition\" , \"version\" : \"0.1\" } }, { \"name\" : \"TimedOut\" , \"actorType\" : \"consumer\" , \"handler\" : { \"moduleName\" : \"execCompute\" , \"functionName\" : \"fulfillServiceExecutionCondition\" , \"version\" : \"0.1\" } } ] }, { \"name\" : \"escrowPayment\" , \"timelock\" : 0 , \"timeout\" : 0 , \"contractName\" : \"EscrowPaymentCondition\" , \"functionName\" : \"fulfill\" , \"parameters\" : [ { \"name\" : \"_did\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_amounts\" , \"type\" : \"uint256[]\" , \"value\" : [] }, { \"name\" : \"_receivers\" , \"type\" : \"address[]\" , \"value\" : [] }, { \"name\" : \"_sender\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_tokenAddress\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_lockCondition\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_releaseCondition\" , \"type\" : \"bytes32\" , \"value\" : \"\" } ], \"events\" : [ { \"name\" : \"Fulfilled\" , \"actorType\" : \"publisher\" , \"handler\" : { \"moduleName\" : \"escrowPaymentConditon\" , \"functionName\" : \"verifyRewardTokens\" , \"version\" : \"0.1\" } } ] } ] } } ] }","title":"Coordinator Provider DDO"},{"location":"architecture/specs/fl/#participant-consumer-ddo","text":"{ \"serviceAgreementId\" : \"bb23s87856d59867503f80a690357406857698570b964ac8dcc9d86da4ada010\" , \"workflow\" : { \"@context\" : \"https://w3id.org/did/v1\" , \"authentication\" : [ { \"type\" : \"RsaSignatureAuthentication2018\" , \"publicKey\" : \"did:nv:0ebed8226ada17fde24b6bf2b95d27f8f05fcce09139ff5cec31f6d81a7cd2ea\" } ], \"created\" : \"2019-02-08T08:13:49Z\" , \"updated\" : \"2019-06-30T14:53:09Z\" , \"id\" : \"did:nv:0bc278fee025464f8012b811d1bce8e22094d0984e4e49139df5d5ff7a028bdf\" , \"proof\" : { \"created\" : \"2019-02-08T08:13:41Z\" , \"creator\" : \"0x37BB53e3d293494DE59fBe1FF78500423dcFd43B\" , \"signatureValue\" : \"did:nv:0bc278fee025464f8012b811d1bce8e22094d0984e4e49139df5d5ff7a028bdf\" , \"type\" : \"DDOIntegritySignature\" , \"checksum\" : { \"0\" : \"0x52b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3bbc3377\" , \"1\" : \"0x999999952b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3\" } }, \"publicKey\" : [ { \"id\" : \"did:nv:b6e2eb5eff1a093ced9826315d5a4ef6c5b5c8bd3c49890ee284231d7e1d0aaa#keys-1\" , \"type\" : \"RsaVerificationKey2018\" , \"owner\" : \"did:nv:6027c1e7cbae06a91fce0557ee53195284825f56a7100be0c53cbf4391aa26cc\" , \"publicKeyPem\" : \"-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\\r\\n\" }, { \"id\" : \"did:nv:b6e2eb5eff1a093ced9826315d5a4ef6c5b5c8bd3c49890ee284231d7e1d0aaa#keys-2\" , \"type\" : \"Ed25519VerificationKey2018\" , \"owner\" : \"did:nv:4c27a254e607cdf91a1206480e7eb8c74856102316c1a462277d4f21c02373b6\" , \"publicKeyBase58\" : \"H3C2AVvLMv6gmMNam3uVAjZpfkcJCwDwnZn6z3wXmqPV\" }, { \"id\" : \"did:nv:b6e2eb5eff1a093ced9826315d5a4ef6c5b5c8bd3c49890ee284231d7e1d0aaa#keys-3\" , \"type\" : \"RsaPublicKeyExchangeKey2018\" , \"owner\" : \"did:nv:5f6b885202ffb9643874be529302eb00d55e226959f1fbacaeda592c5b5c9484\" , \"publicKeyPem\" : \"-----BEGIN PUBLIC KEY...END PUBLIC KEY-----\\r\\n\" } ], \"verifiableCredential\" : [ { \"@context\" : [ \"https://www.w3.org/2018/credentials/v1\" , \"https://www.w3.org/2018/credentials/examples/v1\" ], \"id\" : \"1872\" , \"type\" : [ \"read\" , \"update\" , \"deactivate\" ], \"issuer\" : \"0x610D9314EDF2ced7681BA1633C33fdb8cF365a12\" , \"issuanceDate\" : \"2019-01-01T19:73:24Z\" , \"credentialSubject\" : { \"id\" : \"0x89328493849328493284932\" }, \"proof\" : { \"type\" : \"RsaSignature2018\" , \"created\" : \"2019-01-01T19:73:24Z\" , \"proofPurpose\" : \"assertionMethod\" , \"signatureValue\" : \"ABCJSDAO23...1tzjn4w==\" } } ], \"service\" : [ { \"index\" : 0 , \"serviceEndpoint\" : \"http://localhost:5000/api/v1/metadata/assets/ddo/{did}\" , \"type\" : \"metadata\" , \"attributes\" : { \"main\" : { \"author\" : \"John Doe\" , \"checksum\" : \"0x52b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3bbc3377\" , \"dateCreated\" : \"2019-02-08T08:13:49Z\" , \"datePublished\" : \"2019-05-08T08:13:49Z\" , \"license\" : \"CC-BY\" , \"name\" : \"My workflow\" , \"price\" : \"1\" , \"type\" : \"workflow\" , \"workflow\" : { \"stages\" : [ { \"index\" : 0 , \"stageType\" : \"Participant\" , \"requirements\" : { \"container\" : { \"image\" : \"keykoio/xain-participant\" , \"tag\" : \"latest\" , \"checksum\" : \"sha256:cb57ecfa6ebbefd8ffc7f75c0f00e57a7fa739578a429b6f72a0df19315deadc\" } }, \"input\" : [ { \"index\" : 0 , \"id\" : \"did:nv:12345\" } ], \"transformation\" : { \"id\" : \"did:nv:abcde\" }, \"output\" : { } } ] } }, \"additionalInformation\" : { \"description\" : \"Workflow to aggregate weather information\" , \"tags\" : [ \"weather\" , \"uk\" , \"2011\" , \"workflow\" , \"aggregation\" ], \"copyrightHolder\" : \"John Doe\" } } } ] } } This is a normal data in situ computation workflow with one stage, a set of inputs, one transformation and no output since the participant shouldn't need to generate any data.","title":"Participant Consumer DDO"},{"location":"architecture/specs/fl/#participant-provider-ddo","text":"","title":"Participant Provider DDO"},{"location":"architecture/specs/id_management/","text":"Identity management with on-chain access control \u00b6 shortname: IDM name: Identity management with on-chain access control type: Draft status: Valid version: 0.1 editor: Aitor Argomaniz <aitor@nevermined.io> contributors: - Identity management with on-chain access control - Introduction - Motivation - Concepts - Specifications - Actors - Use Case - Preconditions - Requirements - Architecture - Identity Management - Verifiable Credentials associated with Nevermined assets - Json Web Tokens (JWT) - JWT Structure - JWT Payload - Identity Gateways - Interactions between the actors - Gateway JWT implementation - JWT Authorization Grants - Adding and Revoking Permissions - Annex - Serializing DID Documents - Examples of JWT Grant Tokens This SPEC introduces a pattern for integrating independent Domain Controller system to manage the identity authorization with the Nevermined Service Execution Agreements (SEAs) (also called \"Service Agreements\" or \"Agreements\") as contracts between parties interacting in a transaction. Introduction \u00b6 Corporate environments utilize complex identity management and access control via Domain Controllers (i.e Active Directory). These solutions allow to authenticate and authorize corporate users of a specific domain or network. Implementations like Active Directory enable the management of individual or group permissions within the organization assigning security policies. At the same time, decentralized ecosystems allow the interaction and collaboration between different users part of the network using Decentralized Ledger Technologies (DLT) as source of truth of the shared network. In the data ecosystems where different organizations are members of the same network or consortia, it\u2019s a challenge to handle how the identity is managed within the organization (centralized) and how these different organizations can interact with each other re-using their existing Domain Controllers without moving all the existing identity management rules to a new silo or environment (centralized or decentralized). The intention of this document is to detail how independent organizations can integrate their existing corporate Domain Controllers in a Decentralized data ecosystem allowing the decentralized access control without replicating the existing organization permissions to the decentralized network. Motivation \u00b6 The main motivations of the solution described are: Understand how in a decentralized environment, different organizations with totally independent (and probably incompatible) Domain controllers can manage the permissions of the their decentralized assets (subjects) without replicating the permission policies in a new solution Understand what are the different actors involved and how these actors interact Identify the main interfaces required for the interactions Identify the credentials generation and management Understand how the credentials issued can map to a DLT user identity via keys Facilitate the interoperability between actors in the system Concepts \u00b6 Specifications \u00b6 Nevermined Identity Management solution is designed based on the Verifiable Credentials & Decentralized Identifiers specifications as building block in the design of the solution. So some of the terms and concepts used are based on these specifications. Actors \u00b6 The actors identified in the solution described are: Holder - An actor possessing one or more credentials. This user presents these credentials for identification purposes Issuer - The actors asserting the claims about different organization subjects and creating the credentials for that claims and transmitting to the Holder Verifier - The actors receiving credential presentations from Holders for further verification Verifiable data registry - The actors associated with the organizations managing the internal user and groups permissions W3C Actors in Verifiable Credentials Use Case \u00b6 Preconditions \u00b6 The specification and architecture designed is based in some environment preconditions. These preconditions need to be taken into account in order to adapt the solution designed to the environment where this solution is going to be used. The main environment characteristics are: Multiple and independent organizations participate in a decentralized data ecosystem Each organization have independent Identity Services (like Active Directory) to manage the internal authentication and authorization of their users and groups Users belonging to the organizations need to make use of the decentralized ecosystem authenticating via their Identity Services Different organizations could use totally independent and different infrastructure and technical solutions The rules governing the authorization of users within the organization are kept in the Domain Controllers. It\u2019s not recommended to replicate that information in a different centralized or decentralized repository Users belonging to an organization don\u2019t want to add a new mechanism to authenticate. They are already using their single sign-on (SSO) solution within the organization DLT networks use credentials for identifying, authenticate and authorize users in a decentralized environment Users need to make a friction-less interaction with the decentralized applications connected to the ecosystem without knowing the underlying credentials management (DLT wallets) Requirements \u00b6 The main requirements used to designed the solution are: Multiple and independent organizations need to manage the access control to the assets registered in a decentralized ecosystem A Subject manager or Admin wants to manage the access control to the subjects he/she controls using the Domain Controller solution used in the organization The Admin needs to manage the subjects access control via users and groups The users of a organization need to operate in the DLT network to interact with the subjects registered in that network The users of the decentralized ecosystem are identified in that network via credentials based in the Wallet technologies used in the DLT network The users need have a mapping between their organization identity and their decentralized ecosystem identity The Users or Holders keep their identity that only belongs to them. They need to present the credentials issued by the organizations they belong to verify their identity. The users can belong to one or many groups in one or many different organizations A user of the organization A wants to give permissions of a user or group of the organization B for making use of a subject or asset registered in a decentralized environment Users managing permissions on these decentralized assets should be able to add and revoke permissions The schemas and data existing in the individual deployments of the Identity Services shouldn't be replicated in the decentralized ecosystem. The source of truth are the Identity Services instances Information kept about the users and groups in the DLT network must be minimal and never store PI. Ideally only ids and hashes The decentralized ecosystem register assets and the conditions for who can interact and what is possible to do with these assets is kept on-chain Public information about users like users public keys should be available. User information should be resolvable via decentralized identifiers Architecture \u00b6 Identity Management \u00b6 The proposed solution involves the deployment of a component called Identity Gateway . Each Domain Controller in the Ecosystem needs to provide one Identity Gateway in charge of bridge the internals domain authorization policies with the rest of the world. So it\u2019s assumed for each independent Domain Controller available in the network, there should be at least one Identity Gateway resolving for the Domain Controller policies. W3C Actors in Verifiable Credentials In this scenario each Domain Controller keeps control of the identities of his domain. The only actions that are done by the Domain Controllers are: They identify users as in part of the domain They identify users as part of a group within the domain They are network isolated and respond to authorization queries to the associated Identity Gateway Verifiable Credentials associated with Nevermined assets \u00b6 In Nevermined an Asset can represent any kind of subject registered in the network. Typically assets represent datasets, algorithms, services, etc. Any registered asset within Nevermined always has associated a Decentralized Identifier (DID) that can be resolved into a DID Object (DDO). Typically a DDO includes metadata information describing the asset and the services that are offered by that asset to the rest of the network (access, computation, etc.). In addition to this, a DDO can include a portion describing the users and/or groups that can interact with the asset. This is modeled in the DDO in the shape of W3C Verifiable Credentials. Here you can see an example of a fragment of a DDO including the credentials of an asset for different subjects: { \"@context\" : \"https://www.w3.org/2018/credentials/v1\" , \"type\" : [ \"access\" ], \"issuer\" : \"0x610D9314EDF2ced7681BA1633C33fdb8cF365a12\" , \"issuanceDate\" : \"2019-01-01T19:73:24Z\" , \"credentialSubject\" : [{ \"id\" : \"0x1234\" , \"type\" : \"User\" }, { \"id\" : \"0x5678\" , \"type\" : \"User\" }, { \"id\" : \"Group XXX\" , \"type\" : \"Group\" }] } In the above verifiable credential fragment we are associating access permissions to any holder of the credentials able to authorize the users \u201c0x1234\u201d or \u201c0x5678\u201d or as part of the group \u201cGroup XXX\u201d of the domain. Json Web Tokens (JWT) \u00b6 JSON Web Tokens (JWT) is a compact URL-safe means of representing claims to be transferred between two parties. The claims in a JSON Web Tokens are encoded as a JavaScript Object Notation (JSON) object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or MACed and/or encrypted. JSON Web Token (JWT) is an open standard RFC 7519 that defines a compact and self-contained way for securely transmitting information between parties as a JSON Object. This information can be verified and trusted because it is digitally signed. JSON Web Tokens can be signed using a secret (with HMAC algorithm) or a public/private key pair using RSA. In the architecture design we use JWT for encapsulating the messages between the different parties. JSON Web Tokens consist of three parts separated by dots (.), which are: Header Payload Signature Therefore, a JWT typically looks like the following: Xxxxx.yyyyy.zzzzz In this architecture document, all the JWT messages sent from a client to a server are using the HTTP Authorization header with the Bearer scheme. Example: HTTP GET /api/v1/gateway/resource Authorization: Bearer eyJhbGciOiJIUzI1NiIXVCJ9TJV...r7E20RMHrHDcEfxjoYZgeFONFh7HgQ JWT Structure \u00b6 The header contains the metadata for the token and at a minimal contains the type of the signature and/or encryption algorithm: \"typ\" - the type of the token, which is JWT \"alg\" - the hashing algorithm such as ES256. We are using ECDSA with SHA256. \"cty\" - Header Parameter defined by JSON Web Signature and JSON Web Encryption is used by this specification to convey structural information about the JWT. In our case the header is gonna look like this: { \"typ\" : \"JWT\" , \"alg\" : \"ES256\" , \"cty\" : \"arbitrary\" } JWT Payload \u00b6 The payload contains the claims. Claims are statements about an entity (typically, the user) and additional metadata. There are three types of claims: Reserved claims: These are a set of predefined claims, which are not mandatory but recommended, thought to provide a set of useful, interoperable claims. Public claims: These can be defined at will by those using JWTs. But to avoid collisions they should be defined in the IANA JSON Web Token Registry or be defined as a URI that contains a collision resistant namespace. Private claims: These are the custom claims created to share information between parties that agree on using them. In our case the payload will have the following attributes: iss - Issuer. address of the holder sub - Subject, id of the service agreement aud - Audience, address of the gateway Here an example of the payload: { \"iss\" : \"0x123456\" , \"sub\" : \"did:nv:abcde\" , \"aud\" : \"0xffffff\" } Identity Gateways \u00b6 In this architecture the Identity Gateway is in charge of: Expose to the network the interface allowing to ask for the details of a Domain Controller. Resolve a Domain Controller DID into a DDO describing it. Each Domain Controller should have associated a unique Decentralized Identifier (DID) that resolves into URL where is kept the Decentralized Document (DDO) describing the Domain Controller. Verify the identity of a Holder. When a Holder presents a digital identity it authenticates the Holder. Typically this is happening verifying the signature given by the Holder for a specific Subject Check the authorization of a Holder over a Subject. When a Holder claims authorization for a Subject it integrates with the Domain Controller for verifying the authorization of that Holder. Generates, Signs and Issues credentials Can present some emitted credentials on-chain Interactions between the actors \u00b6 The following flow describes the interaction between actors allowing a Holder to present credentials related to a subject authorized by a Domain Controller. Identity Management Flow The different steps are: The Holder presents a credentials request related to a subject HTTP GET /api/v1/gateway/services/oauth2/token Authorization: Bearer eyJhbGciOiJIUzI1NiIXVCJ9TJV...r7E20RMHrHDcEfxjoYZgeFONFh7HgQ Where the JWT payload is: { \"iss\" : \"0x123456\" , // address of the holder \"sub\" : \"0xabcde\" , // id of the service agreement \"aud\" : \"0xffffff\" // address of the gateway } The Gateway decodes the JWT message, and validates the identity of the Holder checking the signature and the issuer address provided The Gateway queries the domain controller checking the access permissions of the Holder for a specific Subject. The identity Gateway could integrate different kinds of backends like Active Directory, LDAP, databases, etc. The verifiable credentials can include user or group types of credentials subjects. The identity gateway must validate if the user just authenticated fulfill any of the following: If is a user part of the Domain Controller If the user is part of any of the credential groups within the Domain If the Domain Controller validates the Holder has access permissions, the Identity Gateway will generate and sign a credential The credential is issued to the Holder in the JWT format included in the access_token response parameter: { \"access_token\" : \"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiIweDEyMzQ1NiIsInN1YiI6ImRpZDpudjphYmNkZSIsImF1ZCI6IjB4ZmZmZmZmIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyNTAwMjJ9.fiOSfeQwSiDi0ECFuDrHmhx8BHTHMl6MiyiJgJ6BIntjHvcFDFjPwtSYJrhYpeTcBPQ1FO5-fT-n4fQXBF92Vw\" } Which decoded has the following payload: json { \"iss\": \"0x123456\", \"sub\": \"0xabcde\", \"aud\": \"0xffffff\", \"iat\": 1516239022, \"exp\": 1516250022 } In this case it includes the \u201ciat\u201d (when the token was emitted) and \u201cexp\u201d (when the token is expiring). The Holder can present the credentials to a Smart Contract or Optionally the Identity Gateway could present the credentials to a Smart Contract on behalf of the Holder. Gateway JWT implementation \u00b6 The gateway implements the RFC6749: The OAuth 2.0 Authorization Framework framework using JWTs as Authorization Grants and JWTs as Access Tokens JWT Authorization Grants \u00b6 The claims that should be contained in a JWT Authorization Grant depend on the action that we want to perform on the gateway. The claims validation follow RFC7523 . Overall the claim options look like this: Registered name claims { \"iss\" : { \"essential\" : true }, \"sub\" : { \"essential\" : false }, \"aud\" : { \"essential\" : true , \"values\" : [ \"/api/v1/gateway/services/access\" , \"/api/v1/gateway/services/compute\" , \"/api/v1/gateway/services/download\" , \"/api/v1/gateway/services/execute\" ], }, \"exp\" : { \"essential\" : true }, } iss : Is the ethereum address of the consumer sub : (optional): Is the Service Agreement Id if applicable aud : Is the path of the endpoint being called exp : Is the expiration time Private name claims These claims are specific to Nevermined { \"did\" : { \"essential\" : false }, \"execution_id\" : { \"essential\" : false } } did (optional): Is the DID of the related asset execution_id (optional): Is the execution id of the related compute job To request a JWT access token a client needs to make a request to the token endpoint ( /api/v1/services/oauth2/token ) by sendinf the following parameters using application/x-www-form-urlencoded format as per RFC6749 with: grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer : The grant type as per RFC7523 assertion=<jwt grant token> : The assertion with a single JWT grant token as per RFC7523 For examples JWT Grant tokens check Examples of JWT Grant Tokens in the Annex . Adding and Revoking Permissions \u00b6 The administrator of the Domain typically uses the Domain Controller as a unique source of truth for the access control of users and groups. Because the identity gateway asks the Domain Controller for the belonging of users and groups as part of the domain, any modification of the permissions in the Domain Controller policies will be extended automatically to the new authorization queries responded by the Identity Gateway. For the cases where an access token was already given to a user, this will be valid during the lifetime of the credentials assigned to the user. During that period of time, the credentials will be valid for access to the resources granted. Because of that it is recommended to configure the identity gateway to not emit credentials with very long expiration time. To complement this, the Identity Gateway could integrate a cache system to keep track of the credentials granted during their life-cycle, and expose a method for revoking credentials immediately. In that scenario if a Domain Account needs to revoke some credentials related to a Holder and a Subject, it should send a request to the Identity Gateway using the following format: HTTP DELETE /api/v1/gateway/services/domain/credentials Authorization: Bearer eyJhbGciOiJIUzI1NiIXVCJ9TJV...r7E20RMHrHDcEfxjoYZgeFONFh7HgQ Where the JWT payload is: { \"iss\" : \"0x123456\" , // address of the domain controller \"sub\" : \"0xabcd\" , // id of the service agreement \"aud\" : \"0xffffff\" // address of the gateway } For this request the Identity Gateway needs to authenticate the Domain Account via the signature. If all the validations are correct the Identity Gateway needs to send a revoke request to the Smart Contract keeping the authorization permissions on-chain. This scenario is valid when the Identity Gateway integrates a DLT network to backup the authorization permissions. If the Identity Gateway performs the validation for each request, this revocation won\u2019t be necessary because the next authorization request via the Gateway will query the Domain Controller that should have already revoked the authorization permissions. Annex \u00b6 Serializing DID Documents \u00b6 Having a standard JSON document or subtract, the common operations used to serialize fragments of DID Documents is as follows: The object is sorted alphabetically by key, of the existing nested levels In the JSON generated, all the characters between entries are removed (\\n, \\t, \\r, whitespaces, etc.) As a result must be generated a string of only one line After serializing a DID Document or a fragment into a string line, typically it\u2019s necessary to hash that line to include as part of a different document or adding it on-chain. The common method used to do that is using the SHA3-256 (Keccak-256) algorithm (you might have to convert the string to bytes first.) , making sure that final hash generated is prefixed by 0x . Examples of JWT Grant Tokens \u00b6 /api/v1/gateway/services/access // header { \"alg\" : \"ES256K\" , \"typ\" : \"JWT\" } // assertion { \"iss\" : \"0x068Ed00cF0441e4829D9784fCBe7b9e26D4BD8d0\" , \"aud\" : \"/api/v1/gateway/services/access\" , \"sub\" : \"0xf527a6bbc35547f782dda34d64bb9070e743531107994899b1f97d4451aacbe1\" , \"iat\" : 1607967375 , \"exp\" : 1607970975 , \"did\" : \"did:nv:5c19aaf5f7c12ef0a9d898d5a89ca5428f3d0315b0f0a36f5b5d097166e53788\" } /api/v1/gateway/services/compute // header { \"alg\" : \"ES256K\" , \"typ\" : \"JWT\" } // assertion { \"iss\" : \"0x068Ed00cF0441e4829D9784fCBe7b9e26D4BD8d0\" , \"aud\" : \"/api/v1/gateway/services/compute\" , \"sub\" : \"0x3228c55d6e444cdc87bd5425896d5cdfa1e42e0734d04866a6c4386ef4f20144\" , \"iat\" : 1607968935 , \"exp\" : 1607972535 , \"execution_id\" : \"nevermined-compute-82v5j\" } /api/v1/gateway/services/download // header { \"alg\" : \"ES256K\" , \"typ\" : \"JWT\" } // assertion { \"iss\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"aud\" : \"/api/v1/gateway/services/download\" , \"iat\" : 1607969122 , \"exp\" : 1607972722 , \"did\" : \"did:nv:2379d3e2d03f25b8e5fb2fae6e6adeb45cd7674d20905fc172d84915ff68cc73\" } /api/v1/gateway/services/execute // header { \"alg\" : \"ES256K\" , \"typ\" : \"JWT\" } // assertion { \"iss\" : \"0x068Ed00cF0441e4829D9784fCBe7b9e26D4BD8d0\" , \"aud\" : \"/api/v1/gateway/services/execute\" , \"sub\" : \"0x715954fd8a9b48968983ae9b9813e169b4be0d861ccb4bbd8489298cda59c6a9\" , \"iat\" : 1607969247 , \"exp\" : 1607972847 , \"did\" : \"did:nv:e689ed382b15e190a5937f5c070843cce249a692ff09931d570e288bd91e5b81\" }","title":"Identity Management"},{"location":"architecture/specs/id_management/#identity-management-with-on-chain-access-control","text":"shortname: IDM name: Identity management with on-chain access control type: Draft status: Valid version: 0.1 editor: Aitor Argomaniz <aitor@nevermined.io> contributors: - Identity management with on-chain access control - Introduction - Motivation - Concepts - Specifications - Actors - Use Case - Preconditions - Requirements - Architecture - Identity Management - Verifiable Credentials associated with Nevermined assets - Json Web Tokens (JWT) - JWT Structure - JWT Payload - Identity Gateways - Interactions between the actors - Gateway JWT implementation - JWT Authorization Grants - Adding and Revoking Permissions - Annex - Serializing DID Documents - Examples of JWT Grant Tokens This SPEC introduces a pattern for integrating independent Domain Controller system to manage the identity authorization with the Nevermined Service Execution Agreements (SEAs) (also called \"Service Agreements\" or \"Agreements\") as contracts between parties interacting in a transaction.","title":"Identity management with on-chain access control"},{"location":"architecture/specs/id_management/#introduction","text":"Corporate environments utilize complex identity management and access control via Domain Controllers (i.e Active Directory). These solutions allow to authenticate and authorize corporate users of a specific domain or network. Implementations like Active Directory enable the management of individual or group permissions within the organization assigning security policies. At the same time, decentralized ecosystems allow the interaction and collaboration between different users part of the network using Decentralized Ledger Technologies (DLT) as source of truth of the shared network. In the data ecosystems where different organizations are members of the same network or consortia, it\u2019s a challenge to handle how the identity is managed within the organization (centralized) and how these different organizations can interact with each other re-using their existing Domain Controllers without moving all the existing identity management rules to a new silo or environment (centralized or decentralized). The intention of this document is to detail how independent organizations can integrate their existing corporate Domain Controllers in a Decentralized data ecosystem allowing the decentralized access control without replicating the existing organization permissions to the decentralized network.","title":"Introduction"},{"location":"architecture/specs/id_management/#motivation","text":"The main motivations of the solution described are: Understand how in a decentralized environment, different organizations with totally independent (and probably incompatible) Domain controllers can manage the permissions of the their decentralized assets (subjects) without replicating the permission policies in a new solution Understand what are the different actors involved and how these actors interact Identify the main interfaces required for the interactions Identify the credentials generation and management Understand how the credentials issued can map to a DLT user identity via keys Facilitate the interoperability between actors in the system","title":"Motivation"},{"location":"architecture/specs/id_management/#concepts","text":"","title":"Concepts"},{"location":"architecture/specs/id_management/#specifications","text":"Nevermined Identity Management solution is designed based on the Verifiable Credentials & Decentralized Identifiers specifications as building block in the design of the solution. So some of the terms and concepts used are based on these specifications.","title":"Specifications"},{"location":"architecture/specs/id_management/#actors","text":"The actors identified in the solution described are: Holder - An actor possessing one or more credentials. This user presents these credentials for identification purposes Issuer - The actors asserting the claims about different organization subjects and creating the credentials for that claims and transmitting to the Holder Verifier - The actors receiving credential presentations from Holders for further verification Verifiable data registry - The actors associated with the organizations managing the internal user and groups permissions W3C Actors in Verifiable Credentials","title":"Actors"},{"location":"architecture/specs/id_management/#use-case","text":"","title":"Use Case"},{"location":"architecture/specs/id_management/#preconditions","text":"The specification and architecture designed is based in some environment preconditions. These preconditions need to be taken into account in order to adapt the solution designed to the environment where this solution is going to be used. The main environment characteristics are: Multiple and independent organizations participate in a decentralized data ecosystem Each organization have independent Identity Services (like Active Directory) to manage the internal authentication and authorization of their users and groups Users belonging to the organizations need to make use of the decentralized ecosystem authenticating via their Identity Services Different organizations could use totally independent and different infrastructure and technical solutions The rules governing the authorization of users within the organization are kept in the Domain Controllers. It\u2019s not recommended to replicate that information in a different centralized or decentralized repository Users belonging to an organization don\u2019t want to add a new mechanism to authenticate. They are already using their single sign-on (SSO) solution within the organization DLT networks use credentials for identifying, authenticate and authorize users in a decentralized environment Users need to make a friction-less interaction with the decentralized applications connected to the ecosystem without knowing the underlying credentials management (DLT wallets)","title":"Preconditions"},{"location":"architecture/specs/id_management/#requirements","text":"The main requirements used to designed the solution are: Multiple and independent organizations need to manage the access control to the assets registered in a decentralized ecosystem A Subject manager or Admin wants to manage the access control to the subjects he/she controls using the Domain Controller solution used in the organization The Admin needs to manage the subjects access control via users and groups The users of a organization need to operate in the DLT network to interact with the subjects registered in that network The users of the decentralized ecosystem are identified in that network via credentials based in the Wallet technologies used in the DLT network The users need have a mapping between their organization identity and their decentralized ecosystem identity The Users or Holders keep their identity that only belongs to them. They need to present the credentials issued by the organizations they belong to verify their identity. The users can belong to one or many groups in one or many different organizations A user of the organization A wants to give permissions of a user or group of the organization B for making use of a subject or asset registered in a decentralized environment Users managing permissions on these decentralized assets should be able to add and revoke permissions The schemas and data existing in the individual deployments of the Identity Services shouldn't be replicated in the decentralized ecosystem. The source of truth are the Identity Services instances Information kept about the users and groups in the DLT network must be minimal and never store PI. Ideally only ids and hashes The decentralized ecosystem register assets and the conditions for who can interact and what is possible to do with these assets is kept on-chain Public information about users like users public keys should be available. User information should be resolvable via decentralized identifiers","title":"Requirements"},{"location":"architecture/specs/id_management/#architecture","text":"","title":"Architecture"},{"location":"architecture/specs/id_management/#identity-management","text":"The proposed solution involves the deployment of a component called Identity Gateway . Each Domain Controller in the Ecosystem needs to provide one Identity Gateway in charge of bridge the internals domain authorization policies with the rest of the world. So it\u2019s assumed for each independent Domain Controller available in the network, there should be at least one Identity Gateway resolving for the Domain Controller policies. W3C Actors in Verifiable Credentials In this scenario each Domain Controller keeps control of the identities of his domain. The only actions that are done by the Domain Controllers are: They identify users as in part of the domain They identify users as part of a group within the domain They are network isolated and respond to authorization queries to the associated Identity Gateway","title":"Identity Management"},{"location":"architecture/specs/id_management/#verifiable-credentials-associated-with-nevermined-assets","text":"In Nevermined an Asset can represent any kind of subject registered in the network. Typically assets represent datasets, algorithms, services, etc. Any registered asset within Nevermined always has associated a Decentralized Identifier (DID) that can be resolved into a DID Object (DDO). Typically a DDO includes metadata information describing the asset and the services that are offered by that asset to the rest of the network (access, computation, etc.). In addition to this, a DDO can include a portion describing the users and/or groups that can interact with the asset. This is modeled in the DDO in the shape of W3C Verifiable Credentials. Here you can see an example of a fragment of a DDO including the credentials of an asset for different subjects: { \"@context\" : \"https://www.w3.org/2018/credentials/v1\" , \"type\" : [ \"access\" ], \"issuer\" : \"0x610D9314EDF2ced7681BA1633C33fdb8cF365a12\" , \"issuanceDate\" : \"2019-01-01T19:73:24Z\" , \"credentialSubject\" : [{ \"id\" : \"0x1234\" , \"type\" : \"User\" }, { \"id\" : \"0x5678\" , \"type\" : \"User\" }, { \"id\" : \"Group XXX\" , \"type\" : \"Group\" }] } In the above verifiable credential fragment we are associating access permissions to any holder of the credentials able to authorize the users \u201c0x1234\u201d or \u201c0x5678\u201d or as part of the group \u201cGroup XXX\u201d of the domain.","title":"Verifiable Credentials associated with Nevermined assets"},{"location":"architecture/specs/id_management/#json-web-tokens-jwt","text":"JSON Web Tokens (JWT) is a compact URL-safe means of representing claims to be transferred between two parties. The claims in a JSON Web Tokens are encoded as a JavaScript Object Notation (JSON) object that is used as the payload of a JSON Web Signature (JWS) structure or as the plaintext of a JSON Web Encryption (JWE) structure, enabling the claims to be digitally signed or MACed and/or encrypted. JSON Web Token (JWT) is an open standard RFC 7519 that defines a compact and self-contained way for securely transmitting information between parties as a JSON Object. This information can be verified and trusted because it is digitally signed. JSON Web Tokens can be signed using a secret (with HMAC algorithm) or a public/private key pair using RSA. In the architecture design we use JWT for encapsulating the messages between the different parties. JSON Web Tokens consist of three parts separated by dots (.), which are: Header Payload Signature Therefore, a JWT typically looks like the following: Xxxxx.yyyyy.zzzzz In this architecture document, all the JWT messages sent from a client to a server are using the HTTP Authorization header with the Bearer scheme. Example: HTTP GET /api/v1/gateway/resource Authorization: Bearer eyJhbGciOiJIUzI1NiIXVCJ9TJV...r7E20RMHrHDcEfxjoYZgeFONFh7HgQ","title":"Json Web Tokens (JWT)"},{"location":"architecture/specs/id_management/#jwt-structure","text":"The header contains the metadata for the token and at a minimal contains the type of the signature and/or encryption algorithm: \"typ\" - the type of the token, which is JWT \"alg\" - the hashing algorithm such as ES256. We are using ECDSA with SHA256. \"cty\" - Header Parameter defined by JSON Web Signature and JSON Web Encryption is used by this specification to convey structural information about the JWT. In our case the header is gonna look like this: { \"typ\" : \"JWT\" , \"alg\" : \"ES256\" , \"cty\" : \"arbitrary\" }","title":"JWT Structure"},{"location":"architecture/specs/id_management/#jwt-payload","text":"The payload contains the claims. Claims are statements about an entity (typically, the user) and additional metadata. There are three types of claims: Reserved claims: These are a set of predefined claims, which are not mandatory but recommended, thought to provide a set of useful, interoperable claims. Public claims: These can be defined at will by those using JWTs. But to avoid collisions they should be defined in the IANA JSON Web Token Registry or be defined as a URI that contains a collision resistant namespace. Private claims: These are the custom claims created to share information between parties that agree on using them. In our case the payload will have the following attributes: iss - Issuer. address of the holder sub - Subject, id of the service agreement aud - Audience, address of the gateway Here an example of the payload: { \"iss\" : \"0x123456\" , \"sub\" : \"did:nv:abcde\" , \"aud\" : \"0xffffff\" }","title":"JWT Payload"},{"location":"architecture/specs/id_management/#identity-gateways","text":"In this architecture the Identity Gateway is in charge of: Expose to the network the interface allowing to ask for the details of a Domain Controller. Resolve a Domain Controller DID into a DDO describing it. Each Domain Controller should have associated a unique Decentralized Identifier (DID) that resolves into URL where is kept the Decentralized Document (DDO) describing the Domain Controller. Verify the identity of a Holder. When a Holder presents a digital identity it authenticates the Holder. Typically this is happening verifying the signature given by the Holder for a specific Subject Check the authorization of a Holder over a Subject. When a Holder claims authorization for a Subject it integrates with the Domain Controller for verifying the authorization of that Holder. Generates, Signs and Issues credentials Can present some emitted credentials on-chain","title":"Identity Gateways"},{"location":"architecture/specs/id_management/#interactions-between-the-actors","text":"The following flow describes the interaction between actors allowing a Holder to present credentials related to a subject authorized by a Domain Controller. Identity Management Flow The different steps are: The Holder presents a credentials request related to a subject HTTP GET /api/v1/gateway/services/oauth2/token Authorization: Bearer eyJhbGciOiJIUzI1NiIXVCJ9TJV...r7E20RMHrHDcEfxjoYZgeFONFh7HgQ Where the JWT payload is: { \"iss\" : \"0x123456\" , // address of the holder \"sub\" : \"0xabcde\" , // id of the service agreement \"aud\" : \"0xffffff\" // address of the gateway } The Gateway decodes the JWT message, and validates the identity of the Holder checking the signature and the issuer address provided The Gateway queries the domain controller checking the access permissions of the Holder for a specific Subject. The identity Gateway could integrate different kinds of backends like Active Directory, LDAP, databases, etc. The verifiable credentials can include user or group types of credentials subjects. The identity gateway must validate if the user just authenticated fulfill any of the following: If is a user part of the Domain Controller If the user is part of any of the credential groups within the Domain If the Domain Controller validates the Holder has access permissions, the Identity Gateway will generate and sign a credential The credential is issued to the Holder in the JWT format included in the access_token response parameter: { \"access_token\" : \"eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiIweDEyMzQ1NiIsInN1YiI6ImRpZDpudjphYmNkZSIsImF1ZCI6IjB4ZmZmZmZmIiwiaWF0IjoxNTE2MjM5MDIyLCJleHAiOjE1MTYyNTAwMjJ9.fiOSfeQwSiDi0ECFuDrHmhx8BHTHMl6MiyiJgJ6BIntjHvcFDFjPwtSYJrhYpeTcBPQ1FO5-fT-n4fQXBF92Vw\" } Which decoded has the following payload: json { \"iss\": \"0x123456\", \"sub\": \"0xabcde\", \"aud\": \"0xffffff\", \"iat\": 1516239022, \"exp\": 1516250022 } In this case it includes the \u201ciat\u201d (when the token was emitted) and \u201cexp\u201d (when the token is expiring). The Holder can present the credentials to a Smart Contract or Optionally the Identity Gateway could present the credentials to a Smart Contract on behalf of the Holder.","title":"Interactions between the actors"},{"location":"architecture/specs/id_management/#gateway-jwt-implementation","text":"The gateway implements the RFC6749: The OAuth 2.0 Authorization Framework framework using JWTs as Authorization Grants and JWTs as Access Tokens","title":"Gateway JWT implementation"},{"location":"architecture/specs/id_management/#jwt-authorization-grants","text":"The claims that should be contained in a JWT Authorization Grant depend on the action that we want to perform on the gateway. The claims validation follow RFC7523 . Overall the claim options look like this: Registered name claims { \"iss\" : { \"essential\" : true }, \"sub\" : { \"essential\" : false }, \"aud\" : { \"essential\" : true , \"values\" : [ \"/api/v1/gateway/services/access\" , \"/api/v1/gateway/services/compute\" , \"/api/v1/gateway/services/download\" , \"/api/v1/gateway/services/execute\" ], }, \"exp\" : { \"essential\" : true }, } iss : Is the ethereum address of the consumer sub : (optional): Is the Service Agreement Id if applicable aud : Is the path of the endpoint being called exp : Is the expiration time Private name claims These claims are specific to Nevermined { \"did\" : { \"essential\" : false }, \"execution_id\" : { \"essential\" : false } } did (optional): Is the DID of the related asset execution_id (optional): Is the execution id of the related compute job To request a JWT access token a client needs to make a request to the token endpoint ( /api/v1/services/oauth2/token ) by sendinf the following parameters using application/x-www-form-urlencoded format as per RFC6749 with: grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer : The grant type as per RFC7523 assertion=<jwt grant token> : The assertion with a single JWT grant token as per RFC7523 For examples JWT Grant tokens check Examples of JWT Grant Tokens in the Annex .","title":"JWT Authorization Grants"},{"location":"architecture/specs/id_management/#adding-and-revoking-permissions","text":"The administrator of the Domain typically uses the Domain Controller as a unique source of truth for the access control of users and groups. Because the identity gateway asks the Domain Controller for the belonging of users and groups as part of the domain, any modification of the permissions in the Domain Controller policies will be extended automatically to the new authorization queries responded by the Identity Gateway. For the cases where an access token was already given to a user, this will be valid during the lifetime of the credentials assigned to the user. During that period of time, the credentials will be valid for access to the resources granted. Because of that it is recommended to configure the identity gateway to not emit credentials with very long expiration time. To complement this, the Identity Gateway could integrate a cache system to keep track of the credentials granted during their life-cycle, and expose a method for revoking credentials immediately. In that scenario if a Domain Account needs to revoke some credentials related to a Holder and a Subject, it should send a request to the Identity Gateway using the following format: HTTP DELETE /api/v1/gateway/services/domain/credentials Authorization: Bearer eyJhbGciOiJIUzI1NiIXVCJ9TJV...r7E20RMHrHDcEfxjoYZgeFONFh7HgQ Where the JWT payload is: { \"iss\" : \"0x123456\" , // address of the domain controller \"sub\" : \"0xabcd\" , // id of the service agreement \"aud\" : \"0xffffff\" // address of the gateway } For this request the Identity Gateway needs to authenticate the Domain Account via the signature. If all the validations are correct the Identity Gateway needs to send a revoke request to the Smart Contract keeping the authorization permissions on-chain. This scenario is valid when the Identity Gateway integrates a DLT network to backup the authorization permissions. If the Identity Gateway performs the validation for each request, this revocation won\u2019t be necessary because the next authorization request via the Gateway will query the Domain Controller that should have already revoked the authorization permissions.","title":"Adding and Revoking Permissions"},{"location":"architecture/specs/id_management/#annex","text":"","title":"Annex"},{"location":"architecture/specs/id_management/#serializing-did-documents","text":"Having a standard JSON document or subtract, the common operations used to serialize fragments of DID Documents is as follows: The object is sorted alphabetically by key, of the existing nested levels In the JSON generated, all the characters between entries are removed (\\n, \\t, \\r, whitespaces, etc.) As a result must be generated a string of only one line After serializing a DID Document or a fragment into a string line, typically it\u2019s necessary to hash that line to include as part of a different document or adding it on-chain. The common method used to do that is using the SHA3-256 (Keccak-256) algorithm (you might have to convert the string to bytes first.) , making sure that final hash generated is prefixed by 0x .","title":"Serializing DID Documents"},{"location":"architecture/specs/id_management/#examples-of-jwt-grant-tokens","text":"/api/v1/gateway/services/access // header { \"alg\" : \"ES256K\" , \"typ\" : \"JWT\" } // assertion { \"iss\" : \"0x068Ed00cF0441e4829D9784fCBe7b9e26D4BD8d0\" , \"aud\" : \"/api/v1/gateway/services/access\" , \"sub\" : \"0xf527a6bbc35547f782dda34d64bb9070e743531107994899b1f97d4451aacbe1\" , \"iat\" : 1607967375 , \"exp\" : 1607970975 , \"did\" : \"did:nv:5c19aaf5f7c12ef0a9d898d5a89ca5428f3d0315b0f0a36f5b5d097166e53788\" } /api/v1/gateway/services/compute // header { \"alg\" : \"ES256K\" , \"typ\" : \"JWT\" } // assertion { \"iss\" : \"0x068Ed00cF0441e4829D9784fCBe7b9e26D4BD8d0\" , \"aud\" : \"/api/v1/gateway/services/compute\" , \"sub\" : \"0x3228c55d6e444cdc87bd5425896d5cdfa1e42e0734d04866a6c4386ef4f20144\" , \"iat\" : 1607968935 , \"exp\" : 1607972535 , \"execution_id\" : \"nevermined-compute-82v5j\" } /api/v1/gateway/services/download // header { \"alg\" : \"ES256K\" , \"typ\" : \"JWT\" } // assertion { \"iss\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"aud\" : \"/api/v1/gateway/services/download\" , \"iat\" : 1607969122 , \"exp\" : 1607972722 , \"did\" : \"did:nv:2379d3e2d03f25b8e5fb2fae6e6adeb45cd7674d20905fc172d84915ff68cc73\" } /api/v1/gateway/services/execute // header { \"alg\" : \"ES256K\" , \"typ\" : \"JWT\" } // assertion { \"iss\" : \"0x068Ed00cF0441e4829D9784fCBe7b9e26D4BD8d0\" , \"aud\" : \"/api/v1/gateway/services/execute\" , \"sub\" : \"0x715954fd8a9b48968983ae9b9813e169b4be0d861ccb4bbd8489298cda59c6a9\" , \"iat\" : 1607969247 , \"exp\" : 1607972847 , \"did\" : \"did:nv:e689ed382b15e190a5937f5c070843cce249a692ff09931d570e288bd91e5b81\" }","title":"Examples of JWT Grant Tokens"},{"location":"architecture/specs/keytransfer/","text":"KEYTRANSFER SPEC: Data transfer proofs \u00b6 shortname: KEYTRANSFER name: Data transfer proofs type: Standard status: Valid version: 0.1 editor: Sami M\u00e4kel\u00e4 <sami@keyko.io> contributors: Aitor Argomaniz <aitor@keyko.io> KETRANSFER SPEC: Data transfer proofs Motivation Main ideas Actors and Technical Components Flows Publishing Assets Service agreement Accessing from gateway This SPEC describes an addition to ACCESS SPEC, namely new flows with improved guarantees about data transfer. This enables using public storage for encrypted data. Motivation \u00b6 Nevermined manages access control over digital assets. The protocol has been based in authenticate and authorize consumers to get access to components created and registered into an ecosystem by a publisher. When this access control needs to be implemented on top of storage solutions with some authorization mechanism (like Amazon S3 or similar) it's easier. The gateway protects that only authorized users can get access. But when you want to use some storage without any access control capabilities (like a file available in a public HTTP url, or in IPFS or Filecoin), whoever with access to the URL can get access to the file going over any access control mechanism that Nevermined can provided. In this kind of scenarios, they only way to protect this content is to encrypt it, and only allow to decrypt when the user fulfill some conditions. This SPEC is about the defition of the solution that allows to build robust and scalable access control on top of publicly available data. Main ideas \u00b6 If the unencrypted asset is described by its hash, there are at least two use cases for being able to prove that the access to the asset with given hash is transferred: A third party might have reviewed the data and can confirm its properties. Additionally it will show that each recipient gets the same data. If compute attestation is available, for it to work both participants need access to data. To save resources, instead of showing that all the data is transferred, we assume that there is publicaly available encrypted data and only the symmetric key will be transferred (the hash of symmetric key is known by all participants). This does not impact the above use cases: The third party can instead validate the combination of the key and encrypted data. The compute attestation will use the encrypted data hash and the key instead of plain data hash as starting point. Note that with interactive proofs it would be enough for sender to send the decrypted key signed with their ECDSA or similar key. An advantage is that the keys can be used multiple times when using snarks. Actors and Technical Components \u00b6 PUBLISHERS - Provide access to assets and/or services CONSUMERS - Want to get access to assets and/or services PROVIDER - When the publisher is not 100% 'online' can delegate some responsibilities to a provider for making data available on behalf of the publisher Flows \u00b6 Publishing Assets \u00b6 To set up the asset metadata: For the files, the first file represents the key and url attribute contains the plain text key (probably have to change). These parts of metadata are encrypted so they won't show up publicly when querying the gateway. The public parts that have to be added to additionalInformation are poseidonHash : Poseidon hash of the key. providerKey.x and providerKey.y : The Babyjubjub public key of the provider. Service agreement \u00b6 For the service agreement, following data is needed: Address of provider and consumer. Asset ID. Poseidon hash of the data. Babyjubjub keys of the provider and consumer. Payment information. Before entering into the agreement, the consumer should already have downloaded the publicly available encrypted data. Other parts of the flow are the same as normal access flow, but the final fulfilling of the transfer on-chain is different. Provider first has to compute a shared secret using ECDH from his private key and consumers public key. This secret is used to encrypt the key using MiMC. The encrypted key is then sent onchain with the SNARK proof of correctness. Similarly, consumer first has to compute a shared secret using ECDH from his private key and providers public key. The encrypted key is read from chain and then decrypted using MiMC. The hash of the result will be the same as was given beforehand. Here is the complete flow including the different actors: Data Transfer Proofs Deal Flow In the case of an issue, here you can find the flow about how to manage the dispute resolution: Data Transfer Proofs Deal Flow Accessing from gateway \u00b6 In this scenario, the gateway acts as a PROVIDER. This is specially useful when the PUBLISHER doesn't want to be on-line running a service for responding to CONSUMER requests. In these kind of scenarios, the PUBLISHER delegates to the PROVIDER running a gateway the capabilities of releases the decryption key to the CONSUMER when the conditions are fulfilled. Accessing documents using the gateway mostly works the same way as normal flow, but the consumer has to send its Babyjubjub public key too. The data must be checked so that the gateway won't send invalid proofs to the net (it's possible to get the key from the calldata of the fulfill method if they have the corresponding key). Additionally we can check that the eth address corresponds to the babyjub public key. This isn't absolutely necessary, but is needed if we want the gateway to return the data transfer key (or perhaps the data as plain text). Data Transfer Proofs Deal Flow","title":"Data Transfer Proofs"},{"location":"architecture/specs/keytransfer/#keytransfer-spec-data-transfer-proofs","text":"shortname: KEYTRANSFER name: Data transfer proofs type: Standard status: Valid version: 0.1 editor: Sami M\u00e4kel\u00e4 <sami@keyko.io> contributors: Aitor Argomaniz <aitor@keyko.io> KETRANSFER SPEC: Data transfer proofs Motivation Main ideas Actors and Technical Components Flows Publishing Assets Service agreement Accessing from gateway This SPEC describes an addition to ACCESS SPEC, namely new flows with improved guarantees about data transfer. This enables using public storage for encrypted data.","title":"KEYTRANSFER SPEC: Data transfer proofs"},{"location":"architecture/specs/keytransfer/#motivation","text":"Nevermined manages access control over digital assets. The protocol has been based in authenticate and authorize consumers to get access to components created and registered into an ecosystem by a publisher. When this access control needs to be implemented on top of storage solutions with some authorization mechanism (like Amazon S3 or similar) it's easier. The gateway protects that only authorized users can get access. But when you want to use some storage without any access control capabilities (like a file available in a public HTTP url, or in IPFS or Filecoin), whoever with access to the URL can get access to the file going over any access control mechanism that Nevermined can provided. In this kind of scenarios, they only way to protect this content is to encrypt it, and only allow to decrypt when the user fulfill some conditions. This SPEC is about the defition of the solution that allows to build robust and scalable access control on top of publicly available data.","title":"Motivation"},{"location":"architecture/specs/keytransfer/#main-ideas","text":"If the unencrypted asset is described by its hash, there are at least two use cases for being able to prove that the access to the asset with given hash is transferred: A third party might have reviewed the data and can confirm its properties. Additionally it will show that each recipient gets the same data. If compute attestation is available, for it to work both participants need access to data. To save resources, instead of showing that all the data is transferred, we assume that there is publicaly available encrypted data and only the symmetric key will be transferred (the hash of symmetric key is known by all participants). This does not impact the above use cases: The third party can instead validate the combination of the key and encrypted data. The compute attestation will use the encrypted data hash and the key instead of plain data hash as starting point. Note that with interactive proofs it would be enough for sender to send the decrypted key signed with their ECDSA or similar key. An advantage is that the keys can be used multiple times when using snarks.","title":"Main ideas"},{"location":"architecture/specs/keytransfer/#actors-and-technical-components","text":"PUBLISHERS - Provide access to assets and/or services CONSUMERS - Want to get access to assets and/or services PROVIDER - When the publisher is not 100% 'online' can delegate some responsibilities to a provider for making data available on behalf of the publisher","title":"Actors and Technical Components"},{"location":"architecture/specs/keytransfer/#flows","text":"","title":"Flows"},{"location":"architecture/specs/keytransfer/#publishing-assets","text":"To set up the asset metadata: For the files, the first file represents the key and url attribute contains the plain text key (probably have to change). These parts of metadata are encrypted so they won't show up publicly when querying the gateway. The public parts that have to be added to additionalInformation are poseidonHash : Poseidon hash of the key. providerKey.x and providerKey.y : The Babyjubjub public key of the provider.","title":"Publishing Assets"},{"location":"architecture/specs/keytransfer/#service-agreement","text":"For the service agreement, following data is needed: Address of provider and consumer. Asset ID. Poseidon hash of the data. Babyjubjub keys of the provider and consumer. Payment information. Before entering into the agreement, the consumer should already have downloaded the publicly available encrypted data. Other parts of the flow are the same as normal access flow, but the final fulfilling of the transfer on-chain is different. Provider first has to compute a shared secret using ECDH from his private key and consumers public key. This secret is used to encrypt the key using MiMC. The encrypted key is then sent onchain with the SNARK proof of correctness. Similarly, consumer first has to compute a shared secret using ECDH from his private key and providers public key. The encrypted key is read from chain and then decrypted using MiMC. The hash of the result will be the same as was given beforehand. Here is the complete flow including the different actors: Data Transfer Proofs Deal Flow In the case of an issue, here you can find the flow about how to manage the dispute resolution: Data Transfer Proofs Deal Flow","title":"Service agreement"},{"location":"architecture/specs/keytransfer/#accessing-from-gateway","text":"In this scenario, the gateway acts as a PROVIDER. This is specially useful when the PUBLISHER doesn't want to be on-line running a service for responding to CONSUMER requests. In these kind of scenarios, the PUBLISHER delegates to the PROVIDER running a gateway the capabilities of releases the decryption key to the CONSUMER when the conditions are fulfilled. Accessing documents using the gateway mostly works the same way as normal flow, but the consumer has to send its Babyjubjub public key too. The data must be checked so that the gateway won't send invalid proofs to the net (it's possible to get the key from the calldata of the fulfill method if they have the corresponding key). Additionally we can check that the eth address corresponds to the babyjub public key. This isn't absolutely necessary, but is needed if we want the gateway to return the data transfer key (or perhaps the data as plain text). Data Transfer Proofs Deal Flow","title":"Accessing from gateway"},{"location":"architecture/specs/marketplace_api/","text":"MKT-API SPEC: Nevermined Marketplace API \u00b6 shortname: MKT-API name: Nevermined Marketplace API type: Standard status: Draft version: 0.2 editor: Aitor Argomaniz <aitor@nevermined.io> contributors: Table of Contents \u00b6 MKT-API SPEC: Nevermined Marketplace API Table of Contents Motivation Architecture Modules Assets Management Assets Search Users Profiles Permissions Secondary Market NFTs Metadata User Generated Contents NFTs Drops Bookmarks Marketplace Management Multimedia API Access Control Authentication Authorization Storage Links This SPEC introduces a new API that helps to build Marketplace environments on top of the Nevermined core protocol. Motivation \u00b6 With this Specification we want to build the foundations of an API that can be used as reference to implement APIs exposing typical Marketplace functionalities. Most of the Marketplaces (decentralized or not) expose some common functionalities around the assets they manage and their users. The intention of this API is to normalize a common set of this functionalities, allowing to build implementations providing this common functionalities. With that objective in mind, the specification of this API should detail the following capabilities: Assets Management - Creation, Update, Deleting, etc. This is based in the existing Metadata Spec Assets Search - Allowing the search and filtering of assets Users Profile - Allowing to create, update and delete users Secondary Market - Registering the negotiation of parties during a secondary market purchase NFTs Metadata - Recording the metadata associated to a NFT NFTs Drops - Management of NFT drops User Reviews - Allowing users to comment and rate marketplace contents Drops - Managing of NFT drops Bookmarks - Allowing users to save bookmarks about different assets Architecture \u00b6 Modules \u00b6 The API will provide the following functionalities. Assets Management \u00b6 The Assets in a Nevermined ecosystem are represented via DDOs that are resolved via a Decentralized Identifier (DID). While the DIDs are unique identifiers stored on-chain, the metadata of an asset is represented by a DDO recorded in an external data storage (centralized or decentralized). This DDO includes all the additional information describing an asset and the services attached to that asset (access, computation, etc.). This module of the API allows the management of the assets information. The main functionalities provided are the following: Create a DDO of a new asset - POST /api/v1/metadata/assets/ddo Get the DDO of a particular asset - GET /api/v1/metadata/assets/ddo/{did} Update DDO of an existing asset - PUT \u200b/api\u200b/v1\u200b/metadata\u200b/assets\u200b/ddo\u200b/{did} Delete an existing asset - DELETE \u200b/api\u200b/v1\u200b/metadata\u200b/assets\u200b/ddo\u200b/{did} The Creation, Update and Deletion of assets is authorized and only the asset owner and/or the application admin is allowed to do that action. For more information about DID and/or DDO's please refer to the DID SPEC: Decentralized Identifiers and META SPEC: Metadata Ontology . Assets Search \u00b6 This module complements the previous one and provides search functionalities on top of the existing assets metadata. All the actions listed here don't require user authorization: Get all asset IDs - GET \u200b/api\u200b/v1\u200b/metadata\u200b/assets Get DDO of all assets - GET \u200b/api\u200b/v1\u200b/metadata\u200b/assets\u200b/ddo Get a list of DDOs that match with the given text - GET \u200b/api\u200b/v1\u200b/metadata\u200b/assets\u200b/ddo\u200b/query Get a list of DDOs that match with the executed query - POST \u200b/api\u200b/v1\u200b/metadata\u200b/assets\u200b/ddo\u200b/query Users Profiles \u00b6 This module of the API allows the management of user profiles. The main functionalities provided are the following: Create a user profile - POST /api/v1/metadata/profiles Get the metadata of a user profile - GET /api/v1/metadata/profiles/{userId} Get the metadata of a user profile given an address - GET /api/v1/metadata/profiles/address/{publicAddress} Update the user profile - PUT /api/v1/metadata/profiles/{userId} Disable the user profile - DELETE /api/v1/metadata/profiles/{userId} The Creation, Update and Deletion of profiles is authorized and only the profile owner and/or the application admin is allowed to do that action. The model of this API is the following: userId - Unique identifier of the user isListed - Flag identifying if the user is listed in the marketplace. Possible values: true or false state - State of the user in the marketplace. Possible options: disabled , unconfirmed , confirmed addresses - The list of the addressed owned by the user. Addresses can't be shared between different users. nickname - The nickname of the user name - The name of the user (optional) email - The email of the user (optional) url - The url of the user (optional) creationDate - When the user information was created updateDate - When was the last time the user information was updated additionalInformation - List of additional key-value attributes with additional information Here an example of the the permissions document: { \"userId\" : \"jifdwqejidqwa9okdasodkaso\" , \"isListed\" : true , \"state\" : \"confirmed\" , \"addresses\" : [ \"0x37BB53e3d293494DE59fBe1FF78500423dcFd43B\" ], \"nickname\" : \"john.doe\" , \"name\" : \"John Doe\" , \"email\" : \"john.doe@example.com\" , \"creationDate\" : \"2019-01-01T19:73:24Z\" , \"updateDate\" : \"2019-01-01T19:73:24Z\" , \"additionalInformation\" : { \"profilePicture\" : \"http://example.com/avatar.jpg\" , \"linkedinProfile\" : \"http://linkedin.com\" } } Permissions \u00b6 This module of the API allows the management of user permissions in the marketplace via the usage of verifiable credentials. The main functionalities provided are the following: Create a permissions entry - POST /api/v1/permissions Get the information about a permissions entry - GET /api/v1/permissions/{permissionId} Get all the permissions of a user - GET /api/v1/permissions/user/{userId} Get all the permissions of a user of a specific type - GET /api/v1/permissions/user/{userId}/{type} Update the permissions entry - PUT /api/v1/permissions/{permissionId} Disable a permissions entry - DELETE /api/v1/permissions/{permissionId} The Creation, Read, Update and Deletion of permissions is authorized and only the application admin is allowed to do that action. The model of this API is the following: id - Unique identifier for the permissions entry userId - Unique identifier of the user type - The list of permissions owned hold by the user issuer - The account providing the permissions holder - The public address holding the permissions issuanceDate - When the permissions entry was created Here an example of the the permissions document: { \"permissionId\" : \"98it403-295-43954-3s\" , \"userId\" : \"jifdwqejidqwa9okdasodkaso\" , \"type\" : [ \"read\" , \"update\" , \"delete\" ], \"issuer\" : \"0x610D9314EDF2ced7681BA1633C33fdb8cF365a12\" , \"holder\" : \"0x37BB53e3d293494DE59fBe1FF78500423dcFd43B\" , \"issuanceDate\" : \"2019-01-01T19:73:24Z\" } For example when we want to provide a whitelisting functionality allowing to mint only to certain users, a specific type attribute could be created in the user who will hold the minting permissions. Having that a client application could check if a specific user has mint permissions running the following query: HTTP GET /api/v1/permissions/user/jifdwqejidqwa9okdasodkaso/mint Secondary Market \u00b6 This module of the API allows the management of the Secondary Market transactions. The main functionalities provided are the following: Publish an asset in the secondary market - POST /api/v1/agreement/secondary-market Get details of an asset in the secondary market - GET /api/v1/agreement/secondary-market/{id} Update the details of an asset in the secondary market - PUT /api/v1/agreement/secondary-market/{id} Unpublish an asset in the secondary market - DELETE /api/v1/agreement/secondary-market/{id} Get a list of secondary market assets that match with the executed query - POST \u200b/api\u200b/v1\u200b/agreement/secondary-market\u200b/query The Creation, Update and Deletion of assets in the secondary market is authorized and only the asset owner or the application admin is allowed to do that action. The model of this API is the following: id - Unique identifier for the entry serviceAgreementId - Service Agreement Id did - The identifier of the asset seller - The account selling the asset buyer - The account buying the asset createdAt - When the entry was published in the secondary market price - The price amount of the price in the secondary market tokenAddress - The token (Native or ERC20) used dynamicPricingAddress - Contract address if the pricing is defined as dynamic (auctions, etc). If is 0x0 the price is fixed and uses the price attribute NFTs Metadata \u00b6 This module of the API allows the creation of metadata attached to a NFT. The main functionalities provided are the following: Create NFT Metadata of a new asset - POST /api/v1/metadata/nft Get the NFT Metadata of an asset - GET /api/v1/metadata/nft/{did} Update NFT Metadata of an asset - PUT \u200b/api/v1/metadata/nft/{did} Delete NFT Metadata - DELETE \u200b/api/v1/metadata/nft/{did} The Marketplace API could use regular or inmutable storage for recording the NFT Metadata. If the storage is inmutable (IPFS, Filecoin, etc), the Update and Delete methods will return a HTTP 501 Not Implemented error message will be returned. The Creation, Update and Deletion of NFTs Metadata is authorized and only the asset owner is allowed to do that action. The model of this API is the following: did - The identifier of the asset image - The URL to the image associated to the NFT name - Name of the asset description - Description of the asset external_url - URL to the asset in a Nevermined ecosystem animation_url - A URL to a multi-media attachment for the item youtube_url - A URL to a YouTube video seller_fee_basis_points - Royalties for selling the NFT through a marketplace out of Nevermined (i.e OpenSea) fee_recipient - Address of the user receiving the royalties User Generated Contents \u00b6 This module of the API allows the management of User Generated Contents (UGC) like user reviews. The main functionalities provided are the following: Create a user review - POST /api/v1/ugc/reviews Get a user review - GET /api/v1/ugc/reviews/{id} Get all the reviews associated to an asset - GET /api/v1/ugc/asset/{did} Update a review - PUT /api/v1/ugc/reviews/{id} Unpublish a review - DELETE /api/v1/ugc/reviews/{id} The Creation, Update and Deletion of reviews is authorized and only the review owner and/or the application admin is allowed to do that action. The model of this API is the following: id - The identifier of the ugc content did - The identifier of the asset owner - The userId who created the review/rating status - Status of the UGC. Possible values: \"publised\", \"unpublished\", \"deleted\", \"retired\" title - Title of the comment description - Description given by the user rate - Number indicating the rating (flexible dependening to the marketplace). Examples: number between 1 and 5, 1 and 10, 0 and 100, etc. createdAt - When the UGC was created updatedAt - When the UGC was udpated moderatedBy - If the content was moderated, who applied that moderation By default, only UGC reviews with the state set to \"published\" should be displayed/ NFTs Drops \u00b6 This module of the API allows the creation of metadata associated to NFT drops. Drops are an important event in NFT marketplaces where admins AND/OR whitelisted authors can identify which NFTs are gonna be minted and when. The main functionalities provided are the following: Register a new NFT drop (admin or whitelisted author) - POST /api/v1/metadata/drops Search for listed drops - GET /api/v1/metadata/drops Get information about a drop - GET /api/v1/metadata/drop/{did} Update drop information - PUT \u200b/api/v1/metadata/drop/{did} Unlist a drop - DELETE \u200b/api/v1/metadata/drop/{did} The Creation, Update and Deletion of a NFT Drop is authorized and only the asset owner and/or the application admin is allowed to do that action. Bookmarks \u00b6 This module of the API allows users to bookmark marketplace contents. The main functionalities provided are the following: Create a bookmark entry - POST /api/v1/ugc/bookmarks Get a bookmark entry - GET /api/v1/ugc/bookmarks/{id} Get all the user bookmarks - GET /api/v1/ugc/bookmarks/user/{userId} Update an existing bookmark - PUT /api/v1/ugc/bookmarks/{id} Delete a bookmark - DELETE /api/v1/ugc/bookmarks/{bookmarkId} The Creation, Update and Deletion of bookmarks is authorized and only the bookmark owner is allowed to do that action. The model of this API is the following: id - The identifier of the bookmark did - The identifier of the asset userId - The userId who created the bookmark description - Description given by the user createdAt - When the UGC was created Marketplace Management \u00b6 Unpublish multiple assets Disable a user Disable user comments Multimedia \u00b6 URL Check - GET /api/v1/files/check Upload image - POST /api/v1/files/image Upload audio - POST /api/v1/files/audio Marketplace API Data Model API Access Control \u00b6 The API will expose a HTTP REST interface using Json Web Tokens (JWT) for users authorization and authentication. The API will use the following JWT attributes: Issuer ( iss ): the user address. For example: 0xa99d43d86a0758d5632313b8fa3972b6088a21bb Subject ( sub ): the user address or the address of a delegate. For example: 0xa99d43d86a0758d5632313b8fa3972b6088a21bb Issued at ( iat ): the date time of when the JWT token was issued Expiration ( exp ): the expiration date time of the JWT token The API will define a TTL of a maximum of one hour duration. Authentication \u00b6 The client of the API will need to authenticate using login method. This method will require the client to provide to authenticate the user. When the user is authenticated, the API will release a JWT allowing the user to interact with the different API modules. Marketplace API Access Control Flow The flow is the following: The client sends a HTTP GET /login request providing the user address. Example: HTTP GET /api/v1/docs/auth/login/0xa99d43d86a0758d5632313b8fa3972b6088a21bb The server will return a unique challenge token to the user The client will sign locally this challenge token using the local key material The client will send a HTTP POST /login request providing the user address and the challenge token signed HTTP POST /api/v1/docs/auth/login address=0xa99d43d86a0758d5632313b8fa3972b6088a21bb signature=90f8bf6a479f320ead074411a4b0e7944ea8c9c15932c5d68a1b539da0b0f8431d8e50e1a5b2b3bd4cfdcfc387a5ff85d7ef5fac429c4e0e4c1bfc36d4a99770b58f42924e126ece If the server can authenticate the user, it will return a JWT token { \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzUxMiJ9.eyJzdWIiOiIweDkwZjhiZjZhNDc5ZjMyMGVhZDA3NDQxMWE0YjBlNzk0NGVhOGM5YzEiLCJleHAiOjE0OTY1MDUwNzQsIm5iZiI6MTQ5NjUwMzI3NCwiaXNzIjoiTmV1ZnVuZCIsImF1ZCI6IndlYjMiLCJpYXQiOjE0OTY1MDMyNzR9.AaOPxTqBV4iy6GVlAu8XfbmOsIoezKfYjkqZ0SZ_RW6E7qwW-tUwSq8fq-avJrLtmCzLOD2xO9T5esEiIykP3Z9SAKWrTkdo9RwGcqGfvAySurbVAiFgW4MZ9pf9cHcB6zRks53pPcq6X2yqaVzjw28N6kBRQRc23GrUFnEDK6P_t3Tv\" } The user should be able to renew the authentication token passing the Authorization header to the /renew method: HTTP POST /api/v1/docs/auth/renew Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzUxMiJ9.eyJzdWIiOiIweDkwZjhiZjZhNDc5ZjMyMGVhZDA3NDQxMWE0YjBlNzk0NGVhOGM5YzEiLCJleHAiOjE0OTY1MDUwNzQsIm5iZiI6MTQ5NjUwMzI3NCwiaXNzIjoiTmV1ZnVuZCIsImF1ZCI6IndlYjMiLCJpYXQiOjE0OTY1MDMyNzR9.AaOPxTqBV4iy6GVlAu8XfbmOsIoezKfYjkqZ0SZ_RW6E7qwW-tUwSq8fq-avJrLtmCzLOD2xO9T5esEiIykP3Z9SAKWrTkdo9RwGcqGfvAySurbVAiFgW4MZ9pf9cHcB6zRks53pPcq6X2yqaVzjw28N6kBRQRc23GrUFnEDK6P_t3Tv Authorization \u00b6 Once the user is authenticated, the API will be able to authorize or not the user to perform different actions. Every document in the system has a reference to the original public address owning the document. Depending on the module, actions like updating or deleting will require different permissions. All the documents stored into the database will have a verifiableCredential entry witht the holder attribute attached to the document. This attribute will allow to validate the owner of the metadata object and perform any authorization action. For general permissions, the Permissions module will track what actions (described under the type attribute) are managed by each user. The admin permissions can be added and are reserved for users with administrative permissions in the application. Storage \u00b6 The storage of the data can use a standard database and/or an inmutable respository (IPFS, Filecoin, Arweave, ..) as a complement. Different storage backends provide a different set of functionalities to the final user. From one side, regular or standard databases provide easy searching functionalities. In the other side, inmutable storage provide a level of trust on things like the assets metadata. The usage of different storage backends or a combination of both will depend on the use case and/or the Marketplace API configuration. All the documents stored in a regular database or search engine (like Elastic Search) will record the metadata in their current models are they are. In the case this document has a mirror copy into a inmutable data store (like IPFS), the document will include a reference to this inmutable content via a full URL. This typically will be stored into the proof.inmutableUrl attribute. For example if an Asset DDO has a copy into IPFS, it will include an attribute like this: \"proof\" : { \"type\" : \"DDOIntegritySignature\" , \"created\" : \"2016-02-08T16:02:20Z\" , \"creator\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"signatureValue\" : \"0xc9eeb2b8106e\u20266abfdc5d1192641b\" , \"inmutableUrl\" : \"ipfs://QmPChd2hVbrJ6bfo3WBcTW4iZnpHm8TEzWkLHmLpXhF68A\" , \"checksum\" : { \"0\" : \"0x52b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3bbc3377\" , \"1\" : \"0x999999952b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3\" } } Links \u00b6 Decentralized Identifiers SPEC Metadata SPEC","title":"Marketplace API"},{"location":"architecture/specs/marketplace_api/#mkt-api-spec-nevermined-marketplace-api","text":"shortname: MKT-API name: Nevermined Marketplace API type: Standard status: Draft version: 0.2 editor: Aitor Argomaniz <aitor@nevermined.io> contributors:","title":"MKT-API SPEC: Nevermined Marketplace API"},{"location":"architecture/specs/marketplace_api/#table-of-contents","text":"MKT-API SPEC: Nevermined Marketplace API Table of Contents Motivation Architecture Modules Assets Management Assets Search Users Profiles Permissions Secondary Market NFTs Metadata User Generated Contents NFTs Drops Bookmarks Marketplace Management Multimedia API Access Control Authentication Authorization Storage Links This SPEC introduces a new API that helps to build Marketplace environments on top of the Nevermined core protocol.","title":"Table of Contents"},{"location":"architecture/specs/marketplace_api/#motivation","text":"With this Specification we want to build the foundations of an API that can be used as reference to implement APIs exposing typical Marketplace functionalities. Most of the Marketplaces (decentralized or not) expose some common functionalities around the assets they manage and their users. The intention of this API is to normalize a common set of this functionalities, allowing to build implementations providing this common functionalities. With that objective in mind, the specification of this API should detail the following capabilities: Assets Management - Creation, Update, Deleting, etc. This is based in the existing Metadata Spec Assets Search - Allowing the search and filtering of assets Users Profile - Allowing to create, update and delete users Secondary Market - Registering the negotiation of parties during a secondary market purchase NFTs Metadata - Recording the metadata associated to a NFT NFTs Drops - Management of NFT drops User Reviews - Allowing users to comment and rate marketplace contents Drops - Managing of NFT drops Bookmarks - Allowing users to save bookmarks about different assets","title":"Motivation"},{"location":"architecture/specs/marketplace_api/#architecture","text":"","title":"Architecture"},{"location":"architecture/specs/marketplace_api/#modules","text":"The API will provide the following functionalities.","title":"Modules"},{"location":"architecture/specs/marketplace_api/#assets-management","text":"The Assets in a Nevermined ecosystem are represented via DDOs that are resolved via a Decentralized Identifier (DID). While the DIDs are unique identifiers stored on-chain, the metadata of an asset is represented by a DDO recorded in an external data storage (centralized or decentralized). This DDO includes all the additional information describing an asset and the services attached to that asset (access, computation, etc.). This module of the API allows the management of the assets information. The main functionalities provided are the following: Create a DDO of a new asset - POST /api/v1/metadata/assets/ddo Get the DDO of a particular asset - GET /api/v1/metadata/assets/ddo/{did} Update DDO of an existing asset - PUT \u200b/api\u200b/v1\u200b/metadata\u200b/assets\u200b/ddo\u200b/{did} Delete an existing asset - DELETE \u200b/api\u200b/v1\u200b/metadata\u200b/assets\u200b/ddo\u200b/{did} The Creation, Update and Deletion of assets is authorized and only the asset owner and/or the application admin is allowed to do that action. For more information about DID and/or DDO's please refer to the DID SPEC: Decentralized Identifiers and META SPEC: Metadata Ontology .","title":"Assets Management"},{"location":"architecture/specs/marketplace_api/#assets-search","text":"This module complements the previous one and provides search functionalities on top of the existing assets metadata. All the actions listed here don't require user authorization: Get all asset IDs - GET \u200b/api\u200b/v1\u200b/metadata\u200b/assets Get DDO of all assets - GET \u200b/api\u200b/v1\u200b/metadata\u200b/assets\u200b/ddo Get a list of DDOs that match with the given text - GET \u200b/api\u200b/v1\u200b/metadata\u200b/assets\u200b/ddo\u200b/query Get a list of DDOs that match with the executed query - POST \u200b/api\u200b/v1\u200b/metadata\u200b/assets\u200b/ddo\u200b/query","title":"Assets Search"},{"location":"architecture/specs/marketplace_api/#users-profiles","text":"This module of the API allows the management of user profiles. The main functionalities provided are the following: Create a user profile - POST /api/v1/metadata/profiles Get the metadata of a user profile - GET /api/v1/metadata/profiles/{userId} Get the metadata of a user profile given an address - GET /api/v1/metadata/profiles/address/{publicAddress} Update the user profile - PUT /api/v1/metadata/profiles/{userId} Disable the user profile - DELETE /api/v1/metadata/profiles/{userId} The Creation, Update and Deletion of profiles is authorized and only the profile owner and/or the application admin is allowed to do that action. The model of this API is the following: userId - Unique identifier of the user isListed - Flag identifying if the user is listed in the marketplace. Possible values: true or false state - State of the user in the marketplace. Possible options: disabled , unconfirmed , confirmed addresses - The list of the addressed owned by the user. Addresses can't be shared between different users. nickname - The nickname of the user name - The name of the user (optional) email - The email of the user (optional) url - The url of the user (optional) creationDate - When the user information was created updateDate - When was the last time the user information was updated additionalInformation - List of additional key-value attributes with additional information Here an example of the the permissions document: { \"userId\" : \"jifdwqejidqwa9okdasodkaso\" , \"isListed\" : true , \"state\" : \"confirmed\" , \"addresses\" : [ \"0x37BB53e3d293494DE59fBe1FF78500423dcFd43B\" ], \"nickname\" : \"john.doe\" , \"name\" : \"John Doe\" , \"email\" : \"john.doe@example.com\" , \"creationDate\" : \"2019-01-01T19:73:24Z\" , \"updateDate\" : \"2019-01-01T19:73:24Z\" , \"additionalInformation\" : { \"profilePicture\" : \"http://example.com/avatar.jpg\" , \"linkedinProfile\" : \"http://linkedin.com\" } }","title":"Users Profiles"},{"location":"architecture/specs/marketplace_api/#permissions","text":"This module of the API allows the management of user permissions in the marketplace via the usage of verifiable credentials. The main functionalities provided are the following: Create a permissions entry - POST /api/v1/permissions Get the information about a permissions entry - GET /api/v1/permissions/{permissionId} Get all the permissions of a user - GET /api/v1/permissions/user/{userId} Get all the permissions of a user of a specific type - GET /api/v1/permissions/user/{userId}/{type} Update the permissions entry - PUT /api/v1/permissions/{permissionId} Disable a permissions entry - DELETE /api/v1/permissions/{permissionId} The Creation, Read, Update and Deletion of permissions is authorized and only the application admin is allowed to do that action. The model of this API is the following: id - Unique identifier for the permissions entry userId - Unique identifier of the user type - The list of permissions owned hold by the user issuer - The account providing the permissions holder - The public address holding the permissions issuanceDate - When the permissions entry was created Here an example of the the permissions document: { \"permissionId\" : \"98it403-295-43954-3s\" , \"userId\" : \"jifdwqejidqwa9okdasodkaso\" , \"type\" : [ \"read\" , \"update\" , \"delete\" ], \"issuer\" : \"0x610D9314EDF2ced7681BA1633C33fdb8cF365a12\" , \"holder\" : \"0x37BB53e3d293494DE59fBe1FF78500423dcFd43B\" , \"issuanceDate\" : \"2019-01-01T19:73:24Z\" } For example when we want to provide a whitelisting functionality allowing to mint only to certain users, a specific type attribute could be created in the user who will hold the minting permissions. Having that a client application could check if a specific user has mint permissions running the following query: HTTP GET /api/v1/permissions/user/jifdwqejidqwa9okdasodkaso/mint","title":"Permissions"},{"location":"architecture/specs/marketplace_api/#secondary-market","text":"This module of the API allows the management of the Secondary Market transactions. The main functionalities provided are the following: Publish an asset in the secondary market - POST /api/v1/agreement/secondary-market Get details of an asset in the secondary market - GET /api/v1/agreement/secondary-market/{id} Update the details of an asset in the secondary market - PUT /api/v1/agreement/secondary-market/{id} Unpublish an asset in the secondary market - DELETE /api/v1/agreement/secondary-market/{id} Get a list of secondary market assets that match with the executed query - POST \u200b/api\u200b/v1\u200b/agreement/secondary-market\u200b/query The Creation, Update and Deletion of assets in the secondary market is authorized and only the asset owner or the application admin is allowed to do that action. The model of this API is the following: id - Unique identifier for the entry serviceAgreementId - Service Agreement Id did - The identifier of the asset seller - The account selling the asset buyer - The account buying the asset createdAt - When the entry was published in the secondary market price - The price amount of the price in the secondary market tokenAddress - The token (Native or ERC20) used dynamicPricingAddress - Contract address if the pricing is defined as dynamic (auctions, etc). If is 0x0 the price is fixed and uses the price attribute","title":"Secondary Market"},{"location":"architecture/specs/marketplace_api/#nfts-metadata","text":"This module of the API allows the creation of metadata attached to a NFT. The main functionalities provided are the following: Create NFT Metadata of a new asset - POST /api/v1/metadata/nft Get the NFT Metadata of an asset - GET /api/v1/metadata/nft/{did} Update NFT Metadata of an asset - PUT \u200b/api/v1/metadata/nft/{did} Delete NFT Metadata - DELETE \u200b/api/v1/metadata/nft/{did} The Marketplace API could use regular or inmutable storage for recording the NFT Metadata. If the storage is inmutable (IPFS, Filecoin, etc), the Update and Delete methods will return a HTTP 501 Not Implemented error message will be returned. The Creation, Update and Deletion of NFTs Metadata is authorized and only the asset owner is allowed to do that action. The model of this API is the following: did - The identifier of the asset image - The URL to the image associated to the NFT name - Name of the asset description - Description of the asset external_url - URL to the asset in a Nevermined ecosystem animation_url - A URL to a multi-media attachment for the item youtube_url - A URL to a YouTube video seller_fee_basis_points - Royalties for selling the NFT through a marketplace out of Nevermined (i.e OpenSea) fee_recipient - Address of the user receiving the royalties","title":"NFTs Metadata"},{"location":"architecture/specs/marketplace_api/#user-generated-contents","text":"This module of the API allows the management of User Generated Contents (UGC) like user reviews. The main functionalities provided are the following: Create a user review - POST /api/v1/ugc/reviews Get a user review - GET /api/v1/ugc/reviews/{id} Get all the reviews associated to an asset - GET /api/v1/ugc/asset/{did} Update a review - PUT /api/v1/ugc/reviews/{id} Unpublish a review - DELETE /api/v1/ugc/reviews/{id} The Creation, Update and Deletion of reviews is authorized and only the review owner and/or the application admin is allowed to do that action. The model of this API is the following: id - The identifier of the ugc content did - The identifier of the asset owner - The userId who created the review/rating status - Status of the UGC. Possible values: \"publised\", \"unpublished\", \"deleted\", \"retired\" title - Title of the comment description - Description given by the user rate - Number indicating the rating (flexible dependening to the marketplace). Examples: number between 1 and 5, 1 and 10, 0 and 100, etc. createdAt - When the UGC was created updatedAt - When the UGC was udpated moderatedBy - If the content was moderated, who applied that moderation By default, only UGC reviews with the state set to \"published\" should be displayed/","title":"User Generated Contents"},{"location":"architecture/specs/marketplace_api/#nfts-drops","text":"This module of the API allows the creation of metadata associated to NFT drops. Drops are an important event in NFT marketplaces where admins AND/OR whitelisted authors can identify which NFTs are gonna be minted and when. The main functionalities provided are the following: Register a new NFT drop (admin or whitelisted author) - POST /api/v1/metadata/drops Search for listed drops - GET /api/v1/metadata/drops Get information about a drop - GET /api/v1/metadata/drop/{did} Update drop information - PUT \u200b/api/v1/metadata/drop/{did} Unlist a drop - DELETE \u200b/api/v1/metadata/drop/{did} The Creation, Update and Deletion of a NFT Drop is authorized and only the asset owner and/or the application admin is allowed to do that action.","title":"NFTs Drops"},{"location":"architecture/specs/marketplace_api/#bookmarks","text":"This module of the API allows users to bookmark marketplace contents. The main functionalities provided are the following: Create a bookmark entry - POST /api/v1/ugc/bookmarks Get a bookmark entry - GET /api/v1/ugc/bookmarks/{id} Get all the user bookmarks - GET /api/v1/ugc/bookmarks/user/{userId} Update an existing bookmark - PUT /api/v1/ugc/bookmarks/{id} Delete a bookmark - DELETE /api/v1/ugc/bookmarks/{bookmarkId} The Creation, Update and Deletion of bookmarks is authorized and only the bookmark owner is allowed to do that action. The model of this API is the following: id - The identifier of the bookmark did - The identifier of the asset userId - The userId who created the bookmark description - Description given by the user createdAt - When the UGC was created","title":"Bookmarks"},{"location":"architecture/specs/marketplace_api/#marketplace-management","text":"Unpublish multiple assets Disable a user Disable user comments","title":"Marketplace Management"},{"location":"architecture/specs/marketplace_api/#multimedia","text":"URL Check - GET /api/v1/files/check Upload image - POST /api/v1/files/image Upload audio - POST /api/v1/files/audio Marketplace API Data Model","title":"Multimedia"},{"location":"architecture/specs/marketplace_api/#api-access-control","text":"The API will expose a HTTP REST interface using Json Web Tokens (JWT) for users authorization and authentication. The API will use the following JWT attributes: Issuer ( iss ): the user address. For example: 0xa99d43d86a0758d5632313b8fa3972b6088a21bb Subject ( sub ): the user address or the address of a delegate. For example: 0xa99d43d86a0758d5632313b8fa3972b6088a21bb Issued at ( iat ): the date time of when the JWT token was issued Expiration ( exp ): the expiration date time of the JWT token The API will define a TTL of a maximum of one hour duration.","title":"API Access Control"},{"location":"architecture/specs/marketplace_api/#authentication","text":"The client of the API will need to authenticate using login method. This method will require the client to provide to authenticate the user. When the user is authenticated, the API will release a JWT allowing the user to interact with the different API modules. Marketplace API Access Control Flow The flow is the following: The client sends a HTTP GET /login request providing the user address. Example: HTTP GET /api/v1/docs/auth/login/0xa99d43d86a0758d5632313b8fa3972b6088a21bb The server will return a unique challenge token to the user The client will sign locally this challenge token using the local key material The client will send a HTTP POST /login request providing the user address and the challenge token signed HTTP POST /api/v1/docs/auth/login address=0xa99d43d86a0758d5632313b8fa3972b6088a21bb signature=90f8bf6a479f320ead074411a4b0e7944ea8c9c15932c5d68a1b539da0b0f8431d8e50e1a5b2b3bd4cfdcfc387a5ff85d7ef5fac429c4e0e4c1bfc36d4a99770b58f42924e126ece If the server can authenticate the user, it will return a JWT token { \"token\": \"eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzUxMiJ9.eyJzdWIiOiIweDkwZjhiZjZhNDc5ZjMyMGVhZDA3NDQxMWE0YjBlNzk0NGVhOGM5YzEiLCJleHAiOjE0OTY1MDUwNzQsIm5iZiI6MTQ5NjUwMzI3NCwiaXNzIjoiTmV1ZnVuZCIsImF1ZCI6IndlYjMiLCJpYXQiOjE0OTY1MDMyNzR9.AaOPxTqBV4iy6GVlAu8XfbmOsIoezKfYjkqZ0SZ_RW6E7qwW-tUwSq8fq-avJrLtmCzLOD2xO9T5esEiIykP3Z9SAKWrTkdo9RwGcqGfvAySurbVAiFgW4MZ9pf9cHcB6zRks53pPcq6X2yqaVzjw28N6kBRQRc23GrUFnEDK6P_t3Tv\" } The user should be able to renew the authentication token passing the Authorization header to the /renew method: HTTP POST /api/v1/docs/auth/renew Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJFUzUxMiJ9.eyJzdWIiOiIweDkwZjhiZjZhNDc5ZjMyMGVhZDA3NDQxMWE0YjBlNzk0NGVhOGM5YzEiLCJleHAiOjE0OTY1MDUwNzQsIm5iZiI6MTQ5NjUwMzI3NCwiaXNzIjoiTmV1ZnVuZCIsImF1ZCI6IndlYjMiLCJpYXQiOjE0OTY1MDMyNzR9.AaOPxTqBV4iy6GVlAu8XfbmOsIoezKfYjkqZ0SZ_RW6E7qwW-tUwSq8fq-avJrLtmCzLOD2xO9T5esEiIykP3Z9SAKWrTkdo9RwGcqGfvAySurbVAiFgW4MZ9pf9cHcB6zRks53pPcq6X2yqaVzjw28N6kBRQRc23GrUFnEDK6P_t3Tv","title":"Authentication"},{"location":"architecture/specs/marketplace_api/#authorization","text":"Once the user is authenticated, the API will be able to authorize or not the user to perform different actions. Every document in the system has a reference to the original public address owning the document. Depending on the module, actions like updating or deleting will require different permissions. All the documents stored into the database will have a verifiableCredential entry witht the holder attribute attached to the document. This attribute will allow to validate the owner of the metadata object and perform any authorization action. For general permissions, the Permissions module will track what actions (described under the type attribute) are managed by each user. The admin permissions can be added and are reserved for users with administrative permissions in the application.","title":"Authorization"},{"location":"architecture/specs/marketplace_api/#storage","text":"The storage of the data can use a standard database and/or an inmutable respository (IPFS, Filecoin, Arweave, ..) as a complement. Different storage backends provide a different set of functionalities to the final user. From one side, regular or standard databases provide easy searching functionalities. In the other side, inmutable storage provide a level of trust on things like the assets metadata. The usage of different storage backends or a combination of both will depend on the use case and/or the Marketplace API configuration. All the documents stored in a regular database or search engine (like Elastic Search) will record the metadata in their current models are they are. In the case this document has a mirror copy into a inmutable data store (like IPFS), the document will include a reference to this inmutable content via a full URL. This typically will be stored into the proof.inmutableUrl attribute. For example if an Asset DDO has a copy into IPFS, it will include an attribute like this: \"proof\" : { \"type\" : \"DDOIntegritySignature\" , \"created\" : \"2016-02-08T16:02:20Z\" , \"creator\" : \"0x00Bd138aBD70e2F00903268F3Db08f2D25677C9e\" , \"signatureValue\" : \"0xc9eeb2b8106e\u20266abfdc5d1192641b\" , \"inmutableUrl\" : \"ipfs://QmPChd2hVbrJ6bfo3WBcTW4iZnpHm8TEzWkLHmLpXhF68A\" , \"checksum\" : { \"0\" : \"0x52b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3bbc3377\" , \"1\" : \"0x999999952b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3\" } }","title":"Storage"},{"location":"architecture/specs/marketplace_api/#links","text":"Decentralized Identifiers SPEC Metadata SPEC","title":"Links"},{"location":"architecture/specs/metadata/","text":"META SPEC: Metadata Ontology \u00b6 shortname: META name: Metadata Ontology type: Standard status: Valid version: 0.2 editor: Aitor Argomaniz <aitor@nevermined.io> contributors: META SPEC: Metadata Ontology Motivation Life Cycle of Metadata Local Metadata Remote Metadata Metadata Attributes Main Attributes File Attributes Additional Attributes Other Suggested Additional Attributes Curation Attributes Example of Local Metadata Example of Remote Metadata Specific attributes per asset type Algorithm attributes References Motivation \u00b6 Every asset (dataset, algorithm) in Nevermined has an associated Decentralized Identifier (DID) and DID document / DID Descriptor Object (DDO). Because assets without proper descriptive metadata have poor visibility and discoverability. See DID SPEC for information about the overall structure of Nevermined DDOs and DIDs.This OEP is about one particular part of Nevermined DDOs: the asset metadata, a JSON object with information about the asset. This SPEC defines the assets metadata ontology, i.e. the schema for the asset metadata. It's based on the public schema.org DataSet schema . This SPEC doesn't detail the exact method of registering assets on-chain or storing DDOs. The main motivations of this SPEC are to: Specify the common attributes that MUST be included in any asset metadata stored in Nevermined networks Normalize the attributes to use in any curation process, to provide a common structure to sort and filter the DDOs Identify the recommended additional attributes that SHOULD be included in a DDO to facilitate asset search Provide an example of an asset metadata object and additional links for reference Life Cycle of Metadata \u00b6 Local Metadata \u00b6 Metadata is first created by the publisher of the asset. The publisher has knowledge of the file URLs, and they are stored in plaintext in the files object. This initial metadata is the local metadata . Remote Metadata \u00b6 A publisher publishes (registers) an asset using Nevermined SDKs, which might be running on their local machine or remotely. When they do, the local metadata is passed to the SDK, which makes some changes and additions in the metadata, puts it into a DDO, and sends that DDO to a metadata API. The Metadata API may also make some changes and additions to the metadata, such as the datePublished or parts of the curation object. The metadata that finally gets stored by the Metadata API is the remote metadata . A marketplace can and might also act as a publisher. SPEC ACCESS describes the publishing flow in more detail. Metadata Attributes \u00b6 An asset is the representation of different type of resources in Nevermined. Typically can asset could be one of the following asset types: Dataset . An asset representing a dataset or data resource. It could be for example a CSV file or a multiple JPG files. Algorithm . An asset representing a piece of software. It could be a python script using tensorflow, a spark job, etc. Each kind of asset require a different subset of metadata attributes. The distinction between the type of asset (dataset, algorithm) is given by the attribute DDO.services[\"metadata\"].main.type A metadata object has the following attributes, all of which are objects. Attribute Required Description main Yes Main attributes used to calculate the service checksum curation (remote) Curation attributes additionalInformation No Optional attributes encryptedFiles (remote) Encrypted string of the attributes.main.files object. encryptedServices (remote) Encrypted string of the attributes.main.services object. The main , curation and additionalInformation attributes are independent of the asset type, all assets have those metadata sections. Main Attributes \u00b6 This list of attributes can't be modified after creation , because these are considered as the metadata essence of the asset created. This information is used to calculate the unique checksum of the asset. If any change would be necessary in the following attributes, it would be necessary to create a new asset derived from the existing one. The main object has the following attributes, not all are required. Some are required by only the metadata store ( remote ) and others are mandatory for local metadata only. If required or not by both, they are marked with Yes/No in the Required column. Attribute Type Required Description name Text Yes Descriptive name or title of the asset. type Text Yes Type of the asset. Helps to filter by the type of asset. It could be for example (\"dataset\", \"algorithm\"). dateCreated DateTime Yes The date on which the asset was created by the originator. ISO 8601 format, Coordinated Universal Time, e.g. 2019-01-31T08:38:32Z . datePublished DateTime (remote) The date on which the asset DDO is registered into the metadata store (Metadata API) author Text Yes Name of the entity generating this data (e.g. Tfl, Disney Corp, etc.). license Text Yes Short name referencing the license of the asset (e.g. Public Domain, CC-0, CC-BY, No License Specified, etc. ). If it's not specified, the following value will be added: \"No License Specified\". price String Yes Price of the asset. It must be an integer encoded as a string, e.g. \"123000000000000000000\" . files Array of files object Yes Array of File objects including the encrypted file urls. Further metadata about each file is stored, see File Attributes File Attributes \u00b6 File attributes are a subset of the main section. A file object has the following attributes, with the details necessary to consume and validate the data. Attribute Required Description url (local) Content URL. Omitted from the remote metadata. Supports http(s):// and ipfs:// URLs. name no File name. index yes Index number starting from 0 of the file. contentType yes File format. checksum no Checksum of the file using your preferred format (i.e. MD5). Format specified in checksumType . If it's not provided can't be validated if the file was not modified after registering. checksumType no Format of the provided checksum. Can vary according to server (i.e Amazon vs. Azure) contentLength no Size of the file in bytes. encoding no File encoding (e.g. UTF-8). compression no File compression (e.g. no, gzip, bzip2, etc). encrypted no Boolean. Is the file encrypted? If is not set is assumed the file is not encrypted encryptionMode no Encryption mode used. Just valid if encrypted=true resourceId no Remote identifier of the file in the external provider. It is typically the remote id in the cloud provider. attributes no Key-Value hash map with additional attributes describing the asset file. It could include details like the Amazon S3 bucket, region, etc. Additional Attributes \u00b6 All the additional information will be stored as part of the additionalInformation section. Attribute Type Required categories Array of Text No tags Array of Text No description Text No copyrightHolder Text No workExample Text No links Array of Link No inLanguage Text No Other Suggested Additional Attributes \u00b6 These are examples of attributes that can enhance the discoverability of a resource: Attribute Description sla Service Level Agreement. industry updateFrequency An indication of update latency - i.e. How often are updates expected (seldom, annually, quarterly, etc.), or is the resource static that is never expected to get updated. termsOfService privacy keyword A list of keywords/tags describing a dataset. structuredMarkup A link to machine-readable structured markup (such as ttl/json-ld/rdf) describing the dataset. The publisher of a DDO MAY add additional attributes or change the above object definition. Curation Attributes \u00b6 A curation object has the following attributes. Attribute Type Required Description rating Number (decimal) Yes Decimal value between 0 and 1. 0 is the default value. numVotes Integer Yes Number of votes. 0 is the default value. schema Text No Schema applied to calculate the rating. isListed Boolean No Flag unsuitable content. False by default. If it's true, the content must not be returned. Example of Local Metadata \u00b6 { \"main\" : { \"name\" : \"Madrid Weather forecast\" , \"dateCreated\" : \"2019-05-16T12:36:14.535Z\" , \"author\" : \"Norwegian Meteorological Institute\" , \"type\" : \"dataset\" , \"license\" : \"Public Domain\" , \"price\" : \"123000000000000000000\" , \"files\" : [ { \"index\" : 0 , \"url\" : \"https://example-url.net/weather/forecast/madrid/350750305731.xml\" , \"contentLength\" : \"0\" , \"contentType\" : \"text/xml\" , \"compression\" : \"none\" } ] }, \"additionalInformation\" :{ \"description\" : \"Weather forecast of Europe/Madrid in XML format\" , \"copyrightHolder\" : \"Norwegian Meteorological Institute\" , \"categories\" : [ \"Other\" ], \"links\" : [], \"tags\" : [], \"updateFrequency\" : null , \"structuredMarkup\" : [] } } Example of Remote Metadata \u00b6 Similarly, this is how the metadata file would look as a response to querying Metadata API (remote metadata). Note that url is removed from all objects in the files array, and encryptedFiles & curation are added. { \"service\" : [ { \"index\" : 0 , \"serviceEndpoint\" : \"http://metadata:5000/api/v1/metadata/assets/ddo/{did}\" , \"immutableServiceEndpoint\" : \"cid://QmVT3wfySvZJqAvkBCyxoz3EvD3yeLqf3cvAssFDpFFXNm\" , \"type\" : \"metadata\" , \"attributes\" : { \"main\" : { \"type\" : \"dataset\" , \"name\" : \"Madrid Weather forecast\" , \"dateCreated\" : \"2019-05-16T12:36:14.535Z\" , \"author\" : \"Norwegian Meteorological Institute\" , \"license\" : \"Public Domain\" , \"price\" : \"123000000000000000000\" , \"files\" :[ { \"contentLength\" : \"0\" , \"contentType\" : \"text/xml\" , \"compression\" : \"none\" , \"index\" : 0 } ], \"datePublished\" : \"2019-05-16T12:41:01Z\" }, \"encryptedFiles\" : \"0x7a0d1c66ae861\u2026df43aa9\" , \"curation\" :{ \"rating\" : 1 , \"numVotes\" : 7 , \"schema\" : \"BINARY\" , \"isListed\" : true }, \"additionalInformation\" : { \"description\" : \"Weather forecast of Europe/Madrid in XML format\" , \"copyrightHolder\" : \"Norwegian Meteorological Institute\" , \"categories\" : [ \"Other\" ], \"links\" : [], \"tags\" : [], \"updateFrequency\" : null , \"structuredMarkup\" : [] } } } ] } Specific attributes per asset type \u00b6 Depending on the asset type (dataset, algorithm), there are different metadata attributes supported: Algorithm attributes \u00b6 An asset of type algorithm has the following additional attributes under main.algorithm : Attribute Type Required Description language string no Language used to implement the software format string no Packaging format of the software. version string no Version of the software. container Object yes Object describing the Docker container image. The container object has the following attributes: Attribute Type Required Description entrypoint string yes The command to execute, or script to run inside the Docker image. image string yes Name of the Docker image. tag string yes Tag of the Docker image. { \"index\" : 0 , \"serviceEndpoint\" : \"http://localhost:5000/api/v1/metadata/assets/ddo/{did}\" , \"immutableServiceEndpoint\" : \"cid://QmVT3wfySvZJqAvkBCyxoz3EvD3yeLqf3cvAssFDpFFXNm\" , \"type\" : \"metadata\" , \"attributes\" : { \"main\" : { \"author\" : \"John Doe\" , \"dateCreated\" : \"2019-02-08T08:13:49Z\" , \"license\" : \"CC-BY\" , \"name\" : \"My super algorithm\" , \"price\" : \"1\" , \"type\" : \"algorithm\" , \"algorithm\" : { \"language\" : \"scala\" , \"format\" : \"docker-image\" , \"version\" : \"0.1\" , \"container\" : { \"entrypoint\" : \"node $ALGO\" , \"image\" : \"node\" , \"tag\" : \"10\" } }, \"files\" : [ { \"name\" : \"build_model\" , \"url\" : \"https://raw.githubusercontent.com/keyko-io/test-algorithm/master/javascript/algo.js\" , \"index\" : 0 , \"checksum\" : \"efb2c764274b745f5fc37f97c6b0e761\" , \"contentLength\" : \"4535431\" , \"contentType\" : \"text/plain\" , \"encoding\" : \"UTF-8\" , \"compression\" : \"zip\" } ] }, \"additionalInformation\" : { \"description\" : \"Workflow to aggregate weather information\" , \"tags\" : [ \"weather\" , \"uk\" , \"2011\" , \"workflow\" , \"aggregation\" ], \"copyrightHolder\" : \"John Doe\" } } } References \u00b6 Schema.org is a collaborative, community activity with a mission to create, maintain, and promote schemas for structured data on the Internet. Data types use the Schema.org primitive data types . Schema.org: DataSet Schema.org: FileSize Common license types for datasets","title":"Metadata"},{"location":"architecture/specs/metadata/#meta-spec-metadata-ontology","text":"shortname: META name: Metadata Ontology type: Standard status: Valid version: 0.2 editor: Aitor Argomaniz <aitor@nevermined.io> contributors: META SPEC: Metadata Ontology Motivation Life Cycle of Metadata Local Metadata Remote Metadata Metadata Attributes Main Attributes File Attributes Additional Attributes Other Suggested Additional Attributes Curation Attributes Example of Local Metadata Example of Remote Metadata Specific attributes per asset type Algorithm attributes References","title":"META SPEC: Metadata Ontology"},{"location":"architecture/specs/metadata/#motivation","text":"Every asset (dataset, algorithm) in Nevermined has an associated Decentralized Identifier (DID) and DID document / DID Descriptor Object (DDO). Because assets without proper descriptive metadata have poor visibility and discoverability. See DID SPEC for information about the overall structure of Nevermined DDOs and DIDs.This OEP is about one particular part of Nevermined DDOs: the asset metadata, a JSON object with information about the asset. This SPEC defines the assets metadata ontology, i.e. the schema for the asset metadata. It's based on the public schema.org DataSet schema . This SPEC doesn't detail the exact method of registering assets on-chain or storing DDOs. The main motivations of this SPEC are to: Specify the common attributes that MUST be included in any asset metadata stored in Nevermined networks Normalize the attributes to use in any curation process, to provide a common structure to sort and filter the DDOs Identify the recommended additional attributes that SHOULD be included in a DDO to facilitate asset search Provide an example of an asset metadata object and additional links for reference","title":"Motivation"},{"location":"architecture/specs/metadata/#life-cycle-of-metadata","text":"","title":"Life Cycle of Metadata"},{"location":"architecture/specs/metadata/#local-metadata","text":"Metadata is first created by the publisher of the asset. The publisher has knowledge of the file URLs, and they are stored in plaintext in the files object. This initial metadata is the local metadata .","title":"Local Metadata"},{"location":"architecture/specs/metadata/#remote-metadata","text":"A publisher publishes (registers) an asset using Nevermined SDKs, which might be running on their local machine or remotely. When they do, the local metadata is passed to the SDK, which makes some changes and additions in the metadata, puts it into a DDO, and sends that DDO to a metadata API. The Metadata API may also make some changes and additions to the metadata, such as the datePublished or parts of the curation object. The metadata that finally gets stored by the Metadata API is the remote metadata . A marketplace can and might also act as a publisher. SPEC ACCESS describes the publishing flow in more detail.","title":"Remote Metadata"},{"location":"architecture/specs/metadata/#metadata-attributes","text":"An asset is the representation of different type of resources in Nevermined. Typically can asset could be one of the following asset types: Dataset . An asset representing a dataset or data resource. It could be for example a CSV file or a multiple JPG files. Algorithm . An asset representing a piece of software. It could be a python script using tensorflow, a spark job, etc. Each kind of asset require a different subset of metadata attributes. The distinction between the type of asset (dataset, algorithm) is given by the attribute DDO.services[\"metadata\"].main.type A metadata object has the following attributes, all of which are objects. Attribute Required Description main Yes Main attributes used to calculate the service checksum curation (remote) Curation attributes additionalInformation No Optional attributes encryptedFiles (remote) Encrypted string of the attributes.main.files object. encryptedServices (remote) Encrypted string of the attributes.main.services object. The main , curation and additionalInformation attributes are independent of the asset type, all assets have those metadata sections.","title":"Metadata Attributes"},{"location":"architecture/specs/metadata/#main-attributes","text":"This list of attributes can't be modified after creation , because these are considered as the metadata essence of the asset created. This information is used to calculate the unique checksum of the asset. If any change would be necessary in the following attributes, it would be necessary to create a new asset derived from the existing one. The main object has the following attributes, not all are required. Some are required by only the metadata store ( remote ) and others are mandatory for local metadata only. If required or not by both, they are marked with Yes/No in the Required column. Attribute Type Required Description name Text Yes Descriptive name or title of the asset. type Text Yes Type of the asset. Helps to filter by the type of asset. It could be for example (\"dataset\", \"algorithm\"). dateCreated DateTime Yes The date on which the asset was created by the originator. ISO 8601 format, Coordinated Universal Time, e.g. 2019-01-31T08:38:32Z . datePublished DateTime (remote) The date on which the asset DDO is registered into the metadata store (Metadata API) author Text Yes Name of the entity generating this data (e.g. Tfl, Disney Corp, etc.). license Text Yes Short name referencing the license of the asset (e.g. Public Domain, CC-0, CC-BY, No License Specified, etc. ). If it's not specified, the following value will be added: \"No License Specified\". price String Yes Price of the asset. It must be an integer encoded as a string, e.g. \"123000000000000000000\" . files Array of files object Yes Array of File objects including the encrypted file urls. Further metadata about each file is stored, see File Attributes","title":"Main Attributes"},{"location":"architecture/specs/metadata/#file-attributes","text":"File attributes are a subset of the main section. A file object has the following attributes, with the details necessary to consume and validate the data. Attribute Required Description url (local) Content URL. Omitted from the remote metadata. Supports http(s):// and ipfs:// URLs. name no File name. index yes Index number starting from 0 of the file. contentType yes File format. checksum no Checksum of the file using your preferred format (i.e. MD5). Format specified in checksumType . If it's not provided can't be validated if the file was not modified after registering. checksumType no Format of the provided checksum. Can vary according to server (i.e Amazon vs. Azure) contentLength no Size of the file in bytes. encoding no File encoding (e.g. UTF-8). compression no File compression (e.g. no, gzip, bzip2, etc). encrypted no Boolean. Is the file encrypted? If is not set is assumed the file is not encrypted encryptionMode no Encryption mode used. Just valid if encrypted=true resourceId no Remote identifier of the file in the external provider. It is typically the remote id in the cloud provider. attributes no Key-Value hash map with additional attributes describing the asset file. It could include details like the Amazon S3 bucket, region, etc.","title":"File Attributes"},{"location":"architecture/specs/metadata/#additional-attributes","text":"All the additional information will be stored as part of the additionalInformation section. Attribute Type Required categories Array of Text No tags Array of Text No description Text No copyrightHolder Text No workExample Text No links Array of Link No inLanguage Text No","title":"Additional Attributes"},{"location":"architecture/specs/metadata/#other-suggested-additional-attributes","text":"These are examples of attributes that can enhance the discoverability of a resource: Attribute Description sla Service Level Agreement. industry updateFrequency An indication of update latency - i.e. How often are updates expected (seldom, annually, quarterly, etc.), or is the resource static that is never expected to get updated. termsOfService privacy keyword A list of keywords/tags describing a dataset. structuredMarkup A link to machine-readable structured markup (such as ttl/json-ld/rdf) describing the dataset. The publisher of a DDO MAY add additional attributes or change the above object definition.","title":"Other Suggested Additional Attributes"},{"location":"architecture/specs/metadata/#curation-attributes","text":"A curation object has the following attributes. Attribute Type Required Description rating Number (decimal) Yes Decimal value between 0 and 1. 0 is the default value. numVotes Integer Yes Number of votes. 0 is the default value. schema Text No Schema applied to calculate the rating. isListed Boolean No Flag unsuitable content. False by default. If it's true, the content must not be returned.","title":"Curation Attributes"},{"location":"architecture/specs/metadata/#example-of-local-metadata","text":"{ \"main\" : { \"name\" : \"Madrid Weather forecast\" , \"dateCreated\" : \"2019-05-16T12:36:14.535Z\" , \"author\" : \"Norwegian Meteorological Institute\" , \"type\" : \"dataset\" , \"license\" : \"Public Domain\" , \"price\" : \"123000000000000000000\" , \"files\" : [ { \"index\" : 0 , \"url\" : \"https://example-url.net/weather/forecast/madrid/350750305731.xml\" , \"contentLength\" : \"0\" , \"contentType\" : \"text/xml\" , \"compression\" : \"none\" } ] }, \"additionalInformation\" :{ \"description\" : \"Weather forecast of Europe/Madrid in XML format\" , \"copyrightHolder\" : \"Norwegian Meteorological Institute\" , \"categories\" : [ \"Other\" ], \"links\" : [], \"tags\" : [], \"updateFrequency\" : null , \"structuredMarkup\" : [] } }","title":"Example of Local Metadata"},{"location":"architecture/specs/metadata/#example-of-remote-metadata","text":"Similarly, this is how the metadata file would look as a response to querying Metadata API (remote metadata). Note that url is removed from all objects in the files array, and encryptedFiles & curation are added. { \"service\" : [ { \"index\" : 0 , \"serviceEndpoint\" : \"http://metadata:5000/api/v1/metadata/assets/ddo/{did}\" , \"immutableServiceEndpoint\" : \"cid://QmVT3wfySvZJqAvkBCyxoz3EvD3yeLqf3cvAssFDpFFXNm\" , \"type\" : \"metadata\" , \"attributes\" : { \"main\" : { \"type\" : \"dataset\" , \"name\" : \"Madrid Weather forecast\" , \"dateCreated\" : \"2019-05-16T12:36:14.535Z\" , \"author\" : \"Norwegian Meteorological Institute\" , \"license\" : \"Public Domain\" , \"price\" : \"123000000000000000000\" , \"files\" :[ { \"contentLength\" : \"0\" , \"contentType\" : \"text/xml\" , \"compression\" : \"none\" , \"index\" : 0 } ], \"datePublished\" : \"2019-05-16T12:41:01Z\" }, \"encryptedFiles\" : \"0x7a0d1c66ae861\u2026df43aa9\" , \"curation\" :{ \"rating\" : 1 , \"numVotes\" : 7 , \"schema\" : \"BINARY\" , \"isListed\" : true }, \"additionalInformation\" : { \"description\" : \"Weather forecast of Europe/Madrid in XML format\" , \"copyrightHolder\" : \"Norwegian Meteorological Institute\" , \"categories\" : [ \"Other\" ], \"links\" : [], \"tags\" : [], \"updateFrequency\" : null , \"structuredMarkup\" : [] } } } ] }","title":"Example of Remote Metadata"},{"location":"architecture/specs/metadata/#specific-attributes-per-asset-type","text":"Depending on the asset type (dataset, algorithm), there are different metadata attributes supported:","title":"Specific attributes per asset type"},{"location":"architecture/specs/metadata/#algorithm-attributes","text":"An asset of type algorithm has the following additional attributes under main.algorithm : Attribute Type Required Description language string no Language used to implement the software format string no Packaging format of the software. version string no Version of the software. container Object yes Object describing the Docker container image. The container object has the following attributes: Attribute Type Required Description entrypoint string yes The command to execute, or script to run inside the Docker image. image string yes Name of the Docker image. tag string yes Tag of the Docker image. { \"index\" : 0 , \"serviceEndpoint\" : \"http://localhost:5000/api/v1/metadata/assets/ddo/{did}\" , \"immutableServiceEndpoint\" : \"cid://QmVT3wfySvZJqAvkBCyxoz3EvD3yeLqf3cvAssFDpFFXNm\" , \"type\" : \"metadata\" , \"attributes\" : { \"main\" : { \"author\" : \"John Doe\" , \"dateCreated\" : \"2019-02-08T08:13:49Z\" , \"license\" : \"CC-BY\" , \"name\" : \"My super algorithm\" , \"price\" : \"1\" , \"type\" : \"algorithm\" , \"algorithm\" : { \"language\" : \"scala\" , \"format\" : \"docker-image\" , \"version\" : \"0.1\" , \"container\" : { \"entrypoint\" : \"node $ALGO\" , \"image\" : \"node\" , \"tag\" : \"10\" } }, \"files\" : [ { \"name\" : \"build_model\" , \"url\" : \"https://raw.githubusercontent.com/keyko-io/test-algorithm/master/javascript/algo.js\" , \"index\" : 0 , \"checksum\" : \"efb2c764274b745f5fc37f97c6b0e761\" , \"contentLength\" : \"4535431\" , \"contentType\" : \"text/plain\" , \"encoding\" : \"UTF-8\" , \"compression\" : \"zip\" } ] }, \"additionalInformation\" : { \"description\" : \"Workflow to aggregate weather information\" , \"tags\" : [ \"weather\" , \"uk\" , \"2011\" , \"workflow\" , \"aggregation\" ], \"copyrightHolder\" : \"John Doe\" } } }","title":"Algorithm attributes"},{"location":"architecture/specs/metadata/#references","text":"Schema.org is a collaborative, community activity with a mission to create, maintain, and promote schemas for structured data on the Internet. Data types use the Schema.org primitive data types . Schema.org: DataSet Schema.org: FileSize Common license types for datasets","title":"References"},{"location":"architecture/specs/nft/","text":"NFT SPEC: Non-Fungible Tokens Engine \u00b6 shortname: NFT name: Non-Fungible Tokens Engine type: Standard status: Draft version: 0.2 editor: Aitor Argomaniz <aitor@nevermined.io> contributors: Rodolphe Marques <rod@nevermined.io> Table of Contents \u00b6 NFT SPEC: Non Fungible Tokens Engine Motivation Use Case Publisher Consumer Facilitator Concepts Building Blocks NFT Specs Architecture NFTs Principles ERC-721 and ERC-1155 Implementation Flows Publishing an Asset tokenized via NFTs Purchase and usage of a NFT Templates Template for selling a tokenized asset via NFTs Access to contents holding a NFT Template for selling an Asset Using NFTs based on ERC-721 or ERC-1155 Provenance Links This SPEC introduces Non-Fungible Tokens (NFTs) as part of Nevermined architecture allowing the tokenization of assets, sales with secondary market royalties support and exclusive access to NFT holders. This specification and the implementation allow the asset tokenization via ERC-721 and ERC-1155 standards. Motivation \u00b6 With this Specification we want to add to Nevermined the technical capabilities allowing the users to have a platform where digital and physical assets can be represented and traded between people openly, but keeping security, integrity, provenance and content creator's attribution. With that objective in mind, Nevermined must facilitate the execution of use cases like the following: Art publishing, exhibition, selling. Secondary market Collection of objects Tokenization of digital and physical assets (real estate, etc.) etc The intention of this document is to discuss how a fully functional NFT engine can be established in a decentralized system, to allow the support of complex use cases related with assets tokenization. The main objectives of this SPEC are: Understand the main use cases we can to implement Understand how assets can be tokenized using NFTs Understand how asset and NFTs sales can be established between creators, owners and consumers Identify how NFTs rely in some other Nevermined building blocks Specify how NFTs associated to assets (DIDs) can be minted and burner Allow the definition of royalties that enable the retribution of original creators in the secondary market Specify how NFT holders can get access to existing services Understand what provenance information needs to be tracked Use Case \u00b6 The following use case helps to understand the scope of the problem driving the technical implementation to put in place. For this use case we have to take into account the following target users: Publishers (an artist for example) Consumers (a collector) Facilitators (an art gallery for example) Publisher \u00b6 As a Publisher : I want to register digitally an asset I want to associate some metadata information to the assets I register I want to show my track record as publisher (bio, what I created, what I sold, etc.) I want to sell a digital representation of an asset for some price I want to limit the number of copies of an asset for sale I want to be rewarded via royalties in the secondary market for further sales I want to be able to delegate or loan some of my assets to a Facilitator user (gallery, etc.) Consumer \u00b6 As a Consumer : I want to discover relevant assets filtering by multiple parameters I appreciate curated assets avoiding me to waste time searching for high quality I want to see a digital representation of an asset and detailed information of it I want to check the ownership of an asset and full provenance record I want to see how many pieces of an specific assets were created I want to purchase an asset or part of an asset series I want to see and share my list of purchased assets I want to be able the sell any of my purchased assets to others Facilitator \u00b6 As a Facilitator : I want to explore all the assets existing in a the general market I want to invite publishers to expose in my space I want to to receive exhibition requests in my space and curate the assets and publishers to list I want to negotiate with publishers the conditions (sell commission) for listing in my space I want to maximize my sales online I want to provide my track record curating, selling, collecting and listing assets Concepts \u00b6 Building Blocks \u00b6 Nevermined is based in the following building blocks: Decentralized Identifiers (DID) - To identify items across on-chain and off-chain networks Access Control - To control who can do what and under what conditions Provenance - To track all the actions associated with every registered asset Tokenized Payment Gateway - To allow direct payment Integrity - To provide proof that everything is correct Identity Management - To allow to define fine access control policies On top of all of that, this Specification augments Nevermined with the support of Non-Fungible Tokens (NFTs). The main intention of this is to allow the tokenization, transfer, mint and burn of any existing asset published in a Nevermined ecosystem. In Nevermined, any registered asset is a DID registered via the DIDRegistry Smart Contract. This contract provides a generic way to represent the creation of a digital asset in a Nevermined ecosystem. This digital asset can be the representation of anything in the real world, a data set in a big data lake, a vaccine shipment in a supply chain process, an artwork in a virtual (or physical) gallery or anything else. The DIDRegistry tracks that registration in an immutable way, associating this digital asset with the creator of that representation in a Nevermined ecosystem. This Specification associates directly the standard NFT capabilities to any existing asset registered via the DIDRegistry . It allows without friction the possibility of tokenize via NFTs any existing DID. NFT Specs \u00b6 Nowadays the main standard for providing NFTs functionality in Ethereum networks is ERC-721. ERC-721 standard requires a separate contract to be deployed for each token type or collection. This places a lot of redundant bytecode on the Ethereum blockchain and limits certain functionality by the nature of separating each token contract into its own permissioned address. This means high cost, complexity, etc. Additionaly to ERC-721, ERC-1155 standard implements a multi-token factory allowing to register and tokenize multiple and independent assets in the same contract instance without multiple deployments. ERC-1155 design permits transferring multiple token types at once, saving on transaction costs.It is also easy to describe and mix multiple fungible or non-fungible token types in a single contract. Nevermined allows the utilization of ERC-721 and ERC-1155 standards for assets tokenization. Architecture \u00b6 NFTs Principles \u00b6 The NFTs engine is based in the following principles: Every asset has a Decentralized Identifier (aka DID) attached, and every DID as a identifier representing a digital entity can have associated multiple NFTs, allowing the tokenization of any kind of digital asset independently of the physical asset behind of it The user registering a DID can decide if he wants to enable or not the tokenization of the asset via NFTs When the tokenization is enabled for a specific asset, the user registering the asset can define a minting cap. This minting cap can not be changed afterward, because modifying the number of existing items of an asset will affect the further value of them for the NFTs holders. If the minting cap is set to zero, it means the DID minting is not capped. The user registering an asset can specify the royalties that are rewarding the original creator in the secondary market. These royalties must be between 0 and 100 percent. The royalties can not be changed after they are initialized. This protects the buyers of a NFT to have to pay for a different commission to the one agreed during the purchase of a NFT. The payment and transfer of NFTs must always respect the original creators attribution and rewards Users giving or selling NFTs can have a mechanism to facilitate exclusive services to NFT holders ERC-721 and ERC-1155 \u00b6 Different use cases can require the utilization of different NFT standards. Nevermined by default provides a Multi-token implementation based in ERC-1155. That means every asset registered into Nevermined, can be minted by the asset owner generating certain number of tokens attached to them. Internally, the DIDRegistry integrates with this multi-token implementation allowing full assets tokenization without further requirements. In addition to this, for asset owners with already deployed ERC-721 contracts, these external contracts can be integrated as part of the selling and accessing flows allowing the purchase of ERC-721 based NFTs and access to exclusive contents for the NFT holders. Implementation \u00b6 From a Smart Contracts point of view, the DIDRegistry now extends a new NFTUpgradeable smart contract. This new contract implements the ERC-1155 standard and it's based in OpenZeppelin implementation. With this change, when a new Asset is registered via the DIDRegistry, it can automatically mint , burn and transfer NFTs attached to the Asset. Example: await didRegistry . registerMintableDID ( didSeed , checksum , [], url , cappedAmount , royalties , constants . activities . GENERATED , '' ) await didRegistry . mint ( did , 5 ) await didRegistry . burn ( did , 1 ) await didRegistry . balanceOf ( someone , did ) The registerMintableDID is a new method that facilitates a couple new things for users registering assets who want to attach a NFT to them: They enable the NFT functionality for the asset registered. By default, the assets registered via the registerDID method do not have the NFTs functionality enabled. It setups a minting cap for the asset It specify the percentage of royalties (between 0 and 100) that the original creator of the Asset wants in the secondary market for a further sale. When a DID is registered via the traditional registerDID method, the same functionality can be obtained calling the enableAndMintDidNft method. Example: const did = await didRegistry . registerAttribute ( didSeed , checksum , [], url ) await didRegistry . enableAndMintDidNft ( did , 5 , 0 , true ) Flows \u00b6 Publishing an Asset tokenized via NFTs \u00b6 The publishing of an asset (with NFTs associated) involves: Filling and publishing the asset metadata and price The publisher defines the metadata in a DDO object, the number of NFTs to mint, their price and royalties in the secondary market. Association of unique Decentralized Identifiers (DID) and register on-chain The publisher register on-chain via DIDRegistry the new asset id (DID) Adding provenance event about content creation The Contracts track the provenance event of a new Asset registered The publisher initialize the NFT setup associated to the Asset Optionally defining the royalties to receive in further sales in the secondary market Optionally define the limited items of the serie. NFT minting for a DID can be capped The contract mint the NFTs associated to the asset (DID) limited serie All the NFTs minted are locked ready to be used in sales Publishing Flow Purchase and usage of a NFT \u00b6 The purchase of a NFT associated to an asset involves: The consumer discover an interesting asset with NFTs attached to it (offchain) via marketplace, catalog, gallery, etc. The consumer initialize a service agreement on-chain with the intention of purchase a NFT The consumer lock the funds required to purchase a NFT. In case the NFT is being sold by a user that is not the original asset creator, the price must include the original creator royalties The owner or a provider can trigger the TransferNFTCondition condition to approve the purchase and make the transfer of the NFT Anyone can call the new EscrowPayment condition. It will be in charge of: Distribute the rewards to the publisher or seller Distribute the royalties to the original creator (if is not seller itself) Using the existing NFTHolder condition it will be possible to the new NFT owner to get access to Nevermined services Publishing Flow Templates \u00b6 The Nevermined Service Execution Agreements provide standard scenarios for providing access and trigger remote computation. To complement those, this Spec detail 3 additional templates to support the following flows: NFT Sale. An asset owner tokenized an asset and sell one or many of the NFTs to a different user. NFT Access. A NFT holder can get access to exclusive contents for holding that NFT DID Sale. An asset owner wants to sell it totally. Template for selling a tokenized asset via NFTs \u00b6 The NFT Sales template supports a scenario where an Asset owner wants to tokenize an asset and sell pieces of it via NFTs. Owners buying a new NFT can sell them later to others in a secondary market. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing a NFT owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer NFT Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the transfer of the NFT from the current owner for a specific DID. The DID Sales template is provided by the NFTSalesTemplate Smart Contract. Access to contents holding a NFT \u00b6 The NFT Access template is a use case specific template that allows a NFT owner to get access to exclusive contents provided by the original asset creator associated to the NFT. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing NFT holders to get access to Nevermined services. NFT as Access Token The template is a composite of 2 basic conditions: NFT Holding Condition Access Condition Once the agreement is created, the consumer can demonstrate he is holding a NFT for a specific DID. If that's the case the Access condition can be fulfilled by the asset owner or provider and all the agreement is fulfilled. This can be used in scenarios where a data or services owner, can allow users to get access to exclusive services only when they demonstrate they are holding a specific number of NFTs of a DID. The DID Sales template is provided by the NFTAccessTemplate Smart Contract. Template for selling an Asset \u00b6 It supports a scenario where an Asset owner can sell that asset to a new Owner. It is important to say the ownership of the asset is transferred to a new owner but there is always a reference on-chain about the original creator of the asset. This original creator can't be changed and is used to reward later to this user in the secondary market. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing an Asset owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: Lock Payment Condition Transfer DID Condition Escrow Payment Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the ownership transfer of an asset from the current owner for a specific DID. The DID Sales template is provided by the DIDSalesTemplate Smart Contract. DID Sale. An asset owner can put this asset for sale for a price. This not only gives access to the asset, also transfers ownership to the buyer. Further sales reward the creator in the secondary market. NFT Sale. An asset owner tokenize an asset using NFTs and sell them to others for a price. Further sales reward the creator in the secondary market. NFT access. An asset owner can mint, sell and transfer NFTs associated to a DID. Further NFT holders can get access to contents showing the NFT they hold. Using NFTs based on ERC-721 or ERC-1155 \u00b6 For the NFT Sales and Access templates, there are different conditions that allow to specify the contract address to use (and by extension the NFT implementation). These conditions are: TransferNFT NFTHolder The hashValues and fulfill methods now require an additional _contractAddress parameter. This address is the address of the NFT Vault contract (the Nevermined DIDRegistry implementing ERC-1155, or an external ERC-721 or ERC-1155). In addition to this, if instead of a regular transfer a minting is required, the _nftTransfer parameter can be given. If true the service agreements will do regular transfers, if false they will mint new NFTs. Nevermined contract provide interfaces for these contracts and 2 different implementations of each for ERC-1155 & ERC-721. Using these different implementations, the templates can be initialized with addresses using the different standards and keeping at the same time all the logic on top of the contracts equal. Here you can find an example of the transferNFT DDO condition: { \"name\" : \"transferNFT\" , \"timelock\" : 0 , \"timeout\" : 0 , \"contractName\" : \"TransferNFT721Condition\" , \"functionName\" : \"fulfill\" , \"parameters\" : [{ \"name\" : \"_documentId\" , \"type\" : \"bytes32\" , \"value\" : \"f5eaf5a044d71dcdca6eb2a23c6a634c4f97a57dd71c89995f144adad5bb7354\" }, { \"name\" : \"_receiver\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_numberNfts\" , \"type\" : \"uint256\" , \"value\" : \"1\" }, { \"name\" : \"_conditionId\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_contractAddress\" , \"type\" : \"address\" , \"value\" : \"\" }], \"events\" : [{ \"name\" : \"Fulfilled\" , \"actorType\" : \"publisher\" , \"handler\" : { \"moduleName\" : \"transferNFT\" , \"functionName\" : \"fulfillEscrowPaymentCondition\" , \"version\" : \"0.1\" } } And here the whole example. Provenance \u00b6 All the actions associated with the usual tokenization flow provided by NFTs register on-chain the relevant provenance entries allowing to track all that happened related to an asset. When a new asset is created it registers the provenance entry wasGeneratedBy When the asset owner initialize the asset tokenization via NFTs it raise the used provenance entry When the asset owner mint a NFT associated to an asset it raise the used provenance entry When the asset owner burn a NFT associated to an asset it raise the used provenance entry Links \u00b6 The Multi Token Standard EIP-721: ERC-721 Non-Fungible Token Standard OpenZeppelin ERC1155 Smart Contract implementation OpenZeppelin ERC721 Smart Contract implementation","title":"NFTs Engine"},{"location":"architecture/specs/nft/#nft-spec-non-fungible-tokens-engine","text":"shortname: NFT name: Non-Fungible Tokens Engine type: Standard status: Draft version: 0.2 editor: Aitor Argomaniz <aitor@nevermined.io> contributors: Rodolphe Marques <rod@nevermined.io>","title":"NFT SPEC: Non-Fungible Tokens Engine"},{"location":"architecture/specs/nft/#table-of-contents","text":"NFT SPEC: Non Fungible Tokens Engine Motivation Use Case Publisher Consumer Facilitator Concepts Building Blocks NFT Specs Architecture NFTs Principles ERC-721 and ERC-1155 Implementation Flows Publishing an Asset tokenized via NFTs Purchase and usage of a NFT Templates Template for selling a tokenized asset via NFTs Access to contents holding a NFT Template for selling an Asset Using NFTs based on ERC-721 or ERC-1155 Provenance Links This SPEC introduces Non-Fungible Tokens (NFTs) as part of Nevermined architecture allowing the tokenization of assets, sales with secondary market royalties support and exclusive access to NFT holders. This specification and the implementation allow the asset tokenization via ERC-721 and ERC-1155 standards.","title":"Table of Contents"},{"location":"architecture/specs/nft/#motivation","text":"With this Specification we want to add to Nevermined the technical capabilities allowing the users to have a platform where digital and physical assets can be represented and traded between people openly, but keeping security, integrity, provenance and content creator's attribution. With that objective in mind, Nevermined must facilitate the execution of use cases like the following: Art publishing, exhibition, selling. Secondary market Collection of objects Tokenization of digital and physical assets (real estate, etc.) etc The intention of this document is to discuss how a fully functional NFT engine can be established in a decentralized system, to allow the support of complex use cases related with assets tokenization. The main objectives of this SPEC are: Understand the main use cases we can to implement Understand how assets can be tokenized using NFTs Understand how asset and NFTs sales can be established between creators, owners and consumers Identify how NFTs rely in some other Nevermined building blocks Specify how NFTs associated to assets (DIDs) can be minted and burner Allow the definition of royalties that enable the retribution of original creators in the secondary market Specify how NFT holders can get access to existing services Understand what provenance information needs to be tracked","title":"Motivation"},{"location":"architecture/specs/nft/#use-case","text":"The following use case helps to understand the scope of the problem driving the technical implementation to put in place. For this use case we have to take into account the following target users: Publishers (an artist for example) Consumers (a collector) Facilitators (an art gallery for example)","title":"Use Case"},{"location":"architecture/specs/nft/#publisher","text":"As a Publisher : I want to register digitally an asset I want to associate some metadata information to the assets I register I want to show my track record as publisher (bio, what I created, what I sold, etc.) I want to sell a digital representation of an asset for some price I want to limit the number of copies of an asset for sale I want to be rewarded via royalties in the secondary market for further sales I want to be able to delegate or loan some of my assets to a Facilitator user (gallery, etc.)","title":"Publisher"},{"location":"architecture/specs/nft/#consumer","text":"As a Consumer : I want to discover relevant assets filtering by multiple parameters I appreciate curated assets avoiding me to waste time searching for high quality I want to see a digital representation of an asset and detailed information of it I want to check the ownership of an asset and full provenance record I want to see how many pieces of an specific assets were created I want to purchase an asset or part of an asset series I want to see and share my list of purchased assets I want to be able the sell any of my purchased assets to others","title":"Consumer"},{"location":"architecture/specs/nft/#facilitator","text":"As a Facilitator : I want to explore all the assets existing in a the general market I want to invite publishers to expose in my space I want to to receive exhibition requests in my space and curate the assets and publishers to list I want to negotiate with publishers the conditions (sell commission) for listing in my space I want to maximize my sales online I want to provide my track record curating, selling, collecting and listing assets","title":"Facilitator"},{"location":"architecture/specs/nft/#concepts","text":"","title":"Concepts"},{"location":"architecture/specs/nft/#building-blocks","text":"Nevermined is based in the following building blocks: Decentralized Identifiers (DID) - To identify items across on-chain and off-chain networks Access Control - To control who can do what and under what conditions Provenance - To track all the actions associated with every registered asset Tokenized Payment Gateway - To allow direct payment Integrity - To provide proof that everything is correct Identity Management - To allow to define fine access control policies On top of all of that, this Specification augments Nevermined with the support of Non-Fungible Tokens (NFTs). The main intention of this is to allow the tokenization, transfer, mint and burn of any existing asset published in a Nevermined ecosystem. In Nevermined, any registered asset is a DID registered via the DIDRegistry Smart Contract. This contract provides a generic way to represent the creation of a digital asset in a Nevermined ecosystem. This digital asset can be the representation of anything in the real world, a data set in a big data lake, a vaccine shipment in a supply chain process, an artwork in a virtual (or physical) gallery or anything else. The DIDRegistry tracks that registration in an immutable way, associating this digital asset with the creator of that representation in a Nevermined ecosystem. This Specification associates directly the standard NFT capabilities to any existing asset registered via the DIDRegistry . It allows without friction the possibility of tokenize via NFTs any existing DID.","title":"Building Blocks"},{"location":"architecture/specs/nft/#nft-specs","text":"Nowadays the main standard for providing NFTs functionality in Ethereum networks is ERC-721. ERC-721 standard requires a separate contract to be deployed for each token type or collection. This places a lot of redundant bytecode on the Ethereum blockchain and limits certain functionality by the nature of separating each token contract into its own permissioned address. This means high cost, complexity, etc. Additionaly to ERC-721, ERC-1155 standard implements a multi-token factory allowing to register and tokenize multiple and independent assets in the same contract instance without multiple deployments. ERC-1155 design permits transferring multiple token types at once, saving on transaction costs.It is also easy to describe and mix multiple fungible or non-fungible token types in a single contract. Nevermined allows the utilization of ERC-721 and ERC-1155 standards for assets tokenization.","title":"NFT Specs"},{"location":"architecture/specs/nft/#architecture","text":"","title":"Architecture"},{"location":"architecture/specs/nft/#nfts-principles","text":"The NFTs engine is based in the following principles: Every asset has a Decentralized Identifier (aka DID) attached, and every DID as a identifier representing a digital entity can have associated multiple NFTs, allowing the tokenization of any kind of digital asset independently of the physical asset behind of it The user registering a DID can decide if he wants to enable or not the tokenization of the asset via NFTs When the tokenization is enabled for a specific asset, the user registering the asset can define a minting cap. This minting cap can not be changed afterward, because modifying the number of existing items of an asset will affect the further value of them for the NFTs holders. If the minting cap is set to zero, it means the DID minting is not capped. The user registering an asset can specify the royalties that are rewarding the original creator in the secondary market. These royalties must be between 0 and 100 percent. The royalties can not be changed after they are initialized. This protects the buyers of a NFT to have to pay for a different commission to the one agreed during the purchase of a NFT. The payment and transfer of NFTs must always respect the original creators attribution and rewards Users giving or selling NFTs can have a mechanism to facilitate exclusive services to NFT holders","title":"NFTs Principles"},{"location":"architecture/specs/nft/#erc-721-and-erc-1155","text":"Different use cases can require the utilization of different NFT standards. Nevermined by default provides a Multi-token implementation based in ERC-1155. That means every asset registered into Nevermined, can be minted by the asset owner generating certain number of tokens attached to them. Internally, the DIDRegistry integrates with this multi-token implementation allowing full assets tokenization without further requirements. In addition to this, for asset owners with already deployed ERC-721 contracts, these external contracts can be integrated as part of the selling and accessing flows allowing the purchase of ERC-721 based NFTs and access to exclusive contents for the NFT holders.","title":"ERC-721 and ERC-1155"},{"location":"architecture/specs/nft/#implementation","text":"From a Smart Contracts point of view, the DIDRegistry now extends a new NFTUpgradeable smart contract. This new contract implements the ERC-1155 standard and it's based in OpenZeppelin implementation. With this change, when a new Asset is registered via the DIDRegistry, it can automatically mint , burn and transfer NFTs attached to the Asset. Example: await didRegistry . registerMintableDID ( didSeed , checksum , [], url , cappedAmount , royalties , constants . activities . GENERATED , '' ) await didRegistry . mint ( did , 5 ) await didRegistry . burn ( did , 1 ) await didRegistry . balanceOf ( someone , did ) The registerMintableDID is a new method that facilitates a couple new things for users registering assets who want to attach a NFT to them: They enable the NFT functionality for the asset registered. By default, the assets registered via the registerDID method do not have the NFTs functionality enabled. It setups a minting cap for the asset It specify the percentage of royalties (between 0 and 100) that the original creator of the Asset wants in the secondary market for a further sale. When a DID is registered via the traditional registerDID method, the same functionality can be obtained calling the enableAndMintDidNft method. Example: const did = await didRegistry . registerAttribute ( didSeed , checksum , [], url ) await didRegistry . enableAndMintDidNft ( did , 5 , 0 , true )","title":"Implementation"},{"location":"architecture/specs/nft/#flows","text":"","title":"Flows"},{"location":"architecture/specs/nft/#publishing-an-asset-tokenized-via-nfts","text":"The publishing of an asset (with NFTs associated) involves: Filling and publishing the asset metadata and price The publisher defines the metadata in a DDO object, the number of NFTs to mint, their price and royalties in the secondary market. Association of unique Decentralized Identifiers (DID) and register on-chain The publisher register on-chain via DIDRegistry the new asset id (DID) Adding provenance event about content creation The Contracts track the provenance event of a new Asset registered The publisher initialize the NFT setup associated to the Asset Optionally defining the royalties to receive in further sales in the secondary market Optionally define the limited items of the serie. NFT minting for a DID can be capped The contract mint the NFTs associated to the asset (DID) limited serie All the NFTs minted are locked ready to be used in sales Publishing Flow","title":"Publishing an Asset tokenized via NFTs"},{"location":"architecture/specs/nft/#purchase-and-usage-of-a-nft","text":"The purchase of a NFT associated to an asset involves: The consumer discover an interesting asset with NFTs attached to it (offchain) via marketplace, catalog, gallery, etc. The consumer initialize a service agreement on-chain with the intention of purchase a NFT The consumer lock the funds required to purchase a NFT. In case the NFT is being sold by a user that is not the original asset creator, the price must include the original creator royalties The owner or a provider can trigger the TransferNFTCondition condition to approve the purchase and make the transfer of the NFT Anyone can call the new EscrowPayment condition. It will be in charge of: Distribute the rewards to the publisher or seller Distribute the royalties to the original creator (if is not seller itself) Using the existing NFTHolder condition it will be possible to the new NFT owner to get access to Nevermined services Publishing Flow","title":"Purchase and usage of a NFT"},{"location":"architecture/specs/nft/#templates","text":"The Nevermined Service Execution Agreements provide standard scenarios for providing access and trigger remote computation. To complement those, this Spec detail 3 additional templates to support the following flows: NFT Sale. An asset owner tokenized an asset and sell one or many of the NFTs to a different user. NFT Access. A NFT holder can get access to exclusive contents for holding that NFT DID Sale. An asset owner wants to sell it totally.","title":"Templates"},{"location":"architecture/specs/nft/#template-for-selling-a-tokenized-asset-via-nfts","text":"The NFT Sales template supports a scenario where an Asset owner wants to tokenize an asset and sell pieces of it via NFTs. Owners buying a new NFT can sell them later to others in a secondary market. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing a NFT owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: - Lock Payment Condition - Transfer NFT Condition - Escrow Reward Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the transfer of the NFT from the current owner for a specific DID. The DID Sales template is provided by the NFTSalesTemplate Smart Contract.","title":"Template for selling a tokenized asset via NFTs"},{"location":"architecture/specs/nft/#access-to-contents-holding-a-nft","text":"The NFT Access template is a use case specific template that allows a NFT owner to get access to exclusive contents provided by the original asset creator associated to the NFT. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing NFT holders to get access to Nevermined services. NFT as Access Token The template is a composite of 2 basic conditions: NFT Holding Condition Access Condition Once the agreement is created, the consumer can demonstrate he is holding a NFT for a specific DID. If that's the case the Access condition can be fulfilled by the asset owner or provider and all the agreement is fulfilled. This can be used in scenarios where a data or services owner, can allow users to get access to exclusive services only when they demonstrate they are holding a specific number of NFTs of a DID. The DID Sales template is provided by the NFTAccessTemplate Smart Contract.","title":"Access to contents holding a NFT"},{"location":"architecture/specs/nft/#template-for-selling-an-asset","text":"It supports a scenario where an Asset owner can sell that asset to a new Owner. It is important to say the ownership of the asset is transferred to a new owner but there is always a reference on-chain about the original creator of the asset. This original creator can't be changed and is used to reward later to this user in the secondary market. Anyone (consumer/provider/publisher) can use this template in order to setup an agreement allowing an Asset owner to transfer the asset ownership after some payment. The template is a composite of 3 basic conditions: Lock Payment Condition Transfer DID Condition Escrow Payment Condition This scenario takes into account royalties for original creators in the secondary market. Once the agreement is created, the consumer after payment can request the ownership transfer of an asset from the current owner for a specific DID. The DID Sales template is provided by the DIDSalesTemplate Smart Contract. DID Sale. An asset owner can put this asset for sale for a price. This not only gives access to the asset, also transfers ownership to the buyer. Further sales reward the creator in the secondary market. NFT Sale. An asset owner tokenize an asset using NFTs and sell them to others for a price. Further sales reward the creator in the secondary market. NFT access. An asset owner can mint, sell and transfer NFTs associated to a DID. Further NFT holders can get access to contents showing the NFT they hold.","title":"Template for selling an Asset"},{"location":"architecture/specs/nft/#using-nfts-based-on-erc-721-or-erc-1155","text":"For the NFT Sales and Access templates, there are different conditions that allow to specify the contract address to use (and by extension the NFT implementation). These conditions are: TransferNFT NFTHolder The hashValues and fulfill methods now require an additional _contractAddress parameter. This address is the address of the NFT Vault contract (the Nevermined DIDRegistry implementing ERC-1155, or an external ERC-721 or ERC-1155). In addition to this, if instead of a regular transfer a minting is required, the _nftTransfer parameter can be given. If true the service agreements will do regular transfers, if false they will mint new NFTs. Nevermined contract provide interfaces for these contracts and 2 different implementations of each for ERC-1155 & ERC-721. Using these different implementations, the templates can be initialized with addresses using the different standards and keeping at the same time all the logic on top of the contracts equal. Here you can find an example of the transferNFT DDO condition: { \"name\" : \"transferNFT\" , \"timelock\" : 0 , \"timeout\" : 0 , \"contractName\" : \"TransferNFT721Condition\" , \"functionName\" : \"fulfill\" , \"parameters\" : [{ \"name\" : \"_documentId\" , \"type\" : \"bytes32\" , \"value\" : \"f5eaf5a044d71dcdca6eb2a23c6a634c4f97a57dd71c89995f144adad5bb7354\" }, { \"name\" : \"_receiver\" , \"type\" : \"address\" , \"value\" : \"\" }, { \"name\" : \"_numberNfts\" , \"type\" : \"uint256\" , \"value\" : \"1\" }, { \"name\" : \"_conditionId\" , \"type\" : \"bytes32\" , \"value\" : \"\" }, { \"name\" : \"_contractAddress\" , \"type\" : \"address\" , \"value\" : \"\" }], \"events\" : [{ \"name\" : \"Fulfilled\" , \"actorType\" : \"publisher\" , \"handler\" : { \"moduleName\" : \"transferNFT\" , \"functionName\" : \"fulfillEscrowPaymentCondition\" , \"version\" : \"0.1\" } } And here the whole example.","title":"Using NFTs based on ERC-721 or ERC-1155"},{"location":"architecture/specs/nft/#provenance","text":"All the actions associated with the usual tokenization flow provided by NFTs register on-chain the relevant provenance entries allowing to track all that happened related to an asset. When a new asset is created it registers the provenance entry wasGeneratedBy When the asset owner initialize the asset tokenization via NFTs it raise the used provenance entry When the asset owner mint a NFT associated to an asset it raise the used provenance entry When the asset owner burn a NFT associated to an asset it raise the used provenance entry","title":"Provenance"},{"location":"architecture/specs/nft/#links","text":"The Multi Token Standard EIP-721: ERC-721 Non-Fungible Token Standard OpenZeppelin ERC1155 Smart Contract implementation OpenZeppelin ERC721 Smart Contract implementation","title":"Links"},{"location":"architecture/specs/provenance/","text":"PROV SPEC: Decentralized Data Provenance \u00b6 shortname: PROV name: Decentralized Data Provenance type: Standard status: Valid version: 0.2 editor: Aitor Argomaniz <aitor@nevermined.io> contributors: PROV SPEC: Decentralized Data Provenance Motivation Concepts Specifications Provenance Model Provenance Types Entities Agents Activities Provenance Relations Generation: Register a new entity generated by an agent (wasGeneratedBy) Derivation: register relationship between source and derived entities (wasDerivedFrom) Association (wasAssociatedWith) Delegation (actedOnBehalfOf) Usage (used) Activity: Register activities Examples Scenario Actors Flow Architecture Data Process Good Manufacturing Handover to Carrier Handover to the end recipient Registry Provenance Registry Metadata Registry Agents Registry Entities Registry Provenance metadata integrity How to compute the provenance checksum Links This SPEC introduces the concept of asset Data Provenance in Nevermined platform based on the W3C Provenance specification. Motivation \u00b6 The intention of this document is to discuss how data provenance can be established in a decentralized system, permitting integrity validation of this provenance information. The main objectives of this SPEC are: Understand what provenance information needs to be tracked Specify how the provenance integrity check is stored on-chain Identify the actors involved in the publishing and visualization of provenance information Detail how to register relationships between source and derived entities Detail how to register activities Understand how to associate activities with the input and output entities in a workflow Validate cryptographically that an entity was generated from a specific input entity in a specific activity Concepts \u00b6 Specifications \u00b6 Nevermined Data Provenance solution is designed based on the W3C Provenance specifications . In addition to this, Nevermined uses Decentralized Identifiers following the W3C DID specification . The design of Nevermined using both specifications is critical because it enables the construction of a complete and decentralized provenance solution where independent parties can collaborate in the common problem of delivering goods without relying on a central party, and providing transparency, complete traceability, efficiency and a unique source of truth. Provenance Model \u00b6 The W3C PROV specification defines Provenance as: Provenance is information about entities, activities, and people involved in producing a piece of data or thing, which can be used to form assessments about its quality, reliability or trustworthiness. The W3C PROV data model includes a core set of types and relations commonly found in provenance tracking for more specific uses. In particular, the data model includes both Type and Relation categories. Type category contains entity , activity and agent which are core components. Relations category defines key relationships between different types of components, which can be mapped into specific PROV model relations. PROV Mapping Provenance Types \u00b6 Provenance information can be modeled as the interaction between Agents and Entities related via the Activities between them: Entities \u00b6 In PROV, physical, digital, conceptual, or other kinds of things are called entities. Examples of such entities are assets, a web page, a chart, a spellchecker, etc. Agents \u00b6 An agent takes a role in an activity such that the agent can be assigned some degree of responsibility for the activity taking place. An agent can be a person, a piece of software, an inanimate object, an organization, or other entities that may be ascribed responsibility. Activities \u00b6 Activities are how entities come into existence and how their attributes change to become new entities, often making use of previously existing entities to achieve this. They are dynamic aspects of the world, such as actions, processes, etc. For example, if the second version of document D was generated by a translation from the first version of the document in another language, then this translation is an activity. PROV E-R Provenance Relations \u00b6 Relations between agents and entities are open but there are some common relations that can be used as reference: Generation: Register a new entity generated by an agent (wasGeneratedBy) \u00b6 Generation is the completion of production of a new entity by an activity. This entity did not exist before generation and becomes available for usage after this generation. Generation , written wasGeneratedBy(id; e, a, t, attrs) in PROV-N (a notation for provenance aimed at human consumption), has: id : an optional identifier for a generation; entity : an identifier (e) for a created entity. In Nevermined a DID ; activity : an optional identifier (a) for the activity that creates the entity. In Nevermined a DID ; time : an optional \"generation time\" (t), the time at which the entity was completely created; attributes : an optional set (attrs) of attribute-value pairs representing additional information about this generation. While each of id , activity , time , and attributes are optional, at least one of them must be present. PROV uses qualified names to identify things for data provenance, which is essentially a shortened representation of a URI in the form of prefix:localpart . Example: wasGeneratedBy(did:nv:e1, did:nv:a1, 2019-10-26T21:32:52) wasGeneratedBy(did:nv:e2, did:nv:a1, 2019-10-26T10:00:00) The above example shows the existence of two generations (with respective times 2019-10-26T21:32:52 and 2001-10-26T10:00:00), at which new entities, identified by did:nv:e1 and did:nv:e2 , were created by an activity, identified by did:nv:a1 . Derivation: register relationship between source and derived entities (wasDerivedFrom) \u00b6 Derivation is a transformation of an entity into another, an update of an entity resulting in a new one, or the construction of a new entity based on a pre-existing entity. A derivation , written wasDerivedFrom(id; e2, e1, a, g2, u1, attrs) in PROV-N, has: id : an optional identifier for a derivation; generatedEntity : the identifier (e2) of the derived entity generated by the derivation. In Nevermined a DID ; usedEntity : the identifier (e1) of the source entity used by the derivation. In Nevermined a DID ; activity : an optional identifier (a) for the activity using and generating the above entities. In Nevermined a DID ; generation : an optional identifier (g2) for the generation involving the generated entity (e2) and activity (a). In Nevermined a DID ; usage : an optional identifier (u1) for the usage involving the used entity (e1) and activity (a). In Nevermined a DID ; attributes : an optional set (attrs) of attribute-value pairs representing additional information about this derivation. The following descriptions are about derivations between did:nv:e1 and did:nv:e2 , but no information is provided as to the identity of the activity (and usage and generation) underpinning the derivation. In the second line, a type attribute is also provided. wasDerivedFrom(did:nv:e2, did:nv:e1) wasDerivedFrom(did:nv:e2, did:nv:e1, [ prov:type=\"physical transform\" ]) The following description expresses that activity did:nv:a , using the entity did:nv:e1 according to usage did:nv:01 , derived the entity did:nv:e2 and generated it according to generation did:nv:02 . It is followed by descriptions for generation did:nv:02 and usage did:nv:01 . wasDerivedFrom(did:nv:e2, did:nv:e1, did:nv:a, did:nv:02, did:nv:01) wasGeneratedBy(did:nv:02; did:nv:e2, did:nv:a, -) used(did:nv:01; did:nv:a, did:nv:e1, -) With such a comprehensive description of derivation, a program that analyzes provenance can identify the activity underpinning the derivation, it can identify how the preceding entity did:nv:e1 was used by the activity (e.g. for instance, which argument it was passed, if the activity is the result of a function invocation), and which output the derived entity did:nv:e2 was obtained from (say, for a function returning multiple results). Association (wasAssociatedWith) \u00b6 Association is an assignment of responsibility to an agent for an activity, indicating that the agent had a role in the activity. An association, written wasAssociatedWith(id; a, ag, pl, attrs) in PROV-N, has: id : an optional identifier for the association between an activity and an agent; activity : an identifier (a) for the activity; agent : an optional identifier (ag) for the agent associated with the activity; plan : an optional identifier (pl) for the plan the agent relied on in the context of this activity; attributes : an optional set (attrs) of attribute-value pairs representing additional information about this association of this activity with this agent. The following examples are about the association between one activity did:nv:ac1 and one agent did:nv:a00 . In the second example, a type attribute is also provided. wasAssociatedWith(did:nv:ac1, did:nv:a00) wasAssociatedWith(did:nv:ac1, did:nv:a00, [ prov:type=\"manufacturing\" ]) Delegation (actedOnBehalfOf) \u00b6 Delegation is the assignment of authority and responsibility to an agent (by itself or by another agent) to carry out a specific activity as a delegate or representative, while the agent it acts on behalf of retains some responsibility for the outcome of the delegated work. A delegation link, written actedOnBehalfOf(id; ag2, ag1, a, attrs) in PROV-N, has: id : an optional identifier for the delegation link between delegate and responsible; delegate : an identifier (ag2) for the agent associated with an activity, acting on behalf of the responsible agent; responsible : an identifier (ag1) for the agent, on behalf of which the delegate agent acted; activity : an optional identifier (a) of an activity for which the delegation link holds; attributes : an optional set (attrs) of attribute-value pairs representing additional information about this delegation link. In the following example we can see how the agent delegated did:nv:a1 acts on behalf of the did:nv:a2 responsible. actedOnBehalfOf(did:nv:a1, did:nv:a2) actedOnBehalfOf(did:nv:a1, did:nv:a2, [ prov:type=\"ground transportation\" ]) Usage (used) \u00b6 Usage is the beginning of utilizing an entity by an activity. Before usage, the activity had not begun to utilize this entity and could not have been affected by the entity. (Note: This definition is formulated for a given usage; it is permitted for an activity to use the same entity multiple times.) Given that a usage is the beginning of utilizing an entity, it is instantaneous. Usage, written used(id; a, e, t, attrs) in PROV-N, has: id : an optional identifier for a usage; activity : an identifier (a) for the activity that used an entity; entity : an optional identifier (e) for the entity being used; time : an optional \"usage time\" (t), the time at which the entity started to be used; attributes : an optional set (attrs) of attribute-value pairs representing additional information about this usage. In the following example we can see how to associate the activity did:nv:ac1 with the usage of the entity did:nv:e1 in some specific moment. usage(did:nv:ac1, did:nv:e1, now()) usage(did:nv:ac1, did:nv:e1, now(), [ prov:type=\"shipping\" ]) Activity: Register activities \u00b6 An activity is something that occurs over a period of time and acts upon or with entities; it may include consuming, processing, transforming, modifying, relocating, using, or generating entities. An activity , written activity(id, st, et, [attr1=val1, ...]) in PROV-N, has: id : an identifier for an activity; startTime : an optional time (st) for the start of the activity; endTime : an optional time (et) for the end of the activity; attributes : an optional set of attribute-value pairs ((attr1, val1), ...) representing additional information about this activity. Example: activity(a1, 2011-11-16T16:05:00, 2011-11-16T16:06:00, [ ex:host=\"server.example.org\", prov:type='ex:edit' ]) The above example shows the existence of an activity with identifier a1 , start time 2011-11-16T16:05:00 , and end time 2011-11-16T16:06:00 , running on host server.example.org , and of type edit . Examples \u00b6 Taking into account the relations examples, the scenario where a new asset (entity) is created (generation), modified (derivation) and used by a third-party entity can be translated into this: // Entity X is associated with the activity of goodCreation wasAssociatedWith(goodCreation, entityX) // Entity Y is associated with the activity of goodModification wasAssociatedWith(goodModification, entityY) // Entity Z is associated with the activity of goodShipping wasAssociatedWith(goodShipping, entityZ) // A newAsset was created yesterday via goodCreation activity (Entity X) wasGeneratedBy(newAsset goodCreation, yesterday()) // The newDerivedAsset was created today from the newAsset via goodModification activity (Entity Y) wasDerivedFrom(newDerivedAsset, newAsset, goodModification, today()) // The newDerivedAsset is shipped by Entity Z used(goodShipping, newDerivedAsset, now()) Scenario \u00b6 For describing the architecture we are gonna use as a reference a supply chain use case. In this scenario a company manufacturing some goods needs to deliver them to the final customer. To do that the goods need to be transported by different shipping companies until the goods are handed over to the final recipient. Actors \u00b6 As an example to illustrate the architecture we are gonna describe the scenario with the following 4 different actors: Acme Co . International medical company manufacturing different kind of drugs in the their manufacturing center Armadillo Shipping . Courier doing ground and sea transportation of goods. Pigeon Carriers . Company doing air transportation of goods. John Doe . The end recipient of the goods Flow \u00b6 The end to end scenario includes the following steps: Acme Co. manufactures the drug at their manufacturing center Acme Co. hands off the product for transfer from Acme to ground transport (Armadillo Shipping) to begin the journey Armadillo transports the product from the manufacturer to the air freight provider for overseas shipping This may or may not go through a distribution center Armadillo hands off the freight to the air freight provider ( Pigeon Carriers) The air freight provider will take over the shipping and move the freight to their distribution center at the airport to wait for the cargo to be loaded. The cargo is loaded into the plane and transferred to the destination The air freight provider will hand off the cargo to the end recipient (John Doe) Provenance Example Use Case Architecture \u00b6 Data \u00b6 Across the complete supply chain scenario described above different parts of data are generated since the good is manufactured until it is delivered to the end recipient. Here some details about that: When the good is created, the manufacturer generates some additional information about the physical asset. This could include documents with asset specifications, details of manufacturing, certificates of quality, etc. When the good is handed over to the shipping company there are also other pieces of data generated. For example the receipt signed between the agent handing over the goods and the courier. During the transportation process, some additional data could be generated including temperature, humidity, coordinates, etc. When the good is delivered to the end user, both parties sign a delivery receipt. This data is also relevant and necessary for further control. Taking into account the above details we can distinguish different kind of data generated: Files. Including goods specs, receipts, etc. Each agent in the scenario needs to keep track of files or get access to the files created by others. Metadata. Describing the goods or the activities related with the goods during the delivery life-cycle. Nevermined provides a decentralized ecosystem where all this data can be registered and shared between all the agents participating during the supply chain process. It enables the registering of the files generated by the supply chain flow, making them available between the agents independently on the underlying technology. Also enable the registering of the metadata associated with the complete flow allowing to provide a complete lineage of the whole process. All this information is recorded in a decentralized backbone that works as a source of truth for all the parties. Nevermined doesn\u2019t require to replace the existing supply chain software platforms each agent in the system has. It integrates to them and augments their existing capabilities allowing to make available the relevant data generated to the agents participating during the supply process. Process \u00b6 Taking into account the Scenario described before, the end to end flow can be detailed in the following steps: Good Manufacturing \u00b6 Acme Corp. (Manufacturer) has created some goods that need to be delivered to John Doe (End Recipient). Acme uses the supply chain management Oracle SCM platform. When the good is created some relevant data (files, certificates, etc.) is created in the SCM platform. As a complement to that, the good created is registered into Nevermined (via SDK integration). This allows to: Identify unequivocally the good created within the supply chain network. This associates a unique Decentralized Identifier (DID) to the good and identifies Acme Corp. as the unique manufacturer of the good, providing the genesis of the goods lineage. Register some metadata related with the good created, including date of manufacturing, description, conditions, etc. This metadata is hashed and becomes part of the DID created, avoiding further modifications (like date of manufacturing tamper) without breaking the integrity check of the DID. Register the data files as part of the metadata. Typically these files will be stored as part of Acme Corp. SCM system. Nevermined provides a gateway that can integrate different backends. These files registered, equally to the metadata are part of the Nevermined integrity check. Handover to Carrier \u00b6 Acme Corp. needs to send the goods manufactured to John Doe. This delivery process needs to involve 2 independent transport companies, Armadillo Shipping that is doing local ground transportation and Pigeon Carriers that is doing air transportation. Pigeon Carriers will deliver the goods to the end recipient. During this process the following things happen: * Acme Corp. hands over the goods to Armadillo Shipping. During this process there is a digital signature process where Acme Corp. gets the signature from Armadillo of this hand over process. Acme Corp. registers this in the Nevermined Provenance Registry. * Armadillo Shipping transports the goods to the airport to hand over to Pigeon Carriers. During the transportation process some data is created including the temperature of the cargo and the coordinates of the complete trip from the Acme factory to the airport. The files with the data generated are uploaded automatically to the Armadillo SCM system. In addition to this the files are registered into Nevermined with a new DID. When Armadillo hands over the goods to Pigeon Carriers, the digital signature accepting the handover is registered in the Provenance Registry. The handover between carriers could include multiple steps and companies. Also intermediate storage in delivery centers, goods validation or certification, etc. For sake of simplicity here we only describe a simplistic end to end flow, but in essence a complete scenario involving additional steps could be very similar. Handover to the end recipient \u00b6 Pigeon Carriers needs to deliver the goods to John Doe (End Recipient). During this process and very similarly to the above described the following things happens: * John Doe sings digitally the delivery receipt. Pigeon Carriers. registers this in the Nevermined Provenance Registry. * John Doe, having the DID of the goods can track end to end the complete provenance record of the asset. Also for each intermediate step can retrieve the data assets associated with the goods and created during the delivery process. This makes it possible to track end to end the complete cargo flow involving independent agents. The provenance record is immutable and cryptographically secure, providing a transparent and unique source of truth that can be consulted by all the agents involved during and after the completion of the flow. This could allow John Doe to validate that the temperature of the goods were correct during transportation and using the GPS coordinates the cargo never went through unexpected locations. Provenance Architecture Registry \u00b6 Smart Contract \u00b6 struct DIDRegisterList { mapping(bytes32 => DIDRegister) didRegisters; bytes32[] didRegisterIds; } struct DIDRegister { address owner; bytes32 lastChecksum; string url; address lastUpdatedBy; uint256 blockNumberUpdated; address[] providers; address[] delegates; } struct ProvenanceRegistryList { mapping(bytes32 => ProvenanceRegistry) provenanceRegistry; } struct ProvenanceRegistry { bytes32 did; bytes32 relatedDid; bytes32 activityId; address agentId; address agentInvolvedId; uint8 method; address lastUpdatedBy; uint256 blockNumberUpdated; } # DIDRegister owner | lastChecksum | URL | lastUpdatedBy | blockNumber | providers | delegates -------|--------------|-----------------------|-----------------|---------------|---------------|------------------- 0x1234 | 00001 | http://nevermined.io | 2010 | 100 | [0x10] | [] 0xabab | 12213 | http://nevermined.io | 2011 | 100 | [] | [0xaa] # ProvenanceRegistry did | relatedDid | activityId | agentId | agentInvolvedId | method | lastUpdatedBy | blockNumber -------|--------------|-------------------|-------------------|--------------------|-----------|-------------------|----------------- 0x1234 | 0x5678 | 0xaabb | 0xccdd | 0xccbb | 0 | 2010 | 100 0xdddd | | 0xaabb | 0xccdd | | 1 | 2011 | 190 Provenance Registry \u00b6 The Provenance Registry provides a unique source truth of the provenance information registered in the Nevermined network. It is a generic record where the entities (digital or physical assets) represent their complete life-cycle. When it\u2019s necessary to represent the interaction between independent agents (Acme Corp. hands over a good to Armadillo Shipping), it\u2019s necessary to provide the digital signature of the agents participating in the transaction. Using the scenario already described and the W3C PROV specification the complete flow could be described as follows: // Acme Corp. manufacture some stuff wasAssociatedWith(acmeStuffManufacturing, Acme) // Armadillo does ground transportation wasAssociatedWith(armadilloGroundTransport, Armadillo) // Pigeon does air transportation wasAssociatedWith(pigeonAirTransport, Pigeon) // Stuff X is created by the action acmeStuffManufacturing wasGeneratedBy(stuffX, acmeStuffManufacturing, timestamp) // Acme hands off the drugs to Armadillo for ground transportation actedOnBehalfOf(Armadillo, Acme, [prov:type=\"ground transportation\" ]) // Armadillo transport the stuff used(armadilloGroundTransport, stuffX) // Armadillo hands off the drugs to Pigeon for air transportation actedOnBehalfOf(Pigeon, Armadillo, [prov:type=\"air transportation\" ]) // Pigeon transport the stuff used(pigeonGroundTransport, stuffX) // Pigeon delivers the stuff to John actedOnBehalfOf(John, Pigeon, [prov:type=\"delivery\" ]) Metadata Registry \u00b6 Agents Registry \u00b6 All the different actors (Agents in PROV terminology) have associated a digital identity allowing their identification and further authorization and authentication in the network. In Nevermined all the different entities can be registered as a DID. In our example: Acme Corp - did:nv:acme Armadillo Shipping - did:nv:armadillo Pigeon Carriers - did:nv:pigeon John Doe - did:nv:john The different agents DIDs can be resolved to DDOs including the user metadata: { \"@context\" : \"https://www.w3.org/ns/did/v1\" , \"id\" : \"did:nv:acme\" , \"proof\" : { \"created\" : \"2019-02-08T08:13:41Z\" , \"creator\" : \"0x37BB53e3d293494DE59fBe1FF78500423dcFd43B\" , \"signatureValue\" : \"did:nv:0bc278fee025464f8012b811d1bce8e22094d0984e4e49139df5d5ff7a028bdf\" , \"type\" : \"DDOIntegritySignature\" , \"checksum\" : { \"0\" : \"0x52b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3bbc3377\" } }, \"verifiableCredential\" : [{ \"@context\" : [ \"https://www.w3.org/2018/credentials/v1\" , \"https://www.w3.org/2018/credentials/examples/v1\" ], \"id\" : \"1872\" , \"type\" : [ \"read\" , \"update\" , \"deactivate\" ], \"issuer\" : \"0x610D9314EDF2ced7681BA1633C33fdb8cF365a12\" , \"issuanceDate\" : \"2019-01-01T19:73:24Z\" , \"credentialSubject\" : { \"id\" : \"0x37BB53e3d293494DE59fBe1FF78500423dcFd43B\" }, \"proof\" : { \"type\" : \"RsaSignature2018\" , \"created\" : \"2019-01-01T19:73:24Z\" , \"proofPurpose\" : \"assertionMethod\" , \"signatureValue\" : \"ABCJSDAO23...1tzjn4w==\" } }], \"service\" : [{ \"index\" : 0 , \"serviceEndpoint\" : \"http://localhost:5000/api/v1/metadata/agents/ddo/{did}\" , \"type\" : \"metadata\" , \"attributes\" : { \"main\" : { \"name\" : \"Acme Corp\" , \"subjectAddress\" : \"0x37BB53e3d293494DE59fBe1FF78500423dcFd43B\" , \"dateCreated\" : \"2019-02-08T08:13:49Z\" , \"datePublished\" : \"2019-02-08T08:13:49Z\" } } }] } The registration of an identity in the network requires the following steps: Generates the agent DDO Generates the DID using the DDO main metadata Register the DDO off-chain in any kind of metadata service using the Nevermined Metadata interface Register the DID on-chain calling the Smart Contract DIDRegistry associating the DID with the url where the DDO is resolved Using this method, different and totally independent actors of the supply chain scenario can register their digital identity in the network and be discovered/resolvable via the DID on-chain and the agent metadata. Entities Registry \u00b6 In the same way that agents are registered in Nevermined, all the different assets (Entities in PROV terminology) are registered as part of the network and have associated a DID and some metadata in DDO format. This inherits all the benefits of using Decentralized Identifiers, including the integrity validation of metadata associated with an entity. In the Nevermined Metadata specification , a DDO includes some services that are included in the entity/asset registered in the network. Typically this list of services can include: Metadata - Information describing the entity. Depending on the type of entity this could be information of a dataset, a physical object, etc. Some attributes here could be description of the entity, owner, date of creation, author, etc. Digital Access - For digital entities allowing sharing between agents of the network. This service includes the conditions allowing this transaction to happen. Computation - For digital entities with privacy constraints where the agent owner of the digital asset allows to execute a computation where the digital entity is. This could be a Federated Learning job or a classical data pipeline. Provenance. It allows to register the activities and metadata related with an entity. The provenance information is associated with the DDO and is part of the integrity signature of the asset. This provenance metadata is complemented with the on-chain provenance registry. Provenance metadata integrity \u00b6 To guarantee the integrity of the provenance information, the complete provenance JSON object inside of the Provenance service is serialized and hashed using keccak256 . This generated checksum will be stored as part of the Provenance service in the checksum attribute. Additionally, this checksum can be registered on-chain to prevent the tampering of provenance information. Also this checksum can be used as part of the DID computation. How to compute the provenance checksum \u00b6 To generate the checksum in a way that can be computed and verified multiple times, the JSON object must be serialized using the following rules: All the \\n, \\t, \\r characters must be removed All the whitespaces out of the Json entities names or values must be removed The Json document and all the nested objects must be sort alphabetically This must generate a compact JSON object of only one line that can be hashed and the verification of the hash can be re-calculated. Links \u00b6 W3C PROV-O - The Provenance Ontology: https://www.w3.org/TR/2013/NOTE-prov-xml-20130430/ W3C PROV-DM - The Provenance Data Model: https://www.w3.org/TR/2013/REC-prov-dm-20130430/ W3C PROV-XML: https://www.w3.org/TR/2013/NOTE-prov-xml-20130430/ W3C PROV-JSON Serialization: https://www.w3.org/Submission/prov-json/ Resource: Open Provenance Model (OPM) \u00b6 The Open Provenance Model ( OPM ) defines a data model that is open from an inter-operability viewpoint but also with respect to the community of its contributors, reviewers and users. Open Provenance Model It has several tools & libraries: ProvToolbox - a Java toolbox for handling PROV Tutorial Prov Python - a Python implementation of the PROV data model tutorial ipynb notebook example document ProvJS - a JavaScript implementation of the PROV data model ProvStore - Provenance storage and distribution ProvExtract - for dealing with PROV embedded in web pages ProvVis - experimental visualizations of PROV PROV-N Editor - a text editor with PROV-N syntax highlighted","title":"Provenance"},{"location":"architecture/specs/provenance/#prov-spec-decentralized-data-provenance","text":"shortname: PROV name: Decentralized Data Provenance type: Standard status: Valid version: 0.2 editor: Aitor Argomaniz <aitor@nevermined.io> contributors: PROV SPEC: Decentralized Data Provenance Motivation Concepts Specifications Provenance Model Provenance Types Entities Agents Activities Provenance Relations Generation: Register a new entity generated by an agent (wasGeneratedBy) Derivation: register relationship between source and derived entities (wasDerivedFrom) Association (wasAssociatedWith) Delegation (actedOnBehalfOf) Usage (used) Activity: Register activities Examples Scenario Actors Flow Architecture Data Process Good Manufacturing Handover to Carrier Handover to the end recipient Registry Provenance Registry Metadata Registry Agents Registry Entities Registry Provenance metadata integrity How to compute the provenance checksum Links This SPEC introduces the concept of asset Data Provenance in Nevermined platform based on the W3C Provenance specification.","title":"PROV SPEC: Decentralized Data Provenance"},{"location":"architecture/specs/provenance/#motivation","text":"The intention of this document is to discuss how data provenance can be established in a decentralized system, permitting integrity validation of this provenance information. The main objectives of this SPEC are: Understand what provenance information needs to be tracked Specify how the provenance integrity check is stored on-chain Identify the actors involved in the publishing and visualization of provenance information Detail how to register relationships between source and derived entities Detail how to register activities Understand how to associate activities with the input and output entities in a workflow Validate cryptographically that an entity was generated from a specific input entity in a specific activity","title":"Motivation"},{"location":"architecture/specs/provenance/#concepts","text":"","title":"Concepts"},{"location":"architecture/specs/provenance/#specifications","text":"Nevermined Data Provenance solution is designed based on the W3C Provenance specifications . In addition to this, Nevermined uses Decentralized Identifiers following the W3C DID specification . The design of Nevermined using both specifications is critical because it enables the construction of a complete and decentralized provenance solution where independent parties can collaborate in the common problem of delivering goods without relying on a central party, and providing transparency, complete traceability, efficiency and a unique source of truth.","title":"Specifications"},{"location":"architecture/specs/provenance/#provenance-model","text":"The W3C PROV specification defines Provenance as: Provenance is information about entities, activities, and people involved in producing a piece of data or thing, which can be used to form assessments about its quality, reliability or trustworthiness. The W3C PROV data model includes a core set of types and relations commonly found in provenance tracking for more specific uses. In particular, the data model includes both Type and Relation categories. Type category contains entity , activity and agent which are core components. Relations category defines key relationships between different types of components, which can be mapped into specific PROV model relations. PROV Mapping","title":"Provenance Model"},{"location":"architecture/specs/provenance/#provenance-types","text":"Provenance information can be modeled as the interaction between Agents and Entities related via the Activities between them:","title":"Provenance Types"},{"location":"architecture/specs/provenance/#entities","text":"In PROV, physical, digital, conceptual, or other kinds of things are called entities. Examples of such entities are assets, a web page, a chart, a spellchecker, etc.","title":"Entities"},{"location":"architecture/specs/provenance/#agents","text":"An agent takes a role in an activity such that the agent can be assigned some degree of responsibility for the activity taking place. An agent can be a person, a piece of software, an inanimate object, an organization, or other entities that may be ascribed responsibility.","title":"Agents"},{"location":"architecture/specs/provenance/#activities","text":"Activities are how entities come into existence and how their attributes change to become new entities, often making use of previously existing entities to achieve this. They are dynamic aspects of the world, such as actions, processes, etc. For example, if the second version of document D was generated by a translation from the first version of the document in another language, then this translation is an activity. PROV E-R","title":"Activities"},{"location":"architecture/specs/provenance/#provenance-relations","text":"Relations between agents and entities are open but there are some common relations that can be used as reference:","title":"Provenance Relations"},{"location":"architecture/specs/provenance/#generation-register-a-new-entity-generated-by-an-agent-wasgeneratedby","text":"Generation is the completion of production of a new entity by an activity. This entity did not exist before generation and becomes available for usage after this generation. Generation , written wasGeneratedBy(id; e, a, t, attrs) in PROV-N (a notation for provenance aimed at human consumption), has: id : an optional identifier for a generation; entity : an identifier (e) for a created entity. In Nevermined a DID ; activity : an optional identifier (a) for the activity that creates the entity. In Nevermined a DID ; time : an optional \"generation time\" (t), the time at which the entity was completely created; attributes : an optional set (attrs) of attribute-value pairs representing additional information about this generation. While each of id , activity , time , and attributes are optional, at least one of them must be present. PROV uses qualified names to identify things for data provenance, which is essentially a shortened representation of a URI in the form of prefix:localpart . Example: wasGeneratedBy(did:nv:e1, did:nv:a1, 2019-10-26T21:32:52) wasGeneratedBy(did:nv:e2, did:nv:a1, 2019-10-26T10:00:00) The above example shows the existence of two generations (with respective times 2019-10-26T21:32:52 and 2001-10-26T10:00:00), at which new entities, identified by did:nv:e1 and did:nv:e2 , were created by an activity, identified by did:nv:a1 .","title":"Generation: Register a new entity generated by an agent (wasGeneratedBy)"},{"location":"architecture/specs/provenance/#derivation-register-relationship-between-source-and-derived-entities-wasderivedfrom","text":"Derivation is a transformation of an entity into another, an update of an entity resulting in a new one, or the construction of a new entity based on a pre-existing entity. A derivation , written wasDerivedFrom(id; e2, e1, a, g2, u1, attrs) in PROV-N, has: id : an optional identifier for a derivation; generatedEntity : the identifier (e2) of the derived entity generated by the derivation. In Nevermined a DID ; usedEntity : the identifier (e1) of the source entity used by the derivation. In Nevermined a DID ; activity : an optional identifier (a) for the activity using and generating the above entities. In Nevermined a DID ; generation : an optional identifier (g2) for the generation involving the generated entity (e2) and activity (a). In Nevermined a DID ; usage : an optional identifier (u1) for the usage involving the used entity (e1) and activity (a). In Nevermined a DID ; attributes : an optional set (attrs) of attribute-value pairs representing additional information about this derivation. The following descriptions are about derivations between did:nv:e1 and did:nv:e2 , but no information is provided as to the identity of the activity (and usage and generation) underpinning the derivation. In the second line, a type attribute is also provided. wasDerivedFrom(did:nv:e2, did:nv:e1) wasDerivedFrom(did:nv:e2, did:nv:e1, [ prov:type=\"physical transform\" ]) The following description expresses that activity did:nv:a , using the entity did:nv:e1 according to usage did:nv:01 , derived the entity did:nv:e2 and generated it according to generation did:nv:02 . It is followed by descriptions for generation did:nv:02 and usage did:nv:01 . wasDerivedFrom(did:nv:e2, did:nv:e1, did:nv:a, did:nv:02, did:nv:01) wasGeneratedBy(did:nv:02; did:nv:e2, did:nv:a, -) used(did:nv:01; did:nv:a, did:nv:e1, -) With such a comprehensive description of derivation, a program that analyzes provenance can identify the activity underpinning the derivation, it can identify how the preceding entity did:nv:e1 was used by the activity (e.g. for instance, which argument it was passed, if the activity is the result of a function invocation), and which output the derived entity did:nv:e2 was obtained from (say, for a function returning multiple results).","title":"Derivation: register relationship between source and derived entities (wasDerivedFrom)"},{"location":"architecture/specs/provenance/#association-wasassociatedwith","text":"Association is an assignment of responsibility to an agent for an activity, indicating that the agent had a role in the activity. An association, written wasAssociatedWith(id; a, ag, pl, attrs) in PROV-N, has: id : an optional identifier for the association between an activity and an agent; activity : an identifier (a) for the activity; agent : an optional identifier (ag) for the agent associated with the activity; plan : an optional identifier (pl) for the plan the agent relied on in the context of this activity; attributes : an optional set (attrs) of attribute-value pairs representing additional information about this association of this activity with this agent. The following examples are about the association between one activity did:nv:ac1 and one agent did:nv:a00 . In the second example, a type attribute is also provided. wasAssociatedWith(did:nv:ac1, did:nv:a00) wasAssociatedWith(did:nv:ac1, did:nv:a00, [ prov:type=\"manufacturing\" ])","title":"Association (wasAssociatedWith)"},{"location":"architecture/specs/provenance/#delegation-actedonbehalfof","text":"Delegation is the assignment of authority and responsibility to an agent (by itself or by another agent) to carry out a specific activity as a delegate or representative, while the agent it acts on behalf of retains some responsibility for the outcome of the delegated work. A delegation link, written actedOnBehalfOf(id; ag2, ag1, a, attrs) in PROV-N, has: id : an optional identifier for the delegation link between delegate and responsible; delegate : an identifier (ag2) for the agent associated with an activity, acting on behalf of the responsible agent; responsible : an identifier (ag1) for the agent, on behalf of which the delegate agent acted; activity : an optional identifier (a) of an activity for which the delegation link holds; attributes : an optional set (attrs) of attribute-value pairs representing additional information about this delegation link. In the following example we can see how the agent delegated did:nv:a1 acts on behalf of the did:nv:a2 responsible. actedOnBehalfOf(did:nv:a1, did:nv:a2) actedOnBehalfOf(did:nv:a1, did:nv:a2, [ prov:type=\"ground transportation\" ])","title":"Delegation (actedOnBehalfOf)"},{"location":"architecture/specs/provenance/#usage-used","text":"Usage is the beginning of utilizing an entity by an activity. Before usage, the activity had not begun to utilize this entity and could not have been affected by the entity. (Note: This definition is formulated for a given usage; it is permitted for an activity to use the same entity multiple times.) Given that a usage is the beginning of utilizing an entity, it is instantaneous. Usage, written used(id; a, e, t, attrs) in PROV-N, has: id : an optional identifier for a usage; activity : an identifier (a) for the activity that used an entity; entity : an optional identifier (e) for the entity being used; time : an optional \"usage time\" (t), the time at which the entity started to be used; attributes : an optional set (attrs) of attribute-value pairs representing additional information about this usage. In the following example we can see how to associate the activity did:nv:ac1 with the usage of the entity did:nv:e1 in some specific moment. usage(did:nv:ac1, did:nv:e1, now()) usage(did:nv:ac1, did:nv:e1, now(), [ prov:type=\"shipping\" ])","title":"Usage (used)"},{"location":"architecture/specs/provenance/#activity-register-activities","text":"An activity is something that occurs over a period of time and acts upon or with entities; it may include consuming, processing, transforming, modifying, relocating, using, or generating entities. An activity , written activity(id, st, et, [attr1=val1, ...]) in PROV-N, has: id : an identifier for an activity; startTime : an optional time (st) for the start of the activity; endTime : an optional time (et) for the end of the activity; attributes : an optional set of attribute-value pairs ((attr1, val1), ...) representing additional information about this activity. Example: activity(a1, 2011-11-16T16:05:00, 2011-11-16T16:06:00, [ ex:host=\"server.example.org\", prov:type='ex:edit' ]) The above example shows the existence of an activity with identifier a1 , start time 2011-11-16T16:05:00 , and end time 2011-11-16T16:06:00 , running on host server.example.org , and of type edit .","title":"Activity: Register activities"},{"location":"architecture/specs/provenance/#examples","text":"Taking into account the relations examples, the scenario where a new asset (entity) is created (generation), modified (derivation) and used by a third-party entity can be translated into this: // Entity X is associated with the activity of goodCreation wasAssociatedWith(goodCreation, entityX) // Entity Y is associated with the activity of goodModification wasAssociatedWith(goodModification, entityY) // Entity Z is associated with the activity of goodShipping wasAssociatedWith(goodShipping, entityZ) // A newAsset was created yesterday via goodCreation activity (Entity X) wasGeneratedBy(newAsset goodCreation, yesterday()) // The newDerivedAsset was created today from the newAsset via goodModification activity (Entity Y) wasDerivedFrom(newDerivedAsset, newAsset, goodModification, today()) // The newDerivedAsset is shipped by Entity Z used(goodShipping, newDerivedAsset, now())","title":"Examples"},{"location":"architecture/specs/provenance/#scenario","text":"For describing the architecture we are gonna use as a reference a supply chain use case. In this scenario a company manufacturing some goods needs to deliver them to the final customer. To do that the goods need to be transported by different shipping companies until the goods are handed over to the final recipient.","title":"Scenario"},{"location":"architecture/specs/provenance/#actors","text":"As an example to illustrate the architecture we are gonna describe the scenario with the following 4 different actors: Acme Co . International medical company manufacturing different kind of drugs in the their manufacturing center Armadillo Shipping . Courier doing ground and sea transportation of goods. Pigeon Carriers . Company doing air transportation of goods. John Doe . The end recipient of the goods","title":"Actors"},{"location":"architecture/specs/provenance/#flow","text":"The end to end scenario includes the following steps: Acme Co. manufactures the drug at their manufacturing center Acme Co. hands off the product for transfer from Acme to ground transport (Armadillo Shipping) to begin the journey Armadillo transports the product from the manufacturer to the air freight provider for overseas shipping This may or may not go through a distribution center Armadillo hands off the freight to the air freight provider ( Pigeon Carriers) The air freight provider will take over the shipping and move the freight to their distribution center at the airport to wait for the cargo to be loaded. The cargo is loaded into the plane and transferred to the destination The air freight provider will hand off the cargo to the end recipient (John Doe) Provenance Example Use Case","title":"Flow"},{"location":"architecture/specs/provenance/#architecture","text":"","title":"Architecture"},{"location":"architecture/specs/provenance/#data","text":"Across the complete supply chain scenario described above different parts of data are generated since the good is manufactured until it is delivered to the end recipient. Here some details about that: When the good is created, the manufacturer generates some additional information about the physical asset. This could include documents with asset specifications, details of manufacturing, certificates of quality, etc. When the good is handed over to the shipping company there are also other pieces of data generated. For example the receipt signed between the agent handing over the goods and the courier. During the transportation process, some additional data could be generated including temperature, humidity, coordinates, etc. When the good is delivered to the end user, both parties sign a delivery receipt. This data is also relevant and necessary for further control. Taking into account the above details we can distinguish different kind of data generated: Files. Including goods specs, receipts, etc. Each agent in the scenario needs to keep track of files or get access to the files created by others. Metadata. Describing the goods or the activities related with the goods during the delivery life-cycle. Nevermined provides a decentralized ecosystem where all this data can be registered and shared between all the agents participating during the supply chain process. It enables the registering of the files generated by the supply chain flow, making them available between the agents independently on the underlying technology. Also enable the registering of the metadata associated with the complete flow allowing to provide a complete lineage of the whole process. All this information is recorded in a decentralized backbone that works as a source of truth for all the parties. Nevermined doesn\u2019t require to replace the existing supply chain software platforms each agent in the system has. It integrates to them and augments their existing capabilities allowing to make available the relevant data generated to the agents participating during the supply process.","title":"Data"},{"location":"architecture/specs/provenance/#process","text":"Taking into account the Scenario described before, the end to end flow can be detailed in the following steps:","title":"Process"},{"location":"architecture/specs/provenance/#good-manufacturing","text":"Acme Corp. (Manufacturer) has created some goods that need to be delivered to John Doe (End Recipient). Acme uses the supply chain management Oracle SCM platform. When the good is created some relevant data (files, certificates, etc.) is created in the SCM platform. As a complement to that, the good created is registered into Nevermined (via SDK integration). This allows to: Identify unequivocally the good created within the supply chain network. This associates a unique Decentralized Identifier (DID) to the good and identifies Acme Corp. as the unique manufacturer of the good, providing the genesis of the goods lineage. Register some metadata related with the good created, including date of manufacturing, description, conditions, etc. This metadata is hashed and becomes part of the DID created, avoiding further modifications (like date of manufacturing tamper) without breaking the integrity check of the DID. Register the data files as part of the metadata. Typically these files will be stored as part of Acme Corp. SCM system. Nevermined provides a gateway that can integrate different backends. These files registered, equally to the metadata are part of the Nevermined integrity check.","title":"Good Manufacturing"},{"location":"architecture/specs/provenance/#handover-to-carrier","text":"Acme Corp. needs to send the goods manufactured to John Doe. This delivery process needs to involve 2 independent transport companies, Armadillo Shipping that is doing local ground transportation and Pigeon Carriers that is doing air transportation. Pigeon Carriers will deliver the goods to the end recipient. During this process the following things happen: * Acme Corp. hands over the goods to Armadillo Shipping. During this process there is a digital signature process where Acme Corp. gets the signature from Armadillo of this hand over process. Acme Corp. registers this in the Nevermined Provenance Registry. * Armadillo Shipping transports the goods to the airport to hand over to Pigeon Carriers. During the transportation process some data is created including the temperature of the cargo and the coordinates of the complete trip from the Acme factory to the airport. The files with the data generated are uploaded automatically to the Armadillo SCM system. In addition to this the files are registered into Nevermined with a new DID. When Armadillo hands over the goods to Pigeon Carriers, the digital signature accepting the handover is registered in the Provenance Registry. The handover between carriers could include multiple steps and companies. Also intermediate storage in delivery centers, goods validation or certification, etc. For sake of simplicity here we only describe a simplistic end to end flow, but in essence a complete scenario involving additional steps could be very similar.","title":"Handover to Carrier"},{"location":"architecture/specs/provenance/#handover-to-the-end-recipient","text":"Pigeon Carriers needs to deliver the goods to John Doe (End Recipient). During this process and very similarly to the above described the following things happens: * John Doe sings digitally the delivery receipt. Pigeon Carriers. registers this in the Nevermined Provenance Registry. * John Doe, having the DID of the goods can track end to end the complete provenance record of the asset. Also for each intermediate step can retrieve the data assets associated with the goods and created during the delivery process. This makes it possible to track end to end the complete cargo flow involving independent agents. The provenance record is immutable and cryptographically secure, providing a transparent and unique source of truth that can be consulted by all the agents involved during and after the completion of the flow. This could allow John Doe to validate that the temperature of the goods were correct during transportation and using the GPS coordinates the cargo never went through unexpected locations. Provenance Architecture","title":"Handover to the end recipient"},{"location":"architecture/specs/provenance/#registry","text":"","title":"Registry"},{"location":"architecture/specs/provenance/#smart-contract","text":"struct DIDRegisterList { mapping(bytes32 => DIDRegister) didRegisters; bytes32[] didRegisterIds; } struct DIDRegister { address owner; bytes32 lastChecksum; string url; address lastUpdatedBy; uint256 blockNumberUpdated; address[] providers; address[] delegates; } struct ProvenanceRegistryList { mapping(bytes32 => ProvenanceRegistry) provenanceRegistry; } struct ProvenanceRegistry { bytes32 did; bytes32 relatedDid; bytes32 activityId; address agentId; address agentInvolvedId; uint8 method; address lastUpdatedBy; uint256 blockNumberUpdated; } # DIDRegister owner | lastChecksum | URL | lastUpdatedBy | blockNumber | providers | delegates -------|--------------|-----------------------|-----------------|---------------|---------------|------------------- 0x1234 | 00001 | http://nevermined.io | 2010 | 100 | [0x10] | [] 0xabab | 12213 | http://nevermined.io | 2011 | 100 | [] | [0xaa] # ProvenanceRegistry did | relatedDid | activityId | agentId | agentInvolvedId | method | lastUpdatedBy | blockNumber -------|--------------|-------------------|-------------------|--------------------|-----------|-------------------|----------------- 0x1234 | 0x5678 | 0xaabb | 0xccdd | 0xccbb | 0 | 2010 | 100 0xdddd | | 0xaabb | 0xccdd | | 1 | 2011 | 190","title":"Smart Contract"},{"location":"architecture/specs/provenance/#provenance-registry","text":"The Provenance Registry provides a unique source truth of the provenance information registered in the Nevermined network. It is a generic record where the entities (digital or physical assets) represent their complete life-cycle. When it\u2019s necessary to represent the interaction between independent agents (Acme Corp. hands over a good to Armadillo Shipping), it\u2019s necessary to provide the digital signature of the agents participating in the transaction. Using the scenario already described and the W3C PROV specification the complete flow could be described as follows: // Acme Corp. manufacture some stuff wasAssociatedWith(acmeStuffManufacturing, Acme) // Armadillo does ground transportation wasAssociatedWith(armadilloGroundTransport, Armadillo) // Pigeon does air transportation wasAssociatedWith(pigeonAirTransport, Pigeon) // Stuff X is created by the action acmeStuffManufacturing wasGeneratedBy(stuffX, acmeStuffManufacturing, timestamp) // Acme hands off the drugs to Armadillo for ground transportation actedOnBehalfOf(Armadillo, Acme, [prov:type=\"ground transportation\" ]) // Armadillo transport the stuff used(armadilloGroundTransport, stuffX) // Armadillo hands off the drugs to Pigeon for air transportation actedOnBehalfOf(Pigeon, Armadillo, [prov:type=\"air transportation\" ]) // Pigeon transport the stuff used(pigeonGroundTransport, stuffX) // Pigeon delivers the stuff to John actedOnBehalfOf(John, Pigeon, [prov:type=\"delivery\" ])","title":"Provenance Registry"},{"location":"architecture/specs/provenance/#metadata-registry","text":"","title":"Metadata Registry"},{"location":"architecture/specs/provenance/#agents-registry","text":"All the different actors (Agents in PROV terminology) have associated a digital identity allowing their identification and further authorization and authentication in the network. In Nevermined all the different entities can be registered as a DID. In our example: Acme Corp - did:nv:acme Armadillo Shipping - did:nv:armadillo Pigeon Carriers - did:nv:pigeon John Doe - did:nv:john The different agents DIDs can be resolved to DDOs including the user metadata: { \"@context\" : \"https://www.w3.org/ns/did/v1\" , \"id\" : \"did:nv:acme\" , \"proof\" : { \"created\" : \"2019-02-08T08:13:41Z\" , \"creator\" : \"0x37BB53e3d293494DE59fBe1FF78500423dcFd43B\" , \"signatureValue\" : \"did:nv:0bc278fee025464f8012b811d1bce8e22094d0984e4e49139df5d5ff7a028bdf\" , \"type\" : \"DDOIntegritySignature\" , \"checksum\" : { \"0\" : \"0x52b5c93b82dd9e7ecc3d9fdf4755f7f69a54484941897dc517b4adfe3bbc3377\" } }, \"verifiableCredential\" : [{ \"@context\" : [ \"https://www.w3.org/2018/credentials/v1\" , \"https://www.w3.org/2018/credentials/examples/v1\" ], \"id\" : \"1872\" , \"type\" : [ \"read\" , \"update\" , \"deactivate\" ], \"issuer\" : \"0x610D9314EDF2ced7681BA1633C33fdb8cF365a12\" , \"issuanceDate\" : \"2019-01-01T19:73:24Z\" , \"credentialSubject\" : { \"id\" : \"0x37BB53e3d293494DE59fBe1FF78500423dcFd43B\" }, \"proof\" : { \"type\" : \"RsaSignature2018\" , \"created\" : \"2019-01-01T19:73:24Z\" , \"proofPurpose\" : \"assertionMethod\" , \"signatureValue\" : \"ABCJSDAO23...1tzjn4w==\" } }], \"service\" : [{ \"index\" : 0 , \"serviceEndpoint\" : \"http://localhost:5000/api/v1/metadata/agents/ddo/{did}\" , \"type\" : \"metadata\" , \"attributes\" : { \"main\" : { \"name\" : \"Acme Corp\" , \"subjectAddress\" : \"0x37BB53e3d293494DE59fBe1FF78500423dcFd43B\" , \"dateCreated\" : \"2019-02-08T08:13:49Z\" , \"datePublished\" : \"2019-02-08T08:13:49Z\" } } }] } The registration of an identity in the network requires the following steps: Generates the agent DDO Generates the DID using the DDO main metadata Register the DDO off-chain in any kind of metadata service using the Nevermined Metadata interface Register the DID on-chain calling the Smart Contract DIDRegistry associating the DID with the url where the DDO is resolved Using this method, different and totally independent actors of the supply chain scenario can register their digital identity in the network and be discovered/resolvable via the DID on-chain and the agent metadata.","title":"Agents Registry"},{"location":"architecture/specs/provenance/#entities-registry","text":"In the same way that agents are registered in Nevermined, all the different assets (Entities in PROV terminology) are registered as part of the network and have associated a DID and some metadata in DDO format. This inherits all the benefits of using Decentralized Identifiers, including the integrity validation of metadata associated with an entity. In the Nevermined Metadata specification , a DDO includes some services that are included in the entity/asset registered in the network. Typically this list of services can include: Metadata - Information describing the entity. Depending on the type of entity this could be information of a dataset, a physical object, etc. Some attributes here could be description of the entity, owner, date of creation, author, etc. Digital Access - For digital entities allowing sharing between agents of the network. This service includes the conditions allowing this transaction to happen. Computation - For digital entities with privacy constraints where the agent owner of the digital asset allows to execute a computation where the digital entity is. This could be a Federated Learning job or a classical data pipeline. Provenance. It allows to register the activities and metadata related with an entity. The provenance information is associated with the DDO and is part of the integrity signature of the asset. This provenance metadata is complemented with the on-chain provenance registry.","title":"Entities Registry"},{"location":"architecture/specs/provenance/#provenance-metadata-integrity","text":"To guarantee the integrity of the provenance information, the complete provenance JSON object inside of the Provenance service is serialized and hashed using keccak256 . This generated checksum will be stored as part of the Provenance service in the checksum attribute. Additionally, this checksum can be registered on-chain to prevent the tampering of provenance information. Also this checksum can be used as part of the DID computation.","title":"Provenance metadata integrity"},{"location":"architecture/specs/provenance/#how-to-compute-the-provenance-checksum","text":"To generate the checksum in a way that can be computed and verified multiple times, the JSON object must be serialized using the following rules: All the \\n, \\t, \\r characters must be removed All the whitespaces out of the Json entities names or values must be removed The Json document and all the nested objects must be sort alphabetically This must generate a compact JSON object of only one line that can be hashed and the verification of the hash can be re-calculated.","title":"How to compute the provenance checksum"},{"location":"architecture/specs/provenance/#links","text":"W3C PROV-O - The Provenance Ontology: https://www.w3.org/TR/2013/NOTE-prov-xml-20130430/ W3C PROV-DM - The Provenance Data Model: https://www.w3.org/TR/2013/REC-prov-dm-20130430/ W3C PROV-XML: https://www.w3.org/TR/2013/NOTE-prov-xml-20130430/ W3C PROV-JSON Serialization: https://www.w3.org/Submission/prov-json/","title":"Links"},{"location":"architecture/specs/provenance/#resource-open-provenance-model-opm","text":"The Open Provenance Model ( OPM ) defines a data model that is open from an inter-operability viewpoint but also with respect to the community of its contributors, reviewers and users. Open Provenance Model It has several tools & libraries: ProvToolbox - a Java toolbox for handling PROV Tutorial Prov Python - a Python implementation of the PROV data model tutorial ipynb notebook example document ProvJS - a JavaScript implementation of the PROV data model ProvStore - Provenance storage and distribution ProvExtract - for dealing with PROV embedded in web pages ProvVis - experimental visualizations of PROV PROV-N Editor - a text editor with PROV-N syntax highlighted","title":"Resource: Open Provenance Model (OPM)"}]}